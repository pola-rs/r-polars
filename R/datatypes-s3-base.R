# This method is not auto-generated in `generated-*` file,
# because it has a special case for the `union` method
#' @export
`$.polars_dtype_enum` <- function(x, name) {
  # Enum only method `union`
  if (identical(name, "union")) {
    fn <- function(other) {
      wrap({
        check_polars_dtype(other)
        if (!inherits(other, "polars_dtype_enum")) {
          abort(
            sprintf("`other` must be a Enum data type, got: %s", format(other, abbreviated = TRUE))
          )
        }

        PlRDataType$new_enum(unique(c(self$categories, other$categories)))
      })
    }
    self <- x # nolint: object_usage_linter
    environment(fn) <- environment()
    fn
  } else {
    NextMethod()
  }
}

# This method is not auto-generated in `generated-*` file,
# because it has a special case for the `union` method
#' @exportS3Method utils::.DollarNames
.DollarNames.polars_dtype_enum <- function(x, pattern = "") {
  member_names <- ls(x, all.names = TRUE)
  # Enum only method `union`
  method_names <- c("union", names(polars_datatype__methods))

  all_names <- union(member_names, method_names)
  filtered_names <- findMatches(pattern, all_names)

  filtered_names[!startsWith(filtered_names, "_")]
}

#' @export
print.polars_dtype <- function(x, ...) {
  format(x, abbreviated = FALSE) |>
    writeLines()
  invisible(x)
}

#' Format a data type
#'
#' @param ... Ignored.
#' @param abbreviated `r lifecycle::badge("experimental")`
#'   A boolean. If `TRUE`, use the abbreviated form of the dtype name,
#'   e.g. "i64" instead of "Int64".
#' @examples
#' format(pl$Int64)
#' format(pl$Float64, abbreviated = TRUE)
#' @export
#' @keywords internal
format.polars_dtype <- function(x, ..., abbreviated = FALSE) {
  x$`_dt`$as_str(abbreviated = abbreviated)
}
