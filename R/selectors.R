#' Polars column selector function namespace
#'
#' `cs` is an [environment class][environment-class] object that stores all
#' selector functions of the R Polars API which mimics the Python Polars API.
#' It is intended to work the same way in Python as if you had imported
#' Python Polars Selectors with `import polars.selectors as cs`.
#'
#' @section Supported operators:
#' There are 4 supported operators for selectors:
#'
#' * `&` to combine conditions with AND, e.g. select columns that contain
#'   `"oo"` *and* end with `"t"` with `cs$contains("oo") & cs$ends_with("t")`;
#' * `|` to combine conditions with OR, e.g. select columns that contain
#'   `"oo"` *or* end with `"t"` with `cs$contains("oo") | cs$ends_with("t")`;
#' * `-` to substract conditions, e.g. select all columns that have alphanumeric
#'   names except those that contain `"a"` with
#'   `cs$alphanumeric() - cs$contains("a")`;
#' * `!` to invert the selection, e.g. select all columns that *are not* of data
#'   type `String` with `!cs$string()`.
#'
#' Note that Python Polars uses `~` instead of `!` to invert selectors.
#'
#' If we want to apply operators on the data instead of the selector sets,
#' `<selector>$as_expr()` can be used to materialize the selector as a normal
#' expression.
#'
#' @examples
#' cs
#'
#' df <- pl$DataFrame(
#'   colx = c("aa", "bb", "cc"),
#'   coly = c(TRUE, FALSE, TRUE),
#'   colz = c(1, 2, 3),
#' )
#'
#' # Inverting the boolean selector will choose the non-boolean columns:
#' df$select(!cs$boolean())
#'
#' # To invert the values in the selected boolean columns,
#' # we need to materialize the selector as a standard expression instead:
#' df$select(!cs$boolean()$as_expr())
#' @aliases polars_selector Selector
#' @export
cs <- new.env(parent = emptyenv())

# The env for storing selector methods
polars_selector__methods <- new.env(parent = emptyenv())

#' @export
wrap.PlRSelector <- function(x, ...) {
  self <- new.env(parent = emptyenv())
  self$`_rselector` <- x
  self$`_rexpr` <- PlRExpr$new_selector(x)

  lapply(names(polars_namespaces_expr), function(namespace) {
    makeActiveBinding(namespace, function() polars_namespaces_expr[[namespace]](self), self)
  })

  class(self) <- c("polars_selector", "polars_expr", "polars_object")
  self
}

is_column <- function(obj) {
  is_polars_expr(obj) && obj$meta$is_column()
}

selector__invert <- function() {
  cs__all() - self
}

selector__sub <- function(other) {
  wrap({
    if (is_polars_selector(other)) {
      self$`_rselector`$difference(other$`_rselector`)
    } else {
      self$as_expr()$sub(other)
    }
  })
}

selector__or <- function(other) {
  wrap({
    if (is_column(other)) {
      # TODO: @2.0 remove? (check polars-python)
      other <- cs__by_name(other$meta$output_name())
    }
    if (is_polars_selector(other)) {
      self$`_rselector`$union(other$`_rselector`)
    } else {
      self$as_expr()$or(other)
    }
  })
}

selector__and <- function(other) {
  wrap({
    if (is_column(other)) {
      # TODO: @2.0 remove? (check polars-python)
      colname <- other$meta$output_name()
      other <- cs__by_name(colname)
    }
    if (is_polars_selector(other)) {
      self$`_rselector`$intersect(other$`_rselector`)
    } else {
      self$as_expr()$and(other)
    }
  })
}

selector__xor <- function(other) {
  wrap({
    if (is_column(other)) {
      # TODO: @2.0 remove? (check polars-python)
      other <- cs$by_name(other$meta$output_name())
    }
    if (is_polars_selector(other)) {
      self$`_rselector`$exclusive_or(other$`_rselector`)
    } else {
      self$as_expr()$xor(other)
    }
  })
}

selector__exclude <- function(...) {
  wrap({
    check_dots_unnamed()

    input <- list2(...)

    exclude_cols <- Filter(is_string, input)
    exclude_dtypes <- Filter(is_polars_dtype, input)
    unknown <- Filter(
      \(x) !is_string(x) && !is_polars_dtype(x),
      input
    )

    if (length(unknown) > 0L) {
      abort("`...` can only contain column names or polars data types.")
    }
    if (length(exclude_cols) != 0L && length(exclude_dtypes) != 0L) {
      abort(
        c(
          "Can't exclude by both column name and dtype",
          i = "Use a polars selector instead."
        )
      )
    }

    if (length(exclude_dtypes) > 0L) {
      self - cs__by_dtype(...)
    } else {
      self - cs__by_name(..., require_all = FALSE)
    }
  })
}

#' @rdname cs
selector__as_expr <- function() {
  self$`_rexpr` |>
    wrap()
}

# Return escaped regex, potentially representing multiple string fragments.
re_string <- function(string, ..., escape = TRUE) {
  rx <- if (escape) re_escape(string) else string
  paste0(rx, collapse = "|") |>
    sprintf("(%s)", x = _)
}

#' Select no columns
#'
#' This is useful for composition with other selectors.
#' @return A Polars [selector][cs]
#' @seealso [cs] for the documentation on operators supported by selectors.
#' @examples
#' pl$DataFrame(a = 1, b = 2)$select(cs$empty())
cs__empty <- function() {
  PlRSelector$empty() |>
    wrap()
}

#' Select all columns
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(dt = as.Date(c("2000-1-1")), value = 10)
#'
#' # Select all columns, casting them to string:
#' df$select(cs$all()$cast(pl$String))
#'
#' # Select all columns except for those matching the given dtypes:
#' df$select(cs$all() - cs$numeric())
cs__all <- function() {
  PlRSelector$all() |>
    wrap()
}

#' Select all columns with alphabetic names (e.g. only letters)
#'
#' @inheritParams rlang::args_dots_empty
#' @param ascii_only Indicate whether to consider only ASCII alphabetic
#' characters, or the full Unicode range of valid letters (accented,
#' idiographic, etc).
#' @param ignore_spaces Indicate whether to ignore the presence of spaces in
#' column names; if so, only the other (non-space) characters are considered.
#'
#' @details
#' Matching column names cannot contain any non-alphabetic characters. Note
#' that the definition of “alphabetic” consists of all valid Unicode alphabetic
#' characters (`p{Alphabetic}`) by default; this can be changed by setting
#' `ascii_only = TRUE`.
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   no1 = c(100, 200, 300),
#'   café = c("espresso", "latte", "mocha"),
#'   `t or f` = c(TRUE, FALSE, NA),
#'   hmm = c("aaa", "bbb", "ccc"),
#'   都市 = c("東京", "大阪", "京都")
#' )
#'
#' # Select columns with alphabetic names; note that accented characters and
#' # kanji are recognised as alphabetic here:
#' df$select(cs$alpha())
#'
#' # Constrain the definition of “alphabetic” to ASCII characters only:
#' df$select(cs$alpha(ascii_only = TRUE))
#' df$select(cs$alpha(ascii_only = TRUE, ignore_spaces = TRUE))
#'
#' # Select all columns except for those with alphabetic names:
#' df$select(!cs$alpha())
#' df$select(!cs$alpha(ignore_spaces = TRUE))
cs__alpha <- function(ascii_only = FALSE, ..., ignore_spaces = FALSE) {
  wrap({
    check_dots_empty0(...)
    re_alpha <- if (isTRUE(ascii_only)) r"(a-zA-Z)" else r"(\p{Alphabetic})"
    re_space <- if (isTRUE(ignore_spaces)) " " else ""
    PlRSelector$matches(sprintf("^[%s%s]+$", re_alpha, re_space))
  })
}

#' Select all columns with alphanumeric names (e.g. only letters and the digits 0-9)
#'
#' @inheritParams rlang::args_dots_empty
#' @inheritParams cs__alpha
#'
#' @details
#' Matching column names cannot contain any non-alphabetic characters. Note
#' that the definition of “alphabetic” consists of all valid Unicode alphabetic
#' characters (`p{Alphabetic}`) and digit characters (`d`) by default; this can
#' be changed by setting `ascii_only = TRUE`.
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   `1st_col` = c(100, 200, 300),
#'   flagged = c(TRUE, FALSE, TRUE),
#'   `00prefix` = c("01:aa", "02:bb", "03:cc"),
#'   `last col` = c("x", "y", "z")
#' )
#'
#' # Select columns with alphanumeric names:
#' df$select(cs$alphanumeric())
#' df$select(cs$alphanumeric(ignore_spaces = TRUE))
#'
#' # Select all columns except for those with alphanumeric names:
#' df$select(!cs$alphanumeric())
#' df$select(!cs$alphanumeric(ignore_spaces = TRUE))
cs__alphanumeric <- function(ascii_only = FALSE, ..., ignore_spaces = FALSE) {
  wrap({
    check_dots_empty0(...)
    re_alphanumeric <- if (isTRUE(ascii_only)) r"(a-zA-Z)" else r"(\p{Alphabetic})"
    re_digit <- if (isTRUE(ascii_only)) "0-9" else r"(\d)"
    re_space <- if (isTRUE(ignore_spaces)) " " else ""
    PlRSelector$matches(sprintf("^[%s%s%s]+$", re_alphanumeric, re_digit, re_space))
  })
}

#' Select all binary columns
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$select(
#'   a = charToRaw("hello"),
#'   b = pl$lit("world"),
#'   c = charToRaw("!"),
#'   d = pl$lit(":"),
#' )
#'
#' # Select binary columns:
#' df$select(cs$binary())
#'
#' # Select all columns except for those that are binary:
#' df$select(!cs$binary())
cs__binary <- function() {
  cs__by_dtype(pl$Binary)
}

#' Select all boolean columns
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   a = 1:4,
#'   b = c(FALSE, TRUE, FALSE, TRUE)
#' )
#'
#' # Select and invert boolean columns:
#' df$with_columns(inverted = cs$boolean()$not())
#'
#' # Select all columns except for those that are boolean:
#' df$select(!cs$boolean())
cs__boolean <- function() {
  cs__by_dtype(pl$Boolean)
}

#' Select all columns matching the given dtypes
#'
#' @param ... <[`dynamic-dots`][rlang::dyn-dots]> Data types to select.
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   dt = as.Date(c("1999-12-31", "2024-1-1", "2010-7-5")),
#'   value = c(1234500, 5000555, -4500000),
#'   other = c("foo", "bar", "foo")
#' )
#'
#' # Select all columns with date or string dtypes:
#' df$select(cs$by_dtype(pl$Date, pl$String))
#'
#' # Select all columns that are not of date or string dtype:
#' df$select(!cs$by_dtype(pl$Date, pl$String))
#'
#' # Group by string columns and sum the numeric columns:
#' df$group_by(cs$string())$agg(cs$numeric()$sum())$sort("other")
cs__by_dtype <- function(...) {
  wrap({
    check_dots_unnamed()
    parse_into_list_of_datatypes(...) |>
      PlRSelector$by_dtype()
  })
}

#' Select all columns matching the given indices (or range objects)
#'
#' @inheritParams rlang::args_dots_empty
# @param indices One or more column indices (or ranges). Negative indexing is
# supported.
#' @param indices 0-based column indices to select.
#'   Negative indexing is supported.
#' @param require_all Whether to match all indices (the default) or any of the indices.
#'
#' @details
#' Matching columns are returned in the order in which their indexes appear in
#' the selector, not the underlying schema order.
#'
#' @inherit cs__empty return seealso
#' @examples
#' vals <- as.list(0.5 * 0:100)
#' names(vals) <- paste0("c", 0:100)
#' df <- pl$DataFrame(!!!vals)
#' df
#'
#' # Select columns by index (the two first/last columns):
#' df$select(cs$by_index(c(0, 1, -2, -1)))
#'
#' # Use seq()
#' df$select(cs$by_index(c(0, seq(1, 101, 20)), require_all = FALSE))
#' df$select(cs$by_index(c(0, seq(101, 0, -25)), require_all = FALSE))
#'
#' # Select only odd-indexed columns:
#' df$select(!cs$by_index(seq(0, 100, 2)))
cs__by_index <- function(indices, ..., require_all = TRUE) {
  wrap({
    check_dots_empty0(...)

    PlRSelector$by_index(indices, require_all)
  })
}

#' Select all columns matching the given names
#'
#' @param ... <[`dynamic-dots`][rlang::dyn-dots]> Column names to select.
#' @param require_all Whether to match all names (the default) or any of the names.
#'
#' @inherit cs__by_index details
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   foo = c("x", "y"),
#'   bar = c(123, 456),
#'   baz = c(2.0, 5.5),
#'   zap = c(FALSE, TRUE)
#' )
#'
#' # Select columns by name:
#' df$select(cs$by_name("foo", "bar"))
#'
#' # Match any of the given columns by name:
#' df$select(cs$by_name("baz", "moose", "foo", "bear", require_all = FALSE))
#'
#' # Match all columns except for those given:
#' df$select(!cs$by_name("foo", "bar"))
cs__by_name <- function(..., require_all = TRUE) {
  wrap({
    check_dots_unnamed()
    names <- list2(...)
    check_list_of_string(names, arg = "...")

    PlRSelector$by_name(as.character(names), require_all)
  })
}

#' Select all enum columns
#'
#' `r lifecycle::badge("experimental")`
#' @inherit cs__empty return
#' @seealso
#' - [cs] for the documentation on operators supported by selectors.
#' - [`cs$by_dtype()`][cs__by_dtype]: Select all columns matching the given dtype(s).
#' - [`cs$categorical()`][cs__categorical]: Select all categorical columns.
#' @examples
#' df <- pl$DataFrame(
#'   foo = c("xx", "yy"),
#'   bar = c("aa", "bb"),
#'   baz = c(2.0, 5.5),
#'   .schema_overrides = list(
#'     foo = pl$Enum(c("xx", "yy")),
#'     bar = pl$Enum(c("aa", "bb"))
#'   )
#' )
#'
#' # Select all enum columns:
#' df$select(cs$enum())
#'
#' # Select all columns except for those that are enum:
#' df$select(!cs$enum())
#'
#' # If you want to select specific enum columns,
#' # you can use the `by_dtype()` selector:
#' df$select(cs$by_dtype(pl$Enum(c("aa", "bb"))))
cs__enum <- function() {
  PlRSelector$enum() |>
    wrap()
}

#' Select all list columns
#'
#' `r lifecycle::badge("experimental")`
#' @inherit cs__empty return
#' @param inner An optional inner [selector][cs] to select columns having
#'   specific inner [data types][DataType]. If `NULL`, all inner types are selected.
#' @seealso
#' - [cs] for the documentation on operators supported by selectors.
#' - [`cs$by_dtype()`][cs__by_dtype]: Select all columns matching the given dtype(s).
#' - [`cs$array()`][cs__array]: Select all array columns.
#' - [`cs$nested()`][cs__nested]: Select all nested columns.
#' @examples
#' df <- pl$DataFrame(
#'   foo = list(c("xx", "yy"), "x"),
#'   bar = list(c(123, 456), 789),
#'   baz = c(2.0, 5.5),
#' )
#'
#' # Select all list columns:
#' df$select(cs$list())
#'
#' # Select all columns except for those that are list:
#' df$select(!cs$list())
#'
#' # If you want to select specific list columns,
#' # you can specify the inner data type with a selector:
#' df$select(cs$list(cs$string()))
cs__list <- function(inner = NULL) {
  wrap({
    check_polars_selector(inner, allow_null = TRUE)

    PlRSelector$list(inner$`_rselector`)
  })
}

#' Select all array columns
#'
#' `r lifecycle::badge("experimental")`
#' @inherit cs__empty return
#' @inheritParams cs__list
#' @inheritParams rlang::args_dots_empty
#' @param width An optional integer specifying the width of the array columns to select.
#'   If `NULL`, all widths are selected.
#' @seealso
#' - [cs] for the documentation on operators supported by selectors.
#' - [`cs$by_dtype()`][cs__by_dtype]: Select all columns matching the given dtype(s).
#' - [`cs$list()`][cs__list]: Select all list columns.
#' - [`cs$nested()`][cs__nested]: Select all nested columns.
#' @examples
#' df <- pl$DataFrame(
#'   foo = list(c("xx", "yy"), c("x", "y")),
#'   bar = list(123, 456),
#'   baz = c(2.0, 5.5),
#'   .schema_overrides = list(
#'     foo = pl$Array(pl$String, 2),
#'     bar = pl$Array(pl$Int64, 1)
#'   )
#' )
#'
#' # Select all array columns:
#' df$select(cs$array())
#'
#' # Select all columns except for those that are array:
#' df$select(!cs$array())
#'
#' # If you want to select specific array columns,
#' # you can specify the inner data type and/or width:
#' df$select(cs$array(cs$string()))
#' df$select(cs$array(width = 1))
#' df$select(cs$array(cs$string() | cs$numeric(), width = 2))
cs__array <- function(inner = NULL, ..., width = NULL) {
  wrap({
    check_dots_empty0(...)
    check_polars_selector(inner, allow_null = TRUE)

    PlRSelector$array(inner$`_rselector`, width)
  })
}

#' Select all struct columns
#'
#' `r lifecycle::badge("experimental")`
#' @inherit cs__empty return
#' @seealso
#' - [cs] for the documentation on operators supported by selectors.
#' - [`cs$by_dtype()`][cs__by_dtype]: Select all columns matching the given dtype(s).
#' - [`cs$list()`][cs__list]: Select all list columns.
#' - [`cs$array()`][cs__array]: Select all array columns.
#' - [`cs$nested()`][cs__nested]: Select all nested columns.
#' @examples
#' df <- pl$DataFrame(
#'   foo = data.frame(a = c("xx", "x"), b = c("yy", "y")),
#'   bar = data.frame(a = c(123, 456), b = c(789, 101)),
#'   baz = c(2.0, 5.5),
#' )
#'
#' # Select all struct columns:
#' df$select(cs$struct())
#'
#' # Select all columns except for those that are struct:
#' df$select(!cs$struct())
#'
#' # If you want to select specific struct columns,
#' # you can use the `by_dtype()` selector:
#' df$select(cs$by_dtype(pl$Struct(
#'   a = pl$String,
#'   b = pl$String
#' )))
cs__struct <- function() {
  PlRSelector$struct() |>
    wrap()
}

#' Select all nested columns
#'
#' `r lifecycle::badge("experimental")`
#' A nested column is a [list][pl__List], [array][pl__Array] or [struct][pl__Struct].
#' @inherit cs__empty return
#' @seealso
#' - [cs] for the documentation on operators supported by selectors.
#' - [`cs$by_dtype()`][cs__by_dtype]: Select all columns matching the given dtype(s).
#' - [`cs$list()`][cs__list]: Select all list columns.
#' - [`cs$array()`][cs__array]: Select all array columns.
#' - [`cs$struct()`][cs__struct]: Select all struct columns.
#' @examples
#' df <- pl$DataFrame(
#'   foo = data.frame(a = c("xx", "x"), b = c("yy", "y")),
#'   bar = c(123, 456),
#'   baz = c(2, 5.5),
#'   wow = list(c(1, 2), c(3)),
#' )
#'
#' # Select all nested columns:
#' df$select(cs$nested())
#'
#' # Select all columns except for those that are nested:
#' df$select(!cs$nested())
cs__nested <- function() {
  PlRSelector$nested() |>
    wrap()
}

#' Select all categorical columns
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   foo = c("xx", "yy"),
#'   bar = c(123, 456),
#'   baz = c(2.0, 5.5),
#'   .schema_overrides = list(foo = pl$Categorical()),
#' )
#'
#' # Select categorical columns:
#' df$select(cs$categorical())
#'
#' # Select all columns except for those that are categorical:
#' df$select(!cs$categorical())
cs__categorical <- function() {
  PlRSelector$categorical() |>
    wrap()
}

#' Select columns whose names contain the given literal substring(s)
#'
#' @param ... <[`dynamic-dots`][rlang::dyn-dots]> Substring(s) that matching
#' column names should contain.
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   foo = c("x", "y"),
#'   bar = c(123, 456),
#'   baz = c(2.0, 5.5),
#'   zap = c(FALSE, TRUE)
#' )
#'
#' # Select columns that contain the substring "ba":
#' df$select(cs$contains("ba"))
#'
#' # Select columns that contain the substring "ba" or the letter "z":
#' df$select(cs$contains("ba", "z"))
#'
#' # Select all columns except for those that contain the substring "ba":
#' df$select(!cs$contains("ba"))
cs__contains <- function(...) {
  wrap({
    check_dots_unnamed()
    dots <- list2(...)
    check_list_of_string(dots, arg = "...")

    as.character(dots) |>
      re_string() |>
      sprintf("^.*%s.*$", x = _) |>
      PlRSelector$matches()
  })
}

#' Select all date columns
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   dtm = as.POSIXct(c("2001-5-7 10:25", "2031-12-31 00:30")),
#'   dt = as.Date(c("1999-12-31", "2024-8-9"))
#' )
#'
#' # Select date columns:
#' df$select(cs$date())
#'
#' # Select all columns except for those that are dates:
#' df$select(!cs$date())
cs__date <- function() {
  cs__by_dtype(pl$Date)
}

#' Select all datetime columns
#'
#' @param time_unit One (or more) of the allowed time unit precision strings,
#' `"ms"`, `"us"`, and `"ns"`. Default is to select columns with any valid
#' timeunit.
#' @param time_zone One of the followings. The value or each element of the vector
#' will be passed to the `time_zone` argument of the [`pl$Datetime()`][DataType] function:
#' * A character vector of one or more timezone strings, as defined in [OlsonNames()].
#' * `NULL` to select Datetime columns that do not have a timezone.
#' * `"*"` to select Datetime columns that have any timezone.
#' * A list of single timezone strings , `"*"`, and `NULL` to select Datetime columns
#'   that do not have a timezone or have the (specific) timezone.
#'   For example, the default value `list("*", NULL)` selects all Datetime columns.
#'
#' @inherit cs__empty return seealso
#' @examples
#' chr_vec <- c("1999-07-21 05:20:16.987654", "2000-05-16 06:21:21.123456")
#' df <- pl$DataFrame(
#'   tstamp_tokyo = as.POSIXlt(chr_vec, tz = "Asia/Tokyo"),
#'   tstamp_utc = as.POSIXct(chr_vec, tz = "UTC"),
#'   tstamp = as.POSIXct(chr_vec),
#'   dt = as.Date(chr_vec),
#' )
#'
#' # Select all datetime columns:
#' df$select(cs$datetime())
#'
#' # Select all datetime columns that have "ms" precision:
#' df$select(cs$datetime("ms"))
#'
#' # Select all datetime columns that have any timezone:
#' df$select(cs$datetime(time_zone = "*"))
#'
#' # Select all datetime columns that have a specific timezone:
#' df$select(cs$datetime(time_zone = "UTC"))
#'
#' # Select all datetime columns that have NO timezone:
#' df$select(cs$datetime(time_zone = NULL))
#'
#' # Select all columns except for datetime columns:
#' df$select(!cs$datetime())
cs__datetime <- function(time_unit = c("ms", "us", "ns"), time_zone = list("*", NULL)) {
  wrap({
    time_unit <- arg_match(time_unit, values = c("ms", "us", "ns"), multiple = TRUE)
    PlRSelector$datetime(time_unit, time_zone)
  })
}

#' Select all decimal columns
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   foo = c("x", "y"),
#'   bar = c(123, 456),
#'   baz = c("2.0005", "-50.5555"),
#'   .schema_overrides = list(
#'     bar = pl$Decimal(),
#'     baz = pl$Decimal(scale = 5, precision = 10)
#'   )
#' )
#'
#' # Select decimal columns:
#' df$select(cs$decimal())
#'
#' # Select all columns except for those that are decimal:
#' df$select(!cs$decimal())
cs__decimal <- function() {
  PlRSelector$decimal() |>
    wrap()
}

#' Select all columns having names consisting only of digits
#'
#' @inheritParams cs__alpha
#'
#' @details
#' Matching column names cannot contain any non-digit characters. Note that the
#' definition of "digit" consists of all valid Unicode digit characters (`d`)
#' by default; this can be changed by setting `ascii_only = TRUE`.
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   key = c("aaa", "bbb"),
#'   `2001` = 1:2,
#'   `2025` = 3:4
#' )
#'
#' # Select columns with digit names:
#' df$select(cs$digit())
#'
#' # Select all columns except for those with digit names:
#' df$select(!cs$digit())
#'
#' # Demonstrate use of ascii_only flag (by default all valid unicode digits
#' # are considered, but this can be constrained to ascii 0-9):
#' df <- pl$DataFrame(`१९९९` = 1999, `२०७७` = 2077, `3000` = 3000)
#' df$select(cs$digit())
#' df$select(cs$digit(ascii_only = TRUE))
cs__digit <- function(ascii_only = FALSE) {
  wrap({
    re_digit <- if (isTRUE(ascii_only)) "[0-9]" else r"(\d)"
    PlRSelector$matches(sprintf("^%s+$", re_digit))
  })
}

#' Select all duration columns, optionally filtering by time unit
#'
#' @inheritParams cs__datetime
#'
#' @inherit cs__empty return seealso
#' @examplesIf requireNamespace("clock", quietly = TRUE)
#' df <- pl$DataFrame(
#'   dtm = as.POSIXct(c("2001-5-7 10:25", "2031-12-31 00:30")),
#'   dur_ms = clock::duration_milliseconds(1:2),
#'   dur_us = clock::duration_microseconds(1:2),
#'   dur_ns = clock::duration_nanoseconds(1:2),
#' )
#'
#' # Select duration columns:
#' df$select(cs$duration())
#'
#' # Select all duration columns that have "ms" precision:
#' df$select(cs$duration("ms"))
#'
#' # Select all duration columns that have "ms" OR "ns" precision:
#' df$select(cs$duration(c("ms", "ns")))
#'
#' # Select all columns except for those that are duration:
#' df$select(!cs$duration())
cs__duration <- function(time_unit = c("ms", "us", "ns")) {
  wrap({
    time_unit <- arg_match(time_unit, values = c("ms", "us", "ns"), multiple = TRUE)
    PlRSelector$duration(time_unit)
  })
}

#' Select columns that end with the given substring(s)
#'
#' @param ... <[`dynamic-dots`][rlang::dyn-dots]> Substring(s) that matching
#' column names should end with.
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   foo = c("x", "y"),
#'   bar = c(123, 456),
#'   baz = c(2.0, 5.5),
#'   zap = c(FALSE, TRUE)
#' )
#'
#' # Select columns that end with the substring "z":
#' df$select(cs$ends_with("z"))
#'
#' # Select columns that end with either the letter "z" or "r":
#' df$select(cs$ends_with("z", "r"))
#'
#' # Select all columns except for those that end with the substring "z":
#' df$select(!cs$ends_with("z"))
cs__ends_with <- function(...) {
  wrap({
    check_dots_unnamed()
    dots <- list2(...)
    check_list_of_string(dots, arg = "...")

    as.character(dots) |>
      re_string() |>
      sprintf("^.*%s$", x = _) |>
      PlRSelector$matches()
  })
}

#' Select all columns except those matching the given columns, datatypes, or
#' selectors
#'
#' @param ... <[`dynamic-dots`][rlang::dyn-dots]> Column names to exclude.
#'
#' @details
#' If excluding a single selector it is simpler to write as `!selector` instead.
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   aa = 1:3,
#'   ba = c("a", "b", NA),
#'   cc = c(NA, 2.5, 1.5)
#' )
#'
#' # Exclude by column name(s):
#' df$select(cs$exclude("ba", "xx"))
#'
#' # Exclude using a column name, a selector, and a dtype:
#' df$select(cs$exclude("aa", cs$string(), pl$Int32))
cs__exclude <- function(...) {
  wrap({
    check_dots_unnamed()
    input <- list2(...)

    col_names <- Filter(
      \(x) is_string(x) && !(startsWith(x, "^") && !endsWith(x, "$")),
      input
    )
    regexes <- Filter(
      \(x) is_string(x) && startsWith(x, "^") && endsWith(x, "$"),
      input
    )
    dtypes <- Filter(is_polars_dtype, input)
    selectors <- Filter(is_polars_selector, input)
    unknown <- Filter(
      \(x) !is_string(x) && !is_polars_dtype(x) && !is_polars_selector(x),
      input
    )
    if (length(unknown) > 0L) {
      abort("`...` can only contain column names, regexes, polars data types or polars selectors.")
    }

    all_selected <- c(
      cs__by_name(!!!col_names, require_all = FALSE),
      cs__by_dtype(!!!dtypes),
      if (length(regexes) > 0L) {
        cs__matches(sprintf("(%s)", paste0(unlist(regexes), collapse = "|")))
      },
      selectors
    ) |>
      Reduce(`|`, x = _)

    !all_selected
  })
}

#' Select the first column in the current scope
#'
#' @inherit cs__empty return seealso
#' @inheritParams rlang::args_dots_empty
#' @param strict Require the column exists.
#' @examples
#' df <- pl$DataFrame(
#'   foo = c("x", "y"),
#'   bar = c(123L, 456L),
#'   baz = c(2.0, 5.5),
#'   zap = c(FALSE, TRUE)
#' )
#'
#' # Select the first column:
#' df$select(cs$first())
#'
#' # Select everything except for the first column:
#' df$select(!cs$first())
cs__first <- function(..., strict = TRUE) {
  wrap({
    check_dots_empty0(...)
    PlRSelector$first(strict)
  })
}

#' Select all float columns.
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   foo = c("x", "y"),
#'   bar = c(123L, 456L),
#'   baz = c(2.0, 5.5),
#'   zap = c(FALSE, TRUE),
#'   .schema_overrides = list(baz = pl$Float32, zap = pl$Float64),
#' )
#'
#' # Select all float columns:
#' df$select(cs$float())
#'
#' # Select all columns except for those that are float:
#' df$select(!cs$float())
cs__float <- function() {
  PlRSelector$float() |>
    wrap()
}

#' Select all integer columns.
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   foo = c("x", "y"),
#'   bar = c(123L, 456L),
#'   baz = c(2.0, 5.5),
#'   zap = 0:1
#' )
#'
#' # Select all integer columns:
#' df$select(cs$integer())
#'
#' # Select all columns except for those that are integer:
#' df$select(!cs$integer())
cs__integer <- function() {
  PlRSelector$integer() |>
    wrap()
}

#' Select all signed integer columns
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   foo = c(-123L, -456L),
#'   bar = c(3456L, 6789L),
#'   baz = c(7654L, 4321L),
#'   zap = c("ab", "cd"),
#'   .schema_overrides = list(bar = pl$UInt32, baz = pl$UInt64),
#' )
#'
#' # Select signed integer columns:
#' df$select(cs$signed_integer())
#'
#' # Select all columns except for those that are signed integer:
#' df$select(!cs$signed_integer())
#'
#' # Select all integer columns (both signed and unsigned):
#' df$select(cs$integer())
cs__signed_integer <- function() {
  PlRSelector$signed_integer() |>
    wrap()
}

#' Select all unsigned integer columns
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   foo = c(-123L, -456L),
#'   bar = c(3456L, 6789L),
#'   baz = c(7654L, 4321L),
#'   zap = c("ab", "cd"),
#'   .schema_overrides = list(bar = pl$UInt32, baz = pl$UInt64),
#' )
#'
#' # Select unsigned integer columns:
#' df$select(cs$unsigned_integer())
#'
#' # Select all columns except for those that are unsigned integer:
#' df$select(!cs$unsigned_integer())
#'
#' # Select all integer columns (both unsigned and unsigned):
#' df$select(cs$integer())
cs__unsigned_integer <- function() {
  PlRSelector$unsigned_integer() |>
    wrap()
}

#' Select the last column in the current scope
#'
#' @inherit cs__empty return seealso
#' @inheritParams cs__first
#' @examples
#' df <- pl$DataFrame(
#'   foo = c("x", "y"),
#'   bar = c(123L, 456L),
#'   baz = c(2.0, 5.5),
#'   zap = c(FALSE, TRUE)
#' )
#'
#' # Select the last column:
#' df$select(cs$last())
#'
#' # Select everything except for the last column:
#' df$select(!cs$last())
cs__last <- function(..., strict = TRUE) {
  wrap({
    check_dots_empty0(...)
    PlRSelector$last(strict)
  })
}

#' Select all columns that match the given regex pattern
#'
#' @param pattern A valid regular expression pattern, compatible with the
#' `regex crate <https://docs.rs/regex/latest/regex/>`_.
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   foo = c("x", "y"),
#'   bar = c(123, 456),
#'   baz = c(2.0, 5.5),
#'   zap = c(0, 1)
#' )
#'
#' # Match column names containing an "a", preceded by a character that is not
#' # "z":
#' df$select(cs$matches("[^z]a"))
#'
#' # Do not match column names ending in "R" or "z" (case-insensitively):
#' df$select(!cs$matches(r"((?i)R|z$)"))
cs__matches <- function(pattern) {
  wrap({
    check_string(pattern)

    if (pattern == ".*") {
      cs__all()
    } else {
      if (startsWith(pattern, ".*")) {
        pattern <- substring(pattern, 3)
      } else if (endsWith(pattern, ".*")) {
        pattern <- substring(pattern, 1, nchar(pattern) - 2)
      }

      pfx <- if (!startsWith(pattern, "^")) "^.*" else ""
      sfx <- if (!endsWith(pattern, "$")) ".*$" else ""
      sprintf("%s%s%s", pfx, pattern, sfx) |>
        PlRSelector$matches()
    }
  })
}

#' Select all numeric columns.
#'
#' @inherit cs__all return seealso
#' @examples
#' df <- pl$DataFrame(
#'   foo = c("x", "y"),
#'   bar = c(123L, 456L),
#'   baz = c(2.0, 5.5),
#'   zap = 0:1,
#'   .schema_overrides = list(bar = pl$Int16, baz = pl$Float32, zap = pl$UInt8),
#' )
#'
#' # Select all numeric columns:
#' df$select(cs$numeric())
#'
#' # Select all columns except for those that are numeric:
#' df$select(!cs$numeric())
cs__numeric <- function() {
  PlRSelector$numeric() |>
    wrap()
}

#' Select columns that start with the given substring(s)
#'
#' @param ... <[`dynamic-dots`][rlang::dyn-dots]> Substring(s) that matching
#' column names should end with.
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   foo = c("x", "y"),
#'   bar = c(123, 456),
#'   baz = c(2.0, 5.5),
#'   zap = c(FALSE, TRUE)
#' )
#'
#' # Select columns that start with the substring "b":
#' df$select(cs$starts_with("b"))
#'
#' # Select columns that start with either the letter "b" or "z":
#' df$select(cs$starts_with("b", "z"))
#'
#' # Select all columns except for those that start with the substring "b":
#' df$select(!cs$starts_with("b"))
cs__starts_with <- function(...) {
  wrap({
    check_dots_unnamed()
    dots <- list2(...)
    check_list_of_string(dots, arg = "...")

    as.character(dots) |>
      re_string() |>
      sprintf("^%s.*$", x = _) |>
      PlRSelector$matches()
  })
}

#' Select all String (and, optionally, Categorical) string columns.
#'
#' @inheritParams rlang::args_dots_empty
#' @param include_categorical If `TRUE`, also select categorical columns.
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   w = c("xx", "yy", "xx", "yy", "xx"),
#'   x = c(1, 2, 1, 4, -2),
#'   y = c(3.0, 4.5, 1.0, 2.5, -2.0),
#'   z = c("a", "b", "a", "b", "b")
#' )$with_columns(
#'   z = pl$col("z")$cast(pl$Categorical())
#' )
#'
#' # Group by all string columns, sum the numeric columns, then sort by the
#' # string cols:
#' df$group_by(cs$string())$agg(cs$numeric()$sum())$sort(cs$string())
#'
#' # Group by all string and categorical columns:
#' df$
#'   group_by(cs$string(include_categorical = TRUE))$
#'   agg(cs$numeric()$sum())$
#'   sort(cs$string(include_categorical = TRUE))
cs__string <- function(..., include_categorical = FALSE) {
  wrap({
    check_dots_empty0(...)
    if (isTRUE(include_categorical)) {
      cs__by_dtype(pl$String) | cs__categorical()
    } else {
      cs__by_dtype(pl$String)
    }
  })
}

#' Select all temporal columns
#'
#' @inherit cs__empty return seealso
#' @examples
#' df <- pl$DataFrame(
#'   dtm = as.POSIXct(c("2001-5-7 10:25", "2031-12-31 00:30")),
#'   dt = as.Date(c("1999-12-31", "2024-8-9")),
#'   value = 1:2
#' )
#'
#' # Match all temporal columns:
#' df$select(cs$temporal())
#'
#' # Match all temporal columns except for time columns:
#' df$select(cs$temporal() - cs$datetime())
#'
#' # Match all columns except for temporal columns:
#' df$select(!cs$temporal())
cs__temporal <- function() {
  PlRSelector$temporal() |>
    wrap()
}

#' Select all time columns
#'
#' @inherit cs__empty return seealso
#' @examplesIf requireNamespace("hms", quietly = TRUE)
#' df <- pl$DataFrame(
#'   dtm = as.POSIXct(c("2001-5-7 10:25", "2031-12-31 00:30")),
#'   dt = as.Date(c("1999-12-31", "2024-8-9")),
#'   tm = hms::parse_hms(c("0:0:0", "23:59:59"))
#' )
#'
#' # Select time columns:
#' df$select(cs$time())
#'
#' # Select all columns except for those that are time:
#' df$select(!cs$time())
cs__time <- function() {
  cs__by_dtype(pl$Time)
}
