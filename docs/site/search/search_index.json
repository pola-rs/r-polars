{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"polars","text":"<p>The goal of this project is to bring the blazingly fast Polars data manipulation library to R. The underlying computation engine is written in Rust and this R implementation has no other dependencies than R itself (\u2265 4.1.0).</p> <p>Documentation can be found on the r-polars homepage.</p> <p>The primary developer of the upstream Polars project is Ritchie Vink (@ritchie46). This R port is maintained by S\u00f8ren Welling (@sorhawell), together with other contributors. Consider joining our Discord (subchannel) for additional help and discussion.</p> <p>Update: As of March 2023, polars has now reached nearly 100% coverage of the underlying \u201clazy\u201d Expr syntax. While translation of the \u201ceager\u201d syntax is still a little further behind, you should be able to do just about everything using <code>$select()</code> + <code>$with_columns()</code>.</p>"},{"location":"#install","title":"Install","text":"<p>The package is not yet available on CRAN. But we provide convenient installation options for a variety of operating systems:</p>"},{"location":"#r-universe","title":"R-universe","text":"<p>R-universe provides pre-compiled polars binaries for Windows and MacOS (x86_64), with source builds for other platforms. Please see the GitHub release option below for binary install options on Linux.</p> <pre><code>install.packages(\"polars\", repos = \"https://rpolars.r-universe.dev\")\n</code></pre> <p>Special thanks to Jeroen Ooms (@jeroen) for the excellent R-universe support.</p>"},{"location":"#github-releases","title":"GitHub releases","text":"<p>We also provide pre-compiled binaries for various operating systems, as well as source installs, on our GitHub releases page. You can download and install these files manually, or install directly from R. Simply match the URL for your operating system and the desired release. For example, to install the latest release of polars on Linux (x86_64) one would use:</p> <pre><code>install.packages(\n\"https://github.com/pola-rs/r-polars/releases/latest/download/polars__x86_64-pc-linux-gnu.gz\",\nrepos = NULL )\n</code></pre> <p>Similarly for Windows (URL and MacOS (x86_64, URL). Just remember to invoke the <code>repos = NULL</code> argument if you are installing these binary builds directly from within R.</p> <p>One exception worth noting is MacOS (arm64), i.e.\u00a0systems based on the new M1/M2 \u201cSilicon\u201d chips. To install polars on one of these machines, we need to build the package from source and this requires Xcode (<code>xcode-select --install</code>). Once Xcode is installed, you can run the below code chunk to build polars. The corresponding <code>Makevars</code> script will download a \\~200MB cross-compiled object file, while your machine links and builds the final R package.</p> <pre><code># install.packages(\"remotes\")\nremotes::install_github(\n\"https://github.com/pola-rs/r-polars\",\nref = \"long_arms64\", force =TRUE\n)\n</code></pre> <p>Please file an issue if you require a different target or operating system build. Finally, see the bottom of this README for details on how to install rust to build from source (only relevant for developers, or users of unsupported operating systems).</p>"},{"location":"#quickstart-example","title":"Quickstart example","text":"<p>The introductory vignette (<code>vignette(\"polars\")</code>) contains a series of detailed examples. But here is a quick illustration of polars in action.</p> <p>Start by loading the package and creating a Polars <code>DataFrame</code> object. Similar to the Python implementation, note that we use the <code>pl$</code> prefix to specify a Polars constructor.</p> <pre><code>library(polars)\ndat = pl$DataFrame(mtcars)\ndat\n#&gt; polars DataFrame: shape: (32, 11)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 mpg  \u2506 cyl \u2506 disp  \u2506 hp    \u2506 ... \u2506 vs  \u2506 am  \u2506 gear \u2506 carb \u2502\n#&gt; \u2502 ---  \u2506 --- \u2506 ---   \u2506 ---   \u2506     \u2506 --- \u2506 --- \u2506 ---  \u2506 ---  \u2502\n#&gt; \u2502 f64  \u2506 f64 \u2506 f64   \u2506 f64   \u2506     \u2506 f64 \u2506 f64 \u2506 f64  \u2506 f64  \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0  \u2506 4.0  \u2502\n#&gt; \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0  \u2506 4.0  \u2502\n#&gt; \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0  \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0  \u2506 1.0  \u2502\n#&gt; \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0  \u2506 1.0  \u2502\n#&gt; \u2502 ...  \u2506 ... \u2506 ...   \u2506 ...   \u2506 ... \u2506 ... \u2506 ... \u2506 ...  \u2506 ...  \u2502\n#&gt; \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0  \u2506 4.0  \u2502\n#&gt; \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0  \u2506 6.0  \u2502\n#&gt; \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0  \u2506 8.0  \u2502\n#&gt; \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0  \u2506 2.0  \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Once our Polars DataFrame has been created, we can chain together a series of data manipulations as part of the same query. For example:</p> <pre><code>dat$filter(\npl$col(\"cyl\")&gt;=6\n)$groupby(\n\"cyl\", \"am\"\n)$agg(\npl$col(\"mpg\")$mean()$alias(\"mean_mpg\"),\npl$col(\"hp\")$median()$alias(\"med_hp\")\n)\n#&gt; polars DataFrame: shape: (4, 4)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 cyl \u2506 am  \u2506 mean_mpg  \u2506 med_hp \u2502\n#&gt; \u2502 --- \u2506 --- \u2506 ---       \u2506 ---    \u2502\n#&gt; \u2502 f64 \u2506 f64 \u2506 f64       \u2506 f64    \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 6.0 \u2506 1.0 \u2506 20.566667 \u2506 110.0  \u2502\n#&gt; \u2502 6.0 \u2506 0.0 \u2506 19.125    \u2506 116.5  \u2502\n#&gt; \u2502 8.0 \u2506 0.0 \u2506 15.05     \u2506 180.0  \u2502\n#&gt; \u2502 8.0 \u2506 1.0 \u2506 15.4      \u2506 299.5  \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The above is an example of Polars\u2019 eager execution engine. But for maximum performance, it is preferable to use Polars\u2019 lazy execution mode, which allows the package to apply additional query optimizations.</p> <pre><code>ldat = dat$lazy()\nldat$filter(\npl$col(\"cyl\")&gt;=6\n)$groupby(\n\"cyl\", \"am\"\n)$agg(\npl$col(\"mpg\")$mean()$alias(\"mean_mpg\"),\npl$col(\"hp\")$median()$alias(\"med_hp\")\n)$collect()\n#&gt; polars DataFrame: shape: (4, 4)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 cyl \u2506 am  \u2506 mean_mpg  \u2506 med_hp \u2502\n#&gt; \u2502 --- \u2506 --- \u2506 ---       \u2506 ---    \u2502\n#&gt; \u2502 f64 \u2506 f64 \u2506 f64       \u2506 f64    \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 6.0 \u2506 1.0 \u2506 20.566667 \u2506 110.0  \u2502\n#&gt; \u2502 6.0 \u2506 0.0 \u2506 19.125    \u2506 116.5  \u2502\n#&gt; \u2502 8.0 \u2506 0.0 \u2506 15.05     \u2506 180.0  \u2502\n#&gt; \u2502 8.0 \u2506 1.0 \u2506 15.4      \u2506 299.5  \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#contribute","title":"Contribute","text":"<p>Contributions are very welcome!</p> <p>Here are the steps required for an example contribution, where we are implementing the cosine expression:</p> <ul> <li>Look up the polars.Expr.cos method in py-polars   documentation.</li> <li>Press the <code>[source]</code> button to see the Python   impl</li> <li>Find the cos py-polars rust   implementation   (likely just a simple call to the Rust-Polars API)</li> <li>Adapt the Rust part and place it   here.</li> <li>Adapt the Python frontend syntax to R and place it   here.   Add the roxygen docs + examples above.</li> <li>Notice we use <code>Expr_cos = \"use_extendr_wrapper\"</code>, it means we\u2019re just   using unmodified the extendr auto-generated   wrapper</li> <li>Write a test   here.</li> <li>Run <code>renv::restore()</code> and resolve all R packages</li> <li>Run <code>rextendr::document()</code> to recompile and confirm the added method   functions as intended,   e.g.\u00a0<code>pl$DataFrame(a=c(0,pi/2,pi,NA_real_))$select(pl$col(\"a\")$cos())</code></li> <li>Run <code>devtools::test()</code>. See below for how to set up your development   environment correctly.</li> </ul> <p>Note that PRs to polars will be automatically be built and tested on all platforms as part of our GitHub Actions workflow. A more detailed description of the development environment and workflow for local builds is provided below.</p>"},{"location":"#development-environment-and-workflow","title":"Development environment and workflow","text":""},{"location":"#system-dependencies","title":"System dependencies","text":"<p>Rust toolchain</p> <ul> <li>Install <code>rustup</code>, the cross-platform Rust   installer. Then:</li> </ul> <pre><code>rustup toolchain install nightly\nrustup default nightly\n</code></pre> <ul> <li> <p>Windows: Make sure the latest version of   Rtools is installed   and on your PATH.</p> </li> <li> <p>MacOS: Make sure <code>Xcode</code>   is installed.</p> </li> <li> <p>Install CMake and added it to your PATH.</p> </li> </ul>"},{"location":"#development-workflow","title":"Development workflow","text":"<p>Assuming the system dependencies have been met (above), the typical polars development workflow is as follows:</p> <p>Step 1: Fork the polars repo on GitHub and then clone it locally.</p> <pre><code>git clone git@github.com:&lt;YOUR-GITHUB-ACCOUNT&gt;/r-polars.git\ncd r-polars\n</code></pre> <p>Step 2: Build the package and install the suggested package dependencies.</p> <ul> <li>Option A: Using devtools.</li> </ul> <pre><code>Rscript -e 'devtools::install(pkg = \".\", dependencies = TRUE)' </code></pre> <ul> <li>Option B: Using renv.</li> </ul> <pre><code># Rscript -e 'install.packages(\"renv\")'\nRscript -e 'renv::activate(); renv::restore()'\n</code></pre> <p>Step 3: Make your proposed changes to the R and/or Rust code. Don\u2019t forget to run:</p> <pre><code>rextendr::document() # compile Rust code + update wrappers &amp; docs\ndevtools::test()     # run all unit tests\n</code></pre> <p>Step 4 (optional): Build the package locally.</p> <pre><code>R CMD INSTALL --no-multiarch --with-keep.source polars\n</code></pre> <p>Step 5: Commit your changes and submit a PR to the main polars repo.</p> <ul> <li>As aside, notice that <code>./renv.lock</code> sets all R packages during the   server build.</li> </ul> <p>Tip: To speed up the local R CMD check, run the following:</p> <pre><code>devtools::check(\nenv_vars = list(RPOLARS_RUST_SOURCE=\"/YOUR/OWN/ABSOLUTE/PATH/r-polars/src/rust\"),\ncheck_dir = \"./check/\"\n)\nsource(\"./inst/misc/filter_rcmdcheck.R\")\nSys.sleep(5)\nunlink(\"check\",recursive = TRUE, force =TRUE)\n</code></pre> <ul> <li>The <code>RPOLARS_RUST_SOURCE</code> environment variable allows polars to   recover the Cargo cache even if source files have been moved. Replace   with your own absolute path to your local clone!</li> <li><code>filter_rcmdcheck.R</code> removes known warnings from final check report.</li> <li><code>unlink(\"check\")</code> cleans up.</li> </ul>"},{"location":"LICENSE/","title":"MIT License","text":"<p>Copyright (c) 2023 rpolars authors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#all","title":"All","text":""},{"location":"reference/#description","title":"Description","text":"<p>Not to mix up with <code>Expr_object$all()</code> which is a 'reduce Boolean columns by AND' method.</p>"},{"location":"reference/#details","title":"Details","text":"<p>last <code>all()</code> in example is this Expr method, the first <code>pl$all()</code> refers to \"all-columns\" and is an expression constructor</p>"},{"location":"reference/#value","title":"Value","text":"<p>Boolean literal</p>"},{"location":"reference/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(all=c(TRUE,TRUE),some=c(TRUE,FALSE)))$select(pl$all()$all())\n</code></pre>"},{"location":"reference/#and-then","title":"And then","text":""},{"location":"reference/#description_1","title":"Description","text":"<p>map an ok-value or pass on an err-value</p>"},{"location":"reference/#usage","title":"Usage","text":"<pre><code>and_then(x, f)\n</code></pre>"},{"location":"reference/#arguments","title":"Arguments","text":"<code>x</code> <p>any R object</p> <code>f</code> <p>a closure that takes the ok part as input</p>"},{"location":"reference/#value_1","title":"Value","text":"<p>same R object wrapped in a Err-result</p>"},{"location":"reference/#arr-arg-max","title":"Arr arg max","text":""},{"location":"reference/#description_2","title":"Description","text":"<p>Retrieve the index of the maximum value in every sublist.</p>"},{"location":"reference/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_2","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_1","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(s = list(1:2,2:1)))\ndf$select(pl$col(\"s\")$arr$arg_max())\n</code></pre>"},{"location":"reference/#arr-arg-min","title":"Arr arg min","text":""},{"location":"reference/#description_3","title":"Description","text":"<p>Retrieve the index of the minimal value in every sublist.</p>"},{"location":"reference/#format_1","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_3","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_2","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(s = list(1:2,2:1)))\ndf$select(pl$col(\"s\")$arr$arg_min())\n</code></pre>"},{"location":"reference/#arr-concat","title":"Arr concat","text":""},{"location":"reference/#description_4","title":"Description","text":"<p>Concat the arrays in a Series dtype List in linear time.</p>"},{"location":"reference/#arguments_1","title":"Arguments","text":"<code>other</code> <p>Rlist, Expr or column of same tyoe as self.</p>"},{"location":"reference/#format_2","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_4","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_3","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = list(\"a\",\"x\"),\nb = list(c(\"b\",\"c\"),c(\"y\",\"z\"))\n)\ndf$select(pl$col(\"a\")$arr$concat(pl$col(\"b\")))\ndf$select(pl$col(\"a\")$arr$concat(\"hello from R\"))\ndf$select(pl$col(\"a\")$arr$concat(list(\"hello\",c(\"hello\",\"world\"))))\n</code></pre>"},{"location":"reference/#arr-contains","title":"Arr contains","text":""},{"location":"reference/#description_5","title":"Description","text":"<p>Check if sublists contain the given item.</p>"},{"location":"reference/#arguments_2","title":"Arguments","text":"<code>item</code> <p>any into Expr/literal</p>"},{"location":"reference/#format_3","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_5","title":"Value","text":"<p>Expr of a boolean mask</p>"},{"location":"reference/#examples_4","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(3:1, NULL, 1:2))) #NULL or integer() or list()\ndf$select(pl$col(\"a\")$arr$contains(1L))\n</code></pre>"},{"location":"reference/#arr-diff","title":"Arr diff","text":""},{"location":"reference/#description_6","title":"Description","text":"<p>Calculate the n-th discrete difference of every sublist.</p>"},{"location":"reference/#arguments_3","title":"Arguments","text":"<code>n</code> <p>Number of slots to shift</p> <code>null_behavior</code> <p>choice \"ignore\"(default) \"drop\"</p>"},{"location":"reference/#format_4","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_6","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_5","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(s = list(1:4,c(10L,2L,1L))))\ndf$select(pl$col(\"s\")$arr$diff())\n</code></pre>"},{"location":"reference/#arr-eval","title":"Arr eval","text":""},{"location":"reference/#description_7","title":"Description","text":"<p>Run any polars expression against the lists' elements.</p>"},{"location":"reference/#arguments_4","title":"Arguments","text":"<code>Expr</code> <p>Expression to run. Note that you can select an element with <code>pl$first()</code>, or <code>pl$col()</code></p> <code>parallel</code> <p>bool Run all expression parallel. Don't activate this blindly. Parallelism is worth it if there is enough work to do per thread. This likely should not be use in the groupby context, because we already parallel execution per group</p>"},{"location":"reference/#format_5","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_7","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_6","title":"Examples","text":"<pre><code>df = pl$DataFrame(a = list(c(1,8,3), b = c(4,5,2)))\ndf$select(pl$all()$cast(pl$dtypes$Int64))$with_column(\npl$concat_list(c(\"a\",\"b\"))$arr$eval(pl$element()$rank())$alias(\"rank\")\n)\n</code></pre>"},{"location":"reference/#arr-first","title":"Arr first","text":""},{"location":"reference/#description_8","title":"Description","text":"<p>Get the first value of the sublists.</p>"},{"location":"reference/#format_6","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_8","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_7","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(3:1, NULL, 1:2))) #NULL or integer() or list()\ndf$select(pl$col(\"a\")$arr$first())\n</code></pre>"},{"location":"reference/#arr-get","title":"Arr get","text":""},{"location":"reference/#description_9","title":"Description","text":"<p>Get the value by index in the sublists.</p>"},{"location":"reference/#usage_1","title":"Usage","text":"<pre><code>## S3 method for class 'ExprArrNameSpace'\nx[index]\n</code></pre>"},{"location":"reference/#arguments_5","title":"Arguments","text":"<code>x</code> <p>ExprArrNameSpace</p> <code>index</code> <p>value to get</p>"},{"location":"reference/#format_7","title":"Format","text":"<p>function</p>"},{"location":"reference/#details_1","title":"Details","text":"<p><code>\u2060[.ExprArrNameSpace\u2060</code> used as e.g. <code>pl$col(\"a\")$arr[0]</code> same as <code>pl$col(\"a\")$get(0)</code></p>"},{"location":"reference/#value_9","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_8","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(3:1, NULL, 1:2))) #NULL or integer() or list()\ndf$select(pl$col(\"a\")$arr$get(0))\ndf$select(pl$col(\"a\")$arr$get(c(2,0,-1)))\ndf = pl$DataFrame(list(a = list(3:1, NULL, 1:2))) #NULL or integer() or list()\ndf$select(pl$col(\"a\")$arr[0])\ndf$select(pl$col(\"a\")$arr[c(2,0,-1)])\n</code></pre>"},{"location":"reference/#arr-head","title":"Arr head","text":""},{"location":"reference/#description_10","title":"Description","text":"<p>head the first <code>n</code> values of every sublist.</p>"},{"location":"reference/#arguments_6","title":"Arguments","text":"<code>n</code> <p>Numeric or Expr, number of values to return for each sublist.</p>"},{"location":"reference/#format_8","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_10","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_9","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(1:4, c(10L, 2L, 1L))))\ndf$select(pl$col(\"a\")$arr$head(2))\n</code></pre>"},{"location":"reference/#arr-join","title":"Arr join","text":""},{"location":"reference/#description_11","title":"Description","text":"<p>Join all string items in a sublist and place a separator between them. This errors if inner type of list <code>\u2060!= Utf8\u2060</code>.</p>"},{"location":"reference/#arguments_7","title":"Arguments","text":"<code>separator</code> <p>string to separate the items with</p>"},{"location":"reference/#format_9","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_11","title":"Value","text":"<p>Series of dtype Utf8</p>"},{"location":"reference/#examples_10","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(s = list(c(\"a\",\"b\",\"c\"), c(\"x\",\"y\"))))\ndf$select(pl$col(\"s\")$arr$join(\" \"))\n</code></pre>"},{"location":"reference/#arr-last","title":"Arr last","text":""},{"location":"reference/#description_12","title":"Description","text":"<p>Get the last value of the sublists.</p>"},{"location":"reference/#format_10","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_12","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_11","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(3:1, NULL, 1:2))) #NULL or integer() or list()\ndf$select(pl$col(\"a\")$arr$last())\n</code></pre>"},{"location":"reference/#arr-lengths","title":"Arr lengths","text":""},{"location":"reference/#description_13","title":"Description","text":"<p>Get the length of the arrays as UInt32</p>"},{"location":"reference/#format_11","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_13","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_12","title":"Examples","text":"<pre><code>df = pl$DataFrame(list_of_strs = pl$Series(list(c(\"a\",\"b\"),\"c\")))\ndf$with_column(pl$col(\"list_of_strs\")$arr$lengths()$alias(\"list_of_strs_lengths\"))\n</code></pre>"},{"location":"reference/#arr-max","title":"Arr max","text":""},{"location":"reference/#description_14","title":"Description","text":"<p>Compute the max value of the lists in the array.</p>"},{"location":"reference/#format_12","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_14","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_13","title":"Examples","text":"<pre><code>df = pl$DataFrame(values = pl$Series(list(1L,2:3)))\ndf$select(pl$col(\"values\")$arr$max())\n</code></pre>"},{"location":"reference/#arr-mean","title":"Arr mean","text":""},{"location":"reference/#description_15","title":"Description","text":"<p>Compute the mean value of the lists in the array.</p>"},{"location":"reference/#format_13","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_15","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_14","title":"Examples","text":"<pre><code>df = pl$DataFrame(values = pl$Series(list(1L,2:3)))\ndf$select(pl$col(\"values\")$arr$mean())\n</code></pre>"},{"location":"reference/#arr-min","title":"Arr min","text":""},{"location":"reference/#description_16","title":"Description","text":"<p>Compute the min value of the lists in the array.</p>"},{"location":"reference/#format_14","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_16","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_15","title":"Examples","text":"<pre><code>df = pl$DataFrame(values = pl$Series(list(1L,2:3)))\ndf$select(pl$col(\"values\")$arr$min())\n</code></pre>"},{"location":"reference/#arr-reverse","title":"Arr reverse","text":""},{"location":"reference/#description_17","title":"Description","text":"<p>Reverse the arrays in the list.</p>"},{"location":"reference/#format_15","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_17","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_16","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(\nvalues = list(3:1, c(9L, 1:2))\n))\ndf$select(pl$col(\"values\")$arr$reverse())\n</code></pre>"},{"location":"reference/#arr-shift","title":"Arr shift","text":""},{"location":"reference/#description_18","title":"Description","text":"<p>Shift values by the given period.</p>"},{"location":"reference/#arguments_8","title":"Arguments","text":"<code>periods</code> <p>Value. Number of places to shift (may be negative).</p>"},{"location":"reference/#format_16","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_18","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_17","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(s = list(1:4,c(10L,2L,1L))))\ndf$select(pl$col(\"s\")$arr$shift())\n</code></pre>"},{"location":"reference/#arr-slice","title":"Arr slice","text":""},{"location":"reference/#description_19","title":"Description","text":"<p>Slice every sublist.</p>"},{"location":"reference/#arguments_9","title":"Arguments","text":"<code>offset</code> <p>value or Expr. Start index. Negative indexing is supported.</p> <code>length</code> <p>value or Expr. Length of the slice. If set to <code>None</code> (default), the slice is taken to the end of the list.</p>"},{"location":"reference/#format_17","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_19","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_18","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(s = list(1:4,c(10L,2L,1L))))\ndf$select(pl$col(\"s\")$arr$slice(2))\n</code></pre>"},{"location":"reference/#arr-sort","title":"Arr sort","text":""},{"location":"reference/#description_20","title":"Description","text":"<p>Get the value by index in the sublists.</p>"},{"location":"reference/#arguments_10","title":"Arguments","text":"<code>index</code> <p>numeric vector or Expr of length 1 or same length of Series. if length 1 pick same value from each sublist, if length as Series/column, pick by individual index across sublists.</p> <p>So index <code>0</code> would return the first item of every sublist and index <code>-1</code> would return the last item of every sublist if an index is out of bounds, it will return a <code>None</code>.</p>"},{"location":"reference/#format_18","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_20","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_19","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(3:1, NULL, 1:2))) #NULL or integer() or list()\ndf$select(pl$col(\"a\")$arr$get(0))\ndf$select(pl$col(\"a\")$arr$get(c(2,0,-1)))\n</code></pre>"},{"location":"reference/#arr-sum","title":"Arr sum","text":""},{"location":"reference/#description_21","title":"Description","text":"<p>Sum all the lists in the array.</p>"},{"location":"reference/#format_19","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_21","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_20","title":"Examples","text":"<pre><code>df = pl$DataFrame(values = pl$Series(list(1L,2:3)))\ndf$select(pl$col(\"values\")$arr$sum())\n</code></pre>"},{"location":"reference/#arr-tail","title":"Arr tail","text":""},{"location":"reference/#description_22","title":"Description","text":"<p>tail the first <code>n</code> values of every sublist.</p>"},{"location":"reference/#arguments_11","title":"Arguments","text":"<code>n</code> <p>Numeric or Expr, number of values to return for each sublist.</p>"},{"location":"reference/#format_20","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_22","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_21","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(1:4, c(10L, 2L, 1L))))\ndf$select(pl$col(\"a\")$arr$tail(2))\n</code></pre>"},{"location":"reference/#arr-take","title":"Arr take","text":""},{"location":"reference/#description_23","title":"Description","text":"<p>Get the take value of the sublists.</p>"},{"location":"reference/#format_21","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_23","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_22","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(3:1, NULL, 1:2))) #NULL or integer() or list()\nidx = pl$Series(list(0:1,1L,1L))\ndf$select(pl$col(\"a\")$arr$take(99))\n</code></pre>"},{"location":"reference/#arr-to-struct","title":"Arr to struct","text":""},{"location":"reference/#description_24","title":"Description","text":"<p>List to Struct</p>"},{"location":"reference/#arguments_12","title":"Arguments","text":"<code>n_field_strategy</code> <p>Strategy to determine the number of fields of the struct. default = 'first_non_null' else 'max_width'</p> <code>name_generator</code> <p>an R function that takes a scalar column number and outputs a string value. The default NULL is equivalent to the R function <code>\u2060\\(idx) paste0(\"field_\",idx)\u2060</code></p> <code>upper_bound</code> <p>upper_bound numeric A polars <code>LazyFrame</code> needs to know the schema at all time. The caller therefore must provide an <code>upper_bound</code> of struct fields that will be set. If this is incorrectly downstream operation may fail. For instance an <code>\u2060all().sum()\u2060</code> expression will look in the current schema to determine which columns to select. It is adviced to set this value in a lazy query.</p>"},{"location":"reference/#format_22","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_24","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_23","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(1:3, 1:2)))\ndf2 = df$select(pl$col(\"a\")$arr$to_struct(\nname_generator =  \\(idx) paste0(\"hello_you_\",idx))\n)\ndf2$unnest()\ndf2$to_list()\n</code></pre>"},{"location":"reference/#arr-unique","title":"Arr unique","text":""},{"location":"reference/#description_25","title":"Description","text":"<p>Get the unique/distinct values in the list.</p>"},{"location":"reference/#format_23","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_25","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_24","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(1, 1, 2)))\ndf$select(pl$col(\"a\")$arr$unique())\n</code></pre>"},{"location":"reference/#cseries","title":"C.Series","text":""},{"location":"reference/#description_26","title":"Description","text":"<p>Immutable combine series</p>"},{"location":"reference/#usage_2","title":"Usage","text":"<pre><code>## S3 method for class 'Series'\nc(x, ...)\n</code></pre>"},{"location":"reference/#arguments_13","title":"Arguments","text":"<code>x</code> <p>a Series</p> <code>...</code> <p>Series(s) or any object into Series meaning <code>pl$Series(object)</code> returns a series</p>"},{"location":"reference/#details_2","title":"Details","text":"<p>append datatypes has to match. Combine does not rechunk. Read more about R vectors, Series and chunks in <code>docs_translations</code>:</p>"},{"location":"reference/#value_26","title":"Value","text":"<p>a combined Series</p>"},{"location":"reference/#examples_25","title":"Examples","text":"<pre><code>s = c(pl$Series(1:5),3:1,NA_integer_)\ns$chunk_lengths() #the series contain three unmerged chunks\n</code></pre>"},{"location":"reference/#cash-set-dataframe","title":"Cash-set-.DataFrame","text":""},{"location":"reference/#description_27","title":"Description","text":"<p>set value of properties of DataFrames</p>"},{"location":"reference/#usage_3","title":"Usage","text":"<pre><code>## S3 replacement method for class 'DataFrame'\nself$name &lt;- value\n</code></pre>"},{"location":"reference/#arguments_14","title":"Arguments","text":"<code>self</code> <p>DataFrame</p> <code>name</code> <p>name method/property to set</p> <code>value</code> <p>value to insert</p>"},{"location":"reference/#details_3","title":"Details","text":"<p>settable polars object properties may appear to be R objects, but they are not. See <code>\u2060[[method_name]]\u2060</code> example</p>"},{"location":"reference/#value_27","title":"Value","text":"<p>value</p>"},{"location":"reference/#examples_26","title":"Examples","text":"<pre><code>#For internal use\n#is only activated for following methods of DataFrame\nls(polars:::DataFrame.property_setters)\n#specific use case for one object property 'columns' (names)\ndf = pl$DataFrame(iris)\n#get values\ndf$columns\n#set + get values\ndf$columns = letters[1:5] #&lt;- is fine too\ndf$columns\n# Rstudio is not using the standard R code completion tool\n# and it will backtick any special characters. It is possible\n# to completely customize the R / Rstudio code completion except\n# it will trigger Rstudio to backtick any completion! Also R does\n# not support package isolated customization.\n#Concrete example if tabbing on 'df$' the raw R suggestion is df$columns&lt;-\n#however Rstudio backticks it into df$`columns&lt;-`\n#to make life simple, this is valid polars syntax also, and can be used in fast scripting\ndf$`columns&lt;-` = letters[5:1]\n#for stable code prefer e.g.  df$columns = letters[5:1]\n#to see inside code of a property use the [[]] syntax instead\ndf[[\"columns\"]] # to see property code, .pr is the internal polars api into rust polars\npolars:::DataFrame.property_setters$columns #and even more obscure to see setter code\n</code></pre>"},{"location":"reference/#check-no-missing-args","title":"Check no missing args","text":""},{"location":"reference/#description_28","title":"Description","text":"<p>lifecycle: DEPRECATE</p>"},{"location":"reference/#usage_4","title":"Usage","text":"<pre><code>check_no_missing_args(fun, args, warn = TRUE)\n</code></pre>"},{"location":"reference/#arguments_15","title":"Arguments","text":"<code>fun</code> <p>target function to check incomming arguments for</p> <code>args</code> <p>list of args to check</p> <code>warn</code> <p>bool if TRUE throw warning when check fails</p>"},{"location":"reference/#value_28","title":"Value","text":"<p>true if args are correct</p>"},{"location":"reference/#check-tz-to-result","title":"Check tz to result","text":""},{"location":"reference/#description_29","title":"Description","text":"<p>Verify correct time zone</p>"},{"location":"reference/#usage_5","title":"Usage","text":"<pre><code>check_tz_to_result(tz, allow_null = TRUE)\n</code></pre>"},{"location":"reference/#arguments_16","title":"Arguments","text":"<code>tz</code> <p>time zone string or NULL</p> <code>allow_null</code> <p>bool, if TRUE accept NULL</p>"},{"location":"reference/#value_29","title":"Value","text":"<p>a result object, with either a valid string or an Err</p>"},{"location":"reference/#examples_27","title":"Examples","text":"<pre><code> check_tz_to_result = polars:::check_tz_to_result # expose internal\n#return Ok\ncheck_tz_to_result(\"GMT\")\ncheck_tz_to_result(NULL)\n#return Err\ncheck_tz_to_result(\"Alice\")\ncheck_tz_to_result(42)\ncheck_tz_to_result(NULL, allow_null = FALSE)\n</code></pre>"},{"location":"reference/#clone-env-one-level-deep","title":"Clone env one level deep","text":""},{"location":"reference/#description_30","title":"Description","text":"<p>Clone env on level deep.</p>"},{"location":"reference/#usage_6","title":"Usage","text":"<pre><code>clone_env_one_level_deep(env)\n</code></pre>"},{"location":"reference/#arguments_17","title":"Arguments","text":"<code>env</code> <p>an R environment.</p>"},{"location":"reference/#details_4","title":"Details","text":"<p>Sometimes used in polars to produce different hashmaps(environments) containing some of the same, but not all elements.</p> <p>environments are used for collections of methods and types. This function can be used to make a parallel collection pointing to some of the same types. Simply copying an environment, does apparently not spawn a new hashmap, and therefore the collections stay identical.</p>"},{"location":"reference/#value_30","title":"Value","text":"<p>shallow clone of R environment</p>"},{"location":"reference/#examples_28","title":"Examples","text":"<pre><code>fruit_env = new.env(parent = emptyenv())\nfruit_env$banana = TRUE\nfruit_env$apple = FALSE\nenv_1 = new.env(parent = emptyenv())\nenv_1$fruit_env = fruit_env\nenv_naive_copy = env_1\nenv_shallow_clone = polars:::clone_env_one_level_deep(env_1)\n#modifying env_!\nenv_1$minerals = new.env(parent = emptyenv())\nenv_1$fruit_env$apple = 42L\n#naive copy is fully identical to env_1, so copying it not much useful\nls(env_naive_copy)\n#shallow copy env does not have minerals\nls(env_shallow_clone)\n#however shallow clone does subscribe to changes to fruits as they were there\n# at time of cloning\nenv_shallow_clone$fruit_env$apple\n</code></pre>"},{"location":"reference/#coalesce","title":"Coalesce","text":""},{"location":"reference/#description_31","title":"Description","text":"<p>Folds the expressions from left to right, keeping the first non-null value.</p> <p>Folds the expressions from left to right, keeping the first non-null value.</p>"},{"location":"reference/#arguments_18","title":"Arguments","text":"<code>...</code> <p>is a: If one arg:</p> <ul> <li><p>Series or Expr, same as <code>column$sum()</code></p></li> <li><p>string, same as <code>pl$col(column)$sum()</code></p></li> <li><p>numeric, same as <code>pl$lit(column)$sum()</code></p></li> <li><p>list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ...</p></li> </ul> <p>If several args, then wrapped in a list and handled as above.</p> <code>exprs</code> <p>list of Expr or Series or strings or a mix, or a char vector</p>"},{"location":"reference/#value_31","title":"Value","text":"<p>Expr</p> <p>Expr</p>"},{"location":"reference/#examples_29","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = NA_real_,\nb = c(1:2,NA_real_,NA_real_),\nc = c(1:3,NA_real_)\n)\n#use coalesce to get first non Null value for each row, otherwise insert 99.9\ndf$with_column(\npl$coalesce(\"a\", \"b\", \"c\", 99.9)$alias(\"d\")\n)\n#Create lagged columns and collect them into a list. This mimics a rolling window.\ndf = pl$DataFrame(A = c(1,2,9,2,13))\ndf$with_columns(lapply(\n0:2,\n\\(i) pl$col(\"A\")$shift(i)$alias(paste0(\"A_lag_\",i))\n))$select(\npl$concat_list(lapply(2:0,\\(i) pl$col(paste0(\"A_lag_\",i))))$alias(\n\"A_rolling\"\n)\n)\n#concat Expr a Series and an R obejct\npl$concat_list(list(\npl$lit(1:5),\npl$Series(5:1),\nrep(0L,5)\n))$alias(\"alice\")$lit_to_s()\n</code></pre>"},{"location":"reference/#col","title":"Col","text":""},{"location":"reference/#description_32","title":"Description","text":"<p>Return an expression representing a column in a DataFrame.</p>"},{"location":"reference/#arguments_19","title":"Arguments","text":"<code>name</code> <ul> <li><p>a single column by a string</p></li> <li><p>all columns by using a wildcard <code>\"*\"</code></p></li> <li><p>multiple columns as vector of strings</p></li> <li><p>column by regular expression if the regex starts with <code>^</code> and ends with <code>$</code> e.g. pl$DataFrame(iris)$select(pl$col(c(\"^Sepal.*$\")))</p></li> <li><p>a single DataType or an R list of DataTypes, select any column of any such DataType</p></li> <li><p>Series of utf8 strings abiding to above options</p></li> </ul>"},{"location":"reference/#value_32","title":"Value","text":"<p>Column Exprression</p>"},{"location":"reference/#examples_30","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(foo=1, bar=2L,foobar=\"3\"))\n#a single column by a string\ndf$select(pl$col(\"foo\"))\n#all columns by wildcard\ndf$select(pl$col(\"*\"))\ndf$select(pl$all())\n#multiple columns as vector of strings\ndf$select(pl$col(c(\"foo\",\"bar\")))\n#column by regular expression if the regex starts with `^` and ends with `$`\ndf$select(pl$col(\"^foo.*$\"))\n#a single DataType\ndf$select(pl$col(pl$dtypes$Float64))\n# ... or an R list of DataTypes, select any column of any such DataType\ndf$select(pl$col(list(pl$dtypes$Float64, pl$dtypes$Utf8)))\n# from Series of names\ndf$select(pl$col(pl$Series(c(\"bar\",\"foobar\"))))\n</code></pre>"},{"location":"reference/#construct-datatypevector","title":"Construct DataTypeVector","text":""},{"location":"reference/#description_33","title":"Description","text":"<p>lifecycle: Deprecate, move to rust side</p>"},{"location":"reference/#usage_7","title":"Usage","text":"<pre><code>construct_DataTypeVector(l)\n</code></pre>"},{"location":"reference/#arguments_20","title":"Arguments","text":"<code>l</code> <p>list of Expr or string</p>"},{"location":"reference/#value_33","title":"Value","text":"<p>extptr to rust vector of RPolarsDataType's</p>"},{"location":"reference/#construct-protoexprarray","title":"Construct ProtoExprArray","text":""},{"location":"reference/#description_34","title":"Description","text":"<p>construct proto Expr array from args</p>"},{"location":"reference/#usage_8","title":"Usage","text":"<pre><code>construct_ProtoExprArray(...)\n</code></pre>"},{"location":"reference/#arguments_21","title":"Arguments","text":"<code>...</code> <p>any Expr or string</p>"},{"location":"reference/#value_34","title":"Value","text":"<p>ProtoExprArray object</p>"},{"location":"reference/#examples_31","title":"Examples","text":"<pre><code>polars:::construct_ProtoExprArray(pl$col(\"Species\"),\"Sepal.Width\")\n</code></pre>"},{"location":"reference/#dataframe-as-data-frame","title":"DataFrame as data frame","text":""},{"location":"reference/#description_35","title":"Description","text":"<p>return polars DataFrame as R data.frame</p>"},{"location":"reference/#usage_9","title":"Usage","text":"<pre><code>DataFrame_as_data_frame(...)\n\n## S3 method for class 'DataFrame'\nas.data.frame(x, ...)\n</code></pre>"},{"location":"reference/#arguments_22","title":"Arguments","text":"<code>...</code> <p>any params passed to as.data.frame</p> <code>x</code> <p>DataFrame</p>"},{"location":"reference/#value_35","title":"Value","text":"<p>data.frame</p> <p>data.frame</p>"},{"location":"reference/#examples_32","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris[1:3,])\ndf$as_data_frame()\n</code></pre>"},{"location":"reference/#dataframe-class","title":"DataFrame class","text":""},{"location":"reference/#description_36","title":"Description","text":"<p>The <code>DataFrame</code>-class is simply two environments of respectively the public and private methods/function calls to the polars rust side. The instanciated <code>DataFrame</code>-object is an <code>externalptr</code> to a lowlevel rust polars DataFrame object. The pointer address is the only statefullness of the DataFrame object on the R side. Any other state resides on the rust side. The S3 method <code>.DollarNames.DataFrame</code> exposes all public <code>\u2060$foobar()\u2060</code>-methods which are callable onto the object. Most methods return another <code>DataFrame</code>-class instance or similar which allows for method chaining. This class system in lack of a better name could be called \"environment classes\" and is the same class system extendr provides, except here there is both a public and private set of methods. For implementation reasons, the private methods are external and must be called from polars:::.pr.$DataFrame$methodname(), also all private methods must take any self as an argument, thus they are pure functions. Having the private methods as pure functions solved/simplified self-referential complications.</p>"},{"location":"reference/#details_5","title":"Details","text":"<p>Check out the source code in R/dataframe_frame.R how public methods are derived from private methods. Check out extendr-wrappers.R to see the extendr-auto-generated methods. These are moved to .pr and converted into pure external functions in after-wrappers.R. In zzz.R (named zzz to be last file sourced) the extendr-methods are removed and replaced by any function prefixed <code>DataFrame_</code>.</p>"},{"location":"reference/#examples_33","title":"Examples","text":"<pre><code>#see all exported methods\nls(polars:::DataFrame)\n#see all private methods (not intended for regular use)\nls(polars:::.pr$DataFrame)\n#make an object\ndf = pl$DataFrame(iris)\n#use a public method/property\ndf$shape\ndf2 = df\n#use a private method, which has mutability\nresult = polars:::.pr$DataFrame$set_column_from_robj(df,150:1,\"some_ints\")\n#column exists in both dataframes-objects now, as they are just pointers to the same object\n# there are no public methods with mutability\ndf$columns\ndf2$columns\n# set_column_from_robj-method is fallible and returned a result which could be ok or an err.\n# No public method or function will ever return a result.\n# The `result` is very close to the same as output from functions decorated with purrr::safely.\n# To use results on R side, these must be unwrapped first such that\n# potentially errors can be thrown. unwrap(result) is a way to\n# bridge rust not throwing errors with R. Extendr default behaviour is to use panic!(s) which\n# would case some unneccesary confusing and  some very verbose error messages on the inner\n# workings of rust. unwrap(result) #in this case no error, just a NULL because this mutable\n# method does not return any ok-value.\n#try unwrapping an error from polars due to unmatching column lengths\nerr_result = polars:::.pr$DataFrame$set_column_from_robj(df,1:10000,\"wrong_length\")\ntryCatch(unwrap(err_result,call=NULL),error=\\(e) cat(as.character(e)))\n</code></pre>"},{"location":"reference/#dataframe-clone","title":"DataFrame clone","text":""},{"location":"reference/#description_37","title":"Description","text":"<p>Rarely useful as DataFrame is nearly 100% immutable Any modification of a DataFrame would lead to a clone anyways.</p>"},{"location":"reference/#usage_10","title":"Usage","text":"<pre><code>DataFrame_clone()\n</code></pre>"},{"location":"reference/#value_36","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/#examples_34","title":"Examples","text":"<pre><code>df1 = pl$DataFrame(iris);\ndf2 =  df1$clone();\ndf3 = df1\npl$mem_address(df1) != pl$mem_address(df2)\npl$mem_address(df1) == pl$mem_address(df3)\n</code></pre>"},{"location":"reference/#dataframe-columns","title":"DataFrame columns","text":""},{"location":"reference/#description_38","title":"Description","text":"<p>get/set column names of DataFrame object</p> <p>get/set column names of DataFrame object</p>"},{"location":"reference/#usage_11","title":"Usage","text":"<pre><code>RField_datatype()\n\nDataFrame_columns()\n</code></pre>"},{"location":"reference/#value_37","title":"Value","text":"<p>char vec of column names</p> <p>char vec of column names</p>"},{"location":"reference/#examples_35","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris)\n#get values\ndf$columns\n#set + get values\ndf$columns = letters[1:5] #&lt;- is fine too\ndf$columns\ndf = pl$DataFrame(iris)\n#get values\ndf$columns\n#set + get values\ndf$columns = letters[1:5] #&lt;- is fine too\ndf$columns\n</code></pre>"},{"location":"reference/#dataframe-dtypes","title":"DataFrame dtypes","text":""},{"location":"reference/#description_39","title":"Description","text":"<p>Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame.</p> <p>Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame.</p>"},{"location":"reference/#usage_12","title":"Usage","text":"<pre><code>DataFrame_dtypes()\n\nDataFrame_schema()\n</code></pre>"},{"location":"reference/#value_38","title":"Value","text":"<p>width as numeric scalar</p> <p>width as numeric scalar</p>"},{"location":"reference/#examples_36","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$dtypes\npl$DataFrame(iris)$schema\n</code></pre>"},{"location":"reference/#dataframe-estimated-size","title":"DataFrame estimated size","text":""},{"location":"reference/#description_40","title":"Description","text":"<p>Return an estimation of the total (heap) allocated size of the DataFrame.</p>"},{"location":"reference/#usage_13","title":"Usage","text":"<pre><code>DataFrame_estimated_size\n</code></pre>"},{"location":"reference/#format_24","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_39","title":"Value","text":"<p>Bytes</p>"},{"location":"reference/#examples_37","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$estimated_size()\n</code></pre>"},{"location":"reference/#dataframe-first","title":"DataFrame first","text":""},{"location":"reference/#description_41","title":"Description","text":"<p>Get the first row of the DataFrame.</p>"},{"location":"reference/#usage_14","title":"Usage","text":"<pre><code>DataFrame_first()\n</code></pre>"},{"location":"reference/#value_40","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied filter.</p>"},{"location":"reference/#examples_38","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$first()\n</code></pre>"},{"location":"reference/#dataframe-get-column","title":"DataFrame get column","text":""},{"location":"reference/#description_42","title":"Description","text":"<p>get one column by name as series</p>"},{"location":"reference/#usage_15","title":"Usage","text":"<pre><code>DataFrame_get_column(name)\n</code></pre>"},{"location":"reference/#arguments_23","title":"Arguments","text":"<code>name</code> <p>name of column to extract as Series</p>"},{"location":"reference/#value_41","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_39","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris[1,])\ndf$get_column(\"Species\")\n</code></pre>"},{"location":"reference/#dataframe-get-columns","title":"DataFrame get columns","text":""},{"location":"reference/#description_43","title":"Description","text":"<p>get columns as list of series</p>"},{"location":"reference/#usage_16","title":"Usage","text":"<pre><code>DataFrame_get_columns\n</code></pre>"},{"location":"reference/#format_25","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_42","title":"Value","text":"<p>list of series</p>"},{"location":"reference/#examples_40","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris[1,])\ndf$get_columns()\n</code></pre>"},{"location":"reference/#dataframe-groupby","title":"DataFrame groupby","text":""},{"location":"reference/#description_44","title":"Description","text":"<p>DataFrame$groupby(..., maintain_order = FALSE)</p>"},{"location":"reference/#usage_17","title":"Usage","text":"<pre><code>DataFrame_groupby(..., maintain_order = FALSE)\n</code></pre>"},{"location":"reference/#arguments_24","title":"Arguments","text":"<code>...</code> <p>any expression</p> <code>maintain_order</code> <p>bool</p>"},{"location":"reference/#value_43","title":"Value","text":"<p>GroupBy (subclass of DataFrame)</p>"},{"location":"reference/#dataframe-height","title":"DataFrame height","text":""},{"location":"reference/#description_45","title":"Description","text":"<p>Get height(nrow) of DataFrame</p>"},{"location":"reference/#usage_18","title":"Usage","text":"<pre><code>DataFrame_height()\n</code></pre>"},{"location":"reference/#value_44","title":"Value","text":"<p>height as numeric</p>"},{"location":"reference/#examples_41","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$height\n</code></pre>"},{"location":"reference/#dataframe-join","title":"DataFrame join","text":""},{"location":"reference/#description_46","title":"Description","text":"<p>join DataFrame with other DataFrame</p>"},{"location":"reference/#usage_19","title":"Usage","text":"<pre><code>DataFrame_join(\n  other,\n  left_on = NULL,\n  right_on = NULL,\n  on = NULL,\n  how = c(\"inner\", \"left\", \"outer\", \"semi\", \"anti\", \"cross\"),\n  suffix = \"_right\",\n  allow_parallel = TRUE,\n  force_parallel = FALSE\n)\n</code></pre>"},{"location":"reference/#arguments_25","title":"Arguments","text":"<code>other</code> <p>DataFrame</p> <code>left_on</code> <p>names of columns in self LazyFrame, order should match. Type, see on param.</p> <code>right_on</code> <p>names of columns in other LazyFrame, order should match. Type, see on param.</p> <code>on</code> <p>named columns as char vector of named columns, or list of expressions and/or strings.</p> <code>how</code> <p>a string selecting one of the following methods: inner, left, outer, semi, anti, cross</p> <code>suffix</code> <p>name to added right table</p> <code>allow_parallel</code> <p>bool</p> <code>force_parallel</code> <p>bool</p>"},{"location":"reference/#value_45","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/#examples_42","title":"Examples","text":"<pre><code>print(df1 &lt;- pl$DataFrame(list(key=1:3,payload=c('f','i',NA))))\nprint(df2 &lt;- pl$DataFrame(list(key=c(3L,4L,5L,NA_integer_))))\ndf1$join(other = df2,on = 'key')\n</code></pre>"},{"location":"reference/#dataframe-last","title":"DataFrame last","text":""},{"location":"reference/#description_47","title":"Description","text":"<p>Get the last row of the DataFrame.</p>"},{"location":"reference/#usage_20","title":"Usage","text":"<pre><code>DataFrame_last()\n</code></pre>"},{"location":"reference/#value_46","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied filter.</p>"},{"location":"reference/#examples_43","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$last()\n</code></pre>"},{"location":"reference/#dataframe-lazy","title":"DataFrame lazy","text":""},{"location":"reference/#description_48","title":"Description","text":"<p>Start a new lazy query from a DataFrame</p>"},{"location":"reference/#usage_21","title":"Usage","text":"<pre><code>DataFrame_lazy\n</code></pre>"},{"location":"reference/#format_26","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_47","title":"Value","text":"<p>a LazyFrame</p>"},{"location":"reference/#examples_44","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$lazy()\n#use of lazy method\npl$DataFrame(iris)$lazy()$filter(pl$col(\"Sepal.Length\") &gt;= 7.7)$collect()\n</code></pre>"},{"location":"reference/#dataframe-limit","title":"DataFrame limit","text":""},{"location":"reference/#description_49","title":"Description","text":"<p>take limit of n rows of query</p>"},{"location":"reference/#usage_22","title":"Usage","text":"<pre><code>DataFrame_limit(n)\n</code></pre>"},{"location":"reference/#arguments_26","title":"Arguments","text":"<code>n</code> <p>positive numeric or integer number not larger than 2^32</p>"},{"location":"reference/#details_6","title":"Details","text":"<p>any number will converted to u32. Negative raises error</p>"},{"location":"reference/#value_48","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/#dataframe-max","title":"DataFrame max","text":""},{"location":"reference/#description_50","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their maximum value.</p>"},{"location":"reference/#usage_23","title":"Usage","text":"<pre><code>DataFrame_max()\n</code></pre>"},{"location":"reference/#value_49","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied aggregation.</p>"},{"location":"reference/#examples_45","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$max()\n</code></pre>"},{"location":"reference/#dataframe-mean","title":"DataFrame mean","text":""},{"location":"reference/#description_51","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their mean value.</p>"},{"location":"reference/#usage_24","title":"Usage","text":"<pre><code>DataFrame_mean()\n</code></pre>"},{"location":"reference/#value_50","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied aggregation.</p>"},{"location":"reference/#examples_46","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$mean()\n</code></pre>"},{"location":"reference/#dataframe-median","title":"DataFrame median","text":""},{"location":"reference/#description_52","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their median value.</p>"},{"location":"reference/#usage_25","title":"Usage","text":"<pre><code>DataFrame_median()\n</code></pre>"},{"location":"reference/#value_51","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied aggregation.</p>"},{"location":"reference/#examples_47","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$median()\n</code></pre>"},{"location":"reference/#dataframe-min","title":"DataFrame min","text":""},{"location":"reference/#description_53","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their minimum value.</p>"},{"location":"reference/#usage_26","title":"Usage","text":"<pre><code>DataFrame_min()\n</code></pre>"},{"location":"reference/#value_52","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied aggregation.</p>"},{"location":"reference/#examples_48","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$min()\n</code></pre>"},{"location":"reference/#dataframe-null-count","title":"DataFrame null count","text":""},{"location":"reference/#description_54","title":"Description","text":"<p>Create a new DataFrame that shows the null counts per column.</p>"},{"location":"reference/#usage_27","title":"Usage","text":"<pre><code>DataFrame_null_count\n</code></pre>"},{"location":"reference/#format_27","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_53","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/#examples_49","title":"Examples","text":"<pre><code>x = mtcars\nx[1, 2:3] = NA\npl$DataFrame(x)$null_count()\n</code></pre>"},{"location":"reference/#dataframe-print","title":"DataFrame print","text":""},{"location":"reference/#description_55","title":"Description","text":"<p>internal method print DataFrame</p>"},{"location":"reference/#usage_28","title":"Usage","text":"<pre><code>DataFrame_print()\n</code></pre>"},{"location":"reference/#value_54","title":"Value","text":"<p>self</p>"},{"location":"reference/#examples_50","title":"Examples","text":"<pre><code>pl$DataFrame(iris)\n</code></pre>"},{"location":"reference/#dataframe-reverse","title":"DataFrame reverse","text":""},{"location":"reference/#description_56","title":"Description","text":"<p>Reverse the DataFrame.</p>"},{"location":"reference/#usage_29","title":"Usage","text":"<pre><code>DataFrame_reverse()\n</code></pre>"},{"location":"reference/#value_55","title":"Value","text":"<p>LazyFrame</p>"},{"location":"reference/#examples_51","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$reverse()\n</code></pre>"},{"location":"reference/#dataframe-select","title":"DataFrame select","text":""},{"location":"reference/#description_57","title":"Description","text":"<p>related to dplyr <code>mutate()</code> However discards unmentioned columns as data.table <code>.()</code>.</p>"},{"location":"reference/#usage_30","title":"Usage","text":"<pre><code>DataFrame_select(...)\n</code></pre>"},{"location":"reference/#arguments_27","title":"Arguments","text":"<code>...</code> <p>expresssions or strings defining columns to select(keep) in context the DataFrame</p>"},{"location":"reference/#dataframe-shape","title":"DataFrame shape","text":""},{"location":"reference/#description_58","title":"Description","text":"<p>Get shape/dimensions of DataFrame</p>"},{"location":"reference/#usage_31","title":"Usage","text":"<pre><code>DataFrame_shape()\n</code></pre>"},{"location":"reference/#value_56","title":"Value","text":"<p>two length numeric vector of c(nrows,ncols)</p>"},{"location":"reference/#examples_52","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris)$shape\n</code></pre>"},{"location":"reference/#dataframe-slice","title":"DataFrame slice","text":""},{"location":"reference/#description_59","title":"Description","text":"<p>Get a slice of this DataFrame.</p>"},{"location":"reference/#usage_32","title":"Usage","text":"<pre><code>DataFrame_slice(offset, length = NULL)\n</code></pre>"},{"location":"reference/#arguments_28","title":"Arguments","text":"<code>offset</code> <p>integer</p> <code>length</code> <p>integer or NULL</p>"},{"location":"reference/#value_57","title":"Value","text":"<p>LazyFrame</p>"},{"location":"reference/#examples_53","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$slice(2, 4)\nmtcars[2:6,]\n</code></pre>"},{"location":"reference/#dataframe-std","title":"DataFrame std","text":""},{"location":"reference/#description_60","title":"Description","text":"<p>Aggregate the columns of this DataFrame to their standard deviation values.</p>"},{"location":"reference/#usage_33","title":"Usage","text":"<pre><code>DataFrame_std(ddof = 1)\n</code></pre>"},{"location":"reference/#arguments_29","title":"Arguments","text":"<code>ddof</code> <p>integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1.</p>"},{"location":"reference/#value_58","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied aggregation.</p>"},{"location":"reference/#examples_54","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$std()\n</code></pre>"},{"location":"reference/#dataframe-sum","title":"DataFrame sum","text":""},{"location":"reference/#description_61","title":"Description","text":"<p>Aggregate the columns of this DataFrame to their sum values.</p>"},{"location":"reference/#usage_34","title":"Usage","text":"<pre><code>DataFrame_sum()\n</code></pre>"},{"location":"reference/#value_59","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied aggregation.</p>"},{"location":"reference/#examples_55","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$sum()\n</code></pre>"},{"location":"reference/#dataframe-tail","title":"DataFrame tail","text":""},{"location":"reference/#description_62","title":"Description","text":"<p>Get the last n rows.</p>"},{"location":"reference/#usage_35","title":"Usage","text":"<pre><code>DataFrame_tail(n)\n</code></pre>"},{"location":"reference/#arguments_30","title":"Arguments","text":"<code>n</code> <p>positive numeric of integer number not larger than 2^32</p>"},{"location":"reference/#details_7","title":"Details","text":"<p>any number will converted to u32. Negative raises error</p>"},{"location":"reference/#value_60","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/#dataframe-to-series","title":"DataFrame to series","text":""},{"location":"reference/#description_63","title":"Description","text":"<p>get one column by idx as series from DataFrame. Unlike get_column this method will not fail if no series found at idx but return a NULL, idx is zero idx.</p>"},{"location":"reference/#usage_36","title":"Usage","text":"<pre><code>DataFrame_to_series(idx = 0)\n</code></pre>"},{"location":"reference/#arguments_31","title":"Arguments","text":"<code>idx</code> <p>numeric default 0, zero-index of what column to return as Series</p>"},{"location":"reference/#value_61","title":"Value","text":"<p>Series or NULL</p>"},{"location":"reference/#examples_56","title":"Examples","text":"<pre><code>pl$DataFrame(a=1:4)$to_series()\n</code></pre>"},{"location":"reference/#dataframe-to-struct-unnest","title":"DataFrame to Struct unnest","text":""},{"location":"reference/#description_64","title":"Description","text":"<p>to_struct and unnest again</p> <p>Unnest a DataFrame struct columns.</p>"},{"location":"reference/#usage_37","title":"Usage","text":"<pre><code>DataFrame_to_struct(name = \"\")\n\nDataFrame_unnest(names = NULL)\n</code></pre>"},{"location":"reference/#arguments_32","title":"Arguments","text":"<code>name</code> <p>name of new Series</p> <code>names</code> <p>names of struct columns to unnest, default NULL unnest any struct column</p>"},{"location":"reference/#value_62","title":"Value","text":"<p>@to_struct() returns a Series</p> <p>$unnest() returns a DataFrame with all column including any that has been unnested</p>"},{"location":"reference/#examples_57","title":"Examples","text":"<pre><code>#round-trip conversion from DataFrame with two columns\ndf = pl$DataFrame(a=1:5,b=c(\"one\",\"two\",\"three\",\"four\",\"five\"))\ns = df$to_struct()\ns\ns$to_r() # to r list\ndf_s = s$to_frame() #place series in a new DataFrame\ndf_s$unnest() # back to starting df\n</code></pre>"},{"location":"reference/#dataframe-var","title":"DataFrame var","text":""},{"location":"reference/#description_65","title":"Description","text":"<p>Aggregate the columns of this DataFrame to their variance values.</p>"},{"location":"reference/#usage_38","title":"Usage","text":"<pre><code>DataFrame_var(ddof = 1)\n</code></pre>"},{"location":"reference/#arguments_33","title":"Arguments","text":"<code>ddof</code> <p>integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1.</p>"},{"location":"reference/#value_63","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied aggregation.</p>"},{"location":"reference/#examples_58","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$var()\n</code></pre>"},{"location":"reference/#dataframe-width","title":"DataFrame width","text":""},{"location":"reference/#description_66","title":"Description","text":"<p>Get width(ncol) of DataFrame</p>"},{"location":"reference/#usage_39","title":"Usage","text":"<pre><code>DataFrame_width()\n</code></pre>"},{"location":"reference/#value_64","title":"Value","text":"<p>width as numeric scalar</p>"},{"location":"reference/#examples_59","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$width\n</code></pre>"},{"location":"reference/#dataframe-with-columns","title":"DataFrame with columns","text":""},{"location":"reference/#description_67","title":"Description","text":"<p>add or modify columns with expressions</p>"},{"location":"reference/#usage_40","title":"Usage","text":"<pre><code>DataFrame_with_columns(...)\n\nDataFrame_with_column(expr)\n</code></pre>"},{"location":"reference/#arguments_34","title":"Arguments","text":"<code>...</code> <p>any expressions or string column name, or same wrapped in a list</p> <code>expr</code> <p>a single expression or string</p>"},{"location":"reference/#details_8","title":"Details","text":"<p>Like dplyr <code>mutate()</code> as it keeps unmentioned columns unlike $select().</p> <p>with_column is derived from with_columns but takes only one expression argument</p>"},{"location":"reference/#value_65","title":"Value","text":"<p>DataFrame</p> <p>DataFrame</p>"},{"location":"reference/#examples_60","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$with_columns(\npl$col(\"Sepal.Length\")$abs()$alias(\"abs_SL\"),\n(pl$col(\"Sepal.Length\")+2)$alias(\"add_2_SL\")\n)\n#rename columns by naming expression is concidered experimental\npl$set_polars_options(named_exprs = TRUE) #unlock\npl$DataFrame(iris)$with_columns(\npl$col(\"Sepal.Length\")$abs(), #not named expr will keep name \"Sepal.Length\"\nSW_add_2 = (pl$col(\"Sepal.Width\")+2)\n)\n</code></pre>"},{"location":"reference/#dataframe","title":"DataFrame","text":""},{"location":"reference/#description_68","title":"Description","text":"<p>Create new DataFrame</p>"},{"location":"reference/#arguments_35","title":"Arguments","text":"<code>...</code> <ul> <li><p>one data.frame or something that inherits data.frame or DataFrame</p></li> <li><p>one list of mixed vectors and Series of equal length</p></li> <li><p>mixed vectors and/or Series of equal length</p></li> </ul> <p>Columns will be named as of named arguments or alternatively by names of Series or given a placeholder name.</p> <code>make_names_unique</code> <p>default TRUE, any duplicated names will be prefixed a running number</p> <code>parallel</code> <p>bool default FALSE, experimental multithreaded interpretation of R vectors into a polars DataFrame. This is experimental as multiple threads read from R mem simultaneously. So far no issues parallel read from R has been found.</p>"},{"location":"reference/#value_66","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/#examples_61","title":"Examples","text":"<pre><code>pl$DataFrame(\na = list(c(1,2,3,4,5)), #NB if first column should be a list, wrap it in a Series\nb = 1:5,\nc = letters[1:5],\nd = list(1:1,1:2,1:3,1:4,1:5)\n) #directly from vectors\n#from a list of vectors or data.frame\npl$DataFrame(list(\na= c(1,2,3,4,5),\nb=1:5,\nc = letters[1:5],\nd = list(1L,1:2,1:3,1:4,1:5)\n))\n</code></pre>"},{"location":"reference/#datatype-constructors","title":"DataType constructors","text":""},{"location":"reference/#description_69","title":"Description","text":"<p>List of all composite DataType constructors</p>"},{"location":"reference/#usage_41","title":"Usage","text":"<pre><code>DataType_constructors\n</code></pre>"},{"location":"reference/#format_28","title":"Format","text":"<p>An object of class <code>list</code> of length 3.</p>"},{"location":"reference/#details_9","title":"Details","text":"<p>This list is mainly used in <code>zzz.R</code> <code>.onLoad</code> to instantiate singletons of all flag-like DataTypes.</p> <p>Non-flag like DataType called composite DataTypes also carries extra information e.g. Datetime a timeunit and a TimeZone, or List which recursively carries another DataType inside. Composite DataTypes use DataType constructors.</p> <p>Any DataType can be found in pl$dtypes</p>"},{"location":"reference/#value_67","title":"Value","text":"<p>DataType</p>"},{"location":"reference/#examples_62","title":"Examples","text":"<pre><code>#constructors are finally available via pl$... or pl$dtypes$...\npl$List(pl$List(pl$Int64))\n</code></pre>"},{"location":"reference/#datatype-new","title":"DataType new","text":""},{"location":"reference/#description_70","title":"Description","text":"<p>Create a new flag like DataType</p>"},{"location":"reference/#usage_42","title":"Usage","text":"<pre><code>DataType_new(str)\n</code></pre>"},{"location":"reference/#arguments_36","title":"Arguments","text":"<code>str</code> <p>name of DataType to create</p>"},{"location":"reference/#details_10","title":"Details","text":"<p>This function is mainly used in <code>zzz.R</code> <code>.onLoad</code> to instantiate singletons of all flag-like DataType.</p> <p>Non-flag like DataType called composite DataTypes also carries extra information e.g. Datetime a timeunit and a TimeZone, or List which recursively carries another DataType inside. Composite DataTypes use DataType constructors.</p> <p>Any DataType can be found in pl$dtypes</p>"},{"location":"reference/#value_68","title":"Value","text":"<p>DataType</p>"},{"location":"reference/#examples_63","title":"Examples","text":"<pre><code>polars:::DataType_new(\"Int64\")\n</code></pre>"},{"location":"reference/#datatype","title":"DataType","text":""},{"location":"reference/#description_71","title":"Description","text":"<p><code>DataType</code> any polars type (ported so far)</p>"},{"location":"reference/#examples_64","title":"Examples","text":"<pre><code>print(ls(pl$dtypes))\npl$dtypes$Float64\npl$dtypes$Utf8\npl$List(pl$List(pl$UInt64))\npl$Struct(pl$Field(\"CityNames\", pl$Utf8))\n# Some DataType use case, this user function fails because....\n## Not run: \npl$Series(1:4)$apply(\\(x) letters[x])\n## End(Not run)\n#The function changes type from Integer(Int32)[Integers] to char(Utf8)[Strings]\n#specifying the output DataType: Utf8 solves the problem\npl$Series(1:4)$apply(\\(x) letters[x],datatype = pl$dtypes$Utf8)\n</code></pre>"},{"location":"reference/#docs-translations","title":"Docs translations","text":""},{"location":"reference/#description_72","title":"Description","text":"<p>#Comments for how the R and python world translates into polars:</p> <p>R and python are both high-level glue languages great for Data Science. Rust is a pedantic low-level language with similar use cases as C and C++. Polars is written in ~100k lines of rust and has a rust API. Py-polars the python API for polars, is implemented as an interface with the rust API. r-polars is very parallel to py-polars except it interfaces with R. The performance and behavior are unexpectedly quite similar as the 'engine' is the exact same rust code and data structures.</p>"},{"location":"reference/#format_29","title":"Format","text":"<p>info</p>"},{"location":"reference/#translation-details","title":"Translation details","text":""},{"location":"reference/#r-and-the-integerish","title":"R and the integerish","text":"<p>R only has a native Int32 type, no Uint32, Int64, UInt64 , ... types. These days Int32 is getting a bit small, to refer to more rows than ~ 2^31-1. There are packages which provide int64, but the most normal hack' is to just use floats as 'integerish'. There is an unique float64 value for every integer up to about 2^52 which is plenty for all practical concerns. Some polars methods may accept or return a floats even though an integer ideally would be more accurate. Most R functions intermix Int32 (integer) and Float64 (double) seamlessly.</p>"},{"location":"reference/#missingness","title":"Missingness","text":"<p>R has allocated a value in every vector type to signal missingness, these are collectively called <code>NAs</code>. Polars uses a bool bitmask to signal <code>NA</code>-like missing value and it is called <code>Null</code> and <code>Nulls</code> in plural. Not to confuse with R <code>NULL</code> (see paragraph below). Polars supports missingness for any possible type as it kept separately in the bitmask. In python lists the symbol <code>None</code> can carry a similar meaning. R <code>NA</code> ~ polars <code>Null</code> ~ py-polars <code>\u2060[None]\u2060</code> (in a py list)</p>"},{"location":"reference/#sorting-and-comparisons","title":"Sorting and comparisons","text":"<p>From writing alot of tests for all implementations, it appears polars does not have a fully consistent nor well documented behavior, when it comes to comparisons and sorting of floats. Though some general thumb rules do apply: Polars have chosen to define in sorting that <code>Null</code> is a value lower than <code>-Inf</code> as in <code>Expr.arg_min()</code> However except when <code>Null</code> is ignored <code>Expr.min()</code>, there is a <code>Expr.nan_min()</code> but no <code>Expr.nan_min()</code>. <code>NaN</code> is sometimes a value higher than Inf and sometimes regarded as a <code>Null</code>. Polars conventions <code>NaN</code> &gt; <code>Inf</code> &gt; <code>99</code> &gt; <code>-99</code> &gt; <code>-Inf</code> &gt; <code>Null</code> <code>Null == Null</code> yields often times false, sometimes true, sometimes <code>Null</code>. The documentation or examples do not reveal this variations. The best to do, when in doubt, is to do test sort on a small Series/Column of all values.</p> <p>#' R <code>NaN</code> ~ polars <code>NaN</code> ~ python <code>\u2060[float(\"NaN\")]\u2060</code> #only floats have <code>NaN</code>s</p> <p>R <code>Inf</code> ~ polars <code>inf</code> ~ python <code>\u2060[float(\"inf\")]\u2060</code> #only floats have <code>Inf</code></p>"},{"location":"reference/#null-is-not-null-is-not-null","title":"NULL IS NOT Null is not NULL","text":"<p>The R NULL does not exist inside polars frames and series and so on. It resembles the Option::None in the hidden rust code. It resembles the python <code>None</code>. In all three langues the <code>NULL</code>/<code>None</code>/<code>None</code> are used in this context as function argument to signal default behavior or perhaps a deactivated feature. R <code>NULL</code> does NOT translate into the polars bitmask <code>Null</code>, that is <code>NA</code>. R <code>NULL</code> ~ rust-polars <code>Option::None</code> ~ pypolars <code>None</code> #typically used for function arguments</p>"},{"location":"reference/#lists-frames-and-dicts","title":"LISTS, FRAMES AND DICTS","text":"<p>The following translations are relevant when loading data into polars. The R list appears similar to python dictionary (hashmap), but is implemented more similar to the python list (array of pointers). R list do support string naming elements via a string vector. In polars both lists (of vectors or series) and data.frames can be used to construct a polars DataFrame, just a as dictionaries would be used in python. In terms of loading in/out data the follow tranlation holds: R <code>data.frame</code>/<code>list</code> ~ polars <code>DataFrame</code> ~ python <code>dictonary</code></p>"},{"location":"reference/#series-and-vectors","title":"Series and Vectors","text":"<p>The R vector (Integer, Double, Character, ...) resembles the Series as both are external from any frame and can be of any length. The implementation is quite different. E.g. <code>for</code>-loop appending to an R vector is considered quite bad for performance. The vector will be fully rewritten in memory for every append. The polars Series has chunked memory allocation, which allows any appened data to be written only. However fragmented memory is not great for fast computations and polars objects have a <code>rechunk</code>()-method, to reallocate chunks into one. Rechunk might be called implicitly by polars. In the context of constructing. Series and extracting data , the following translation holds: R <code>vector</code> ~ polars <code>Series</code>/<code>column</code> ~ python <code>list</code></p>"},{"location":"reference/#expressions","title":"Expressions","text":"<p>The polars Expr do not have any base R counterpart. Expr are analogous to how ggplot split plotting instructions from the rendering. Base R plot immediately pushes any instruction by adding e.g. pixels to a .png canvas. <code>ggplot</code> collects instructions and in the end when executed the rendering can be performed with optimization across all instructions. Btw <code>ggplot</code> command-syntax is a monoid meaning the order does not matter, that is not the case for polars Expr. Polars Expr's can be understood as a DSL (domain specific language) that expresses syntax trees of instructions. R expressions evaluate to syntax trees also, but it difficult to optimize the execution order automaticly, without rewriting the code. A great selling point of Polars is that any query will be optimized. Expr are very light-weight symbols chained together.</p>"},{"location":"reference/#dot-dollarnamesdataframe","title":"Dot-DollarNames.DataFrame","text":""},{"location":"reference/#description_73","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/#usage_43","title":"Usage","text":"<pre><code>## S3 method for class 'DataFrame'\n.DollarNames(x, pattern = \"\")\n</code></pre>"},{"location":"reference/#arguments_37","title":"Arguments","text":"<code>x</code> <p>DataFrame</p> <code>pattern</code> <p>code-stump as string to auto-complete</p>"},{"location":"reference/#dot-dollarnamesexpr","title":"Dot-DollarNames.Expr","text":""},{"location":"reference/#description_74","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/#usage_44","title":"Usage","text":"<pre><code>## S3 method for class 'Expr'\n.DollarNames(x, pattern = \"\")\n</code></pre>"},{"location":"reference/#arguments_38","title":"Arguments","text":"<code>x</code> <p>Expr</p> <code>pattern</code> <p>code-stump as string to auto-complete</p>"},{"location":"reference/#dot-dollarnamesgroupby","title":"Dot-DollarNames.GroupBy","text":""},{"location":"reference/#description_75","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/#usage_45","title":"Usage","text":"<pre><code>## S3 method for class 'GroupBy'\n.DollarNames(x, pattern = \"\")\n</code></pre>"},{"location":"reference/#arguments_39","title":"Arguments","text":"<code>x</code> <p>GroupBy</p> <code>pattern</code> <p>code-stump as string to auto-complete</p>"},{"location":"reference/#dot-dollarnameslazyframe","title":"Dot-DollarNames.LazyFrame","text":""},{"location":"reference/#description_76","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/#usage_46","title":"Usage","text":"<pre><code>## S3 method for class 'LazyFrame'\n.DollarNames(x, pattern = \"\")\n</code></pre>"},{"location":"reference/#arguments_40","title":"Arguments","text":"<code>x</code> <p>LazyFrame</p> <code>pattern</code> <p>code-stump as string to auto-complete</p>"},{"location":"reference/#dot-dollarnamespolarsbackgroundhandle","title":"Dot-DollarNames.PolarsBackgroundHandle","text":""},{"location":"reference/#description_77","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/#usage_47","title":"Usage","text":"<pre><code>## S3 method for class 'PolarsBackgroundHandle'\n.DollarNames(x, pattern = \"\")\n</code></pre>"},{"location":"reference/#arguments_41","title":"Arguments","text":"<code>x</code> <p>LazyFrame</p> <code>pattern</code> <p>code-stump as string to auto-complete</p>"},{"location":"reference/#dot-dollarnamesseries","title":"Dot-DollarNames.Series","text":""},{"location":"reference/#description_78","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/#usage_48","title":"Usage","text":"<pre><code>## S3 method for class 'Series'\n.DollarNames(x, pattern = \"\")\n</code></pre>"},{"location":"reference/#arguments_42","title":"Arguments","text":"<code>x</code> <p>Series</p> <code>pattern</code> <p>code-stump as string to auto-complete</p>"},{"location":"reference/#dot-dollarnamesvecdataframe","title":"Dot-DollarNames.VecDataFrame","text":""},{"location":"reference/#description_79","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/#usage_49","title":"Usage","text":"<pre><code>## S3 method for class 'VecDataFrame'\n.DollarNames(x, pattern = \"\")\n</code></pre>"},{"location":"reference/#arguments_43","title":"Arguments","text":"<code>x</code> <p>VecDataFrame</p> <code>pattern</code> <p>code-stump as string to auto-complete</p>"},{"location":"reference/#dot-dollarnameswhen","title":"Dot-DollarNames.When","text":""},{"location":"reference/#description_80","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/#usage_50","title":"Usage","text":"<pre><code>## S3 method for class 'When'\n.DollarNames(x, pattern = \"\")\n</code></pre>"},{"location":"reference/#arguments_44","title":"Arguments","text":"<code>x</code> <p>When</p> <code>pattern</code> <p>code-stump as string to auto-complete</p>"},{"location":"reference/#dot-dollarnameswhenthen","title":"Dot-DollarNames.WhenThen","text":""},{"location":"reference/#description_81","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/#usage_51","title":"Usage","text":"<pre><code>## S3 method for class 'WhenThen'\n.DollarNames(x, pattern = \"\")\n</code></pre>"},{"location":"reference/#arguments_45","title":"Arguments","text":"<code>x</code> <p>WhenThen</p> <code>pattern</code> <p>code-stump as string to auto-complete</p>"},{"location":"reference/#dot-dollarnameswhenthenthen","title":"Dot-DollarNames.WhenThenThen","text":""},{"location":"reference/#description_82","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/#usage_52","title":"Usage","text":"<pre><code>## S3 method for class 'WhenThenThen'\n.DollarNames(x, pattern = \"\")\n</code></pre>"},{"location":"reference/#arguments_46","title":"Arguments","text":"<code>x</code> <p>WhenThenThen</p> <code>pattern</code> <p>code-stump as string to auto-complete</p>"},{"location":"reference/#dot-pr","title":"Dot-pr","text":""},{"location":"reference/#description_83","title":"Description","text":"<p><code>.pr</code> Original extendr bindings converted into pure functions</p>"},{"location":"reference/#usage_53","title":"Usage","text":"<pre><code>.pr\n</code></pre>"},{"location":"reference/#format_30","title":"Format","text":"<p>An object of class <code>environment</code> of length 16.</p>"},{"location":"reference/#examples_65","title":"Examples","text":"<pre><code>#.pr$DataFrame$print() is an external function where self is passed as arg\npolars:::.pr$DataFrame$print(self = pl$DataFrame(iris))\npolars:::print_env(.pr,\".pr the collection of private method calls to rust-polars\")\n</code></pre>"},{"location":"reference/#element","title":"Element","text":""},{"location":"reference/#description_84","title":"Description","text":"<p>Alias for an element in evaluated in an <code>eval</code> expression.</p>"},{"location":"reference/#value_69","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_66","title":"Examples","text":"<pre><code>pl$lit(1:5)$cumulative_eval(pl$element()$first()-pl$element()$last() ** 2)$to_r()\n</code></pre>"},{"location":"reference/#err","title":"Err","text":""},{"location":"reference/#description_85","title":"Description","text":"<p>Wrap in Err</p>"},{"location":"reference/#usage_54","title":"Usage","text":"<pre><code>Err(x)\n</code></pre>"},{"location":"reference/#arguments_47","title":"Arguments","text":"<code>x</code> <p>any R object</p>"},{"location":"reference/#value_70","title":"Value","text":"<p>same R object wrapped in a Err-result</p>"},{"location":"reference/#expr-abs","title":"Expr abs","text":""},{"location":"reference/#description_86","title":"Description","text":"<p>Compute absolute values</p>"},{"location":"reference/#usage_55","title":"Usage","text":"<pre><code>Expr_abs\n</code></pre>"},{"location":"reference/#format_31","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_71","title":"Value","text":"<p>Exprs abs</p>"},{"location":"reference/#examples_67","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=-1:1))$select(pl$col(\"a\"),pl$col(\"a\")$abs()$alias(\"abs\"))\n</code></pre>"},{"location":"reference/#expr-add","title":"Expr add","text":""},{"location":"reference/#description_87","title":"Description","text":"<p>Addition</p>"},{"location":"reference/#usage_56","title":"Usage","text":"<pre><code>Expr_add(other)\n\n## S3 method for class 'Expr'\ne1 + e2\n</code></pre>"},{"location":"reference/#arguments_48","title":"Arguments","text":"<code>other</code> <p>literal or Robj which can become a literal</p> <code>e1</code> <p>lhs Expr</p> <code>e2</code> <p>rhs Expr or anything which can become a literal Expression</p>"},{"location":"reference/#value_72","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/#examples_68","title":"Examples","text":"<pre><code>#three syntaxes same result\npl$lit(5) + 10\npl$lit(5) + pl$lit(10)\npl$lit(5)$add(pl$lit(10))\n+pl$lit(5) #unary use resolves to same as pl$lit(5)\n</code></pre>"},{"location":"reference/#expr-agg-groups","title":"Expr agg groups","text":""},{"location":"reference/#description_88","title":"Description","text":"<p>Get the group indexes of the group by operation. Should be used in aggregation context only.</p>"},{"location":"reference/#usage_57","title":"Usage","text":"<pre><code>Expr_agg_groups\n</code></pre>"},{"location":"reference/#format_32","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_73","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/#examples_69","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(\ngroup = c(\"one\",\"one\",\"one\",\"two\",\"two\",\"two\"),\nvalue =  c(94, 95, 96, 97, 97, 99)\n))\ndf$groupby(\"group\", maintain_order=TRUE)$agg(pl$col(\"value\")$agg_groups())\n</code></pre>"},{"location":"reference/#expr-alias","title":"Expr alias","text":""},{"location":"reference/#description_89","title":"Description","text":"<p>Rename the output of an expression.</p>"},{"location":"reference/#usage_58","title":"Usage","text":"<pre><code>Expr_alias(name)\n</code></pre>"},{"location":"reference/#arguments_49","title":"Arguments","text":"<code>name</code> <p>string new name of output</p>"},{"location":"reference/#format_33","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_74","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_70","title":"Examples","text":"<pre><code>pl$col(\"bob\")$alias(\"alice\")\n</code></pre>"},{"location":"reference/#expr-all","title":"Expr all","text":""},{"location":"reference/#description_90","title":"Description","text":"<p>Check if all boolean values in a Boolean column are <code>TRUE</code>. This method is an expression - not to be confused with <code>pl$all</code> which is a function to select all columns.</p>"},{"location":"reference/#usage_59","title":"Usage","text":"<pre><code>Expr_all\n</code></pre>"},{"location":"reference/#format_34","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#details_11","title":"Details","text":"<p>last <code>all()</code> in example is this Expr method, the first <code>pl$all()</code> refers to \"all-columns\" and is an expression constructor</p>"},{"location":"reference/#value_75","title":"Value","text":"<p>Boolean literal</p>"},{"location":"reference/#examples_71","title":"Examples","text":"<pre><code>pl$DataFrame(\nall=c(TRUE,TRUE),\nany=c(TRUE,FALSE),\nnone=c(FALSE,FALSE)\n)$select(\npl$all()$all()\n)\n</code></pre>"},{"location":"reference/#expr-and","title":"Expr and","text":""},{"location":"reference/#description_91","title":"Description","text":"<p>combine to boolean exprresions with AND</p>"},{"location":"reference/#usage_60","title":"Usage","text":"<pre><code>Expr_and(other)\n</code></pre>"},{"location":"reference/#arguments_50","title":"Arguments","text":"<code>other</code> <p>literal or Robj which can become a literal</p>"},{"location":"reference/#format_35","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_76","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_72","title":"Examples","text":"<pre><code>pl$lit(TRUE) &amp; TRUE\npl$lit(TRUE)$and(pl$lit(TRUE))\n</code></pre>"},{"location":"reference/#expr-any","title":"Expr any","text":""},{"location":"reference/#description_92","title":"Description","text":"<p>Check if any boolean value in a Boolean column is <code>TRUE</code>.</p>"},{"location":"reference/#usage_61","title":"Usage","text":"<pre><code>Expr_any\n</code></pre>"},{"location":"reference/#format_36","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_77","title":"Value","text":"<p>Boolean literal</p>"},{"location":"reference/#examples_73","title":"Examples","text":"<pre><code>pl$DataFrame(\nall=c(TRUE,TRUE),\nany=c(TRUE,FALSE),\nnone=c(FALSE,FALSE)\n)$select(\npl$all()$any()\n)\n</code></pre>"},{"location":"reference/#expr-append","title":"Expr append","text":""},{"location":"reference/#description_93","title":"Description","text":"<p>This is done by adding the chunks of <code>other</code> to this <code>output</code>.</p>"},{"location":"reference/#usage_62","title":"Usage","text":"<pre><code>Expr_append(other, upcast = TRUE)\n</code></pre>"},{"location":"reference/#arguments_51","title":"Arguments","text":"<code>other</code> <p>Expr, into Expr</p> <code>upcast</code> <p>bool upcast to, if any supertype of two non equal datatypes.</p>"},{"location":"reference/#format_37","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_78","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_74","title":"Examples","text":"<pre><code>#append bottom to to row\ndf = pl$DataFrame(list(a = 1:3, b = c(NA_real_,4,5)))\ndf$select(pl$all()$head(1)$append(pl$all()$tail(1)))\n#implicit upcast, when default = TRUE\npl$DataFrame(list())$select(pl$lit(42)$append(42L))\npl$DataFrame(list())$select(pl$lit(42)$append(FALSE))\npl$DataFrame(list())$select(pl$lit(\"Bob\")$append(FALSE))\n</code></pre>"},{"location":"reference/#expr-apply","title":"Expr apply","text":""},{"location":"reference/#description_94","title":"Description","text":"<p>Apply a custom/user-defined function (UDF) in a GroupBy or Projection context. Depending on the context it has the following behavior: -Selection</p>"},{"location":"reference/#usage_63","title":"Usage","text":"<pre><code>Expr_apply(\n  f,\n  return_type = NULL,\n  strict_return_type = TRUE,\n  allow_fail_eval = FALSE\n)\n</code></pre>"},{"location":"reference/#arguments_52","title":"Arguments","text":"<code>f</code> <p>r function see details depending on context</p> <code>return_type</code> <p>NULL or one of pl$dtypes, the output datatype, NULL is the same as input.</p> <code>strict_return_type</code> <p>bool (default TRUE), error if not correct datatype returned from R, if FALSE will convert to a Polars Null and carry on.</p> <code>allow_fail_eval</code> <p>bool (default FALSE), if TRUE will not raise user function error but convert result to a polars Null and carry on.</p>"},{"location":"reference/#details_12","title":"Details","text":"<p>Apply a user function in a groupby or projection(select) context</p> <p>Depending on context the following behaviour:</p> <ul> <li> <p>Projection/Selection: Expects an <code>f</code> to operate on R scalar values.     Polars will convert each element into an R value and pass it to the     function The output of the user function will be converted back into     a polars type. Return type must match. See param return type. Apply     in selection context should be avoided as a <code>lapply()</code> has half the     overhead.</p> </li> <li> <p>Groupby Expects a user function <code>f</code> to take a <code>Series</code> and return a     <code>Series</code> or Robj convertable to <code>Series</code>, eg. R vector. GroupBy     context much faster if number groups are quite fewer than number of     rows, as the iteration is only across the groups. The r user     function could e.g. do vectorized operations and stay quite     performant. use <code>s$to_r()</code> to convert input Series to an r vector or     list. use <code>s$to_r_vector</code> and <code>s$to_r_list()</code> to force conversion to     vector or list.</p> </li> </ul> <p>Implementing logic using an R function is almost always significantly slower and more memory intensive than implementing the same logic using the native expression API because: - The native expression engine runs in Rust; functions run in R. - Use of R functions forces the DataFrame to be materialized in memory. - Polars-native expressions can be parallelised (R functions cannot*). - Polars-native expressions can be logically optimised (R functions cannot). Wherever possible you should strongly prefer the native expression API to achieve the best performance.</p>"},{"location":"reference/#value_79","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_75","title":"Examples","text":"<pre><code>#apply over groups - normal usage\n# s is a series of all values for one column within group, here Species\ne_all =pl$all() #perform groupby agg on all columns otherwise e.g. pl$col(\"Sepal.Length\")\ne_sum  = e_all$apply(\\(s)  sum(s$to_r()))$suffix(\"_sum\")\ne_head = e_all$apply(\\(s) head(s$to_r(),2))$suffix(\"_head\")\npl$DataFrame(iris)$groupby(\"Species\")$agg(e_sum,e_head)\n# apply over single values (should be avoided as it takes ~2.5us overhead + R function exec time\n# on a 2015 MacBook Pro) x is an R scalar\n#perform on all Float64 columns, using pl$all requires user function can handle any input type\ne_all =pl$col(pl$dtypes$Float64)\ne_add10  = e_all$apply(\\(x)  {x+10})$suffix(\"_sum\")\n#quite silly index into alphabet(letters) by ceil of float value\n#must set return_type as not the same as input\ne_letter = e_all$apply(\\(x) letters[ceiling(x)], return_type = pl$dtypes$Utf8)$suffix(\"_letter\")\npl$DataFrame(iris)$select(e_add10,e_letter)\n##timing \"slow\" apply in select /with_columns context, this makes apply\nn = 1000000L\nset.seed(1)\ndf = pl$DataFrame(list(\na = 1:n,\nb = sample(letters,n,replace=TRUE)\n))\nprint(\"apply over 1 million values takes ~2.5 sec on 2015 MacBook Pro\")\nsystem.time({\nrdf = df$with_columns(\npl$col(\"a\")$apply(\\(x) {\nx*2L\n})$alias(\"bob\")\n)\n})\nprint(\"R lapply 1 million values take ~1sec on 2015 MacBook Pro\")\nsystem.time({\nlapply(df$get_column(\"a\")$to_r(),\\(x) x*2L )\n})\nprint(\"using polars syntax takes ~1ms\")\nsystem.time({\n(df$get_column(\"a\") * 2L)\n})\nprint(\"using R vector syntax takes ~4ms\")\nr_vec = df$get_column(\"a\")$to_r()\nsystem.time({\nr_vec * 2L\n})\n</code></pre>"},{"location":"reference/#expr-arccos","title":"Expr arccos","text":""},{"location":"reference/#description_95","title":"Description","text":"<p>Compute the element-wise value for the inverse cosine.</p>"},{"location":"reference/#usage_64","title":"Usage","text":"<pre><code>Expr_arccos\n</code></pre>"},{"location":"reference/#format_38","title":"Format","text":"<p>Method</p>"},{"location":"reference/#details_13","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/#value_80","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_76","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,cos(0.5),0,1,NA_real_))$select(pl$col(\"a\")$arccos())\n</code></pre>"},{"location":"reference/#expr-arccosh","title":"Expr arccosh","text":""},{"location":"reference/#description_96","title":"Description","text":"<p>Compute the element-wise value for the inverse hyperbolic cosine.</p>"},{"location":"reference/#usage_65","title":"Usage","text":"<pre><code>Expr_arccosh\n</code></pre>"},{"location":"reference/#format_39","title":"Format","text":"<p>Method</p>"},{"location":"reference/#details_14","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/#value_81","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_77","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,cosh(0.5),0,1,NA_real_))$select(pl$col(\"a\")$arccosh())\n</code></pre>"},{"location":"reference/#expr-arcsin","title":"Expr arcsin","text":""},{"location":"reference/#description_97","title":"Description","text":"<p>Compute the element-wise value for the inverse sine.</p>"},{"location":"reference/#usage_66","title":"Usage","text":"<pre><code>Expr_arcsin\n</code></pre>"},{"location":"reference/#format_40","title":"Format","text":"<p>Method</p>"},{"location":"reference/#details_15","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/#value_82","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_78","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,sin(0.5),0,1,NA_real_))$select(pl$col(\"a\")$arcsin())\n</code></pre>"},{"location":"reference/#expr-arcsinh","title":"Expr arcsinh","text":""},{"location":"reference/#description_98","title":"Description","text":"<p>Compute the element-wise value for the inverse hyperbolic sine.</p>"},{"location":"reference/#usage_67","title":"Usage","text":"<pre><code>Expr_arcsinh\n</code></pre>"},{"location":"reference/#format_41","title":"Format","text":"<p>Method</p>"},{"location":"reference/#details_16","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/#value_83","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_79","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,sinh(0.5),0,1,NA_real_))$select(pl$col(\"a\")$arcsinh())\n</code></pre>"},{"location":"reference/#expr-arctan","title":"Expr arctan","text":""},{"location":"reference/#description_99","title":"Description","text":"<p>Compute the element-wise value for the inverse tangent.</p>"},{"location":"reference/#usage_68","title":"Usage","text":"<pre><code>Expr_arctan\n</code></pre>"},{"location":"reference/#format_42","title":"Format","text":"<p>Method</p>"},{"location":"reference/#details_17","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/#value_84","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_80","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,tan(0.5),0,1,NA_real_))$select(pl$col(\"a\")$arctan())\n</code></pre>"},{"location":"reference/#expr-arctanh","title":"Expr arctanh","text":""},{"location":"reference/#description_100","title":"Description","text":"<p>Compute the element-wise value for the inverse hyperbolic tangent.</p>"},{"location":"reference/#usage_69","title":"Usage","text":"<pre><code>Expr_arctanh\n</code></pre>"},{"location":"reference/#format_43","title":"Format","text":"<p>Method</p>"},{"location":"reference/#details_18","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/#value_85","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_81","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,tanh(0.5),0,1,NA_real_))$select(pl$col(\"a\")$arctanh())\n</code></pre>"},{"location":"reference/#expr-arg-max","title":"Expr arg max","text":""},{"location":"reference/#description_101","title":"Description","text":"<p>Get the index of the minimal value.</p>"},{"location":"reference/#usage_70","title":"Usage","text":"<pre><code>Expr_arg_max\n</code></pre>"},{"location":"reference/#format_44","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_19","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_86","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_82","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(6, 1, 0, NA, Inf, NaN)\n))$select(pl$col(\"a\")$arg_max())\n</code></pre>"},{"location":"reference/#expr-arg-min","title":"Expr arg min","text":""},{"location":"reference/#description_102","title":"Description","text":"<p>Get the index of the minimal value.</p>"},{"location":"reference/#usage_71","title":"Usage","text":"<pre><code>Expr_arg_min\n</code></pre>"},{"location":"reference/#format_45","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_20","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_87","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_83","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(6, 1, 0, NA, Inf, NaN)\n))$select(pl$col(\"a\")$arg_min())\n</code></pre>"},{"location":"reference/#expr-arg-sort","title":"Expr arg sort","text":""},{"location":"reference/#description_103","title":"Description","text":"<p>Get the index values that would sort this column. If 'reverse=True' the smallest elements will be given.</p> <p>argsort is a alias for arg_sort</p>"},{"location":"reference/#usage_72","title":"Usage","text":"<pre><code>Expr_arg_sort(reverse = FALSE, nulls_last = FALSE)\n\nExpr_argsort(reverse = FALSE, nulls_last = FALSE)\n</code></pre>"},{"location":"reference/#arguments_53","title":"Arguments","text":"<code>reverse</code> <p>bool default FALSE, reverses sort</p> <code>nulls_last</code> <p>bool, default FALSE, place Nulls last</p>"},{"location":"reference/#format_46","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_21","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_88","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_84","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(6, 1, 0, NA, Inf, NaN)\n))$select(pl$col(\"a\")$arg_sort())\n</code></pre>"},{"location":"reference/#expr-arg-unique","title":"Expr arg unique","text":""},{"location":"reference/#description_104","title":"Description","text":"<p>Index of First Unique Value.</p>"},{"location":"reference/#usage_73","title":"Usage","text":"<pre><code>Expr_arg_unique\n</code></pre>"},{"location":"reference/#format_47","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_89","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_85","title":"Examples","text":"<pre><code>pl$select(pl$lit(c(1:2,1:3))$arg_unique())\n</code></pre>"},{"location":"reference/#expr-arr","title":"Expr arr","text":""},{"location":"reference/#description_105","title":"Description","text":"<p>Create an object namespace of all list related methods. See the individual method pages for full details</p>"},{"location":"reference/#usage_74","title":"Usage","text":"<pre><code>Expr_arr()\n</code></pre>"},{"location":"reference/#value_90","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_86","title":"Examples","text":"<pre><code>df_with_list = pl$DataFrame(\ngroup = c(1,1,2,2,3),\nvalue = c(1:5)\n)$groupby(\n\"group\",maintain_order = TRUE\n)$agg(\npl$col(\"value\") * 3L\n)\ndf_with_list$with_column(\npl$col(\"value\")$arr$lengths()$alias(\"group_size\")\n)\n</code></pre>"},{"location":"reference/#expr-backward-fill","title":"Expr backward fill","text":""},{"location":"reference/#description_106","title":"Description","text":"<p>Fill missing values with the next to be seen values.</p>"},{"location":"reference/#usage_75","title":"Usage","text":"<pre><code>Expr_backward_fill(limit = NULL)\n</code></pre>"},{"location":"reference/#arguments_54","title":"Arguments","text":"<code>limit</code> <p>Expr or <code>\u2060Into&lt;Expr&gt;\u2060</code> The number of consecutive null values to backward fill.</p>"},{"location":"reference/#format_48","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_22","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_91","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_87","title":"Examples","text":"<pre><code>l = list(a=c(1L,rep(NA_integer_,3L),10))\npl$DataFrame(l)$select(\npl$col(\"a\")$backward_fill()$alias(\"bf_null\"),\npl$col(\"a\")$backward_fill(limit = 0)$alias(\"bf_l0\"),\npl$col(\"a\")$backward_fill(limit = 1)$alias(\"bf_l1\")\n)$to_list()\n</code></pre>"},{"location":"reference/#expr-bin","title":"Expr bin","text":""},{"location":"reference/#description_107","title":"Description","text":"<p>Create an object namespace of all binary related methods. See the individual method pages for full details</p>"},{"location":"reference/#usage_76","title":"Usage","text":"<pre><code>Expr_bin()\n</code></pre>"},{"location":"reference/#value_92","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_88","title":"Examples","text":"<pre><code>#missing\n</code></pre>"},{"location":"reference/#expr-cast","title":"Expr cast","text":""},{"location":"reference/#description_108","title":"Description","text":"<p>Cast between DataType(s)</p>"},{"location":"reference/#usage_77","title":"Usage","text":"<pre><code>Expr_cast(dtype, strict = TRUE)\n</code></pre>"},{"location":"reference/#arguments_55","title":"Arguments","text":"<code>dtype</code> <p>DataType to cast to.</p> <code>strict</code> <p>bool if true an error will be thrown if cast failed at resolve time.</p>"},{"location":"reference/#value_93","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_89","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = 1:3, b = 1:3))\ndf$with_columns(\npl$col(\"a\")$cast(pl$dtypes$Float64, TRUE),\npl$col(\"a\")$cast(pl$dtypes$Int32, TRUE)\n)\n</code></pre>"},{"location":"reference/#expr-cat","title":"Expr cat","text":""},{"location":"reference/#description_109","title":"Description","text":"<p>Create an object namespace of all cat related methods. See the individual method pages for full details</p>"},{"location":"reference/#usage_78","title":"Usage","text":"<pre><code>Expr_cat()\n</code></pre>"},{"location":"reference/#value_94","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_90","title":"Examples","text":"<pre><code>#missing\n</code></pre>"},{"location":"reference/#expr-ceil","title":"Expr ceil","text":""},{"location":"reference/#description_110","title":"Description","text":"<p>Rounds up to the nearest integer value. Only works on floating point Series.</p>"},{"location":"reference/#usage_79","title":"Usage","text":"<pre><code>Expr_ceil\n</code></pre>"},{"location":"reference/#format_49","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_95","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_91","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(0.33, 0.5, 1.02, 1.5, NaN , NA, Inf, -Inf)\n))$select(\npl$col(\"a\")$ceil()\n)\n</code></pre>"},{"location":"reference/#expr-clip","title":"Expr clip","text":""},{"location":"reference/#description_111","title":"Description","text":"<p>Clip (limit) the values in an array to a <code>min</code> and <code>max</code> boundary.</p>"},{"location":"reference/#usage_80","title":"Usage","text":"<pre><code>Expr_clip(min, max)\n\nExpr_clip_min(min)\n\nExpr_clip_max(max)\n</code></pre>"},{"location":"reference/#arguments_56","title":"Arguments","text":"<code>min</code> <p>Minimum Value, ints and floats or any literal expression of ints and floats</p> <code>max</code> <p>Maximum Value, ints and floats or any literal expression of ints and floats</p>"},{"location":"reference/#details_23","title":"Details","text":"<p>Only works for numerical types. If you want to clip other dtypes, consider writing a \"when, then, otherwise\" expression. See :func:<code>when</code> for more information.</p>"},{"location":"reference/#value_96","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_92","title":"Examples","text":"<pre><code>df = pl$DataFrame(foo = c(-50L, 5L, NA_integer_,50L))\ndf$with_column(pl$col(\"foo\")$clip(1L,10L)$alias(\"foo_clipped\"))\ndf$with_column(pl$col(\"foo\")$clip_min(1L)$alias(\"foo_clipped\"))\ndf$with_column(pl$col(\"foo\")$clip_max(10L)$alias(\"foo_clipped\"))\n</code></pre>"},{"location":"reference/#expr-cos","title":"Expr cos","text":""},{"location":"reference/#description_112","title":"Description","text":"<p>Compute the element-wise value for the cosine.</p>"},{"location":"reference/#usage_81","title":"Usage","text":"<pre><code>Expr_cos\n</code></pre>"},{"location":"reference/#format_50","title":"Format","text":"<p>Method</p>"},{"location":"reference/#details_24","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/#value_97","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_93","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(0,pi/2,pi,NA_real_))$select(pl$col(\"a\")$cos())\n</code></pre>"},{"location":"reference/#expr-cosh","title":"Expr cosh","text":""},{"location":"reference/#description_113","title":"Description","text":"<p>Compute the element-wise value for the hyperbolic cosine.</p>"},{"location":"reference/#usage_82","title":"Usage","text":"<pre><code>Expr_cosh\n</code></pre>"},{"location":"reference/#format_51","title":"Format","text":"<p>Method</p>"},{"location":"reference/#details_25","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/#value_98","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_94","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,acosh(1.5),0,1,NA_real_))$select(pl$col(\"a\")$cosh())\n</code></pre>"},{"location":"reference/#expr-count","title":"Expr count","text":""},{"location":"reference/#description_114","title":"Description","text":"<p>Count the number of values in this expression. Similar to R length()</p>"},{"location":"reference/#usage_83","title":"Usage","text":"<pre><code>Expr_count\n\nExpr_len\n</code></pre>"},{"location":"reference/#format_52","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p> <p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_99","title":"Value","text":"<p>Expr</p> <p>Expr</p>"},{"location":"reference/#examples_95","title":"Examples","text":"<pre><code>pl$DataFrame(\nall=c(TRUE,TRUE),\nany=c(TRUE,FALSE),\nnone=c(FALSE,FALSE)\n)$select(\npl$all()$count()\n)\npl$DataFrame(\nall=c(TRUE,TRUE),\nany=c(TRUE,FALSE),\nnone=c(FALSE,FALSE)\n)$select(\npl$all()$len(),\npl$col(\"all\")$first()$len()$alias(\"all_first\")\n)\n</code></pre>"},{"location":"reference/#expr-cumcount","title":"Expr cumcount","text":""},{"location":"reference/#description_115","title":"Description","text":"<p>Get an array with the cumulative count computed at every element. Counting from 0 to len</p>"},{"location":"reference/#usage_84","title":"Usage","text":"<pre><code>Expr_cumcount(reverse = FALSE)\n</code></pre>"},{"location":"reference/#arguments_57","title":"Arguments","text":"<code>reverse</code> <p>bool, default FALSE, if true roll over vector from back to forth</p>"},{"location":"reference/#format_53","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_26","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues.</p> <p>cumcount does not seem to count within lists.</p>"},{"location":"reference/#value_100","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_96","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:4))$select(\npl$col(\"a\")$cumcount()$alias(\"cumcount\"),\npl$col(\"a\")$cumcount(reverse=TRUE)$alias(\"cumcount_reversed\")\n)\n</code></pre>"},{"location":"reference/#expr-cummin","title":"Expr cummin","text":""},{"location":"reference/#description_116","title":"Description","text":"<p>Get an array with the cumulative min computed at every element.</p> <p>Get an array with the cumulative max computed at every element.</p>"},{"location":"reference/#usage_85","title":"Usage","text":"<pre><code>Expr_cummin(reverse = FALSE)\n\nExpr_cummax(reverse = FALSE)\n</code></pre>"},{"location":"reference/#arguments_58","title":"Arguments","text":"<code>reverse</code> <p>bool, default FALSE, if true roll over vector from back to forth</p>"},{"location":"reference/#format_54","title":"Format","text":"<p>a method</p> <p>a method</p>"},{"location":"reference/#details_27","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues.</p> <p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p> <p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues.</p> <p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_101","title":"Value","text":"<p>Expr</p> <p>Expr</p>"},{"location":"reference/#examples_97","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:4))$select(\npl$col(\"a\")$cummin()$alias(\"cummin\"),\npl$col(\"a\")$cummin(reverse=TRUE)$alias(\"cummin_reversed\")\n)\npl$DataFrame(list(a=1:4))$select(\npl$col(\"a\")$cummax()$alias(\"cummux\"),\npl$col(\"a\")$cummax(reverse=TRUE)$alias(\"cummax_reversed\")\n)\n</code></pre>"},{"location":"reference/#expr-cumprod","title":"Expr cumprod","text":""},{"location":"reference/#description_117","title":"Description","text":"<p>Get an array with the cumulative product computed at every element.</p>"},{"location":"reference/#usage_86","title":"Usage","text":"<pre><code>Expr_cumprod(reverse = FALSE)\n</code></pre>"},{"location":"reference/#arguments_59","title":"Arguments","text":"<code>reverse</code> <p>bool, default FALSE, if true roll over vector from back to forth</p>"},{"location":"reference/#format_55","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_28","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues.</p>"},{"location":"reference/#value_102","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_98","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:4))$select(\npl$col(\"a\")$cumprod()$alias(\"cumprod\"),\npl$col(\"a\")$cumprod(reverse=TRUE)$alias(\"cumprod_reversed\")\n)\n</code></pre>"},{"location":"reference/#expr-cumsum","title":"Expr cumsum","text":""},{"location":"reference/#description_118","title":"Description","text":"<p>Get an array with the cumulative sum computed at every element.</p>"},{"location":"reference/#usage_87","title":"Usage","text":"<pre><code>Expr_cumsum(reverse = FALSE)\n</code></pre>"},{"location":"reference/#arguments_60","title":"Arguments","text":"<code>reverse</code> <p>bool, default FALSE, if true roll over vector from back to forth</p>"},{"location":"reference/#format_56","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_29","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues.</p>"},{"location":"reference/#value_103","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_99","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:4))$select(\npl$col(\"a\")$cumsum()$alias(\"cumsum\"),\npl$col(\"a\")$cumsum(reverse=TRUE)$alias(\"cumsum_reversed\")\n)\n</code></pre>"},{"location":"reference/#expr-cumulative-eval","title":"Expr cumulative eval","text":""},{"location":"reference/#description_119","title":"Description","text":"<p>Run an expression over a sliding window that increases <code>1</code> slot every iteration.</p>"},{"location":"reference/#usage_88","title":"Usage","text":"<pre><code>Expr_cumulative_eval(expr, min_periods = 1L, parallel = FALSE)\n</code></pre>"},{"location":"reference/#arguments_61","title":"Arguments","text":"<code>expr</code> <p>Expression to evaluate</p> <code>min_periods</code> <p>Number of valid values there should be in the window before the expression is evaluated. valid values = <code>length - null_count</code></p> <code>parallel</code> <p>Run in parallel. Don't do this in a groupby or another operation that already has much parallelization.</p>"},{"location":"reference/#details_30","title":"Details","text":"<p>Warnings</p> <p>This functionality is experimental and may change without it being considered a breaking change. This can be really slow as it can have <code>O(n^2)</code> complexity. Don't use this for operations that visit all elements.</p>"},{"location":"reference/#value_104","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_100","title":"Examples","text":"<pre><code>pl$lit(1:5)$cumulative_eval(pl$element()$first()-pl$element()$last() ** 2)$to_r()\n</code></pre>"},{"location":"reference/#expr-diff","title":"Expr diff","text":""},{"location":"reference/#description_120","title":"Description","text":"<p>Calculate the n-th discrete difference.</p>"},{"location":"reference/#usage_89","title":"Usage","text":"<pre><code>Expr_diff(n = 1, null_behavior = \"ignore\")\n</code></pre>"},{"location":"reference/#arguments_62","title":"Arguments","text":"<code>n</code> <p>Integerish Number of slots to shift.</p> <code>null_behavior</code> <p>option default 'ignore', else 'drop'</p>"},{"location":"reference/#value_105","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_101","title":"Examples","text":"<pre><code>pl$DataFrame(list( a=c(20L,10L,30L,40L)))$select(\npl$col(\"a\")$diff()$alias(\"diff_default\"),\npl$col(\"a\")$diff(2,\"ignore\")$alias(\"diff_2_ignore\")\n)\n</code></pre>"},{"location":"reference/#expr-div","title":"Expr div","text":""},{"location":"reference/#description_121","title":"Description","text":"<p>Divide</p>"},{"location":"reference/#usage_90","title":"Usage","text":"<pre><code>Expr_div(other)\n\n## S3 method for class 'Expr'\ne1 / e2\n</code></pre>"},{"location":"reference/#arguments_63","title":"Arguments","text":"<code>other</code> <p>literal or Robj which can become a literal</p> <code>e1</code> <p>lhs Expr</p> <code>e2</code> <p>rhs Expr or anything which can become a literal Expression</p>"},{"location":"reference/#value_106","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/#examples_102","title":"Examples","text":"<pre><code>#three syntaxes same result\npl$lit(5) / 10\npl$lit(5) / pl$lit(10)\npl$lit(5)$div(pl$lit(10))\n</code></pre>"},{"location":"reference/#expr-dot","title":"Expr dot","text":""},{"location":"reference/#description_122","title":"Description","text":"<p>Compute the dot/inner product between two Expressions.</p>"},{"location":"reference/#usage_91","title":"Usage","text":"<pre><code>Expr_dot(other)\n</code></pre>"},{"location":"reference/#arguments_64","title":"Arguments","text":"<code>other</code> <p>Expr to compute dot product with.</p>"},{"location":"reference/#format_57","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_107","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_103","title":"Examples","text":"<pre><code>pl$DataFrame(\na=1:4,b=c(1,2,3,4),c=\"bob\"\n)$select(\npl$col(\"a\")$dot(pl$col(\"b\"))$alias(\"a dot b\"),\npl$col(\"a\")$dot(pl$col(\"a\"))$alias(\"a dot a\")\n)\n</code></pre>"},{"location":"reference/#expr-drop-nans","title":"Expr drop nans","text":""},{"location":"reference/#description_123","title":"Description","text":"<p>Drop floating point NaN values. Similar to R syntax <code>x[!is.nan(x)]</code></p>"},{"location":"reference/#usage_92","title":"Usage","text":"<pre><code>Expr_drop_nans\n</code></pre>"},{"location":"reference/#format_58","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#details_31","title":"Details","text":"<p>Note that NaN values are not null values! (null corrosponds to R NA, not R NULL) To drop null values, use method <code>drop_nulls</code>.</p> <p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_108","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_104","title":"Examples","text":"<pre><code> pl$DataFrame(list(x=c(1,2,NaN,NA)))$select(pl$col(\"x\")$drop_nans())\n</code></pre>"},{"location":"reference/#expr-drop-nulls","title":"Expr drop nulls","text":""},{"location":"reference/#description_124","title":"Description","text":"<p>Drop null values. Similar to R syntax <code>x[!(is.na(x) &amp; !is.nan(x))]</code></p>"},{"location":"reference/#usage_93","title":"Usage","text":"<pre><code>Expr_drop_nulls\n</code></pre>"},{"location":"reference/#format_59","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#details_32","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_109","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_105","title":"Examples","text":"<pre><code> pl$DataFrame(list(x=c(1,2,NaN,NA)))$select(pl$col(\"x\")$drop_nulls())\n</code></pre>"},{"location":"reference/#expr-dt","title":"Expr dt","text":""},{"location":"reference/#description_125","title":"Description","text":"<p>Create an object namespace of all datetime related methods. See the individual method pages for full details</p>"},{"location":"reference/#usage_94","title":"Usage","text":"<pre><code>Expr_dt()\n</code></pre>"},{"location":"reference/#value_110","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_106","title":"Examples","text":"<pre><code>#missing\n</code></pre>"},{"location":"reference/#expr-entropy","title":"Expr entropy","text":""},{"location":"reference/#description_126","title":"Description","text":"<p>Computes the entropy. Uses the formula <code>-sum(pk * log(pk))</code> where <code>pk</code> are discrete probabilities. Return Null if input is not values</p>"},{"location":"reference/#usage_95","title":"Usage","text":"<pre><code>Expr_entropy(base = base::exp(1), normalize = TRUE)\n</code></pre>"},{"location":"reference/#arguments_65","title":"Arguments","text":"<code>base</code> <p>Given exponential base, defaults to <code>e</code></p> <code>normalize</code> <p>Normalize pk if it doesn't sum to 1.</p>"},{"location":"reference/#value_111","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_107","title":"Examples","text":"<pre><code>pl$select(pl$lit(c(\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"))$unique_counts()$entropy(base=2))\n</code></pre>"},{"location":"reference/#expr-eq","title":"Expr eq","text":""},{"location":"reference/#description_127","title":"Description","text":"<p>eq method and operator</p>"},{"location":"reference/#usage_96","title":"Usage","text":"<pre><code>Expr_eq(other)\n\n## S3 method for class 'Expr'\ne1 == e2\n</code></pre>"},{"location":"reference/#arguments_66","title":"Arguments","text":"<code>other</code> <p>literal or Robj which can become a literal</p> <code>e1</code> <p>lhs Expr</p> <code>e2</code> <p>rhs Expr or anything which can become a literal Expression</p>"},{"location":"reference/#details_33","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_112","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/#examples_108","title":"Examples","text":"<pre><code>#' #three syntaxes same result\npl$lit(2) == 2\npl$lit(2) ==  pl$lit(2)\npl$lit(2)$eq(pl$lit(2))\n</code></pre>"},{"location":"reference/#expr-ewm-mean-std-var","title":"Expr ewm mean std var","text":""},{"location":"reference/#description_128","title":"Description","text":"<p>Exponentially-weighted moving average/std/var.</p> <p>Ewm_std</p> <p>Ewm_var</p>"},{"location":"reference/#usage_97","title":"Usage","text":"<pre><code>Expr_ewm_mean(\n  com = NULL,\n  span = NULL,\n  half_life = NULL,\n  alpha = NULL,\n  adjust = TRUE,\n  min_periods = 1L,\n  ignore_nulls = TRUE\n)\n\nExpr_ewm_std(\n  com = NULL,\n  span = NULL,\n  half_life = NULL,\n  alpha = NULL,\n  adjust = TRUE,\n  bias = FALSE,\n  min_periods = 1L,\n  ignore_nulls = TRUE\n)\n\nExpr_ewm_var(\n  com = NULL,\n  span = NULL,\n  half_life = NULL,\n  alpha = NULL,\n  adjust = TRUE,\n  bias = FALSE,\n  min_periods = 1L,\n  ignore_nulls = TRUE\n)\n</code></pre>"},{"location":"reference/#arguments_67","title":"Arguments","text":"<code>com</code> <p>Specify decay in terms of center of mass, <code>\\gamma</code>, with <code> \\alpha = \\frac{1}{1 + \\gamma} \\; \\forall \\; \\gamma \\geq 0 </code></p> <code>span</code> <p>Specify decay in terms of span, <code>\\theta</code>, with <code>\\alpha = \\frac{2}{\\theta + 1} \\; \\forall \\; \\theta \\geq 1 </code></p> <code>half_life</code> <p>Specify decay in terms of half-life, :math:<code>\u2060\\lambda\u2060</code>, with <code> \\alpha = 1 - \\exp \\left\\{ \\frac{ -\\ln(2) }{ \\lambda } \\right\\} </code> <code> \\forall \\; \\lambda &gt; 0</code></p> <code>alpha</code> <p>Specify smoothing factor alpha directly, <code>0 &lt; \\alpha \\leq 1</code>.</p> <code>adjust</code> <p>Divide by decaying adjustment factor in beginning periods to account for imbalance in relative weightings</p> <ul> <li><p>When <code>adjust=TRUE</code> the EW function is calculated using weights <code>w_i = (1 - \\alpha)^i </code></p></li> <li><p>When <code>adjust=FALSE</code> the EW function is calculated recursively by <code> y_0 = x_0 \\\\ y_t = (1 - \\alpha)y_{t - 1} + \\alpha x_t </code></p></li> </ul> <code>min_periods</code> <p>Minimum number of observations in window required to have a value (otherwise result is null).</p> <code>ignore_nulls</code> <p>ignore_nulls Ignore missing values when calculating weights.</p> <ul> <li><p>When <code>ignore_nulls=FALSE</code> (default), weights are based on absolute positions. For example, the weights of :math:<code>x_0</code> and :math:<code>x_2</code> used in calculating the final weighted average of <code>[</code> <code>x_0</code>, None, <code>x_2</code>\\<code>\u2060]\u2060</code> are <code>1-\\alpha)^2</code> and <code>1</code> if <code>adjust=TRUE</code>, and <code>(1-\\alpha)^2</code> and <code>\\alpha</code> if <code>adjust=FALSE</code>.</p></li> <li><p>When <code>ignore_nulls=TRUE</code>, weights are based on relative positions. For example, the weights of <code>x_0</code> and <code>x_2</code> used in calculating the final weighted average of <code>[</code> <code>x_0</code>, None, <code>x_2</code><code>\u2060]\u2060</code> are <code>1-\\alpha</code> and <code>1</code> if <code>adjust=TRUE</code>, and <code>1-\\alpha</code> and <code>\\alpha</code> if <code>adjust=FALSE</code>.</p></li> </ul> <code>bias</code> <p>When bias=FALSE', apply a correction to make the estimate statistically unbiased.</p>"},{"location":"reference/#format_60","title":"Format","text":"<p>Method</p>"},{"location":"reference/#value_113","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_109","title":"Examples","text":"<pre><code>pl$DataFrame(a = 1:3)$select(pl$col(\"a\")$ewm_mean(com=1))\npl$DataFrame(a = 1:3)$select(pl$col(\"a\")$ewm_std(com=1))\npl$DataFrame(a = 1:3)$select(pl$col(\"a\")$ewm_std(com=1))\n</code></pre>"},{"location":"reference/#expr-exclude","title":"Expr exclude","text":""},{"location":"reference/#description_129","title":"Description","text":"<p>You may also use regexes in the exclude list. They must start with <code>^</code> and end with <code>$</code>.</p>"},{"location":"reference/#usage_98","title":"Usage","text":"<pre><code>Expr_exclude(columns)\n</code></pre>"},{"location":"reference/#arguments_68","title":"Arguments","text":"<code>columns</code> <p>given param type:</p> <ul> <li><p>string: exclude name of column or exclude regex starting with ^and ending with$</p></li> <li><p>character vector: exclude all these column names, no regex allowed</p></li> <li><p>DataType: Exclude any of this DataType</p></li> <li><p>List(DataType): Excldue any of these DataType(s)</p></li> </ul>"},{"location":"reference/#value_114","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_110","title":"Examples","text":"<pre><code> #make DataFrame\ndf = pl$DataFrame(iris)\n#by name(s)\ndf$select(pl$all()$exclude(\"Species\"))\n#by type\ndf$select(pl$all()$exclude(pl$Categorical))\ndf$select(pl$all()$exclude(list(pl$Categorical,pl$Float64)))\n#by regex\ndf$select(pl$all()$exclude(\"^Sepal.*$\"))\n</code></pre>"},{"location":"reference/#expr-exp","title":"Expr exp","text":""},{"location":"reference/#description_130","title":"Description","text":"<p>Compute the exponential, element-wise.</p>"},{"location":"reference/#usage_99","title":"Usage","text":"<pre><code>Expr_exp\n</code></pre>"},{"location":"reference/#format_61","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_115","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_111","title":"Examples","text":"<pre><code>log10123 = suppressWarnings(log(-1:3))\nall.equal(\npl$DataFrame(list(a = log10123))$select(pl$col(\"a\")$exp())$as_data_frame()$a,\nexp(1)^log10123\n)\n</code></pre>"},{"location":"reference/#expr-explode","title":"Expr explode","text":""},{"location":"reference/#description_131","title":"Description","text":"<p>This means that every item is expanded to a new row.</p> <p>( flatten is an alias for explode )</p>"},{"location":"reference/#usage_100","title":"Usage","text":"<pre><code>Expr_explode\n\nExpr_flatten\n</code></pre>"},{"location":"reference/#format_62","title":"Format","text":"<p>a method</p> <p>a method</p>"},{"location":"reference/#details_34","title":"Details","text":"<p>explode/flatten does not support categorical</p>"},{"location":"reference/#value_116","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_112","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=letters))$select(pl$col(\"a\")$explode()$take(0:5))\nlisted_group_df =  pl$DataFrame(iris[c(1:3,51:53),])$groupby(\"Species\")$agg(pl$all())\nprint(listed_group_df)\nvectors_df = listed_group_df$select(\npl$col(c(\"Sepal.Width\",\"Sepal.Length\"))$explode()\n)\nprint(vectors_df)\n</code></pre>"},{"location":"reference/#expr-extend-constant","title":"Expr extend constant","text":""},{"location":"reference/#description_132","title":"Description","text":"<p>Extend the Series with given number of values.</p>"},{"location":"reference/#usage_101","title":"Usage","text":"<pre><code>Expr_extend_constant(value, n)\n</code></pre>"},{"location":"reference/#arguments_69","title":"Arguments","text":"<code>value</code> <p>The value to extend the Series with. This value may be None to fill with nulls.</p> <code>n</code> <p>The number of values to extend.</p>"},{"location":"reference/#format_63","title":"Format","text":"<p>Method</p>"},{"location":"reference/#value_117","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_113","title":"Examples","text":"<pre><code>pl$select(\npl$lit(c(\"5\",\"Bob_is_not_a_number\"))\n$cast(pl$dtypes$UInt64, strict = FALSE)\n$extend_constant(10.1, 2)\n)\npl$select(\npl$lit(c(\"5\",\"Bob_is_not_a_number\"))\n$cast(pl$dtypes$Utf8, strict = FALSE)\n$extend_constant(\"chuchu\", 2)\n)\n</code></pre>"},{"location":"reference/#expr-extend-expr","title":"Expr extend expr","text":""},{"location":"reference/#description_133","title":"Description","text":"<p>Extend the Series with a expression repeated a number of times</p>"},{"location":"reference/#usage_102","title":"Usage","text":"<pre><code>Expr_extend_expr(value, n)\n</code></pre>"},{"location":"reference/#arguments_70","title":"Arguments","text":"<code>value</code> <p>The expr to extend the Series with. This value may be None to fill with nulls.</p> <code>n</code> <p>The number of values to extend.</p>"},{"location":"reference/#format_64","title":"Format","text":"<p>Method</p>"},{"location":"reference/#value_118","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_114","title":"Examples","text":"<pre><code>pl$select(\npl$lit(c(\"5\",\"Bob_is_not_a_number\"))\n$cast(pl$dtypes$UInt64, strict = FALSE)\n$extend_expr(10.1, 2)\n)\npl$select(\npl$lit(c(\"5\",\"Bob_is_not_a_number\"))\n$cast(pl$dtypes$Utf8, strict = FALSE)\n$extend_expr(\"chuchu\", 2)\n)\n</code></pre>"},{"location":"reference/#expr-fill-nan","title":"Expr fill nan","text":""},{"location":"reference/#description_134","title":"Description","text":"<p>Fill missing values with last seen values.</p>"},{"location":"reference/#usage_103","title":"Usage","text":"<pre><code>Expr_fill_nan(expr = NULL)\n</code></pre>"},{"location":"reference/#arguments_71","title":"Arguments","text":"<code>expr</code> <p>Expr or into Expr, value to fill NaNs with</p>"},{"location":"reference/#format_65","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_35","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_119","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_115","title":"Examples","text":"<pre><code>l = list(a=c(1,NaN,NaN,3))\npl$DataFrame(l)$select(\npl$col(\"a\")$fill_nan()$alias(\"fill_default\"),\npl$col(\"a\")$fill_nan(pl$lit(NA))$alias(\"fill_NA\"), #same as default\npl$col(\"a\")$fill_nan(2)$alias(\"fill_float2\"),\npl$col(\"a\")$fill_nan(\"hej\")$alias(\"fill_str\") #implicit cast to Utf8\n)$to_list()\n</code></pre>"},{"location":"reference/#expr-fill-null","title":"Expr fill null","text":""},{"location":"reference/#description_135","title":"Description","text":"<p>Shift the values by value or as strategy.</p>"},{"location":"reference/#usage_104","title":"Usage","text":"<pre><code>Expr_fill_null(value = NULL, strategy = NULL, limit = NULL)\n</code></pre>"},{"location":"reference/#arguments_72","title":"Arguments","text":"<code>value</code> <p>Expr or <code>\u2060Into&lt;Expr&gt;\u2060</code> to fill Null values with</p> <code>strategy</code> <p>default NULL else 'forward', 'backward', 'min', 'max', 'mean', 'zero', 'one'</p> <code>limit</code> <p>Number of consecutive null values to fill when using the 'forward' or 'backward' strategy.</p>"},{"location":"reference/#format_66","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_36","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_120","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_116","title":"Examples","text":"<pre><code>pl$select(\npl$lit(0:3)$shift_and_fill(-2, fill_value = 42)$alias(\"shift-2\"),\npl$lit(0:3)$shift_and_fill(2, fill_value = pl$lit(42)/2)$alias(\"shift+2\")\n)\n</code></pre>"},{"location":"reference/#expr-filter","title":"Expr filter","text":""},{"location":"reference/#description_136","title":"Description","text":"<p>Mostly useful in an aggregation context. If you want to filter on a DataFrame level, use <code>LazyFrame.filter</code>.</p> <p>where() is an alias for pl$filter</p>"},{"location":"reference/#usage_105","title":"Usage","text":"<pre><code>Expr_filter(predicate)\n\nExpr_where(predicate)\n</code></pre>"},{"location":"reference/#arguments_73","title":"Arguments","text":"<code>predicate</code> <p>Expr or something <code>\u2060Into&lt;Expr&gt;\u2060</code>. Should be a boolean expression.</p>"},{"location":"reference/#format_67","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_121","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_117","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(\ngroup_col =  c(\"g1\", \"g1\", \"g2\"),\nb = c(1, 2, 3)\n))\ndf$groupby(\"group_col\")$agg(\npl$col(\"b\")$filter(pl$col(\"b\") &lt; 2)$sum()$alias(\"lt\"),\npl$col(\"b\")$filter(pl$col(\"b\") &gt;= 2)$sum()$alias(\"gte\")\n)\n</code></pre>"},{"location":"reference/#expr-first","title":"Expr first","text":""},{"location":"reference/#description_137","title":"Description","text":"<p>Get the first value. Similar to R head(x,1)</p>"},{"location":"reference/#usage_106","title":"Usage","text":"<pre><code>Expr_first\n</code></pre>"},{"location":"reference/#format_68","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_122","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_118","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,2,3)))$select(pl$col(\"x\")$first())\n</code></pre>"},{"location":"reference/#expr-floor","title":"Expr floor","text":""},{"location":"reference/#description_138","title":"Description","text":"<p>Rounds down to the nearest integer value. Only works on floating point Series.</p>"},{"location":"reference/#usage_107","title":"Usage","text":"<pre><code>Expr_floor\n</code></pre>"},{"location":"reference/#format_69","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_123","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_119","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(0.33, 0.5, 1.02, 1.5, NaN , NA, Inf, -Inf)\n))$select(\npl$col(\"a\")$floor()\n)\n</code></pre>"},{"location":"reference/#expr-forward-fill","title":"Expr forward fill","text":""},{"location":"reference/#description_139","title":"Description","text":"<p>Fill missing values with last seen values.</p>"},{"location":"reference/#usage_108","title":"Usage","text":"<pre><code>Expr_forward_fill(limit = NULL)\n</code></pre>"},{"location":"reference/#arguments_74","title":"Arguments","text":"<code>limit</code> <p>Expr or <code>\u2060Into&lt;Expr&gt;\u2060</code> The number of consecutive null values to forward fill.</p>"},{"location":"reference/#format_70","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_37","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_124","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_120","title":"Examples","text":"<pre><code>l = list(a=c(1L,rep(NA_integer_,3L),10))\npl$DataFrame(l)$select(\npl$col(\"a\")$forward_fill()$alias(\"ff_null\"),\npl$col(\"a\")$forward_fill(limit = 0)$alias(\"ff_l0\"),\npl$col(\"a\")$forward_fill(limit = 1)$alias(\"ff_l1\")\n)$to_list()\n</code></pre>"},{"location":"reference/#expr-gt-eq","title":"Expr gt eq","text":""},{"location":"reference/#description_140","title":"Description","text":"<p>gt_eq method and operator</p>"},{"location":"reference/#usage_109","title":"Usage","text":"<pre><code>Expr_gt_eq(other)\n\n## S3 method for class 'Expr'\ne1 &gt;= e2\n</code></pre>"},{"location":"reference/#arguments_75","title":"Arguments","text":"<code>other</code> <p>literal or Robj which can become a literal</p> <code>e1</code> <p>lhs Expr</p> <code>e2</code> <p>rhs Expr or anything which can become a literal Expression</p>"},{"location":"reference/#details_38","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_125","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/#examples_121","title":"Examples","text":"<pre><code>#' #three syntaxes same result\npl$lit(2) &gt;= 2\npl$lit(2) &gt;=  pl$lit(2)\npl$lit(2)$gt_eq(pl$lit(2))\n</code></pre>"},{"location":"reference/#expr-gt","title":"Expr gt","text":""},{"location":"reference/#description_141","title":"Description","text":"<p>gt method and operator</p>"},{"location":"reference/#usage_110","title":"Usage","text":"<pre><code>Expr_gt(other)\n\n## S3 method for class 'Expr'\ne1 &gt; e2\n</code></pre>"},{"location":"reference/#arguments_76","title":"Arguments","text":"<code>other</code> <p>literal or Robj which can become a literal</p> <code>e1</code> <p>lhs Expr</p> <code>e2</code> <p>rhs Expr or anything which can become a literal Expression</p>"},{"location":"reference/#details_39","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_126","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/#examples_122","title":"Examples","text":"<pre><code>#' #three syntaxes same result\npl$lit(2) &gt; 1\npl$lit(2) &gt; pl$lit(1)\npl$lit(2)$gt(pl$lit(1))\n</code></pre>"},{"location":"reference/#expr-hash","title":"Expr hash","text":""},{"location":"reference/#description_142","title":"Description","text":"<p>Hash the elements in the selection. The hash value is of type <code>UInt64</code>.</p>"},{"location":"reference/#usage_111","title":"Usage","text":"<pre><code>Expr_hash(seed = 0, seed_1 = NULL, seed_2 = NULL, seed_3 = NULL)\n</code></pre>"},{"location":"reference/#arguments_77","title":"Arguments","text":"<code>seed</code> <p>Random seed parameter. Defaults to 0.</p> <code>seed_1</code> <p>Random seed parameter. Defaults to arg seed.</p> <code>seed_2</code> <p>Random seed parameter. Defaults to arg seed.</p> <code>seed_3</code> <p>Random seed parameter. Defaults to arg seed. The column will be coerced to UInt32. Give this dtype to make the coercion a no-op.</p>"},{"location":"reference/#value_127","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_123","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris)\ndf$select(pl$all()$head(2)$hash(1234)$cast(pl$Utf8))$to_list()\n</code></pre>"},{"location":"reference/#expr-head","title":"Expr head","text":""},{"location":"reference/#description_143","title":"Description","text":"<p>Get the head n elements. Similar to R head(x)</p>"},{"location":"reference/#usage_112","title":"Usage","text":"<pre><code>Expr_head(n = 10)\n</code></pre>"},{"location":"reference/#arguments_78","title":"Arguments","text":"<code>n</code> <p>numeric number of elements to select from head</p>"},{"location":"reference/#value_128","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_124","title":"Examples","text":"<pre><code>#get 3 first elements\npl$DataFrame(list(x=1:11))$select(pl$col(\"x\")$head(3))\n</code></pre>"},{"location":"reference/#expr-inspect","title":"Expr inspect","text":""},{"location":"reference/#description_144","title":"Description","text":"<p>Print the value that this expression evaluates to and pass on the value. The printing will happen when the expression evaluates, not when it is formed.</p>"},{"location":"reference/#usage_113","title":"Usage","text":"<pre><code>Expr_inspect(fmt = \"{}\")\n</code></pre>"},{"location":"reference/#arguments_79","title":"Arguments","text":"<code>fmt</code> <p>format string, should contain one set of <code>{}</code> where object will be printed This formatting mimics python \"string\".format() use in pypolars. The string can contain any thing but should have exactly one set of curly bracket .</p>"},{"location":"reference/#value_129","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_125","title":"Examples","text":"<pre><code>pl$select(pl$lit(1:5)$inspect(\n\"before dropping half the column it was:{}and not it is dropped\")$head(2)\n)\n</code></pre>"},{"location":"reference/#expr-interpolate","title":"Expr interpolate","text":""},{"location":"reference/#description_145","title":"Description","text":"<p>Fill nulls with linear interpolation over missing values. Can also be used to regrid data to a new grid - see examples below.</p>"},{"location":"reference/#usage_114","title":"Usage","text":"<pre><code>Expr_interpolate(method = \"linear\")\n</code></pre>"},{"location":"reference/#arguments_80","title":"Arguments","text":"<code>method</code> <p>string 'linear' or 'nearest', default \"linear\"</p>"},{"location":"reference/#value_130","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_126","title":"Examples","text":"<pre><code>pl$select(pl$lit(c(1,NA,4,NA,100,NaN,150))$interpolate())\n#x, y interpolation over a grid\ndf_original_grid = pl$DataFrame(list(\ngrid_points = c(1, 3, 10),\nvalues = c(2.0, 6.0, 20.0)\n))\ndf_new_grid = pl$DataFrame(list(grid_points = (1:10)*1.0))\n# Interpolate from this to the new grid\ndf_new_grid$join(\ndf_original_grid, on=\"grid_points\", how=\"left\"\n)$with_columns(pl$col(\"values\")$interpolate())\n</code></pre>"},{"location":"reference/#expr-is-between","title":"Expr is between","text":""},{"location":"reference/#description_146","title":"Description","text":"<p>Check if this expression is between start and end.</p>"},{"location":"reference/#usage_115","title":"Usage","text":"<pre><code>Expr_is_between(start, end, include_bounds = FALSE)\n</code></pre>"},{"location":"reference/#arguments_81","title":"Arguments","text":"<code>start</code> <p>Lower bound as primitive or datetime</p> <code>end</code> <p>Lower bound as primitive or datetime</p> <code>include_bounds</code> <p>bool vector or scalar: FALSE: Exclude both start and end (default). TRUE: Include both start and end. c(FALSE, FALSE): Exclude start and exclude end. c(TRUE, TRUE): Include start and include end. c(FALSE, TRUE): Exclude start and include end. c(TRUE, FALSE): Include start and exclude end.</p>"},{"location":"reference/#details_40","title":"Details","text":"<p>alias the column to 'in_between' This function is equivalent to a combination of &lt; &lt;= &gt;= and the &amp;-and operator.</p>"},{"location":"reference/#value_131","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_127","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(num = 1:5))\ndf$select(pl$col(\"num\")$is_between(2,4))\ndf$select(pl$col(\"num\")$is_between(2,4,TRUE))\ndf$select(pl$col(\"num\")$is_between(2,4,c(FALSE, TRUE)))\n#start end can be a vector/expr with same length as column\ndf$select(pl$col(\"num\")$is_between(c(0,2,3,3,3),6))\n</code></pre>"},{"location":"reference/#expr-is-duplicated","title":"Expr is duplicated","text":""},{"location":"reference/#description_147","title":"Description","text":"<p>Get mask of duplicated values.</p>"},{"location":"reference/#usage_116","title":"Usage","text":"<pre><code>Expr_is_duplicated\n</code></pre>"},{"location":"reference/#format_71","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_41","title":"Details","text":"<p>is_duplicated is the opposite of <code>is_unique()</code> Looking for R like <code>duplicated()</code>?, use <code>some_expr$is_first()$is_not()</code></p>"},{"location":"reference/#value_132","title":"Value","text":"<p>Expr (boolean)</p>"},{"location":"reference/#examples_128","title":"Examples","text":"<pre><code>v = c(1,1,2,2,3,NA,NaN,Inf)\nall.equal(\npl$select(\npl$lit(v)$is_unique()$alias(\"is_unique\"),\npl$lit(v)$is_first()$alias(\"is_first\"),\npl$lit(v)$is_duplicated()$alias(\"is_duplicated\"),\npl$lit(v)$is_first()$is_not()$alias(\"R_duplicated\")\n)$to_list(),\nlist(\nis_unique = !v %in% v[duplicated(v)],\nis_first  = !duplicated(v),\nis_duplicated = v %in% v[duplicated(v)],\nR_duplicated = duplicated(v)\n)\n)\n</code></pre>"},{"location":"reference/#expr-is-finite","title":"Expr is finite","text":""},{"location":"reference/#description_148","title":"Description","text":"<p>Returns a boolean output indicating which values are finite.</p>"},{"location":"reference/#usage_117","title":"Usage","text":"<pre><code>Expr_is_finite\n</code></pre>"},{"location":"reference/#format_72","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_42","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_133","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_129","title":"Examples","text":"<pre><code>pl$DataFrame(list(alice=c(0,NaN,NA,Inf,-Inf)))$select(pl$col(\"alice\")$is_finite())\n</code></pre>"},{"location":"reference/#expr-is-first","title":"Expr is first","text":""},{"location":"reference/#description_149","title":"Description","text":"<p>Get a mask of the first unique value.</p>"},{"location":"reference/#usage_118","title":"Usage","text":"<pre><code>Expr_is_first\n</code></pre>"},{"location":"reference/#format_73","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_134","title":"Value","text":"<p>Expr (boolean)</p>"},{"location":"reference/#examples_130","title":"Examples","text":"<pre><code>v = c(1,1,2,2,3,NA,NaN,Inf)\nall.equal(\npl$select(\npl$lit(v)$is_unique()$alias(\"is_unique\"),\npl$lit(v)$is_first()$alias(\"is_first\"),\npl$lit(v)$is_duplicated()$alias(\"is_duplicated\"),\npl$lit(v)$is_first()$is_not()$alias(\"R_duplicated\")\n)$to_list(),\nlist(\nis_unique = !v %in% v[duplicated(v)],\nis_first  = !duplicated(v),\nis_duplicated = v %in% v[duplicated(v)],\nR_duplicated = duplicated(v)\n)\n)\n</code></pre>"},{"location":"reference/#expr-is-in","title":"Expr is in","text":""},{"location":"reference/#description_150","title":"Description","text":"<p>combine to boolean expresions with similar to <code>%in%</code></p>"},{"location":"reference/#usage_119","title":"Usage","text":"<pre><code>Expr_is_in(other)\n</code></pre>"},{"location":"reference/#arguments_82","title":"Arguments","text":"<code>other</code> <p>literal or Robj which can become a literal</p>"},{"location":"reference/#format_74","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_135","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_131","title":"Examples","text":"<pre><code>#R Na_integer -&gt; polars Null(Int32) is in polars Null(Int32)\npl$DataFrame(list(a=c(1:4,NA_integer_)))$select(\npl$col(\"a\")$is_in(pl$lit(NA_real_))\n)$as_data_frame()[[1L]]\n</code></pre>"},{"location":"reference/#expr-is-infinite","title":"Expr is infinite","text":""},{"location":"reference/#description_151","title":"Description","text":"<p>Returns a boolean output indicating which values are infinite.</p>"},{"location":"reference/#usage_120","title":"Usage","text":"<pre><code>Expr_is_infinite\n</code></pre>"},{"location":"reference/#format_75","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_43","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_136","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_132","title":"Examples","text":"<pre><code>pl$DataFrame(list(alice=c(0,NaN,NA,Inf,-Inf)))$select(pl$col(\"alice\")$is_infinite())\n</code></pre>"},{"location":"reference/#expr-is-nan","title":"Expr is nan","text":""},{"location":"reference/#description_152","title":"Description","text":"<p>Returns a boolean Series indicating which values are NaN.</p>"},{"location":"reference/#usage_121","title":"Usage","text":"<pre><code>Expr_is_nan\n</code></pre>"},{"location":"reference/#format_76","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_44","title":"Details","text":"<p>Floating point NaN's are a different flag from Null(polars) which is the same as NA_real_(R). See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_137","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_133","title":"Examples","text":"<pre><code>pl$DataFrame(list(alice=c(0,NaN,NA,Inf,-Inf)))$select(pl$col(\"alice\")$is_nan())\n</code></pre>"},{"location":"reference/#expr-is-not-nan","title":"Expr is not nan","text":""},{"location":"reference/#description_153","title":"Description","text":"<p>Returns a boolean Series indicating which values are not NaN.</p>"},{"location":"reference/#usage_122","title":"Usage","text":"<pre><code>Expr_is_not_nan\n</code></pre>"},{"location":"reference/#format_77","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_45","title":"Details","text":"<p>Floating point NaN's are a different flag from Null(polars) which is the same as NA_real_(R).</p> <p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_138","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_134","title":"Examples","text":"<pre><code>pl$DataFrame(list(alice=c(0,NaN,NA,Inf,-Inf)))$select(pl$col(\"alice\")$is_not_nan())\n</code></pre>"},{"location":"reference/#expr-is-not-null","title":"Expr is not null","text":""},{"location":"reference/#description_154","title":"Description","text":"<p>Returns a boolean Series indicating which values are not null. Similar to R syntax !is.na(x) null polars about the same as R NA</p>"},{"location":"reference/#usage_123","title":"Usage","text":"<pre><code>Expr_is_not_null\n</code></pre>"},{"location":"reference/#format_78","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#details_46","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_139","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_135","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NA,3)))$select(pl$col(\"x\")$is_not_null())\n</code></pre>"},{"location":"reference/#expr-is-not","title":"Expr is not","text":""},{"location":"reference/#description_155","title":"Description","text":"<p>not method and operator</p>"},{"location":"reference/#usage_124","title":"Usage","text":"<pre><code>Expr_is_not(other)\n\n## S3 method for class 'Expr'\n!x\n</code></pre>"},{"location":"reference/#arguments_83","title":"Arguments","text":"<code>x</code> <p>Expr</p> <code>other</code> <p>literal or Robj which can become a literal</p>"},{"location":"reference/#format_79","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_140","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/#examples_136","title":"Examples","text":"<pre><code>#two syntaxes same result\npl$lit(TRUE)$is_not()\n!pl$lit(TRUE)\n</code></pre>"},{"location":"reference/#expr-is-null","title":"Expr is null","text":""},{"location":"reference/#description_156","title":"Description","text":"<p>Returns a boolean Series indicating which values are null. Similar to R syntax is.na(x) null polars about the same as R NA</p>"},{"location":"reference/#usage_125","title":"Usage","text":"<pre><code>Expr_is_null\n</code></pre>"},{"location":"reference/#format_80","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#details_47","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_141","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_137","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NA,3)))$select(pl$col(\"x\")$is_null())\n</code></pre>"},{"location":"reference/#expr-is-unique","title":"Expr is unique","text":""},{"location":"reference/#description_157","title":"Description","text":"<p>Get mask of unique values</p>"},{"location":"reference/#usage_126","title":"Usage","text":"<pre><code>Expr_is_unique\n</code></pre>"},{"location":"reference/#format_81","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_142","title":"Value","text":"<p>Expr (boolean)</p>"},{"location":"reference/#examples_138","title":"Examples","text":"<pre><code>v = c(1,1,2,2,3,NA,NaN,Inf)\nall.equal(\npl$select(\npl$lit(v)$is_unique()$alias(\"is_unique\"),\npl$lit(v)$is_first()$alias(\"is_first\"),\npl$lit(v)$is_duplicated()$alias(\"is_duplicated\"),\npl$lit(v)$is_first()$is_not()$alias(\"R_duplicated\")\n)$to_list(),\nlist(\nis_unique = !v %in% v[duplicated(v)],\nis_first  = !duplicated(v),\nis_duplicated = v %in% v[duplicated(v)],\nR_duplicated = duplicated(v)\n)\n)\n</code></pre>"},{"location":"reference/#expr-keep-name","title":"Expr keep name","text":""},{"location":"reference/#description_158","title":"Description","text":"<p>Keep the original root name of the expression.</p>"},{"location":"reference/#usage_127","title":"Usage","text":"<pre><code>Expr_keep_name\n</code></pre>"},{"location":"reference/#format_82","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_143","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_139","title":"Examples","text":"<pre><code>pl$DataFrame(list(alice=1:3))$select(pl$col(\"alice\")$alias(\"bob\")$keep_name())\n</code></pre>"},{"location":"reference/#expr-kurtosis","title":"Expr kurtosis","text":""},{"location":"reference/#description_159","title":"Description","text":"<p>Compute the kurtosis (Fisher or Pearson) of a dataset.</p>"},{"location":"reference/#usage_128","title":"Usage","text":"<pre><code>Expr_kurtosis(fisher = TRUE, bias = TRUE)\n</code></pre>"},{"location":"reference/#arguments_84","title":"Arguments","text":"<code>fisher</code> <p>bool se details</p> <code>bias</code> <p>bool, If FALSE, then the calculations are corrected for statistical bias.</p>"},{"location":"reference/#details_48","title":"Details","text":"<p>Kurtosis is the fourth central moment divided by the square of the variance. If Fisher's definition is used, then 3.0 is subtracted from the result to give 0.0 for a normal distribution. If bias is False then the kurtosis is calculated using k statistics to eliminate bias coming from biased moment estimators See scipy.stats for more information</p> <p>#' See scipy.stats for more information.</p>"},{"location":"reference/#value_144","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#references","title":"References","text":"<p>https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.kurtosis.html?highlight=kurtosis</p>"},{"location":"reference/#examples_140","title":"Examples","text":"<pre><code>df = pl$DataFrame(list( a=c(1:3,2:1)))\ndf$select(pl$col(\"a\")$kurtosis())\n</code></pre>"},{"location":"reference/#expr-last","title":"Expr last","text":""},{"location":"reference/#description_160","title":"Description","text":"<p>Get the lastvalue. Similar to R syntax tail(x,1)</p>"},{"location":"reference/#usage_129","title":"Usage","text":"<pre><code>Expr_last\n</code></pre>"},{"location":"reference/#format_83","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_145","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_141","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,2,3)))$select(pl$col(\"x\")$last())\n</code></pre>"},{"location":"reference/#expr-limit","title":"Expr limit","text":""},{"location":"reference/#description_161","title":"Description","text":"<p>Alias for Head Get the head n elements. Similar to R head(x)</p>"},{"location":"reference/#usage_130","title":"Usage","text":"<pre><code>Expr_limit(n = 10)\n</code></pre>"},{"location":"reference/#arguments_85","title":"Arguments","text":"<code>n</code> <p>numeric number of elements to select from head</p>"},{"location":"reference/#value_146","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_142","title":"Examples","text":"<pre><code>#get 3 first elements\npl$DataFrame(list(x=1:11))$select(pl$col(\"x\")$limit(3))\n</code></pre>"},{"location":"reference/#expr-list","title":"Expr list","text":""},{"location":"reference/#description_162","title":"Description","text":"<p>Aggregate to list.</p>"},{"location":"reference/#usage_131","title":"Usage","text":"<pre><code>Expr_list\n</code></pre>"},{"location":"reference/#format_84","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_49","title":"Details","text":"<p>use to_struct to wrap a DataFrame</p>"},{"location":"reference/#value_147","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_143","title":"Examples","text":"<pre><code>pl$select(pl$lit(1:4)$list(), pl$lit(c(\"a\")))\n</code></pre>"},{"location":"reference/#expr-lit-to-df","title":"Expr lit to df","text":""},{"location":"reference/#description_163","title":"Description","text":"<p>collect an expression based on literals into a DataFrame</p>"},{"location":"reference/#usage_132","title":"Usage","text":"<pre><code>Expr_lit_to_df()\n</code></pre>"},{"location":"reference/#value_148","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_144","title":"Examples","text":"<pre><code>(\npl$Series(list(1:1, 1:2, 1:3, 1:4))\n$print()\n$to_lit()\n$arr$lengths()\n$sum()\n$cast(pl$dtypes$Int8)\n$lit_to_df()\n)\n</code></pre>"},{"location":"reference/#expr-lit-to-s","title":"Expr lit to s","text":""},{"location":"reference/#description_164","title":"Description","text":"<p>collect an expression based on literals into a Series</p>"},{"location":"reference/#usage_133","title":"Usage","text":"<pre><code>Expr_lit_to_s()\n</code></pre>"},{"location":"reference/#value_149","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_145","title":"Examples","text":"<pre><code>(\npl$Series(list(1:1, 1:2, 1:3, 1:4))\n$print()\n$to_lit()\n$arr$lengths()\n$sum()\n$cast(pl$dtypes$Int8)\n$lit_to_s()\n)\n</code></pre>"},{"location":"reference/#expr-log","title":"Expr log","text":""},{"location":"reference/#description_165","title":"Description","text":"<p>Compute the base x logarithm of the input array, element-wise.</p>"},{"location":"reference/#usage_134","title":"Usage","text":"<pre><code>Expr_log(base = base::exp(1))\n</code></pre>"},{"location":"reference/#arguments_86","title":"Arguments","text":"<code>base</code> <p>numeric base value for log, default base::exp(1)</p>"},{"location":"reference/#value_150","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_146","title":"Examples","text":"<pre><code>pl$DataFrame(list(a = exp(1)^(-1:3)))$select(pl$col(\"a\")$log())\n</code></pre>"},{"location":"reference/#expr-log10","title":"Expr log10","text":""},{"location":"reference/#description_166","title":"Description","text":"<p>Compute the base 10 logarithm of the input array, element-wise.</p>"},{"location":"reference/#usage_135","title":"Usage","text":"<pre><code>Expr_log10\n</code></pre>"},{"location":"reference/#format_85","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_151","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_147","title":"Examples","text":"<pre><code>pl$DataFrame(list(a = 10^(-1:3)))$select(pl$col(\"a\")$log10())\n</code></pre>"},{"location":"reference/#expr-lt-eq","title":"Expr lt eq","text":""},{"location":"reference/#description_167","title":"Description","text":"<p>lt_eq method and operator</p>"},{"location":"reference/#usage_136","title":"Usage","text":"<pre><code>Expr_lt_eq(other)\n\n## S3 method for class 'Expr'\ne1 &lt;= e2\n</code></pre>"},{"location":"reference/#arguments_87","title":"Arguments","text":"<code>other</code> <p>literal or Robj which can become a literal</p> <code>e1</code> <p>lhs Expr</p> <code>e2</code> <p>rhs Expr or anything which can become a literal Expression</p>"},{"location":"reference/#details_50","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_152","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/#examples_148","title":"Examples","text":"<pre><code>#' #three syntaxes same result\npl$lit(2) &lt;= 2\npl$lit(2) &lt;=  pl$lit(2)\npl$lit(2)$lt_eq(pl$lit(2))\n</code></pre>"},{"location":"reference/#expr-lt","title":"Expr lt","text":""},{"location":"reference/#description_168","title":"Description","text":"<p>lt method and operator</p>"},{"location":"reference/#usage_137","title":"Usage","text":"<pre><code>Expr_lt(other)\n\n## S3 method for class 'Expr'\ne1 &lt; e2\n</code></pre>"},{"location":"reference/#arguments_88","title":"Arguments","text":"<code>other</code> <p>literal or Robj which can become a literal</p> <code>e1</code> <p>lhs Expr</p> <code>e2</code> <p>rhs Expr or anything which can become a literal Expression</p>"},{"location":"reference/#details_51","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_153","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/#examples_149","title":"Examples","text":"<pre><code>#' #three syntaxes same result\npl$lit(5) &lt; 10\npl$lit(5) &lt; pl$lit(10)\npl$lit(5)$lt(pl$lit(10))\n</code></pre>"},{"location":"reference/#expr-map-alias","title":"Expr map alias","text":""},{"location":"reference/#description_169","title":"Description","text":"<p>Rename the output of an expression by mapping a function over the root name.</p>"},{"location":"reference/#usage_138","title":"Usage","text":"<pre><code>Expr_map_alias(fun)\n</code></pre>"},{"location":"reference/#arguments_89","title":"Arguments","text":"<code>fun</code> <p>an R function which takes a string as input and return a string</p>"},{"location":"reference/#value_154","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_150","title":"Examples","text":"<pre><code>pl$DataFrame(list(alice=1:3))$select(\npl$col(\"alice\")$alias(\"joe_is_not_root\")$map_alias(\\(x) paste0(x,\"_and_bob\"))\n)\n</code></pre>"},{"location":"reference/#expr-map","title":"Expr map","text":""},{"location":"reference/#description_170","title":"Description","text":"<p>Expr_map</p>"},{"location":"reference/#usage_139","title":"Usage","text":"<pre><code>Expr_map(f, output_type = NULL, agg_list = FALSE)\n</code></pre>"},{"location":"reference/#arguments_90","title":"Arguments","text":"<code>f</code> <p>a function mapping a series</p> <code>output_type</code> <p>NULL or one of pl$dtypes$..., the output datatype, NULL is the same as input.</p> <code>agg_list</code> <p>Aggregate list. Map from vector to group in groupby context. Likely not so useful.</p>"},{"location":"reference/#details_52","title":"Details","text":"<p>user function return should be a series or any Robj convertable into a Series. In PyPolars likely return must be Series. User functions do fully support <code>browser()</code>, helpful to investigate.</p>"},{"location":"reference/#value_155","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_151","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$select(pl$col(\"Sepal.Length\")$map(\\(x) {\npaste(\"cheese\",as.character(x$to_r_vector()))\n}, pl$dtypes$Utf8))\n</code></pre>"},{"location":"reference/#expr-max","title":"Expr max","text":""},{"location":"reference/#description_171","title":"Description","text":"<p>Get maximum value.</p>"},{"location":"reference/#usage_140","title":"Usage","text":"<pre><code>Expr_max\n</code></pre>"},{"location":"reference/#format_86","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#details_53","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_156","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_152","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NA,3)))$select(pl$col(\"x\")$max() == 3) #is true\n</code></pre>"},{"location":"reference/#expr-mean","title":"Expr mean","text":""},{"location":"reference/#description_172","title":"Description","text":"<p>Get mean value.</p>"},{"location":"reference/#usage_141","title":"Usage","text":"<pre><code>Expr_mean\n</code></pre>"},{"location":"reference/#format_87","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_157","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_153","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NA,3)))$select(pl$col(\"x\")$mean()==2) #is true\n</code></pre>"},{"location":"reference/#expr-median","title":"Expr median","text":""},{"location":"reference/#description_173","title":"Description","text":"<p>Get median value.</p>"},{"location":"reference/#usage_142","title":"Usage","text":"<pre><code>Expr_median\n</code></pre>"},{"location":"reference/#format_88","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_158","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_154","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NA,2)))$select(pl$col(\"x\")$median()==1.5) #is true\n</code></pre>"},{"location":"reference/#expr-meta","title":"Expr meta","text":""},{"location":"reference/#description_174","title":"Description","text":"<p>Create an object namespace of all meta related methods. See the individual method pages for full details</p>"},{"location":"reference/#usage_143","title":"Usage","text":"<pre><code>Expr_meta()\n</code></pre>"},{"location":"reference/#value_159","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_155","title":"Examples","text":"<pre><code>#missing\n</code></pre>"},{"location":"reference/#expr-min","title":"Expr min","text":""},{"location":"reference/#description_175","title":"Description","text":"<p>Get minimum value.</p>"},{"location":"reference/#usage_144","title":"Usage","text":"<pre><code>Expr_min\n</code></pre>"},{"location":"reference/#format_89","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#details_54","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_160","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_156","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NA,3)))$select(pl$col(\"x\")$min()== 1 ) #is true\n</code></pre>"},{"location":"reference/#expr-mode","title":"Expr mode","text":""},{"location":"reference/#description_176","title":"Description","text":"<p>Compute the most occurring value(s). Can return multiple Values.</p>"},{"location":"reference/#usage_145","title":"Usage","text":"<pre><code>Expr_mode\n</code></pre>"},{"location":"reference/#format_90","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_161","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_157","title":"Examples","text":"<pre><code>df =pl$DataFrame(list(a=1:6,b = c(1L,1L,3L,3L,5L,6L), c = c(1L,1L,2L,2L,3L,3L)))\ndf$select(pl$col(\"a\")$mode())\ndf$select(pl$col(\"b\")$mode())\ndf$select(pl$col(\"c\")$mode())\n</code></pre>"},{"location":"reference/#expr-mul","title":"Expr mul","text":""},{"location":"reference/#description_177","title":"Description","text":"<p>Multiplication</p>"},{"location":"reference/#usage_146","title":"Usage","text":"<pre><code>Expr_mul(other)\n\n## S3 method for class 'Expr'\ne1 * e2\n</code></pre>"},{"location":"reference/#arguments_91","title":"Arguments","text":"<code>other</code> <p>literal or Robj which can become a literal</p> <code>e1</code> <p>lhs Expr</p> <code>e2</code> <p>rhs Expr or anything which can become a literal Expression</p>"},{"location":"reference/#value_162","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/#examples_158","title":"Examples","text":"<pre><code>#three syntaxes same result\npl$lit(5) * 10\npl$lit(5) * pl$lit(10)\npl$lit(5)$mul(pl$lit(10))\n</code></pre>"},{"location":"reference/#expr-n-unique","title":"Expr n unique","text":""},{"location":"reference/#description_178","title":"Description","text":"<p>Count number of unique values. Similar to R length(unique(x))</p>"},{"location":"reference/#usage_147","title":"Usage","text":"<pre><code>Expr_n_unique\n</code></pre>"},{"location":"reference/#format_91","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_163","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_159","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$select(pl$col(\"Species\")$n_unique())\n</code></pre>"},{"location":"reference/#expr-nan-max","title":"Expr nan max","text":""},{"location":"reference/#description_179","title":"Description","text":"<p>Get maximum value, but propagate/poison encountered <code>NaN</code> values. Get maximum value.</p>"},{"location":"reference/#usage_148","title":"Usage","text":"<pre><code>Expr_nan_max\n</code></pre>"},{"location":"reference/#format_92","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#details_55","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_164","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_160","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NaN,Inf,3)))$select(pl$col(\"x\")$nan_max()$is_nan()) #is true\n</code></pre>"},{"location":"reference/#expr-nan-min","title":"Expr nan min","text":""},{"location":"reference/#description_180","title":"Description","text":"<p>Get minimum value, but propagate/poison encountered <code>NaN</code> values.</p>"},{"location":"reference/#usage_149","title":"Usage","text":"<pre><code>Expr_nan_min\n</code></pre>"},{"location":"reference/#format_93","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#details_56","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_165","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_161","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NaN,-Inf,3)))$select(pl$col(\"x\")$nan_min()$is_nan()) #is true\n</code></pre>"},{"location":"reference/#expr-neq","title":"Expr neq","text":""},{"location":"reference/#description_181","title":"Description","text":"<p>neq method and operator</p>"},{"location":"reference/#usage_150","title":"Usage","text":"<pre><code>Expr_neq(other)\n\n## S3 method for class 'Expr'\ne1 != e2\n</code></pre>"},{"location":"reference/#arguments_92","title":"Arguments","text":"<code>other</code> <p>literal or Robj which can become a literal</p> <code>e1</code> <p>lhs Expr</p> <code>e2</code> <p>rhs Expr or anything which can become a literal Expression</p>"},{"location":"reference/#details_57","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_166","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/#examples_162","title":"Examples","text":"<pre><code>#' #three syntaxes same result\npl$lit(1) != 2\npl$lit(1) !=  pl$lit(2)\npl$lit(1)$neq(pl$lit(2))\n</code></pre>"},{"location":"reference/#expr-null-count","title":"Expr null count","text":""},{"location":"reference/#description_182","title":"Description","text":"<p>Count <code>Nulls</code></p>"},{"location":"reference/#usage_151","title":"Usage","text":"<pre><code>Expr_null_count\n</code></pre>"},{"location":"reference/#format_94","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_167","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_163","title":"Examples","text":"<pre><code>pl$select(pl$lit(c(NA,\"a\",NA,\"b\"))$null_count())\n</code></pre>"},{"location":"reference/#expr-or","title":"Expr or","text":""},{"location":"reference/#description_183","title":"Description","text":"<p>combine to boolean expresions with OR</p>"},{"location":"reference/#usage_152","title":"Usage","text":"<pre><code>Expr_or(other)\n</code></pre>"},{"location":"reference/#arguments_93","title":"Arguments","text":"<code>other</code> <p>Expr or into Expr</p>"},{"location":"reference/#format_95","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_168","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_164","title":"Examples","text":"<pre><code>pl$lit(TRUE) | FALSE\npl$lit(TRUE)$or(pl$lit(TRUE))\n</code></pre>"},{"location":"reference/#expr-over","title":"Expr over","text":""},{"location":"reference/#description_184","title":"Description","text":"<p>Apply window function over a subgroup. This is similar to a groupby + aggregation + self join. Or similar to <code>\u2060window functions in Postgres &lt;https://www.postgresql.org/docs/current/tutorial-window.html&gt;\u2060</code>_.</p>"},{"location":"reference/#usage_153","title":"Usage","text":"<pre><code>Expr_over(...)\n</code></pre>"},{"location":"reference/#arguments_94","title":"Arguments","text":"<code>...</code> <p>of strings or columns to group by</p>"},{"location":"reference/#value_169","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_165","title":"Examples","text":"<pre><code>pl$DataFrame(\nval = 1:5,\na = c(\"+\",\"+\",\"-\",\"-\",\"+\"),\nb = c(\"+\",\"-\",\"+\",\"-\",\"+\")\n)$select(\npl$col(\"val\")$count()$over(\"a\",\"b\")\n)\n</code></pre>"},{"location":"reference/#expr-pct-change","title":"Expr pct change","text":""},{"location":"reference/#description_185","title":"Description","text":"<p>Computes percentage change between values. Percentage change (as fraction) between current element and most-recent non-null element at least <code>n</code> period(s) before the current element. Computes the change from the previous row by default.</p>"},{"location":"reference/#usage_154","title":"Usage","text":"<pre><code>Expr_pct_change(n = 1)\n</code></pre>"},{"location":"reference/#arguments_95","title":"Arguments","text":"<code>n</code> <p>periods to shift for forming percent change.</p>"},{"location":"reference/#value_170","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_166","title":"Examples","text":"<pre><code>df = pl$DataFrame(list( a=c(10L, 11L, 12L, NA_integer_, 12L)))\ndf$with_column(pl$col(\"a\")$pct_change()$alias(\"pct_change\"))\n</code></pre>"},{"location":"reference/#expr-pow","title":"Expr pow","text":""},{"location":"reference/#description_186","title":"Description","text":"<p>Raise expression to the power of exponent.</p>"},{"location":"reference/#usage_155","title":"Usage","text":"<pre><code>Expr_pow(exponent)\n</code></pre>"},{"location":"reference/#arguments_96","title":"Arguments","text":"<code>exponent</code> <p>exponent</p>"},{"location":"reference/#value_171","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_167","title":"Examples","text":"<pre><code>pl$DataFrame(a= -1:3)$select(\npl$lit(2)$pow(pl$col(\"a\"))\n)$get_column(\"literal\")$to_r()== 2^(-1:3)\npl$DataFrame(a = -1:3)$select(\npl$lit(2) ^ (pl$col(\"a\"))\n)$get_column(\"literal\")$to_r()== 2^(-1:3)\n</code></pre>"},{"location":"reference/#expr-product","title":"Expr product","text":""},{"location":"reference/#description_187","title":"Description","text":"<p>Compute the product of an expression.</p>"},{"location":"reference/#usage_156","title":"Usage","text":"<pre><code>Expr_product\n</code></pre>"},{"location":"reference/#format_96","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#details_58","title":"Details","text":"<p>does not support integer32 currently, .cast() to f64 or i64 first.</p>"},{"location":"reference/#value_172","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_168","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,2,3)))$select(pl$col(\"x\")$product()==6) #is true\n</code></pre>"},{"location":"reference/#expr-quantile","title":"Expr quantile","text":""},{"location":"reference/#description_188","title":"Description","text":"<p>Get quantile value.</p>"},{"location":"reference/#usage_157","title":"Usage","text":"<pre><code>Expr_quantile(quantile, interpolation = \"nearest\")\n</code></pre>"},{"location":"reference/#arguments_97","title":"Arguments","text":"<code>quantile</code> <p>numeric/Expression 0.0 to 1.0</p> <code>interpolation</code> <p>string value from choices \"nearest\", \"higher\", \"lower\", \"midpoint\", \"linear\"</p>"},{"location":"reference/#format_97","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_59","title":"Details","text":"<p><code>Nulls</code> are ignored and <code>NaNs</code> are ranked as the largest value. For linear interpolation <code>NaN</code> poisons <code>Inf</code>, that poisons any other value.</p>"},{"location":"reference/#value_173","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_169","title":"Examples","text":"<pre><code>pl$select(pl$lit(-5:5)$quantile(.5))\n</code></pre>"},{"location":"reference/#expr-rank","title":"Expr rank","text":""},{"location":"reference/#description_189","title":"Description","text":"<p>Assign ranks to data, dealing with ties appropriately.</p>"},{"location":"reference/#usage_158","title":"Usage","text":"<pre><code>Expr_rank(method = \"average\", reverse = FALSE)\n</code></pre>"},{"location":"reference/#arguments_98","title":"Arguments","text":"<code>method</code> <p>string option 'average', 'min', 'max', 'dense', 'ordinal', 'random'</p> <p>#' The method used to assign ranks to tied elements. The following methods are available (default is 'average'):</p> <ul> <li><p>'average' : The average of the ranks that would have been assigned to all the tied values is assigned to each value.</p></li> <li><p>'min' : The minimum of the ranks that would have been assigned to all the tied values is assigned to each value. (This is also referred to as \"competition\" ranking.)</p></li> <li><p>'max' : The maximum of the ranks that would have been assigned to all the tied values is assigned to each value.</p></li> <li><p>'dense' : Like 'min', but the rank of the next highest element is assigned the rank immediately after those assigned to the tied elements.</p></li> <li><p>'ordinal' : All values are given a distinct rank, corresponding to the order that the values occur in the Series.</p></li> <li><p>'random' : Like 'ordinal', but the rank for ties is not dependent on the order that the values occur in the Series.</p></li> </ul> <code>reverse</code> <p>bool, reverse the operation</p>"},{"location":"reference/#value_174","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_170","title":"Examples","text":"<pre><code>#  The 'average' method:\ndf = pl$DataFrame(list(a = c(3, 6, 1, 1, 6)))\ndf$select(pl$col(\"a\")$rank())\n#  The 'ordinal' method:\ndf = pl$DataFrame(list(a = c(3, 6, 1, 1, 6)))\ndf$select(pl$col(\"a\")$rank(\"ordinal\"))\n</code></pre>"},{"location":"reference/#expr-rechunk","title":"Expr rechunk","text":""},{"location":"reference/#description_190","title":"Description","text":"<p>Create a single chunk of memory for this Series.</p>"},{"location":"reference/#usage_159","title":"Usage","text":"<pre><code>Expr_rechunk\n</code></pre>"},{"location":"reference/#format_98","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_60","title":"Details","text":"<p>See rechunk() explained here <code>docs_translations</code></p>"},{"location":"reference/#value_175","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_171","title":"Examples","text":"<pre><code>#get chunked lengths with/without rechunk\nseries_list = pl$DataFrame(list(a=1:3,b=4:6))$select(\npl$col(\"a\")$append(pl$col(\"b\"))$alias(\"a_chunked\"),\npl$col(\"a\")$append(pl$col(\"b\"))$rechunk()$alias(\"a_rechunked\")\n)$get_columns()\nlapply(series_list, \\(x) x$chunk_lengths())\n</code></pre>"},{"location":"reference/#expr-reinterpret","title":"Expr reinterpret","text":""},{"location":"reference/#description_191","title":"Description","text":"<p>Reinterpret the underlying bits as a signed/unsigned integer. This operation is only allowed for 64bit integers. For lower bits integers, you can safely use that cast operation.</p>"},{"location":"reference/#usage_160","title":"Usage","text":"<pre><code>Expr_reinterpret(signed = TRUE)\n</code></pre>"},{"location":"reference/#arguments_99","title":"Arguments","text":"<code>signed</code> <p>bool reinterpret into Int64 else UInt64</p>"},{"location":"reference/#value_176","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_172","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris)\ndf$select(pl$all()$head(2)$hash(1,2,3,4)$reinterpret())$as_data_frame()\n</code></pre>"},{"location":"reference/#expr-rep-extend","title":"Expr rep extend","text":""},{"location":"reference/#description_192","title":"Description","text":"<p>Extend a series with a repeated series or value.</p>"},{"location":"reference/#usage_161","title":"Usage","text":"<pre><code>Expr_rep_extend(expr, n, rechunk = TRUE, upcast = TRUE)\n</code></pre>"},{"location":"reference/#arguments_100","title":"Arguments","text":"<code>expr</code> <p>Expr or into Expr</p> <code>n</code> <p>Numeric the number of times to repeat, must be non-negative and finite</p> <code>rechunk</code> <p>bool default = TRUE, if true memory layout will be rewritten</p> <code>upcast</code> <p>bool default = TRUE, passed to self$append(), if TRUE non identical types will be casted to common super type if any. If FALSE or no common super type throw error.</p>"},{"location":"reference/#format_99","title":"Format","text":"<p>Method</p>"},{"location":"reference/#value_177","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_173","title":"Examples","text":"<pre><code>pl$select(pl$lit(c(1,2,3))$rep_extend(1:3, n = 5))\n</code></pre>"},{"location":"reference/#expr-rep","title":"Expr rep","text":""},{"location":"reference/#description_193","title":"Description","text":"<p>This expression takes input and repeats it n times and append chunk</p>"},{"location":"reference/#usage_162","title":"Usage","text":"<pre><code>Expr_rep(n, rechunk = TRUE)\n</code></pre>"},{"location":"reference/#arguments_101","title":"Arguments","text":"<code>n</code> <p>Numeric the number of times to repeat, must be non-negative and finite</p> <code>rechunk</code> <p>bool default = TRUE, if true memory layout will be rewritten</p>"},{"location":"reference/#format_100","title":"Format","text":"<p>Method</p>"},{"location":"reference/#details_61","title":"Details","text":"<p>if self$len() == 1 , has a special faster implementation, Here rechunk is not necessary, and takes no effect.</p> <p>if self$len() &gt; 1 , then the expression instructs the series to append onto itself n time and rewrite memory</p>"},{"location":"reference/#value_178","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_174","title":"Examples","text":"<pre><code>pl$select(\npl$lit(\"alice\")$rep(n = 3)\n)\npl$select(\npl$lit(1:3)$rep(n = 2)\n)\n</code></pre>"},{"location":"reference/#expr-repeat-by","title":"Expr repeat by","text":""},{"location":"reference/#description_194","title":"Description","text":"<p>Repeat the elements in this Series as specified in the given expression. The repeated elements are expanded into a <code>List</code>.</p>"},{"location":"reference/#usage_163","title":"Usage","text":"<pre><code>Expr_repeat_by(by)\n</code></pre>"},{"location":"reference/#arguments_102","title":"Arguments","text":"<code>by</code> <p>Expr Numeric column that determines how often the values will be repeated. The column will be coerced to UInt32. Give this dtype to make the coercion a no-op.</p>"},{"location":"reference/#value_179","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_175","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = c(\"x\",\"y\",\"z\"), n = c(0:2)))\ndf$select(pl$col(\"a\")$repeat_by(\"n\"))\n</code></pre>"},{"location":"reference/#expr-reshape","title":"Expr reshape","text":""},{"location":"reference/#description_195","title":"Description","text":"<p>Reshape this Expr to a flat Series or a Series of Lists.</p>"},{"location":"reference/#usage_164","title":"Usage","text":"<pre><code>Expr_reshape(dims)\n</code></pre>"},{"location":"reference/#arguments_103","title":"Arguments","text":"<code>dims</code> <p>numeric vec of the dimension sizes. If a -1 is used in any of the dimensions, that dimension is inferred.</p>"},{"location":"reference/#format_101","title":"Format","text":"<p>Method</p>"},{"location":"reference/#value_180","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_176","title":"Examples","text":"<pre><code>pl$select(pl$lit(1:12)$reshape(c(3,4)))\npl$select(pl$lit(1:12)$reshape(c(3,-1)))\n</code></pre>"},{"location":"reference/#expr-rolling-max","title":"Expr rolling max","text":""},{"location":"reference/#description_196","title":"Description","text":"<p>Apply a rolling max (moving max) over the values in this array. A window of length <code>window_size</code> will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/#usage_165","title":"Usage","text":"<pre><code>Expr_rolling_max(\n  window_size,\n  weights = NULL,\n  min_periods = NULL,\n  center = FALSE,\n  by = NULL,\n  closed = \"left\"\n)\n</code></pre>"},{"location":"reference/#arguments_104","title":"Arguments","text":"<code>window_size</code> <p>The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language:</p> <ul> <li><p>1ns (1 nanosecond)</p></li> <li><p>1us (1 microsecond)</p></li> <li><p>1ms (1 millisecond)</p></li> <li><p>1s (1 second)</p></li> <li><p>1m (1 minute)</p></li> <li><p>1h (1 hour)</p></li> <li><p>1d (1 day)</p></li> <li><p>1w (1 week)</p></li> <li><p>1mo (1 calendar month)</p></li> <li><p>1y (1 calendar year)</p></li> <li><p>1i (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set.</p></li> </ul> <code>weights</code> <p>An optional slice with the same length as the window that will be multiplied elementwise with the values in the window.</p> <code>min_periods</code> <p>The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size.</p> <code>center</code> <p>Set the labels at the center of the window</p> <code>by</code> <p>If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or <code>\u2060\"3s\u2060</code>, you must set the column that will be used to determine the windows. This column must be of dtype <code>\u2060{Date, Datetime}\u2060</code></p> <code>closed</code> <p>: 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.</p>"},{"location":"reference/#details_62","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using <code>groupby_rolling</code> this method can cache the window size computation.</p>"},{"location":"reference/#value_181","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_177","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(pl$col(\"a\")$rolling_max(window_size = 2))\n</code></pre>"},{"location":"reference/#expr-rolling-mean","title":"Expr rolling mean","text":""},{"location":"reference/#description_197","title":"Description","text":"<p>Apply a rolling mean (moving mean) over the values in this array. A window of length <code>window_size</code> will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/#usage_166","title":"Usage","text":"<pre><code>Expr_rolling_mean(\n  window_size,\n  weights = NULL,\n  min_periods = NULL,\n  center = FALSE,\n  by = NULL,\n  closed = \"left\"\n)\n</code></pre>"},{"location":"reference/#arguments_105","title":"Arguments","text":"<code>window_size</code> <p>The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language:</p> <ul> <li><p>1ns (1 nanosecond)</p></li> <li><p>1us (1 microsecond)</p></li> <li><p>1ms (1 millisecond)</p></li> <li><p>1s (1 second)</p></li> <li><p>1m (1 minute)</p></li> <li><p>1h (1 hour)</p></li> <li><p>1d (1 day)</p></li> <li><p>1w (1 week)</p></li> <li><p>1mo (1 calendar month)</p></li> <li><p>1y (1 calendar year)</p></li> <li><p>1i (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set.</p></li> </ul> <code>weights</code> <p>An optional slice with the same length as the window that will be multiplied elementwise with the values in the window.</p> <code>min_periods</code> <p>The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size.</p> <code>center</code> <p>Set the labels at the center of the window</p> <code>by</code> <p>If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or <code>\u2060\"3s\u2060</code>, you must set the column that will be used to determine the windows. This column must be of dtype <code>\u2060{Date, Datetime}\u2060</code></p> <code>closed</code> <p>: 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.</p>"},{"location":"reference/#details_63","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using <code>groupby_rolling</code> this method can cache the window size computation.</p>"},{"location":"reference/#value_182","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_178","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(pl$col(\"a\")$rolling_mean(window_size = 2))\n</code></pre>"},{"location":"reference/#expr-rolling-median","title":"Expr rolling median","text":""},{"location":"reference/#description_198","title":"Description","text":"<p>Apply a rolling median (moving median) over the values in this array. A window of length <code>window_size</code> will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/#usage_167","title":"Usage","text":"<pre><code>Expr_rolling_median(\n  window_size,\n  weights = NULL,\n  min_periods = NULL,\n  center = FALSE,\n  by = NULL,\n  closed = \"left\"\n)\n</code></pre>"},{"location":"reference/#arguments_106","title":"Arguments","text":"<code>window_size</code> <p>The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language:</p> <ul> <li><p>1ns (1 nanosecond)</p></li> <li><p>1us (1 microsecond)</p></li> <li><p>1ms (1 millisecond)</p></li> <li><p>1s (1 second)</p></li> <li><p>1m (1 minute)</p></li> <li><p>1h (1 hour)</p></li> <li><p>1d (1 day)</p></li> <li><p>1w (1 week)</p></li> <li><p>1mo (1 calendar month)</p></li> <li><p>1y (1 calendar year)</p></li> <li><p>1i (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set.</p></li> </ul> <code>weights</code> <p>An optional slice with the same length as the window that will be multiplied elementwise with the values in the window.</p> <code>min_periods</code> <p>The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size.</p> <code>center</code> <p>Set the labels at the center of the window</p> <code>by</code> <p>If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or <code>\u2060\"3s\u2060</code>, you must set the column that will be used to determine the windows. This column must be of dtype <code>\u2060{Date, Datetime}\u2060</code></p> <code>closed</code> <p>: 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.</p>"},{"location":"reference/#details_64","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using <code>groupby_rolling</code> this method can cache the window size computation.</p>"},{"location":"reference/#value_183","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_179","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(pl$col(\"a\")$rolling_median(window_size = 2))\n</code></pre>"},{"location":"reference/#expr-rolling-min","title":"Expr rolling min","text":""},{"location":"reference/#description_199","title":"Description","text":"<p>Apply a rolling min (moving min) over the values in this array. A window of length <code>window_size</code> will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/#usage_168","title":"Usage","text":"<pre><code>Expr_rolling_min(\n  window_size,\n  weights = NULL,\n  min_periods = NULL,\n  center = FALSE,\n  by = NULL,\n  closed = \"left\"\n)\n</code></pre>"},{"location":"reference/#arguments_107","title":"Arguments","text":"<code>window_size</code> <p>The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language:</p> <ul> <li><p>1ns (1 nanosecond)</p></li> <li><p>1us (1 microsecond)</p></li> <li><p>1ms (1 millisecond)</p></li> <li><p>1s (1 second)</p></li> <li><p>1m (1 minute)</p></li> <li><p>1h (1 hour)</p></li> <li><p>1d (1 day)</p></li> <li><p>1w (1 week)</p></li> <li><p>1mo (1 calendar month)</p></li> <li><p>1y (1 calendar year)</p></li> <li><p>1i (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set.</p></li> </ul> <code>weights</code> <p>An optional slice with the same length as the window that will be multiplied elementwise with the values in the window.</p> <code>min_periods</code> <p>The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size.</p> <code>center</code> <p>Set the labels at the center of the window</p> <code>by</code> <p>If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or <code>\u2060\"3s\u2060</code>, you must set the column that will be used to determine the windows. This column must be of dtype <code>\u2060{Date, Datetime}\u2060</code></p> <code>closed</code> <p>: 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.</p>"},{"location":"reference/#details_65","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using <code>groupby_rolling</code> this method can cache the window size computation.</p>"},{"location":"reference/#value_184","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_180","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(pl$col(\"a\")$rolling_min(window_size = 2))\n</code></pre>"},{"location":"reference/#expr-rolling-quantile","title":"Expr rolling quantile","text":""},{"location":"reference/#description_200","title":"Description","text":"<p>Apply a rolling quantile (moving quantile) over the values in this array. A window of length <code>window_size</code> will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/#usage_169","title":"Usage","text":"<pre><code>Expr_rolling_quantile(\n  quantile,\n  interpolation = \"nearest\",\n  window_size,\n  weights = NULL,\n  min_periods = NULL,\n  center = FALSE,\n  by = NULL,\n  closed = \"left\"\n)\n</code></pre>"},{"location":"reference/#arguments_108","title":"Arguments","text":"<code>quantile</code> <p>Quantile between 0.0 and 1.0.</p> <code>interpolation</code> <p>choice c('nearest', 'higher', 'lower', 'midpoint', 'linear')</p> <code>window_size</code> <p>The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language:</p> <ul> <li><p>1ns (1 nanosecond)</p></li> <li><p>1us (1 microsecond)</p></li> <li><p>1ms (1 millisecond)</p></li> <li><p>1s (1 second)</p></li> <li><p>1m (1 minute)</p></li> <li><p>1h (1 hour)</p></li> <li><p>1d (1 day)</p></li> <li><p>1w (1 week)</p></li> <li><p>1mo (1 calendar month)</p></li> <li><p>1y (1 calendar year)</p></li> <li><p>1i (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set.</p></li> </ul> <code>weights</code> <p>An optional slice with the same length as the window that will be multiplied elementwise with the values in the window.</p> <code>min_periods</code> <p>The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size.</p> <code>center</code> <p>Set the labels at the center of the window</p> <code>by</code> <p>If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or <code>\u2060\"3s\u2060</code>, you must set the column that will be used to determine the windows. This column must be of dtype <code>\u2060{Date, Datetime}\u2060</code></p> <code>closed</code> <p>: 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.</p>"},{"location":"reference/#details_66","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using <code>groupby_rolling</code> this method can cache the window size computation.</p>"},{"location":"reference/#value_185","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_181","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(\npl$col(\"a\")$rolling_quantile(window_size = 2, quantile = .5)\n)\n</code></pre>"},{"location":"reference/#expr-rolling-skew","title":"Expr rolling skew","text":""},{"location":"reference/#description_201","title":"Description","text":"<p>Compute a rolling skew.</p>"},{"location":"reference/#usage_170","title":"Usage","text":"<pre><code>Expr_rolling_skew(window_size, bias = TRUE)\n</code></pre>"},{"location":"reference/#arguments_109","title":"Arguments","text":"<code>window_size</code> <p>integerish, Size of the rolling window</p> <code>bias</code> <p>bool default = TRUE, If False, then the calculations are corrected for statistical bias.</p>"},{"location":"reference/#details_67","title":"Details","text":"<p>Extra comments copied from rust-polars_0.25.1 Compute the sample skewness of a data set.</p> <p>For normally distributed data, the skewness should be about zero. For uni-modal continuous distributions, a skewness value greater than zero means that there is more weight in the right tail of the distribution. The function <code>skewtest</code> can be used to determine if the skewness value is close enough to zero, statistically speaking. see: https://github.com/scipy/scipy/blob/47bb6febaa10658c72962b9615d5d5aa2513fa3a/scipy/stats/stats.py#L1024</p>"},{"location":"reference/#value_186","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_182","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=iris$Sepal.Length))$select(pl$col(\"a\")$rolling_skew(window_size = 4 )$head(10))\n</code></pre>"},{"location":"reference/#expr-rolling-std","title":"Expr rolling std","text":""},{"location":"reference/#description_202","title":"Description","text":"<p>Apply a rolling std (moving std) over the values in this array. A window of length <code>window_size</code> will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/#usage_171","title":"Usage","text":"<pre><code>Expr_rolling_std(\n  window_size,\n  weights = NULL,\n  min_periods = NULL,\n  center = FALSE,\n  by = NULL,\n  closed = \"left\"\n)\n</code></pre>"},{"location":"reference/#arguments_110","title":"Arguments","text":"<code>window_size</code> <p>The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language:</p> <ul> <li><p>1ns (1 nanosecond)</p></li> <li><p>1us (1 microsecond)</p></li> <li><p>1ms (1 millisecond)</p></li> <li><p>1s (1 second)</p></li> <li><p>1m (1 minute)</p></li> <li><p>1h (1 hour)</p></li> <li><p>1d (1 day)</p></li> <li><p>1w (1 week)</p></li> <li><p>1mo (1 calendar month)</p></li> <li><p>1y (1 calendar year)</p></li> <li><p>1i (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set.</p></li> </ul> <code>weights</code> <p>An optional slice with the same length as the window that will be multiplied elementwise with the values in the window.</p> <code>min_periods</code> <p>The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size.</p> <code>center</code> <p>Set the labels at the center of the window</p> <code>by</code> <p>If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or <code>\u2060\"3s\u2060</code>, you must set the column that will be used to determine the windows. This column must be of dtype <code>\u2060{Date, Datetime}\u2060</code></p> <code>closed</code> <p>: 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.</p>"},{"location":"reference/#details_68","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using <code>groupby_rolling</code> this method can cache the window size computation.</p>"},{"location":"reference/#value_187","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_183","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(pl$col(\"a\")$rolling_std(window_size = 2))\n</code></pre>"},{"location":"reference/#expr-rolling-sum","title":"Expr rolling sum","text":""},{"location":"reference/#description_203","title":"Description","text":"<p>Apply a rolling sum (moving sum) over the values in this array. A window of length <code>window_size</code> will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/#usage_172","title":"Usage","text":"<pre><code>Expr_rolling_sum(\n  window_size,\n  weights = NULL,\n  min_periods = NULL,\n  center = FALSE,\n  by = NULL,\n  closed = \"left\"\n)\n</code></pre>"},{"location":"reference/#arguments_111","title":"Arguments","text":"<code>window_size</code> <p>The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language:</p> <ul> <li><p>1ns (1 nanosecond)</p></li> <li><p>1us (1 microsecond)</p></li> <li><p>1ms (1 millisecond)</p></li> <li><p>1s (1 second)</p></li> <li><p>1m (1 minute)</p></li> <li><p>1h (1 hour)</p></li> <li><p>1d (1 day)</p></li> <li><p>1w (1 week)</p></li> <li><p>1mo (1 calendar month)</p></li> <li><p>1y (1 calendar year)</p></li> <li><p>1i (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set.</p></li> </ul> <code>weights</code> <p>An optional slice with the same length as the window that will be multiplied elementwise with the values in the window.</p> <code>min_periods</code> <p>The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size.</p> <code>center</code> <p>Set the labels at the center of the window</p> <code>by</code> <p>If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or <code>\u2060\"3s\u2060</code>, you must set the column that will be used to determine the windows. This column must be of dtype <code>\u2060{Date, Datetime}\u2060</code></p> <code>closed</code> <p>: 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.</p>"},{"location":"reference/#details_69","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using <code>groupby_rolling</code> this method can cache the window size computation.</p>"},{"location":"reference/#value_188","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_184","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(pl$col(\"a\")$rolling_sum(window_size = 2))\n</code></pre>"},{"location":"reference/#expr-rolling-var","title":"Expr rolling var","text":""},{"location":"reference/#description_204","title":"Description","text":"<p>Apply a rolling var (moving var) over the values in this array. A window of length <code>window_size</code> will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/#usage_173","title":"Usage","text":"<pre><code>Expr_rolling_var(\n  window_size,\n  weights = NULL,\n  min_periods = NULL,\n  center = FALSE,\n  by = NULL,\n  closed = \"left\"\n)\n</code></pre>"},{"location":"reference/#arguments_112","title":"Arguments","text":"<code>window_size</code> <p>The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language:</p> <ul> <li><p>1ns (1 nanosecond)</p></li> <li><p>1us (1 microsecond)</p></li> <li><p>1ms (1 millisecond)</p></li> <li><p>1s (1 second)</p></li> <li><p>1m (1 minute)</p></li> <li><p>1h (1 hour)</p></li> <li><p>1d (1 day)</p></li> <li><p>1w (1 week)</p></li> <li><p>1mo (1 calendar month)</p></li> <li><p>1y (1 calendar year)</p></li> <li><p>1i (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set.</p></li> </ul> <code>weights</code> <p>An optional slice with the same length as the window that will be multiplied elementwise with the values in the window.</p> <code>min_periods</code> <p>The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size.</p> <code>center</code> <p>Set the labels at the center of the window</p> <code>by</code> <p>If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or <code>\u2060\"3s\u2060</code>, you must set the column that will be used to determine the windows. This column must be of dtype <code>\u2060{Date, Datetime}\u2060</code></p> <code>closed</code> <p>: 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.</p>"},{"location":"reference/#details_70","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using <code>groupby_rolling</code> this method can cache the window size computation.</p>"},{"location":"reference/#value_189","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_185","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(pl$col(\"a\")$rolling_var(window_size = 2))\n</code></pre>"},{"location":"reference/#expr-round","title":"Expr round","text":""},{"location":"reference/#description_205","title":"Description","text":"<p>Round underlying floating point data by <code>decimals</code> digits.</p>"},{"location":"reference/#usage_174","title":"Usage","text":"<pre><code>Expr_round(decimals)\n</code></pre>"},{"location":"reference/#arguments_113","title":"Arguments","text":"<code>decimals</code> <p>integer Number of decimals to round by.</p>"},{"location":"reference/#format_102","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_190","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_186","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(0.33, 0.5, 1.02, 1.5, NaN , NA, Inf, -Inf)\n))$select(\npl$col(\"a\")$round(0)\n)\n</code></pre>"},{"location":"reference/#expr-rpow","title":"Expr rpow","text":""},{"location":"reference/#description_206","title":"Description","text":"<p>Raise a base to the power of the expression as exponent.</p>"},{"location":"reference/#usage_175","title":"Usage","text":"<pre><code>Expr_rpow(base)\n\ne1 %**% e2\n\n`%**%.Expr`(e1, e2)\n</code></pre>"},{"location":"reference/#arguments_114","title":"Arguments","text":"<code>base</code> <p>real or Expr, the value of the base, self is the exponent</p> <code>e1</code> <p>value where ** operator is defined</p> <code>e2</code> <p>value where ** operator is defined</p>"},{"location":"reference/#details_71","title":"Details","text":"<p>do not use <code>\u2060**\u2060</code>, R secretly parses that just as if it was a <code>^</code></p>"},{"location":"reference/#value_191","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_187","title":"Examples","text":"<pre><code>pl$DataFrame(list(a = -1:3))$select(\npl$lit(2)$rpow(pl$col(\"a\"))\n)$get_column(\"a\")$to_r() ==  (-1:3)^2\npl$DataFrame(list(a = -1:3))$select(\npl$lit(2) %**% (pl$col(\"a\"))\n)$get_column(\"a\")$to_r() ==  (-1:3)^2\n</code></pre>"},{"location":"reference/#expr-sample","title":"Expr sample","text":""},{"location":"reference/#description_207","title":"Description","text":"<p>#' Sample from this expression.</p>"},{"location":"reference/#usage_176","title":"Usage","text":"<pre><code>Expr_sample(\n  frac = NULL,\n  with_replacement = TRUE,\n  shuffle = FALSE,\n  seed = NULL,\n  n = NULL\n)\n</code></pre>"},{"location":"reference/#arguments_115","title":"Arguments","text":"<code>frac</code> <p>Fraction of items to return. Cannot be used with <code>n</code>.</p> <code>with_replacement</code> <p>Allow values to be sampled more than once.</p> <code>shuffle</code> <p>Shuffle the order of sampled data points. (implicitly TRUE if, with_replacement = TRUE)</p> <code>seed</code> <p>Seed for the random number generator. If set to None (default), a random seed is used.</p> <code>n</code> <p>Number of items to return. Cannot be used with <code>frac</code>.</p>"},{"location":"reference/#format_103","title":"Format","text":"<p>Method</p>"},{"location":"reference/#value_192","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_188","title":"Examples","text":"<pre><code>df = pl$DataFrame(a=1:3)\ndf$select(pl$col(\"a\")$sample(frac=1,with_replacement=TRUE,seed=1L))\ndf$select(pl$col(\"a\")$sample(frac=2,with_replacement=TRUE,seed=1L))\ndf$select(pl$col(\"a\")$sample(n=2,with_replacement=FALSE,seed=1L))\n</code></pre>"},{"location":"reference/#expr-search-sorted","title":"Expr search sorted","text":""},{"location":"reference/#description_208","title":"Description","text":"<p>Find indices in self where elements should be inserted into to maintain order.</p>"},{"location":"reference/#usage_177","title":"Usage","text":"<pre><code>Expr_search_sorted(element)\n</code></pre>"},{"location":"reference/#arguments_116","title":"Arguments","text":"<code>element</code> <p>a R value into literal or an expression of an element</p>"},{"location":"reference/#format_104","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_72","title":"Details","text":"<p>This function look up where to insert element if to keep self column sorted. It is assumed the self column is already sorted ascending, otherwise wrongs answers. This function is a bit under documented in py-polars.</p>"},{"location":"reference/#value_193","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_189","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=0:100))$select(pl$col(\"a\")$search_sorted(pl$lit(42L)))\n</code></pre>"},{"location":"reference/#expr-set-sorted","title":"Expr set sorted","text":""},{"location":"reference/#description_209","title":"Description","text":"<p>Flags the expression as 'sorted'.</p>"},{"location":"reference/#usage_178","title":"Usage","text":"<pre><code>Expr_set_sorted(reverse = FALSE)\n</code></pre>"},{"location":"reference/#arguments_117","title":"Arguments","text":"<code>reverse</code> <p>bool if TRUE Descending else Ascending</p>"},{"location":"reference/#value_194","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_190","title":"Examples","text":"<pre><code>#correct use flag something correctly as ascendingly sorted\ns = pl$select(pl$lit(1:4)$set_sorted()$alias(\"a\"))$get_column(\"a\")\ns$flags # see flags\n#incorrect use, flag somthing as not sorted ascendingly\ns2 = pl$select(pl$lit(c(1,3,2,4))$set_sorted()$alias(\"a\"))$get_column(\"a\")\ns2$sort() #sorting skipped, although not actually sorted\n</code></pre>"},{"location":"reference/#expr-shift-and-fill","title":"Expr shift and fill","text":""},{"location":"reference/#description_210","title":"Description","text":"<p>Shift the values by a given period and fill the resulting null values.</p>"},{"location":"reference/#usage_179","title":"Usage","text":"<pre><code>Expr_shift_and_fill(periods, fill_value)\n</code></pre>"},{"location":"reference/#arguments_118","title":"Arguments","text":"<code>periods</code> <p>numeric number of periods to shift, may be negative.</p> <code>fill_value</code> <p>Fill None values with the result of this expression.</p>"},{"location":"reference/#format_105","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_73","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_195","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_191","title":"Examples","text":"<pre><code>pl$select(\npl$lit(0:3),\npl$lit(0:3)$shift_and_fill(-2, fill_value = 42)$alias(\"shift-2\"),\npl$lit(0:3)$shift_and_fill(2, fill_value = pl$lit(42)/2)$alias(\"shift+2\")\n)\n</code></pre>"},{"location":"reference/#expr-shift","title":"Expr shift","text":""},{"location":"reference/#description_211","title":"Description","text":"<p>Shift values</p>"},{"location":"reference/#usage_180","title":"Usage","text":"<pre><code>Expr_shift(periods)\n</code></pre>"},{"location":"reference/#arguments_119","title":"Arguments","text":"<code>periods</code> <p>numeric number of periods to shift, may be negative.</p>"},{"location":"reference/#format_106","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_74","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_196","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_192","title":"Examples","text":"<pre><code>pl$select(\npl$lit(0:3)$shift(-2)$alias(\"shift-2\"),\npl$lit(0:3)$shift(2)$alias(\"shift+2\")\n)\n</code></pre>"},{"location":"reference/#expr-shrink-dtype","title":"Expr shrink dtype","text":""},{"location":"reference/#description_212","title":"Description","text":"<p>Shrink numeric columns to the minimal required datatype. Shrink to the dtype needed to fit the extrema of this <code>\u2060[Series]\u2060</code>. This can be used to reduce memory pressure.</p>"},{"location":"reference/#usage_181","title":"Usage","text":"<pre><code>Expr_shrink_dtype\n</code></pre>"},{"location":"reference/#format_107","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_197","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_193","title":"Examples","text":"<pre><code> pl$DataFrame(\na= c(1L, 2L, 3L),\nb= c(1L, 2L, bitwShiftL(2L,29)),\nc= c(-1L, 2L, bitwShiftL(1L,15)),\nd= c(-112L, 2L, 112L),\ne= c(-112L, 2L, 129L),\nf= c(\"a\", \"b\", \"c\"),\ng= c(0.1, 1.32, 0.12),\nh= c(TRUE, NA, FALSE)\n)$with_column( pl$col(\"b\")$cast(pl$Int64) *32L\n)$select(pl$all()$shrink_dtype())\n</code></pre>"},{"location":"reference/#expr-shuffle","title":"Expr shuffle","text":""},{"location":"reference/#description_213","title":"Description","text":"<p>Shuffle the contents of this expr.</p>"},{"location":"reference/#usage_182","title":"Usage","text":"<pre><code>Expr_shuffle(seed = NULL)\n</code></pre>"},{"location":"reference/#arguments_120","title":"Arguments","text":"<code>seed</code> <p>numeric value of 0 to 2^52 Seed for the random number generator. If set to Null (default), a random seed value intergish value between 0 and 10000 is picked</p>"},{"location":"reference/#format_108","title":"Format","text":"<p>Method</p>"},{"location":"reference/#value_198","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_194","title":"Examples","text":"<pre><code>pl$DataFrame(a = 1:3)$select(pl$col(\"a\")$shuffle(seed=1))\n</code></pre>"},{"location":"reference/#expr-sign","title":"Expr sign","text":""},{"location":"reference/#description_214","title":"Description","text":"<p>Compute the element-wise indication of the sign.</p>"},{"location":"reference/#usage_183","title":"Usage","text":"<pre><code>Expr_sign\n</code></pre>"},{"location":"reference/#format_109","title":"Format","text":"<p>Method</p>"},{"location":"reference/#value_199","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_195","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(.9,-0,0,4,NA_real_))$select(pl$col(\"a\")$sign())\n</code></pre>"},{"location":"reference/#expr-sin","title":"Expr sin","text":""},{"location":"reference/#description_215","title":"Description","text":"<p>Compute the element-wise value for the sine.</p>"},{"location":"reference/#usage_184","title":"Usage","text":"<pre><code>Expr_sin\n</code></pre>"},{"location":"reference/#format_110","title":"Format","text":"<p>Method</p>"},{"location":"reference/#details_75","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/#value_200","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_196","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(0,pi/2,pi,NA_real_))$select(pl$col(\"a\")$sin())\n</code></pre>"},{"location":"reference/#expr-sinh","title":"Expr sinh","text":""},{"location":"reference/#description_216","title":"Description","text":"<p>Compute the element-wise value for the hyperbolic sine.</p>"},{"location":"reference/#usage_185","title":"Usage","text":"<pre><code>Expr_sinh\n</code></pre>"},{"location":"reference/#format_111","title":"Format","text":"<p>Method</p>"},{"location":"reference/#details_76","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/#value_201","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_197","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,asinh(0.5),0,1,NA_real_))$select(pl$col(\"a\")$sinh())\n</code></pre>"},{"location":"reference/#expr-skew","title":"Expr skew","text":""},{"location":"reference/#description_217","title":"Description","text":"<p>Compute the sample skewness of a data set.</p>"},{"location":"reference/#usage_186","title":"Usage","text":"<pre><code>Expr_skew(bias = TRUE)\n</code></pre>"},{"location":"reference/#arguments_121","title":"Arguments","text":"<code>bias</code> <p>If False, then the calculations are corrected for statistical bias.</p>"},{"location":"reference/#details_77","title":"Details","text":"<p>For normally distributed data, the skewness should be about zero. For unimodal continuous distributions, a skewness value greater than zero means that there is more weight in the right tail of the distribution. The function <code>skewtest</code> can be used to determine if the skewness value is close enough to zero, statistically speaking.</p> <p>See scipy.stats for more information.</p>"},{"location":"reference/#notes","title":"Notes","text":"<p>The sample skewness is computed as the Fisher-Pearson coefficient of skewness, i.e.</p> <p><code>g_1=\\frac{m_3}{m_2^{3/2}}</code></p> <p>where</p> <p><code>m_i=\\frac{1}{N}\\sum_{n=1}^N(x[n]-\\bar{x})^i</code></p> <p>is the biased sample :math:<code>\u2060i\\texttt{th}\u2060</code> central moment, and <code>\\bar{x}</code> is the sample mean. If <code>bias</code> is False, the calculations are corrected for bias and the value computed is the adjusted Fisher-Pearson standardized moment coefficient, i.e.</p> <p><code>G_1 = \\frac{k_3}{k_2^{3/2}} = \\frac{\\sqrt{N(N-1)}}{N-2}\\frac{m_3}{m_2^{3/2}}</code></p>"},{"location":"reference/#value_202","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#references_1","title":"References","text":"<p>https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.skew.html?highlight=skew#scipy.stats.skew</p>"},{"location":"reference/#examples_198","title":"Examples","text":"<pre><code>df = pl$DataFrame(list( a=c(1:3,2:1)))\ndf$select(pl$col(\"a\")$skew())\n</code></pre>"},{"location":"reference/#expr-slice","title":"Expr slice","text":""},{"location":"reference/#description_218","title":"Description","text":"<p>Get a slice of this expression.</p>"},{"location":"reference/#usage_187","title":"Usage","text":"<pre><code>Expr_slice(offset, length = NULL)\n</code></pre>"},{"location":"reference/#arguments_122","title":"Arguments","text":"<code>offset</code> <p>numeric or expression, zero-indexed where to start slice negative value indicate starting (one-indexed) from back</p> <code>length</code> <p>how many elements should slice contain, default NULL is max length</p>"},{"location":"reference/#format_112","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_203","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_199","title":"Examples","text":"<pre><code>#as head\npl$DataFrame(list(a=0:100))$select(\npl$all()$slice(0,6)\n)\n#as tail\npl$DataFrame(list(a=0:100))$select(\npl$all()$slice(-6,6)\n)\npl$DataFrame(list(a=0:100))$select(\npl$all()$slice(80)\n)\n</code></pre>"},{"location":"reference/#expr-sort-by","title":"Expr sort by","text":""},{"location":"reference/#description_219","title":"Description","text":"<p>Sort this column by the ordering of another column, or multiple other columns.</p>"},{"location":"reference/#usage_188","title":"Usage","text":"<pre><code>Expr_sort_by(by, reverse = FALSE)\n</code></pre>"},{"location":"reference/#arguments_123","title":"Arguments","text":"<code>by</code> <p>one expression or list expressions and/or strings(interpreted as column names)</p> <code>reverse</code> <p>single bool to boolean vector, any is_TRUE will give reverse sorting of that column</p>"},{"location":"reference/#format_113","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_78","title":"Details","text":"<p>In projection/ selection context the whole column is sorted. If used in a groupby context, the groups are sorted.</p> <p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_204","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_200","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(\ngroup = c(\"a\",\"a\",\"a\",\"b\",\"b\",\"b\"),\nvalue1 = c(98,1,3,2,99,100),\nvalue2 = c(\"d\",\"f\",\"b\",\"e\",\"c\",\"a\")\n))\n# by one column/expression\ndf$select(\npl$col(\"group\")$sort_by(\"value1\")\n)\n# by two columns/expressions\ndf$select(\npl$col(\"group\")$sort_by(list(\"value2\",pl$col(\"value1\")), reverse =c(TRUE,FALSE))\n)\n# by some expression\ndf$select(\npl$col(\"group\")$sort_by(pl$col(\"value1\")$sort(reverse=TRUE))\n)\n#quite similar usecase as R function `order()`\nl = list(\nab = c(rep(\"a\",6),rep(\"b\",6)),\nv4 = rep(1:4, 3),\nv3 = rep(1:3, 4),\nv2 = rep(1:2,6),\nv1 = 1:12\n)\ndf = pl$DataFrame(l)\n#examples of order versus sort_by\nall.equal(\ndf$select(\npl$col(\"ab\")$sort_by(\"v4\")$alias(\"ab4\"),\npl$col(\"ab\")$sort_by(\"v3\")$alias(\"ab3\"),\npl$col(\"ab\")$sort_by(\"v2\")$alias(\"ab2\"),\npl$col(\"ab\")$sort_by(\"v1\")$alias(\"ab1\"),\npl$col(\"ab\")$sort_by(list(\"v3\",pl$col(\"v1\")),reverse=c(FALSE,TRUE))$alias(\"ab13FT\"),\npl$col(\"ab\")$sort_by(list(\"v3\",pl$col(\"v1\")),reverse=TRUE)$alias(\"ab13T\")\n)$to_list(),\nlist(\nab4 = l$ab[order(l$v4)],\nab3 = l$ab[order(l$v3)],\nab2 = l$ab[order(l$v2)],\nab1 = l$ab[order(l$v1)],\nab13FT= l$ab[order(l$v3,rev(l$v1))],\nab13T = l$ab[order(l$v3,l$v1,decreasing= TRUE)]\n)\n)\n</code></pre>"},{"location":"reference/#expr-sort","title":"Expr sort","text":""},{"location":"reference/#description_220","title":"Description","text":"<p>Sort this column. In projection/ selection context the whole column is sorted. If used in a groupby context, the groups are sorted.</p>"},{"location":"reference/#usage_189","title":"Usage","text":"<pre><code>Expr_sort(reverse = FALSE, nulls_last = FALSE)\n</code></pre>"},{"location":"reference/#arguments_124","title":"Arguments","text":"<code>reverse</code> <p>bool default FALSE, reverses sort</p> <code>nulls_last</code> <p>bool, default FALSE, place Nulls last</p>"},{"location":"reference/#format_114","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_79","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_205","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_201","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(6, 1, 0, NA, Inf, NaN)\n))$select(pl$col(\"a\")$sort())\n</code></pre>"},{"location":"reference/#expr-sqrt","title":"Expr sqrt","text":""},{"location":"reference/#description_221","title":"Description","text":"<p>Compute the square root of the elements.</p>"},{"location":"reference/#usage_190","title":"Usage","text":"<pre><code>Expr_sqrt()\n</code></pre>"},{"location":"reference/#value_206","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_202","title":"Examples","text":"<pre><code>pl$DataFrame(list(a = -1:3))$select(pl$col(\"a\")$sqrt())\n</code></pre>"},{"location":"reference/#expr-std","title":"Expr std","text":""},{"location":"reference/#description_222","title":"Description","text":"<p>Get Standard Deviation</p>"},{"location":"reference/#usage_191","title":"Usage","text":"<pre><code>Expr_std(ddof = 1)\n</code></pre>"},{"location":"reference/#arguments_125","title":"Arguments","text":"<code>ddof</code> <p>integer in range <code>\u2060[0;255]\u2060</code> degrees of freedom</p>"},{"location":"reference/#format_115","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_207","title":"Value","text":"<p>Expr (f64 scalar)</p>"},{"location":"reference/#examples_203","title":"Examples","text":"<pre><code>pl$select(pl$lit(1:5)$std())\n</code></pre>"},{"location":"reference/#expr-str","title":"Expr str","text":""},{"location":"reference/#description_223","title":"Description","text":"<p>Create an object namespace of all string related methods. See the individual method pages for full details</p>"},{"location":"reference/#usage_192","title":"Usage","text":"<pre><code>Expr_str()\n</code></pre>"},{"location":"reference/#value_208","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_204","title":"Examples","text":"<pre><code>#missing\n</code></pre>"},{"location":"reference/#expr-struct","title":"Expr struct","text":""},{"location":"reference/#description_224","title":"Description","text":"<p>Create an object namespace of all struct related methods. See the individual method pages for full details</p>"},{"location":"reference/#usage_193","title":"Usage","text":"<pre><code>Expr_struct()\n</code></pre>"},{"location":"reference/#value_209","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_205","title":"Examples","text":"<pre><code>#missing\n</code></pre>"},{"location":"reference/#expr-sub","title":"Expr sub","text":""},{"location":"reference/#description_225","title":"Description","text":"<p>Substract</p>"},{"location":"reference/#usage_194","title":"Usage","text":"<pre><code>Expr_sub(other)\n\n## S3 method for class 'Expr'\ne1 - e2\n</code></pre>"},{"location":"reference/#arguments_126","title":"Arguments","text":"<code>other</code> <p>literal or Robj which can become a literal</p> <code>e1</code> <p>lhs Expr</p> <code>e2</code> <p>rhs Expr or anything which can become a literal Expression</p>"},{"location":"reference/#value_210","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/#examples_206","title":"Examples","text":"<pre><code>#three syntaxes same result\npl$lit(5) - 10\npl$lit(5) - pl$lit(10)\npl$lit(5)$sub(pl$lit(10))\n-pl$lit(5)\n</code></pre>"},{"location":"reference/#expr-sum","title":"Expr sum","text":""},{"location":"reference/#description_226","title":"Description","text":"<p>Get sum value</p>"},{"location":"reference/#usage_195","title":"Usage","text":"<pre><code>Expr_sum\n</code></pre>"},{"location":"reference/#format_116","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#details_80","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues.</p>"},{"location":"reference/#value_211","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_207","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1L,NA,2L)))$select(pl$col(\"x\")$sum())#is i32 3 (Int32 not casted)\n</code></pre>"},{"location":"reference/#expr-tail","title":"Expr tail","text":""},{"location":"reference/#description_227","title":"Description","text":"<p>Get the tail n elements. Similar to R tail(x)</p>"},{"location":"reference/#usage_196","title":"Usage","text":"<pre><code>Expr_tail(n = 10)\n</code></pre>"},{"location":"reference/#arguments_127","title":"Arguments","text":"<code>n</code> <p>numeric number of elements to select from tail</p>"},{"location":"reference/#value_212","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_208","title":"Examples","text":"<pre><code>#get 3 last elements\npl$DataFrame(list(x=1:11))$select(pl$col(\"x\")$tail(3))\n</code></pre>"},{"location":"reference/#expr-take-every","title":"Expr take every","text":""},{"location":"reference/#description_228","title":"Description","text":"<p>Take every nth value in the Series and return as a new Series.</p>"},{"location":"reference/#usage_197","title":"Usage","text":"<pre><code>Expr_take_every(n)\n</code></pre>"},{"location":"reference/#arguments_128","title":"Arguments","text":"<code>n</code> <p>positive integerish value</p>"},{"location":"reference/#format_117","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_213","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_209","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=0:24))$select(pl$col(\"a\")$take_every(6))\n</code></pre>"},{"location":"reference/#expr-take","title":"Expr take","text":""},{"location":"reference/#description_229","title":"Description","text":"<p>Take values by index.</p>"},{"location":"reference/#usage_198","title":"Usage","text":"<pre><code>Expr_take(indices)\n</code></pre>"},{"location":"reference/#arguments_129","title":"Arguments","text":"<code>indices</code> <p>R scalar/vector or Series, or Expr that leads to a UInt32 dtyped Series.</p>"},{"location":"reference/#format_118","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_81","title":"Details","text":"<p>similar to R indexing syntax e.g. <code>letters[c(1,3,5)]</code>, however as an expression, not as eager computation exceeding</p>"},{"location":"reference/#value_214","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_210","title":"Examples","text":"<pre><code>pl$select( pl$lit(0:10)$take(c(1,8,0,7)))\n</code></pre>"},{"location":"reference/#expr-tan","title":"Expr tan","text":""},{"location":"reference/#description_230","title":"Description","text":"<p>Compute the element-wise value for the tangent.</p>"},{"location":"reference/#usage_199","title":"Usage","text":"<pre><code>Expr_tan\n</code></pre>"},{"location":"reference/#format_119","title":"Format","text":"<p>Method</p>"},{"location":"reference/#details_82","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/#value_215","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_211","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(0,pi/2,pi,NA_real_))$select(pl$col(\"a\")$tan())\n</code></pre>"},{"location":"reference/#expr-tanh","title":"Expr tanh","text":""},{"location":"reference/#description_231","title":"Description","text":"<p>Compute the element-wise value for the hyperbolic tangent.</p>"},{"location":"reference/#usage_200","title":"Usage","text":"<pre><code>Expr_tanh\n</code></pre>"},{"location":"reference/#format_120","title":"Format","text":"<p>Method</p>"},{"location":"reference/#details_83","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/#value_216","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_212","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,atanh(0.5),0,1,NA_real_))$select(pl$col(\"a\")$tanh())\n</code></pre>"},{"location":"reference/#expr-to-physical","title":"Expr to physical","text":""},{"location":"reference/#description_232","title":"Description","text":"<p>expression request underlying physical base representation</p>"},{"location":"reference/#usage_201","title":"Usage","text":"<pre><code>Expr_to_physical\n</code></pre>"},{"location":"reference/#format_121","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_217","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_213","title":"Examples","text":"<pre><code>pl$DataFrame(\nlist(vals = c(\"a\", \"x\", NA, \"a\"))\n)$with_columns(\npl$col(\"vals\")$cast(pl$Categorical),\npl$col(\"vals\")\n$cast(pl$Categorical)\n$to_physical()\n$alias(\"vals_physical\")\n)\n</code></pre>"},{"location":"reference/#expr-to-r","title":"Expr to r","text":""},{"location":"reference/#description_233","title":"Description","text":"<p>debug an expression by evaluating in empty DataFrame and return first series to R</p>"},{"location":"reference/#usage_202","title":"Usage","text":"<pre><code>Expr_to_r(df = NULL, i = 0)\n</code></pre>"},{"location":"reference/#arguments_130","title":"Arguments","text":"<code>df</code> <p>otherwise a DataFrame to evaluate in, default NULL is an empty DataFrame</p> <code>i</code> <p>numeric column to extract zero index default first, expression could generate multiple columns</p>"},{"location":"reference/#format_122","title":"Format","text":"<p>Method</p>"},{"location":"reference/#value_218","title":"Value","text":"<p>R object</p>"},{"location":"reference/#examples_214","title":"Examples","text":"<pre><code>pl$lit(1:3)$to_r()\npl$expr_to_r(pl$lit(1:3))\npl$expr_to_r(1:3)\n</code></pre>"},{"location":"reference/#expr-to-struct","title":"Expr to struct","text":""},{"location":"reference/#description_234","title":"Description","text":"<p>pass expr to pl$struct</p>"},{"location":"reference/#usage_203","title":"Usage","text":"<pre><code>Expr_to_struct()\n</code></pre>"},{"location":"reference/#value_219","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_215","title":"Examples","text":"<pre><code>e = pl$all()$to_struct()$alias(\"my_struct\")\nprint(e)\npl$DataFrame(iris)$select(e)\n</code></pre>"},{"location":"reference/#expr-top-k","title":"Expr top k","text":""},{"location":"reference/#description_235","title":"Description","text":"<p>Return the <code>k</code> largest elements. If 'reverse=True' the smallest elements will be given.</p>"},{"location":"reference/#usage_204","title":"Usage","text":"<pre><code>Expr_top_k(k, reverse = FALSE)\n</code></pre>"},{"location":"reference/#arguments_131","title":"Arguments","text":"<code>k</code> <p>numeric k top values to get</p> <code>reverse</code> <p>bool if true then k smallest values</p>"},{"location":"reference/#format_123","title":"Format","text":"<p>a method</p>"},{"location":"reference/#details_84","title":"Details","text":"<p>This has time complexity: <code>O(n + k \\\\log{}n - \\frac{k}{2})</code></p> <p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/#value_220","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_216","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(6, 1, 0, NA, Inf, NaN)\n))$select(pl$col(\"a\")$top_k(5))\n</code></pre>"},{"location":"reference/#expr-unique-counts","title":"Expr unique counts","text":""},{"location":"reference/#description_236","title":"Description","text":"<p>Return a count of the unique values in the order of appearance. This method differs from <code>value_counts</code> in that it does not return the values, only the counts and might be faster</p>"},{"location":"reference/#usage_205","title":"Usage","text":"<pre><code>Expr_unique_counts\n</code></pre>"},{"location":"reference/#format_124","title":"Format","text":"<p>Method</p>"},{"location":"reference/#value_221","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_217","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$select(pl$col(\"Species\")$unique_counts())\n</code></pre>"},{"location":"reference/#expr-unique","title":"Expr unique","text":""},{"location":"reference/#description_237","title":"Description","text":"<p>Get unique values of this expression. Similar to R unique()</p>"},{"location":"reference/#usage_206","title":"Usage","text":"<pre><code>Expr_unique(maintain_order = FALSE)\n</code></pre>"},{"location":"reference/#arguments_132","title":"Arguments","text":"<code>maintain_order</code> <p>bool, if TRUE guranteed same order, if FALSE maybe</p>"},{"location":"reference/#value_222","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_218","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$select(pl$col(\"Species\")$unique())\n</code></pre>"},{"location":"reference/#expr-upper-lower-bound","title":"Expr upper lower bound","text":""},{"location":"reference/#description_238","title":"Description","text":"<p>Calculate the upper/lower bound. Returns a unit Series with the highest value possible for the dtype of this expression.</p>"},{"location":"reference/#usage_207","title":"Usage","text":"<pre><code>Expr_upper_bound\n\nExpr_lower_bound\n</code></pre>"},{"location":"reference/#format_125","title":"Format","text":"<p>Method</p> <p>Method</p>"},{"location":"reference/#details_85","title":"Details","text":"<p>Notice lower bound i32 exported to R is NA_integer_ for now</p>"},{"location":"reference/#value_223","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_219","title":"Examples","text":"<pre><code>pl$DataFrame(i32=1L,f64=1)$select(pl$all()$upper_bound())\npl$DataFrame(i32=1L,f64=1)$select(pl$all()$lower_bound())\n</code></pre>"},{"location":"reference/#expr-value-counts","title":"Expr value counts","text":""},{"location":"reference/#description_239","title":"Description","text":"<p>Count all unique values and create a struct mapping value to count.</p>"},{"location":"reference/#usage_208","title":"Usage","text":"<pre><code>Expr_value_counts(multithreaded = FALSE, sort = FALSE)\n</code></pre>"},{"location":"reference/#arguments_133","title":"Arguments","text":"<code>multithreaded</code> <p>Better to turn this off in the aggregation context, as it can lead to contention.</p> <code>sort</code> <p>Ensure the output is sorted from most values to least.</p>"},{"location":"reference/#format_126","title":"Format","text":"<p>Method</p>"},{"location":"reference/#value_224","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_220","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris)$select(pl$col(\"Species\")$value_counts())\ndf\ndf$unnest()$as_data_frame() #recommended to unnest structs before converting to R\n</code></pre>"},{"location":"reference/#expr-var","title":"Expr var","text":""},{"location":"reference/#description_240","title":"Description","text":"<p>Get Variance</p>"},{"location":"reference/#usage_209","title":"Usage","text":"<pre><code>Expr_var(ddof = 1)\n</code></pre>"},{"location":"reference/#arguments_134","title":"Arguments","text":"<code>ddof</code> <p>integer in range <code>\u2060[0;255]\u2060</code> degrees of freedom</p>"},{"location":"reference/#format_127","title":"Format","text":"<p>a method</p>"},{"location":"reference/#value_225","title":"Value","text":"<p>Expr (f64 scalar)</p>"},{"location":"reference/#examples_221","title":"Examples","text":"<pre><code>pl$select(pl$lit(1:5)$var())\n</code></pre>"},{"location":"reference/#expr-xor","title":"Expr xor","text":""},{"location":"reference/#description_241","title":"Description","text":"<p>combine to boolean expresions with XOR</p>"},{"location":"reference/#usage_210","title":"Usage","text":"<pre><code>Expr_xor(other)\n</code></pre>"},{"location":"reference/#arguments_135","title":"Arguments","text":"<code>other</code> <p>literal or Robj which can become a literal</p>"},{"location":"reference/#format_128","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_226","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_222","title":"Examples","text":"<pre><code>pl$lit(TRUE)$xor(pl$lit(FALSE))\n</code></pre>"},{"location":"reference/#expr-cash-print-open-paren-close-paren","title":"Expr-cash-print-open-paren-close-paren","text":""},{"location":"reference/#description_242","title":"Description","text":"<p>internal method print Expr</p>"},{"location":"reference/#usage_211","title":"Usage","text":"<pre><code>Expr_print()\n</code></pre>"},{"location":"reference/#examples_223","title":"Examples","text":"<pre><code>pl$DataFrame(iris)\n</code></pre>"},{"location":"reference/#expr","title":"Expr","text":""},{"location":"reference/#description_243","title":"Description","text":"<p>Polars pl$Expr</p>"},{"location":"reference/#usage_212","title":"Usage","text":"<pre><code>Expr_lit(x)\n\nExpr_suffix(suffix)\n\nExpr_prefix(prefix)\n\nExpr_reverse()\n</code></pre>"},{"location":"reference/#arguments_136","title":"Arguments","text":"<code>x</code> <p>an R Scalar, or R vector/list (via Series) into Expr</p> <code>suffix</code> <p>string suffix to be added to a name</p> <code>prefix</code> <p>string suffix to be added to a name</p>"},{"location":"reference/#details_86","title":"Details","text":"<p>pl$lit(NULL) translates into a typeless polars Null</p>"},{"location":"reference/#value_227","title":"Value","text":"<p>Expr, literal of that value</p> <p>Expr</p> <p>Expr</p> <p>Expr</p>"},{"location":"reference/#examples_224","title":"Examples","text":"<pre><code>2+2\n#Expr has the following methods/constructors\nls(polars:::Expr)\npl$col(\"this_column\")$sum()$over(\"that_column\")\n#scalars to literal, explit `pl$lit(42)` implicit `+ 2`\npl$col(\"some_column\") / pl$lit(42) + 2\n#vector to literal explicitly via Series and back again\n#R vector to expression and back again\npl$select(pl$lit(pl$Series(1:4)))$to_list()[[1L]]\n#r vecot to literal and back r vector\npl$lit(1:4)$to_r()\n#r vector to literal to dataframe\npl$select(pl$lit(1:4))\n#r vector to literal to Series\npl$lit(1:4)$lit_to_s()\n#vectors to literal implicitly\n(pl$lit(2) + 1:4 ) / 4:1\npl$col(\"some\")$suffix(\"_column\")\npl$col(\"some\")$suffix(\"_column\")\npl$DataFrame(list(a=1:5))$select(pl$col(\"a\")$reverse())\n</code></pre>"},{"location":"reference/#exprbin-contains","title":"ExprBin contains","text":""},{"location":"reference/#description_244","title":"Description","text":"<p>R Check if binaries in Series contain a binary substring.</p>"},{"location":"reference/#arguments_137","title":"Arguments","text":"<code>lit</code> <p>The binary substring to look for</p>"},{"location":"reference/#value_228","title":"Value","text":"<p>Expr returning a Boolean</p>"},{"location":"reference/#exprbin-decode","title":"ExprBin decode","text":""},{"location":"reference/#description_245","title":"Description","text":"<p>Decode a value using the provided encoding.</p>"},{"location":"reference/#arguments_138","title":"Arguments","text":"<code>encoding</code> <p>binary choice either 'hex' or 'base64'</p> <code>strict</code> <p>Raise an error if the underlying value cannot be decoded, otherwise mask out with a null value.</p>"},{"location":"reference/#value_229","title":"Value","text":"<p>binary array with values decoded using provided encoding</p>"},{"location":"reference/#exprbin-encode","title":"ExprBin encode","text":""},{"location":"reference/#description_246","title":"Description","text":"<p>Encode a value using the provided encoding.</p>"},{"location":"reference/#arguments_139","title":"Arguments","text":"<code>encoding</code> <p>binary choice either 'hex' or 'base64'</p>"},{"location":"reference/#value_230","title":"Value","text":"<p>binary array with values encoded using provided encoding</p>"},{"location":"reference/#exprbin-ends-with","title":"ExprBin ends with","text":""},{"location":"reference/#description_247","title":"Description","text":"<p>Check if string values end with a binary substring.</p>"},{"location":"reference/#value_231","title":"Value","text":"<p>Expr returning a Boolean</p>"},{"location":"reference/#exprbin-starts-with","title":"ExprBin starts with","text":""},{"location":"reference/#description_248","title":"Description","text":"<p>Check if values starts with a binary substring.</p>"},{"location":"reference/#arguments_140","title":"Arguments","text":"<code>sub</code> <p>Prefix substring.</p>"},{"location":"reference/#exprcat-set-ordering","title":"ExprCat set ordering","text":""},{"location":"reference/#description_249","title":"Description","text":"<p>Determine how this categorical series should be sorted.</p>"},{"location":"reference/#arguments_141","title":"Arguments","text":"<code>ordering</code> <p>string either 'physical' or 'lexical'</p> <ul> <li><p>'physical' -&gt; Use the physical representation of the categories to determine the order (default).</p></li> <li><p>'lexical' -&gt; Use the string values to determine the ordering.</p></li> </ul>"},{"location":"reference/#value_232","title":"Value","text":"<p>bool: TRUE if equal</p>"},{"location":"reference/#examples_225","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ncats =  c(\"z\", \"z\", \"k\", \"a\", \"b\"),\nvals =  c(3, 1, 2, 2, 3)\n)$with_columns(\npl$col(\"cats\")$cast(pl$Categorical)$cat$set_ordering(\"physical\")\n)\ndf$select(pl$all()$sort())\n</code></pre>"},{"location":"reference/#exprdt-cast-time-unit","title":"ExprDT cast time unit","text":""},{"location":"reference/#description_250","title":"Description","text":"<p>Cast the underlying data to another time unit. This may lose precision. The corresponding global timepoint will stay unchanged +/- precision.</p>"},{"location":"reference/#arguments_142","title":"Arguments","text":"<code>tu</code> <p>string option either 'ns', 'us', or 'ms'</p>"},{"location":"reference/#format_129","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_233","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/#examples_226","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2001-1-1\"), high = as.Date(\"2001-1-3\"), interval = \"1d\")\n)\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$dt$cast_time_unit()$alias(\"cast_time_unit_ns\"),\npl$col(\"date\")$dt$cast_time_unit(tu=\"ms\")$alias(\"cast_time_unit_ms\")\n)\n</code></pre>"},{"location":"reference/#exprdt-combine","title":"ExprDT combine","text":""},{"location":"reference/#description_251","title":"Description","text":"<p>Create a naive Datetime from an existing Date/Datetime expression and a Time. Each date/datetime in the first half of the interval is mapped to the start of its bucket. Each date/datetime in the second half of the interval is mapped to the end of its bucket.</p>"},{"location":"reference/#arguments_143","title":"Arguments","text":"<code>tm</code> <p>Expr or numeric or PTime, the number of epoch since or before(if negative) the Date or tm is an Expr e.g. a column of DataType 'Time' or something into an Expr.</p> <code>tu</code> <p>time unit of epochs, default is \"us\", if tm is a PTime, then tz passed via PTime.</p>"},{"location":"reference/#format_130","title":"Format","text":"<p>function</p>"},{"location":"reference/#details_87","title":"Details","text":"<p>The <code>tu</code> allows the following time time units the following string language:</p> <ul> <li> <p>1ns # 1 nanosecond</p> </li> <li> <p>1us # 1 microsecond</p> </li> <li> <p>1ms # 1 millisecond</p> </li> </ul>"},{"location":"reference/#value_234","title":"Value","text":"<p>Date/Datetime expr</p>"},{"location":"reference/#examples_227","title":"Examples","text":"<pre><code>#Using pl$PTime\npl$lit(as.Date(\"2021-01-01\"))$dt$combine(pl$PTime(\"02:34:12\"))$lit_to_s()\npl$lit(as.Date(\"2021-01-01\"))$dt$combine(pl$PTime(3600 * 1.5, tu=\"s\"))$lit_to_s()\npl$lit(as.Date(\"2021-01-01\"))$dt$combine(pl$PTime(3600 * 1.5E6 + 123, tu=\"us\"))$lit_to_s()\n#pass double and set tu manually\npl$lit(as.Date(\"2021-01-01\"))$dt$combine(3600 * 1.5E6 + 123, tu=\"us\")$lit_to_s()\n#if needed to convert back to R it is more intuitive to set a specific time zone\nexpr = pl$lit(as.Date(\"2021-01-01\"))$dt$combine(3600 * 1.5E6 + 123, tu=\"us\")\nexpr$cast(pl$Datetime(tu = \"us\", tz = \"GMT\"))$to_r()\n</code></pre>"},{"location":"reference/#exprdt-convert-time-zone","title":"ExprDT convert time zone","text":""},{"location":"reference/#description_252","title":"Description","text":"<p>Set time zone for a Series of type Datetime. Use to change time zone annotation, but keep the corresponding global timepoint.</p>"},{"location":"reference/#arguments_144","title":"Arguments","text":"<code>tz</code> <p>String time zone from base::OlsonNames()</p>"},{"location":"reference/#format_131","title":"Format","text":"<p>function</p>"},{"location":"reference/#details_88","title":"Details","text":"<p>corresponds to in R manually modifying the tzone attribute of POSIXt objects</p>"},{"location":"reference/#value_235","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/#examples_228","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2001-3-1\"), high = as.Date(\"2001-5-1\"), interval = \"1mo\")\n)\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")\n$dt$replace_time_zone(\"Europe/Amsterdam\")\n$dt$convert_time_zone(\"Europe/London\")\n$alias(\"London_with\"),\npl$col(\"date\")\n$dt$tz_localize(\"Europe/London\")\n$alias(\"London_localize\")\n)\n</code></pre>"},{"location":"reference/#exprdt-day","title":"ExprDT day","text":""},{"location":"reference/#description_253","title":"Description","text":"<p>Extract day from underlying Date representation. Applies to Date and Datetime columns. Returns the day of month starting from 1. The return value ranges from 1 to 31. (The last day of month differs by months.)</p>"},{"location":"reference/#format_132","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_236","title":"Value","text":"<p>Expr of day as UInt32</p>"},{"location":"reference/#examples_229","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$day()$alias(\"day\")\n)\n</code></pre>"},{"location":"reference/#exprdt-days","title":"ExprDT days","text":""},{"location":"reference/#description_254","title":"Description","text":"<p>Extract the days from a Duration type.</p>"},{"location":"reference/#format_133","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_237","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/#examples_230","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2020-3-1\"), high = as.Date(\"2020-5-1\"), interval = \"1mo\")\n)\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$diff()$dt$days()$alias(\"days_diff\")\n)\n</code></pre>"},{"location":"reference/#exprdt-epoch","title":"ExprDT epoch","text":""},{"location":"reference/#description_255","title":"Description","text":"<p>Get the time passed since the Unix EPOCH in the give time unit.</p>"},{"location":"reference/#arguments_145","title":"Arguments","text":"<code>tu</code> <p>string option either 'ns', 'us', 'ms', 's' or 'd'</p>"},{"location":"reference/#format_134","title":"Format","text":"<p>function</p>"},{"location":"reference/#details_89","title":"Details","text":"<p>ns and perhaps us will exceed integerish limit if returning to R as flaot64/double.</p>"},{"location":"reference/#value_238","title":"Value","text":"<p>Expr of epoch as UInt32</p>"},{"location":"reference/#examples_231","title":"Examples","text":"<pre><code>pl$date_range(as.Date(\"2022-1-1\"),lazy = TRUE)$dt$epoch(\"ns\")$lit_to_s()\npl$date_range(as.Date(\"2022-1-1\"),lazy = TRUE)$dt$epoch(\"ms\")$lit_to_s()\npl$date_range(as.Date(\"2022-1-1\"),lazy = TRUE)$dt$epoch(\"s\")$lit_to_s()\npl$date_range(as.Date(\"2022-1-1\"),lazy = TRUE)$dt$epoch(\"d\")$lit_to_s()\n</code></pre>"},{"location":"reference/#exprdt-hour","title":"ExprDT hour","text":""},{"location":"reference/#description_256","title":"Description","text":"<p>Extract hour from underlying Datetime representation. Applies to Datetime columns. Returns the hour number from 0 to 23.</p>"},{"location":"reference/#format_135","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_239","title":"Value","text":"<p>Expr of hour as UInt32</p>"},{"location":"reference/#examples_232","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$hour()$alias(\"hour\")\n)\n</code></pre>"},{"location":"reference/#exprdt-hours","title":"ExprDT hours","text":""},{"location":"reference/#description_257","title":"Description","text":"<p>Extract the hours from a Duration type.</p>"},{"location":"reference/#format_136","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_240","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/#examples_233","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2020-1-1\"), high = as.Date(\"2020-1-4\"), interval = \"1d\")\n)\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$diff()$dt$hours()$alias(\"hours_diff\")\n)\n</code></pre>"},{"location":"reference/#exprdt-iso-year","title":"ExprDT iso year","text":""},{"location":"reference/#description_258","title":"Description","text":"<p>Extract ISO year from underlying Date representation. Applies to Date and Datetime columns. Returns the year number in the ISO standard. This may not correspond with the calendar year.</p>"},{"location":"reference/#format_137","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_241","title":"Value","text":"<p>Expr of iso_year as Int32</p>"},{"location":"reference/#examples_234","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$year()$alias(\"year\"),\npl$col(\"date\")$dt$iso_year()$alias(\"iso_year\")\n)\n</code></pre>"},{"location":"reference/#exprdt-microsecond","title":"ExprDT microsecond","text":""},{"location":"reference/#description_259","title":"Description","text":"<p>Extract microseconds from underlying Datetime representation. Applies to Datetime columns.</p>"},{"location":"reference/#format_138","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_242","title":"Value","text":"<p>Expr of microsecond as Int64</p>"},{"location":"reference/#examples_235","title":"Examples","text":"<pre><code>pl$DataFrame(date = pl$date_range(\nas.numeric(as.POSIXct(\"2001-1-1\"))*1E6+456789, #manually convert to us\nas.numeric(as.POSIXct(\"2001-1-1 00:00:6\"))*1E6,\ninterval = \"2s654321us\",\ntime_unit = \"us\" #instruct polars input is us, and store as us\n))$with_columns(\npl$col(\"date\")$cast(pl$Int64)$alias(\"datetime int64\"),\npl$col(\"date\")$dt$microsecond()$alias(\"microsecond\")\n)\n</code></pre>"},{"location":"reference/#exprdt-microseconds","title":"ExprDT microseconds","text":""},{"location":"reference/#description_260","title":"Description","text":"<p>Extract the microseconds from a Duration type.</p>"},{"location":"reference/#format_139","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_243","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/#examples_236","title":"Examples","text":"<pre><code>df = pl$DataFrame(date = pl$date_range(\nlow = as.POSIXct(\"2020-1-1\", tz = \"GMT\"),\nhigh = as.POSIXct(\"2020-1-1 00:00:01\", tz = \"GMT\"),\ninterval = \"1ms\"\n))\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$diff()$dt$microseconds()$alias(\"seconds_diff\")\n)\n</code></pre>"},{"location":"reference/#exprdt-millisecond","title":"ExprDT millisecond","text":""},{"location":"reference/#description_261","title":"Description","text":"<p>Extract milliseconds from underlying Datetime representation. Applies to Datetime columns.</p>"},{"location":"reference/#format_140","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_244","title":"Value","text":"<p>Expr of millisecond as Int64</p>"},{"location":"reference/#examples_237","title":"Examples","text":"<pre><code>pl$DataFrame(date = pl$date_range(\nas.numeric(as.POSIXct(\"2001-1-1\"))*1E6+456789, #manually convert to us\nas.numeric(as.POSIXct(\"2001-1-1 00:00:6\"))*1E6,\ninterval = \"2s654321us\",\ntime_unit = \"us\" #instruct polars input is us, and store as us\n))$with_columns(\npl$col(\"date\")$cast(pl$Int64)$alias(\"datetime int64\"),\npl$col(\"date\")$dt$millisecond()$alias(\"millisecond\")\n)\n</code></pre>"},{"location":"reference/#exprdt-milliseconds","title":"ExprDT milliseconds","text":""},{"location":"reference/#description_262","title":"Description","text":"<p>Extract the milliseconds from a Duration type.</p>"},{"location":"reference/#format_141","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_245","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/#examples_238","title":"Examples","text":"<pre><code>df = pl$DataFrame(date = pl$date_range(\nlow = as.POSIXct(\"2020-1-1\", tz = \"GMT\"),\nhigh = as.POSIXct(\"2020-1-1 00:00:01\", tz = \"GMT\"),\ninterval = \"1ms\"\n))\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$diff()$dt$milliseconds()$alias(\"seconds_diff\")\n)\n</code></pre>"},{"location":"reference/#exprdt-minute","title":"ExprDT minute","text":""},{"location":"reference/#description_263","title":"Description","text":"<p>Extract minutes from underlying Datetime representation. Applies to Datetime columns. Returns the minute number from 0 to 59.</p>"},{"location":"reference/#format_142","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_246","title":"Value","text":"<p>Expr of minute as UInt32</p>"},{"location":"reference/#examples_239","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$minute()$alias(\"minute\")\n)\n</code></pre>"},{"location":"reference/#exprdt-minutes","title":"ExprDT minutes","text":""},{"location":"reference/#description_264","title":"Description","text":"<p>Extract the minutes from a Duration type.</p>"},{"location":"reference/#format_143","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_247","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/#examples_240","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2020-1-1\"), high = as.Date(\"2020-1-4\"), interval = \"1d\")\n)\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$diff()$dt$minutes()$alias(\"minutes_diff\")\n)\n</code></pre>"},{"location":"reference/#exprdt-month","title":"ExprDT month","text":""},{"location":"reference/#description_265","title":"Description","text":"<p>Extract month from underlying Date representation. Applies to Date and Datetime columns. Returns the month number starting from 1. The return value ranges from 1 to 12.</p>"},{"location":"reference/#format_144","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_248","title":"Value","text":"<p>Expr of month as UInt32</p>"},{"location":"reference/#examples_241","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$month()$alias(\"month\")\n)\n</code></pre>"},{"location":"reference/#exprdt-nanosecond","title":"ExprDT nanosecond","text":""},{"location":"reference/#description_266","title":"Description","text":"<p>Extract seconds from underlying Datetime representation. Applies to Datetime columns. Returns the integer second number from 0 to 59, or a floating point number from 0 &lt; 60 if <code>fractional=True</code> that includes any milli/micro/nanosecond component.</p>"},{"location":"reference/#format_145","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_249","title":"Value","text":"<p>Expr of second as Int64</p>"},{"location":"reference/#examples_242","title":"Examples","text":"<pre><code>pl$DataFrame(date = pl$date_range(\nas.numeric(as.POSIXct(\"2001-1-1\"))*1E9+123456789, #manually convert to us\nas.numeric(as.POSIXct(\"2001-1-1 00:00:6\"))*1E9,\ninterval = \"1s987654321ns\",\ntime_unit = \"ns\" #instruct polars input is us, and store as us\n))$with_columns(\npl$col(\"date\")$cast(pl$Int64)$alias(\"datetime int64\"),\npl$col(\"date\")$dt$nanosecond()$alias(\"nanosecond\")\n)\n</code></pre>"},{"location":"reference/#exprdt-nanoseconds","title":"ExprDT nanoseconds","text":""},{"location":"reference/#description_267","title":"Description","text":"<p>Extract the nanoseconds from a Duration type.</p>"},{"location":"reference/#format_146","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_250","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/#examples_243","title":"Examples","text":"<pre><code>df = pl$DataFrame(date = pl$date_range(\nlow = as.POSIXct(\"2020-1-1\", tz = \"GMT\"),\nhigh = as.POSIXct(\"2020-1-1 00:00:01\", tz = \"GMT\"),\ninterval = \"1ms\"\n))\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$diff()$dt$nanoseconds()$alias(\"seconds_diff\")\n)\n</code></pre>"},{"location":"reference/#exprdt-offset-by","title":"ExprDT offset by","text":""},{"location":"reference/#description_268","title":"Description","text":"<p>Offset this date by a relative time offset. This differs from <code>pl$col(\"foo_datetime_tu\") + value_tu</code> in that it can take months and leap years into account. Note that only a single minus sign is allowed in the <code>by</code> string, as the first character.</p>"},{"location":"reference/#arguments_146","title":"Arguments","text":"<code>by</code> <p>optional string encoding duration see details.</p>"},{"location":"reference/#format_147","title":"Format","text":"<p>function</p>"},{"location":"reference/#details_90","title":"Details","text":"<p>The <code>by</code> are created with the the following string language:</p> <ul> <li> <p>1ns # 1 nanosecond</p> </li> <li> <p>1us # 1 microsecond</p> </li> <li> <p>1ms # 1 millisecond</p> </li> <li> <p>1s # 1 second</p> </li> <li> <p>1m # 1 minute</p> </li> <li> <p>1h # 1 hour</p> </li> <li> <p>1d # 1 day</p> </li> <li> <p>1w # 1 calendar week</p> </li> <li> <p>1mo # 1 calendar month</p> </li> <li> <p>1y # 1 calendar year</p> </li> <li> <p>1i # 1 index count</p> </li> </ul> <p>These strings can be combined:</p> <ul> <li>3d12h4m25s # 3 days, 12 hours, 4 minutes, and 25 seconds</li> </ul>"},{"location":"reference/#value_251","title":"Value","text":"<p>Date/Datetime expr</p>"},{"location":"reference/#examples_244","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndates = pl$date_range(as.Date(\"2000-1-1\"),as.Date(\"2005-1-1\"), \"1y\")\n)\ndf$select(\npl$col(\"dates\")$dt$offset_by(\"1y\")$alias(\"date_plus_1y\"),\npl$col(\"dates\")$dt$offset_by(\"-1y2mo\")$alias(\"date_min\")\n)\n</code></pre>"},{"location":"reference/#exprdt-ordinal-day","title":"ExprDT ordinal day","text":""},{"location":"reference/#description_269","title":"Description","text":"<p>Extract ordinal day from underlying Date representation. Applies to Date and Datetime columns. Returns the day of year starting from 1. The return value ranges from 1 to 366. (The last day of year differs by years.)</p>"},{"location":"reference/#format_148","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_252","title":"Value","text":"<p>Expr of ordinal_day as UInt32</p>"},{"location":"reference/#examples_245","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$ordinal_day()$alias(\"ordinal_day\")\n)\n</code></pre>"},{"location":"reference/#exprdt-quarter","title":"ExprDT quarter","text":""},{"location":"reference/#description_270","title":"Description","text":"<p>Extract quarter from underlying Date representation. Applies to Date and Datetime columns. Returns the quarter ranging from 1 to 4.</p>"},{"location":"reference/#format_149","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_253","title":"Value","text":"<p>Expr of quater as UInt32</p>"},{"location":"reference/#examples_246","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$quarter()$alias(\"quarter\")\n)\n</code></pre>"},{"location":"reference/#exprdt-replace-time-zone","title":"ExprDT replace time zone","text":""},{"location":"reference/#description_271","title":"Description","text":"<p>Cast time zone for a Series of type Datetime. Different from <code>convert_time_zone</code>, this will also modify the underlying timestamp. Use to correct a wrong time zone annotation. This will change the corresponding global timepoint.</p>"},{"location":"reference/#arguments_147","title":"Arguments","text":"<code>tz</code> <p>Null or string time zone from base::OlsonNames()</p>"},{"location":"reference/#format_150","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_254","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/#examples_247","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2001-3-1\"), high = as.Date(\"2001-7-1\"), interval = \"1mo\")\n)\ndf = df$with_columns(\npl$col(\"date\")\n$dt$replace_time_zone(\"Europe/Amsterdam\")\n$dt$convert_time_zone(\"Europe/London\")\n$alias(\"london_timezone\")\n)\ndf2 = df$with_columns(\npl$col(\"london_timezone\")\n$dt$replace_time_zone(\"Europe/Amsterdam\")\n$alias(\"cast London_to_Amsterdam\"),\npl$col(\"london_timezone\")\n$dt$convert_time_zone(\"Europe/Amsterdam\")\n$alias(\"with London_to_Amsterdam\"),\npl$col(\"london_timezone\")\n$dt$convert_time_zone(\"Europe/Amsterdam\")\n$dt$replace_time_zone(NULL)\n$alias(\"strip tz from with-'Europe/Amsterdam'\")\n)\ndf2\n</code></pre>"},{"location":"reference/#exprdt-round","title":"ExprDT round","text":""},{"location":"reference/#description_272","title":"Description","text":"<p>Divide the date/datetime range into buckets. Each date/datetime in the first half of the interval is mapped to the start of its bucket. Each date/datetime in the second half of the interval is mapped to the end of its bucket.</p>"},{"location":"reference/#arguments_148","title":"Arguments","text":"<code>every</code> <p>string encoding duration see details.</p> <code>ofset</code> <p>optional string encoding duration see details.</p>"},{"location":"reference/#format_151","title":"Format","text":"<p>function</p>"},{"location":"reference/#details_91","title":"Details","text":"<p>The <code>every</code> and <code>offset</code> argument are created with the the following string language:</p> <ul> <li> <p>1ns # 1 nanosecond</p> </li> <li> <p>1us # 1 microsecond</p> </li> <li> <p>1ms # 1 millisecond</p> </li> <li> <p>1s # 1 second</p> </li> <li> <p>1m # 1 minute</p> </li> <li> <p>1h # 1 hour</p> </li> <li> <p>1d # 1 day</p> </li> <li> <p>1w # 1 calendar week</p> </li> <li> <p>1mo # 1 calendar month</p> </li> <li> <p>1y # 1 calendar year These strings can be combined:</p> <ul> <li>3d12h4m25s # 3 days, 12 hours, 4 minutes, and 25 seconds</li> </ul> </li> </ul> <p>This functionality is currently experimental and may change without it being considered a breaking change.</p>"},{"location":"reference/#value_255","title":"Value","text":"<p>Date/Datetime expr</p>"},{"location":"reference/#examples_248","title":"Examples","text":"<pre><code>t1 = as.POSIXct(\"3040-01-01\",tz = \"GMT\")\nt2 = t1 + as.difftime(25,units = \"secs\")\ns = pl$date_range(t1, t2, interval = \"2s\", time_unit = \"ms\")\n#use a dt namespace function\ndf = pl$DataFrame(datetime = s)$with_columns(\npl$col(\"datetime\")$dt$truncate(\"4s\")$alias(\"truncated_4s\"),\npl$col(\"datetime\")$dt$truncate(\"4s\",offset(\"3s\"))$alias(\"truncated_4s_offset_2s\")\n)\ndf\n</code></pre>"},{"location":"reference/#exprdt-second","title":"ExprDT second","text":""},{"location":"reference/#description_273","title":"Description","text":"<p>Extract seconds from underlying Datetime representation. Applies to Datetime columns. Returns the integer second number from 0 to 59, or a floating point number from 0 &lt; 60 if <code>fractional=True</code> that includes any milli/micro/nanosecond component.</p>"},{"location":"reference/#format_152","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_256","title":"Value","text":"<p>Expr of second as UInt32</p>"},{"location":"reference/#examples_249","title":"Examples","text":"<pre><code>pl$DataFrame(date = pl$date_range(\nas.numeric(as.POSIXct(\"2001-1-1\"))*1E6+456789, #manually convert to us\nas.numeric(as.POSIXct(\"2001-1-1 00:00:6\"))*1E6,\ninterval = \"2s654321us\",\ntime_unit = \"us\" #instruct polars input is us, and store as us\n))$with_columns(\npl$col(\"date\")$dt$second()$alias(\"second\"),\npl$col(\"date\")$dt$second(fractional = TRUE)$alias(\"second_frac\")\n)\n</code></pre>"},{"location":"reference/#exprdt-seconds","title":"ExprDT seconds","text":""},{"location":"reference/#description_274","title":"Description","text":"<p>Extract the seconds from a Duration type.</p>"},{"location":"reference/#format_153","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_257","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/#examples_250","title":"Examples","text":"<pre><code>df = pl$DataFrame(date = pl$date_range(\nlow = as.POSIXct(\"2020-1-1\", tz = \"GMT\"),\nhigh = as.POSIXct(\"2020-1-1 00:04:00\", tz = \"GMT\"),\ninterval = \"1m\"\n))\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$diff()$dt$seconds()$alias(\"seconds_diff\")\n)\n</code></pre>"},{"location":"reference/#exprdt-strftime","title":"ExprDT strftime","text":""},{"location":"reference/#description_275","title":"Description","text":"<p>Format Date/Datetime with a formatting rule. See <code>\u2060chrono strftime/strptime &lt;https://docs.rs/chrono/latest/chrono/format/strftime/index.html&gt;\u2060</code>_.</p>"},{"location":"reference/#arguments_149","title":"Arguments","text":"<code>fmt</code> <p>string format very much like in R passed to chrono</p>"},{"location":"reference/#format_154","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_258","title":"Value","text":"<p>Date/Datetime expr</p>"},{"location":"reference/#examples_251","title":"Examples","text":"<pre><code>pl$lit(as.POSIXct(\"2021-01-02 12:13:14\",tz=\"GMT\"))$dt$strftime(\"this is the year: %Y\")$to_r()\n</code></pre>"},{"location":"reference/#exprdt-timestamp","title":"ExprDT timestamp","text":""},{"location":"reference/#description_276","title":"Description","text":"<p>Return a timestamp in the given time unit.</p>"},{"location":"reference/#arguments_150","title":"Arguments","text":"<code>tu</code> <p>string option either 'ns', 'us', or 'ms'</p>"},{"location":"reference/#format_155","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_259","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/#examples_252","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2001-1-1\"), high = as.Date(\"2001-1-3\"), interval = \"1d\")\n)\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$dt$timestamp()$alias(\"timestamp_ns\"),\npl$col(\"date\")$dt$timestamp(tu=\"ms\")$alias(\"timestamp_ms\")\n)\n</code></pre>"},{"location":"reference/#exprdt-truncate","title":"ExprDT truncate","text":""},{"location":"reference/#description_277","title":"Description","text":"<p>Divide the date/datetime range into buckets. Each date/datetime is mapped to the start of its bucket.</p>"},{"location":"reference/#arguments_151","title":"Arguments","text":"<code>every</code> <p>string encoding duration see details.</p> <code>ofset</code> <p>optional string encoding duration see details.</p>"},{"location":"reference/#format_156","title":"Format","text":"<p>function</p>"},{"location":"reference/#details_92","title":"Details","text":"<p>The <code>every</code> and <code>offset</code> argument are created with the the following string language:</p> <ul> <li> <p>1ns # 1 nanosecond</p> </li> <li> <p>1us # 1 microsecond</p> </li> <li> <p>1ms # 1 millisecond</p> </li> <li> <p>1s # 1 second</p> </li> <li> <p>1m # 1 minute</p> </li> <li> <p>1h # 1 hour</p> </li> <li> <p>1d # 1 day</p> </li> <li> <p>1w # 1 calendar week</p> </li> <li> <p>1mo # 1 calendar month</p> </li> <li> <p>1y # 1 calendar year These strings can be combined:</p> <ul> <li>3d12h4m25s # 3 days, 12 hours, 4 minutes, and 25 seconds</li> </ul> </li> </ul>"},{"location":"reference/#value_260","title":"Value","text":"<p>Date/Datetime expr</p>"},{"location":"reference/#examples_253","title":"Examples","text":"<pre><code>t1 = as.POSIXct(\"3040-01-01\",tz = \"GMT\")\nt2 = t1 + as.difftime(25,units = \"secs\")\ns = pl$date_range(t1, t2, interval = \"2s\", time_unit = \"ms\")\n#use a dt namespace function\ndf = pl$DataFrame(datetime = s)$with_columns(\npl$col(\"datetime\")$dt$truncate(\"4s\")$alias(\"truncated_4s\"),\npl$col(\"datetime\")$dt$truncate(\"4s\",offset(\"3s\"))$alias(\"truncated_4s_offset_2s\")\n)\ndf\n</code></pre>"},{"location":"reference/#exprdt-tz-localize","title":"ExprDT tz localize","text":""},{"location":"reference/#description_278","title":"Description","text":"<p>Localize tz-naive Datetime Series to tz-aware Datetime Series. This method takes a naive Datetime Series and makes this time zone aware. It does not move the time to another time zone.</p>"},{"location":"reference/#arguments_152","title":"Arguments","text":"<code>tz</code> <p>string of time zone (no NULL allowed) see allowed timezone in base::OlsonNames()</p>"},{"location":"reference/#format_157","title":"Format","text":"<p>function</p>"},{"location":"reference/#details_93","title":"Details","text":"<p>In R as modifying tzone attribute manually but takes into account summertime. See unittest \"dt$convert_time_zone dt$tz_localize\" for a more detailed comparison to base R.</p>"},{"location":"reference/#value_261","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/#examples_254","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2001-3-1\"), high = as.Date(\"2001-7-1\"), interval = \"1mo\")\n)\ndf = df$with_columns(\npl$col(\"date\")\n$dt$replace_time_zone(\"Europe/Amsterdam\")\n$dt$convert_time_zone(\"Europe/London\")\n$alias(\"london_timezone\"),\npl$col(\"date\")\n$dt$tz_localize(\"Europe/London\")\n$alias(\"tz_loc_london\")\n)\ndf2 = df$with_columns(\npl$col(\"london_timezone\")\n$dt$replace_time_zone(\"Europe/Amsterdam\")\n$alias(\"cast London_to_Amsterdam\"),\npl$col(\"london_timezone\")\n$dt$convert_time_zone(\"Europe/Amsterdam\")\n$alias(\"with London_to_Amsterdam\"),\npl$col(\"london_timezone\")\n$dt$convert_time_zone(\"Europe/Amsterdam\")\n$dt$replace_time_zone(NULL)\n$alias(\"strip tz from with-'Europe/Amsterdam'\")\n)\ndf2\n</code></pre>"},{"location":"reference/#exprdt-week","title":"ExprDT week","text":""},{"location":"reference/#description_279","title":"Description","text":"<p>Extract the week from the underlying Date representation. Applies to Date and Datetime columns. Returns the ISO week number starting from 1. The return value ranges from 1 to 53. (The last week of year differs by years.)</p>"},{"location":"reference/#format_158","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_262","title":"Value","text":"<p>Expr of week as UInt32</p>"},{"location":"reference/#examples_255","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$week()$alias(\"week\")\n)\n</code></pre>"},{"location":"reference/#exprdt-weekday","title":"ExprDT weekday","text":""},{"location":"reference/#description_280","title":"Description","text":"<p>Extract the week day from the underlying Date representation. Applies to Date and Datetime columns. Returns the ISO weekday number where monday = 1 and sunday = 7</p>"},{"location":"reference/#format_159","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_263","title":"Value","text":"<p>Expr of weekday as UInt32</p>"},{"location":"reference/#examples_256","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$weekday()$alias(\"weekday\")\n)\n</code></pre>"},{"location":"reference/#exprdt-with-time-unit","title":"ExprDT with time unit","text":""},{"location":"reference/#description_281","title":"Description","text":"<p>Set time unit of a Series of dtype Datetime or Duration. This does not modify underlying data, and should be used to fix an incorrect time unit. The corresponding global timepoint will change.</p>"},{"location":"reference/#arguments_153","title":"Arguments","text":"<code>tu</code> <p>string option either 'ns', 'us', or 'ms'</p>"},{"location":"reference/#format_160","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_264","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/#examples_257","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2001-1-1\"), high = as.Date(\"2001-1-3\"), interval = \"1d\")\n)\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$dt$with_time_unit()$alias(\"with_time_unit_ns\"),\npl$col(\"date\")$dt$with_time_unit(tu=\"ms\")$alias(\"with_time_unit_ms\")\n)\n</code></pre>"},{"location":"reference/#exprdt-year","title":"ExprDT year","text":""},{"location":"reference/#description_282","title":"Description","text":"<p>Extract year from underlying Date representation. Applies to Date and Datetime columns. Returns the year number in the calendar date.</p>"},{"location":"reference/#format_161","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_265","title":"Value","text":"<p>Expr of Year as Int32</p>"},{"location":"reference/#examples_258","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$year()$alias(\"year\"),\npl$col(\"date\")$dt$iso_year()$alias(\"iso_year\")\n)\n</code></pre>"},{"location":"reference/#exprmeta-eq","title":"ExprMeta eq","text":""},{"location":"reference/#description_283","title":"Description","text":"<p>Are two expressions on a meta level equal</p>"},{"location":"reference/#arguments_154","title":"Arguments","text":"<code>other</code> <p>Expr to compare with</p>"},{"location":"reference/#value_266","title":"Value","text":"<p>bool: TRUE if equal</p>"},{"location":"reference/#examples_259","title":"Examples","text":"<pre><code>#three naive expression literals\ne1 = pl$lit(40) + 2\ne2 = pl$lit(42)\ne3 = pl$lit(40) +2\n#e1 and e3 are identical expressions\ne1$meta$eq(e3)\n#e_test is an expression testing whether e1 and e2 evaluates to the same value.\ne_test = e1 == e2 # or e_test = e1$eq(e2)\n#direct evaluate e_test, possible because only made up of literals\ne_test$to_r()\n#e1 and e2 are on the meta-level NOT identical expressions\ne1$meta$neq(e2)\n</code></pre>"},{"location":"reference/#exprmeta-has-multiple-outputs","title":"ExprMeta has multiple outputs","text":""},{"location":"reference/#description_284","title":"Description","text":"<p>Whether this expression expands into multiple expressions.</p>"},{"location":"reference/#value_267","title":"Value","text":"<p>Bool</p>"},{"location":"reference/#examples_260","title":"Examples","text":"<pre><code>pl$all()$meta$has_multiple_outputs()\npl$col(\"some_colname\")$meta$has_multiple_outputs()\n</code></pre>"},{"location":"reference/#exprmeta-is-regex-projection","title":"ExprMeta is regex projection","text":""},{"location":"reference/#description_285","title":"Description","text":"<p>Whether this expression expands to columns that match a regex pattern.</p>"},{"location":"reference/#value_268","title":"Value","text":"<p>Bool</p>"},{"location":"reference/#examples_261","title":"Examples","text":"<pre><code>pl$col(\"^Sepal.*$\")$meta$is_regex_projection()\npl$col(\"Sepal.Length\")$meta$is_regex_projection()\n</code></pre>"},{"location":"reference/#exprmeta-neq","title":"ExprMeta neq","text":""},{"location":"reference/#description_286","title":"Description","text":"<p>Are two expressions on a meta level NOT equal</p>"},{"location":"reference/#arguments_155","title":"Arguments","text":"<code>other</code> <p>Expr to compare with</p>"},{"location":"reference/#value_269","title":"Value","text":"<p>bool: TRUE if NOT equal</p>"},{"location":"reference/#examples_262","title":"Examples","text":"<pre><code>#three naive expression literals\ne1 = pl$lit(40) + 2\ne2 = pl$lit(42)\ne3 = pl$lit(40) +2\n#e1 and e3 are identical expressions\ne1$meta$eq(e3)\n#e_test is an expression testing whether e1 and e2 evaluates to the same value.\ne_test = e1 == e2 # or e_test = e1$eq(e2)\n#direct evaluate e_test, possible because only made up of literals\ne_test$to_r()\n#e1 and e2 are on the meta-level NOT identical expressions\ne1$meta$neq(e2)\n</code></pre>"},{"location":"reference/#exprmeta-output-name","title":"ExprMeta output name","text":""},{"location":"reference/#description_287","title":"Description","text":"<p>Get the column name that this expression would produce. It might not always be possible to determine the output name as it might depend on the schema of the context. In that case this will raise an error.</p>"},{"location":"reference/#value_270","title":"Value","text":"<p>R charvec of output names.</p>"},{"location":"reference/#examples_263","title":"Examples","text":"<pre><code>e = pl$col(\"alice\")$alias(\"bob\")\ne$meta$root_names() == \"alice\"\ne$meta$output_name() == \"bob\"\ne$meta$undo_aliases()$meta$output_name() == \"alice\"\n</code></pre>"},{"location":"reference/#exprmeta-pop","title":"ExprMeta pop","text":""},{"location":"reference/#description_288","title":"Description","text":"<p>Pop the latest expression and return the input(s) of the popped expression.</p>"},{"location":"reference/#value_271","title":"Value","text":"<p>R list of Expr(s) usually one, only multiple if top Expr took more Expr as input.</p>"},{"location":"reference/#examples_264","title":"Examples","text":"<pre><code>e1 = pl$lit(40) + 2\ne2 = pl$lit(42)$sum()\ne1\ne1$meta$pop()\ne2\ne2$meta$pop()\n</code></pre>"},{"location":"reference/#exprmeta-root-names","title":"ExprMeta root names","text":""},{"location":"reference/#description_289","title":"Description","text":"<p>Get a vector with the root column name</p>"},{"location":"reference/#value_272","title":"Value","text":"<p>R charvec of root names.</p>"},{"location":"reference/#examples_265","title":"Examples","text":"<pre><code>e = pl$col(\"alice\")$alias(\"bob\")\ne$meta$root_names() == \"alice\"\ne$meta$output_name() == \"bob\"\ne$meta$undo_aliases()$meta$output_name() == \"alice\"\n</code></pre>"},{"location":"reference/#exprmeta-undo-aliases","title":"ExprMeta undo aliases","text":""},{"location":"reference/#description_290","title":"Description","text":"<p>Undo any renaming operation like <code>alias</code> or <code>keep_name</code>.</p>"},{"location":"reference/#value_273","title":"Value","text":"<p>Expr with aliases undone</p>"},{"location":"reference/#examples_266","title":"Examples","text":"<pre><code>e = pl$col(\"alice\")$alias(\"bob\")\ne$meta$root_names() == \"alice\"\ne$meta$output_name() == \"bob\"\ne$meta$undo_aliases()$meta$output_name() == \"alice\"\n</code></pre>"},{"location":"reference/#exprstr-concat","title":"ExprStr concat","text":""},{"location":"reference/#description_291","title":"Description","text":"<p>Vertically concat the values in the Series to a single string value.</p>"},{"location":"reference/#arguments_156","title":"Arguments","text":"<code>delimiter</code> <p>string The delimiter to insert between consecutive string values.</p>"},{"location":"reference/#value_274","title":"Value","text":"<p>Expr of Utf8 concatenated</p>"},{"location":"reference/#examples_267","title":"Examples","text":"<pre><code>#concatenate a Series of strings to a single string\ndf = pl$DataFrame(foo = c(\"1\", NA, 2))\ndf$select(pl$col(\"foo\")$str$concat(\"-\"))\n#Series list of strings to Series of concatenated strings\ndf = pl$DataFrame(list(bar = list(c(\"a\",\"b\", \"c\"), c(\"1\",\"2\",NA))))\ndf$select(pl$col(\"bar\")$arr$eval(pl$col()$str$concat())$arr$first())\n</code></pre>"},{"location":"reference/#exprstr-contains","title":"ExprStr contains","text":""},{"location":"reference/#description_292","title":"Description","text":"<p>R Check if string contains a substring that matches a regex.</p>"},{"location":"reference/#arguments_157","title":"Arguments","text":"<code>pattern</code> <p>String or Expr of a string, a valid regex pattern.</p> <code>literal</code> <p>bool, treat pattern as a literal string. NULL is aliased with FALSE.</p> <code>strict</code> <p>bool, raise an error if the underlying pattern is not a valid regex expression, otherwise mask out with a null value.</p>"},{"location":"reference/#details_94","title":"Details","text":"<p>starts_with : Check if string values start with a substring. ends_with : Check if string values end with a substring.</p>"},{"location":"reference/#value_275","title":"Value","text":"<p>Expr returning a Boolean</p>"},{"location":"reference/#examples_268","title":"Examples","text":"<pre><code>df = pl$DataFrame(a = c(\"Crab\", \"cat and dog\", \"rab$bit\", NA))\ndf$select(\npl$col(\"a\"),\npl$col(\"a\")$str$contains(\"cat|bit\")$alias(\"regex\"),\npl$col(\"a\")$str$contains(\"rab$\", literal=TRUE)$alias(\"literal\")\n)\n</code></pre>"},{"location":"reference/#exprstr-count-match","title":"ExprStr count match","text":""},{"location":"reference/#description_293","title":"Description","text":"<p>Count all successive non-overlapping regex matches.</p>"},{"location":"reference/#arguments_158","title":"Arguments","text":"<code>pattern</code> <p>A valid regex pattern</p>"},{"location":"reference/#value_276","title":"Value","text":"<p>UInt32 array. Contain null if original value is null or regex capture nothing.</p>"},{"location":"reference/#examples_269","title":"Examples","text":"<pre><code>df = pl$DataFrame( foo = c(\"123 bla 45 asd\", \"xyz 678 910t\"))\ndf$select(\npl$col(\"foo\")$str$count_match(r\"{(\\d)}\")$alias(\"count digits\")\n)\n</code></pre>"},{"location":"reference/#exprstr-decode","title":"ExprStr decode","text":""},{"location":"reference/#description_294","title":"Description","text":"<p>Decode a value using the provided encoding.</p>"},{"location":"reference/#arguments_159","title":"Arguments","text":"<code>encoding</code> <p>string choice either 'hex' or 'base64'</p> <code>...</code> <p>not used currently</p> <code>strict</code> <p>Raise an error if the underlying value cannot be decoded, otherwise mask out with a null value.</p>"},{"location":"reference/#value_277","title":"Value","text":"<p>Utf8 array with values decoded using provided encoding</p>"},{"location":"reference/#examples_270","title":"Examples","text":"<pre><code>df = pl$DataFrame( strings = c(\"foo\", \"bar\", NA))\ndf$select(pl$col(\"strings\")$str$encode(\"hex\"))\ndf$with_columns(\npl$col(\"strings\")$str$encode(\"base64\")$alias(\"base64\"), #notice DataType is not encoded\npl$col(\"strings\")$str$encode(\"hex\")$alias(\"hex\")   #... and must restored with cast\n)$with_columns(\npl$col(\"base64\")$str$decode(\"base64\")$alias(\"base64_decoded\")$cast(pl$Utf8),\npl$col(\"hex\")$str$decode(\"hex\")$alias(\"hex_decoded\")$cast(pl$Utf8)\n)\n</code></pre>"},{"location":"reference/#exprstr-encode","title":"ExprStr encode","text":""},{"location":"reference/#description_295","title":"Description","text":"<p>Encode a value using the provided encoding.</p>"},{"location":"reference/#arguments_160","title":"Arguments","text":"<code>encoding</code> <p>string choice either 'hex' or 'base64'</p>"},{"location":"reference/#value_278","title":"Value","text":"<p>Utf8 array with values encoded using provided encoding</p>"},{"location":"reference/#examples_271","title":"Examples","text":"<pre><code>df = pl$DataFrame( strings = c(\"foo\", \"bar\", NA))\ndf$select(pl$col(\"strings\")$str$encode(\"hex\"))\ndf$with_columns(\npl$col(\"strings\")$str$encode(\"base64\")$alias(\"base64\"), #notice DataType is not encoded\npl$col(\"strings\")$str$encode(\"hex\")$alias(\"hex\")   #... and must restored with cast\n)$with_columns(\npl$col(\"base64\")$str$decode(\"base64\")$alias(\"base64_decoded\")$cast(pl$Utf8),\npl$col(\"hex\")$str$decode(\"hex\")$alias(\"hex_decoded\")$cast(pl$Utf8)\n)\n</code></pre>"},{"location":"reference/#exprstr-ends-with","title":"ExprStr ends with","text":""},{"location":"reference/#description_296","title":"Description","text":"<p>Check if string values end with a substring.</p>"},{"location":"reference/#arguments_161","title":"Arguments","text":"<code>sub</code> <p>Suffix substring or Expr.</p>"},{"location":"reference/#details_95","title":"Details","text":"<p>contains : Check if string contains a substring that matches a regex. starts_with : Check if string values start with a substring.</p>"},{"location":"reference/#value_279","title":"Value","text":"<p>Expr returning a Boolean</p>"},{"location":"reference/#examples_272","title":"Examples","text":"<pre><code>df = pl$DataFrame(fruits = c(\"apple\", \"mango\", NA))\ndf$select(\npl$col(\"fruits\"),\npl$col(\"fruits\")$str$ends_with(\"go\")$alias(\"has_suffix\")\n)\n</code></pre>"},{"location":"reference/#exprstr-explode","title":"ExprStr explode","text":""},{"location":"reference/#description_297","title":"Description","text":"<p>Returns a column with a separate row for every string character.</p>"},{"location":"reference/#value_280","title":"Value","text":"<p>Expr: Series of dtype Utf8.</p>"},{"location":"reference/#examples_273","title":"Examples","text":"<pre><code>df = pl$DataFrame(a = c(\"foo\", \"bar\"))\ndf$select(pl$col(\"a\")$str$explode())\n</code></pre>"},{"location":"reference/#exprstr-extract-all","title":"ExprStr extract all","text":""},{"location":"reference/#description_298","title":"Description","text":"<p>Extracts all matches for the given regex pattern. Extracts each successive non-overlapping regex match in an individual string as an array.</p>"},{"location":"reference/#arguments_162","title":"Arguments","text":"<code>pattern</code> <p>A valid regex pattern</p>"},{"location":"reference/#value_281","title":"Value","text":"<p><code>List[Utf8]</code> array. Contain null if original value is null or regex capture nothing.</p>"},{"location":"reference/#examples_274","title":"Examples","text":"<pre><code>df = pl$DataFrame( foo = c(\"123 bla 45 asd\", \"xyz 678 910t\"))\ndf$select(\npl$col(\"foo\")$str$extract_all(r\"((\\d+))\")$alias(\"extracted_nrs\")\n)\n</code></pre>"},{"location":"reference/#exprstr-extract","title":"ExprStr extract","text":""},{"location":"reference/#description_299","title":"Description","text":"<p>Extract the target capture group from provided patterns.</p>"},{"location":"reference/#arguments_163","title":"Arguments","text":"<code>pattern</code> <p>A valid regex pattern</p> <code>group_index</code> <p>Index of the targeted capture group. Group 0 mean the whole pattern, first group begin at index 1. Default to the first capture group.</p>"},{"location":"reference/#value_282","title":"Value","text":"<p>Utf8 array. Contain null if original value is null or regex capture nothing.</p>"},{"location":"reference/#examples_275","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na =  c(\n\"http://vote.com/ballon_dor?candidate=messi&amp;ref=polars\",\n\"http://vote.com/ballon_dor?candidat=jorginho&amp;ref=polars\",\n\"http://vote.com/ballon_dor?candidate=ronaldo&amp;ref=polars\"\n)\n)\ndf$select(\npl$col(\"a\")$str$extract(r\"(candidate=(\\w+))\", 1)\n)\n</code></pre>"},{"location":"reference/#exprstr-json-extract","title":"ExprStr json extract","text":""},{"location":"reference/#description_300","title":"Description","text":"<p>Parse string values as JSON.</p>"},{"location":"reference/#arguments_164","title":"Arguments","text":"<code>dtype</code> <p>The dtype to cast the extracted value to. If None, the dtype will be inferred from the JSON value.</p>"},{"location":"reference/#details_96","title":"Details","text":"<p>Throw errors if encounter invalid json strings.</p>"},{"location":"reference/#value_283","title":"Value","text":"<p>Expr returning a boolean</p>"},{"location":"reference/#examples_276","title":"Examples","text":"<pre><code>df = pl$DataFrame(\njson_val =  c('{\"a\":1, \"b\": true}', NA, '{\"a\":2, \"b\": false}')\n)\ndtype = pl$Struct(pl$Field(\"a\", pl$Int64), pl$Field(\"b\", pl$Boolean))\ndf$select(pl$col(\"json_val\")$str$json_extract(dtype))\n</code></pre>"},{"location":"reference/#exprstr-json-path-match","title":"ExprStr json path match","text":""},{"location":"reference/#description_301","title":"Description","text":"<p>Extract the first match of json string with provided JSONPath expression.</p>"},{"location":"reference/#arguments_165","title":"Arguments","text":"<code>json_path</code> <p>A valid JSON path query string.</p>"},{"location":"reference/#details_97","title":"Details","text":"<p>Throw errors if encounter invalid json strings. All return value will be casted to Utf8 regardless of the original value. Documentation on JSONPath standard can be found <code>\u2060here &lt;https://goessner.net/articles/JsonPath/&gt;\u2060</code>_.</p>"},{"location":"reference/#value_284","title":"Value","text":"<p>Utf8 array. Contain null if original value is null or the json_path return nothing.</p>"},{"location":"reference/#examples_277","title":"Examples","text":"<pre><code>df = pl$DataFrame(\njson_val =  c('{\"a\":\"1\"}', NA, '{\"a\":2}', '{\"a\":2.1}', '{\"a\":true}')\n)\ndf$select(pl$col(\"json_val\")$str$json_path_match(\"$.a\"))\n</code></pre>"},{"location":"reference/#exprstr-lengths","title":"ExprStr lengths","text":""},{"location":"reference/#description_302","title":"Description","text":"<p>Get length of the strings as UInt32 (as number of bytes).</p>"},{"location":"reference/#format_162","title":"Format","text":"<p>function</p>"},{"location":"reference/#details_98","title":"Details","text":"<p>The returned lengths are equal to the number of bytes in the UTF8 string. If you need the length in terms of the number of characters, use <code>n_chars</code> instead.</p>"},{"location":"reference/#value_285","title":"Value","text":"<p>Expr of u32 lengths</p>"},{"location":"reference/#examples_278","title":"Examples","text":"<pre><code>pl$DataFrame(\ns = c(\"Caf\u00e9\", NA, \"345\", \"\u00e6\u00f8\u00e5\")\n)$select(\npl$col(\"s\"),\npl$col(\"s\")$str$lengths()$alias(\"lengths\"),\npl$col(\"s\")$str$n_chars()$alias(\"n_chars\")\n)\n</code></pre>"},{"location":"reference/#exprstr-ljust","title":"ExprStr ljust","text":""},{"location":"reference/#description_303","title":"Description","text":"<p>Return the string left justified in a string of length <code>width</code>.</p>"},{"location":"reference/#arguments_166","title":"Arguments","text":"<code>width</code> <p>Justify left to this length.</p> <code>fillchar</code> <p>Fill with this ASCII character.</p>"},{"location":"reference/#details_99","title":"Details","text":"<p>Padding is done using the specified <code>fillchar</code>. The original string is returned if <code>width</code> is less than or equal to <code>len(s)</code>.</p>"},{"location":"reference/#value_286","title":"Value","text":"<p>Expr of Utf8</p>"},{"location":"reference/#examples_279","title":"Examples","text":"<pre><code>df = pl$DataFrame(a = c(\"cow\", \"monkey\", NA, \"hippopotamus\"))\ndf$select(pl$col(\"a\")$str$ljust(8, \"*\"))\n</code></pre>"},{"location":"reference/#exprstr-lstrip","title":"ExprStr lstrip","text":""},{"location":"reference/#description_304","title":"Description","text":"<p>Remove leading characters.</p>"},{"location":"reference/#arguments_167","title":"Arguments","text":"<code>matches</code> <p>The set of characters to be removed. All combinations of this set of characters will be stripped. If set to NULL (default), all whitespace is removed instead.</p>"},{"location":"reference/#details_100","title":"Details","text":"<p>will not strip anyt chars beyond the first char not matched. <code>strip()</code> starts from both left and right. Whereas <code>lstrip()</code>and <code>rstrip()</code> starts from left and right respectively.</p>"},{"location":"reference/#value_287","title":"Value","text":"<p>Expr of Utf8 lowercase chars</p>"},{"location":"reference/#examples_280","title":"Examples","text":"<pre><code>df = pl$DataFrame(foo = c(\" hello\", \"\\tworld\"))\ndf$select(pl$col(\"foo\")$str$strip())\ndf$select(pl$col(\"foo\")$str$strip(\" hel rld\"))\ndf$select(pl$col(\"foo\")$str$lstrip(\" hel rld\"))\ndf$select(pl$col(\"foo\")$str$rstrip(\" hel\\trld\"))\ndf$select(pl$col(\"foo\")$str$rstrip(\"rldhel\\t \"))\n</code></pre>"},{"location":"reference/#exprstr-n-chars","title":"ExprStr n chars","text":""},{"location":"reference/#description_305","title":"Description","text":"<p>Get length of the strings as UInt32 (as number of chars).</p>"},{"location":"reference/#format_163","title":"Format","text":"<p>function</p>"},{"location":"reference/#details_101","title":"Details","text":"<p>If you know that you are working with ASCII text, <code>lengths</code> will be equivalent, and faster (returns length in terms of the number of bytes).</p>"},{"location":"reference/#value_288","title":"Value","text":"<p>Expr of u32 n_chars</p>"},{"location":"reference/#examples_281","title":"Examples","text":"<pre><code>pl$DataFrame(\ns = c(\"Caf\u00e9\", NA, \"345\", \"\u00e6\u00f8\u00e5\")\n)$select(\npl$col(\"s\"),\npl$col(\"s\")$str$lengths()$alias(\"lengths\"),\npl$col(\"s\")$str$n_chars()$alias(\"n_chars\")\n)\n</code></pre>"},{"location":"reference/#exprstr-parse-int","title":"ExprStr parse int","text":""},{"location":"reference/#description_306","title":"Description","text":"<p>Parse integers with base radix from strings. By default base 2.</p>"},{"location":"reference/#arguments_168","title":"Arguments","text":"<code>radix</code> <p>Positive integer which is the base of the string we are parsing. Default: 2</p>"},{"location":"reference/#value_289","title":"Value","text":"<p>Expr: Series of dtype i32.</p>"},{"location":"reference/#examples_282","title":"Examples","text":"<pre><code>df = pl$DataFrame(bin = c(\"110\", \"101\", \"010\"))\ndf$select(pl$col(\"bin\")$str$parse_int(2))\n</code></pre>"},{"location":"reference/#exprstr-replace-all","title":"ExprStr replace all","text":""},{"location":"reference/#description_307","title":"Description","text":"<p>Replace all matching regex/literal substrings with a new string value.</p>"},{"location":"reference/#arguments_169","title":"Arguments","text":"<code>pattern</code> <p>Into, regex pattern</p> <code>value</code> <p>Into replcacement</p> <code>literal</code> <p>bool, treat pattern as a literal string.</p>"},{"location":"reference/#value_290","title":"Value","text":"<p>Expr of Utf8 Series</p>"},{"location":"reference/#see-also","title":"See Also","text":"<p>replace : Replace first matching regex/literal substring.</p>"},{"location":"reference/#examples_283","title":"Examples","text":"<pre><code>df = pl$DataFrame(id = c(1, 2), text = c(\"abcabc\", \"123a123\"))\ndf$with_columns(\npl$col(\"text\")$str$replace_all(\"a\", \"-\")\n)\n</code></pre>"},{"location":"reference/#exprstr-replace","title":"ExprStr replace","text":""},{"location":"reference/#description_308","title":"Description","text":"<p>Replace first matching regex/literal substring with a new string value.</p>"},{"location":"reference/#arguments_170","title":"Arguments","text":"<code>pattern</code> <p>Into, regex pattern</p> <code>value</code> <p>Into replcacement</p> <code>literal</code> <p>bool, Treat pattern as a literal string.</p>"},{"location":"reference/#value_291","title":"Value","text":"<p>Expr of Utf8 Series</p>"},{"location":"reference/#see-also_1","title":"See Also","text":"<p>replace_all : Replace all matching regex/literal substrings.</p>"},{"location":"reference/#examples_284","title":"Examples","text":"<pre><code>df = pl$DataFrame(id = c(1, 2), text = c(\"123abc\", \"abc456\"))\ndf$with_columns(\npl$col(\"text\")$str$replace(r\"{abc\\b}\", \"ABC\")\n)\n</code></pre>"},{"location":"reference/#exprstr-rjust","title":"ExprStr rjust","text":""},{"location":"reference/#description_309","title":"Description","text":"<p>Return the string left justified in a string of length <code>width</code>.</p>"},{"location":"reference/#arguments_171","title":"Arguments","text":"<code>width</code> <p>Justify left to this length.</p> <code>fillchar</code> <p>Fill with this ASCII character.</p>"},{"location":"reference/#details_102","title":"Details","text":"<p>Padding is done using the specified <code>fillchar</code>. The original string is returned if <code>width</code> is less than or equal to <code>len(s)</code>.</p>"},{"location":"reference/#value_292","title":"Value","text":"<p>Expr of Utf8</p>"},{"location":"reference/#examples_285","title":"Examples","text":"<pre><code>df = pl$DataFrame(a = c(\"cow\", \"monkey\", NA, \"hippopotamus\"))\ndf$select(pl$col(\"a\")$str$rjust(8, \"*\"))\n</code></pre>"},{"location":"reference/#exprstr-rstrip","title":"ExprStr rstrip","text":""},{"location":"reference/#description_310","title":"Description","text":"<p>Remove leading characters.</p>"},{"location":"reference/#arguments_172","title":"Arguments","text":"<code>matches</code> <p>The set of characters to be removed. All combinations of this set of characters will be stripped. If set to NULL (default), all whitespace is removed instead.</p>"},{"location":"reference/#details_103","title":"Details","text":"<p>will not strip anyt chars beyond the first char not matched. <code>strip()</code> starts from both left and right. Whereas <code>rstrip()</code>and <code>rstrip()</code> starts from left and right respectively.</p>"},{"location":"reference/#value_293","title":"Value","text":"<p>Expr of Utf8 lowercase chars</p>"},{"location":"reference/#examples_286","title":"Examples","text":"<pre><code>df = pl$DataFrame(foo = c(\" hello\", \"\\tworld\"))\ndf$select(pl$col(\"foo\")$str$strip())\ndf$select(pl$col(\"foo\")$str$strip(\" hel rld\"))\ndf$select(pl$col(\"foo\")$str$lstrip(\" hel rld\"))\ndf$select(pl$col(\"foo\")$str$rstrip(\" hel\\trld\"))\ndf$select(pl$col(\"foo\")$str$rstrip(\"rldhel\\t \"))\n</code></pre>"},{"location":"reference/#exprstr-slice","title":"ExprStr slice","text":""},{"location":"reference/#description_311","title":"Description","text":"<p>Create subslices of the string values of a Utf8 Series.</p>"},{"location":"reference/#arguments_173","title":"Arguments","text":"<code>pattern</code> <p>Into, regex pattern</p> <code>value</code> <p>Into replcacement</p> <code>literal</code> <p>bool, treat pattern as a literal string.</p>"},{"location":"reference/#value_294","title":"Value","text":"<p>Expr: Series of dtype Utf8.</p>"},{"location":"reference/#examples_287","title":"Examples","text":"<pre><code>df = pl$DataFrame(s = c(\"pear\", NA, \"papaya\", \"dragonfruit\"))\ndf$with_columns(\npl$col(\"s\")$str$slice(-3)$alias(\"s_sliced\")\n)\n</code></pre>"},{"location":"reference/#exprstr-split-exact","title":"ExprStr split exact","text":""},{"location":"reference/#description_312","title":"Description","text":"<p>Split the string by a substring using <code>n</code> splits. Results in a struct of <code>n+1</code> fields. If it cannot make <code>n</code> splits, the remaining field elements will be null.</p>"},{"location":"reference/#arguments_174","title":"Arguments","text":"<code>by</code> <p>Substring to split by.</p> <code>n</code> <p>Number of splits to make.</p> <code>inclusive</code> <p>If True, include the split_exact character/string in the results.</p>"},{"location":"reference/#value_295","title":"Value","text":"<p>Struct where each of n+1 fields is of Utf8 type</p>"},{"location":"reference/#examples_288","title":"Examples","text":"<pre><code>df = pl$DataFrame(s = c(\"a_1\", NA, \"c\", \"d_4\"))\ndf$select( pl$col(\"s\")$str$split_exact(by=\"_\",1))\n</code></pre>"},{"location":"reference/#exprstr-split","title":"ExprStr split","text":""},{"location":"reference/#description_313","title":"Description","text":"<p>Split the string by a substring.</p>"},{"location":"reference/#arguments_175","title":"Arguments","text":"<code>by</code> <p>Substring to split by.</p> <code>inclusive</code> <p>If True, include the split character/string in the results.</p>"},{"location":"reference/#value_296","title":"Value","text":"<p>List of Utf8 type</p>"},{"location":"reference/#examples_289","title":"Examples","text":"<pre><code>df = pl$DataFrame(s = c(\"foo bar\", \"foo-bar\", \"foo bar baz\"))\ndf$select( pl$col(\"s\")$str$split(by=\" \"))\n</code></pre>"},{"location":"reference/#exprstr-splitn","title":"ExprStr splitn","text":""},{"location":"reference/#description_314","title":"Description","text":"<p>Split the string by a substring, restricted to returning at most <code>n</code> items. If the number of possible splits is less than <code>n-1</code>, the remaining field elements will be null. If the number of possible splits is <code>n-1</code> or greater, the last (nth) substring will contain the remainder of the string.</p>"},{"location":"reference/#arguments_176","title":"Arguments","text":"<code>by</code> <p>Substring to split by.</p> <code>n</code> <p>Number of splits to make.</p>"},{"location":"reference/#value_297","title":"Value","text":"<p>Struct where each of n+1 fields is of Utf8 type</p>"},{"location":"reference/#examples_290","title":"Examples","text":"<pre><code>df = pl$DataFrame(s = c(\"a_1\", NA, \"c\", \"d_4\"))\ndf$select( pl$col(\"s\")$str$splitn(by=\"_\",0))\ndf$select( pl$col(\"s\")$str$splitn(by=\"_\",1))\ndf$select( pl$col(\"s\")$str$splitn(by=\"_\",2))\n</code></pre>"},{"location":"reference/#exprstr-starts-with","title":"ExprStr starts with","text":""},{"location":"reference/#description_315","title":"Description","text":"<p>Check if string values starts with a substring.</p>"},{"location":"reference/#arguments_177","title":"Arguments","text":"<code>sub</code> <p>Prefix substring or Expr.</p>"},{"location":"reference/#details_104","title":"Details","text":"<p>contains : Check if string contains a substring that matches a regex. ends_with : Check if string values end with a substring.</p>"},{"location":"reference/#value_298","title":"Value","text":"<p>Expr returning a Boolean</p>"},{"location":"reference/#examples_291","title":"Examples","text":"<pre><code>df = pl$DataFrame(fruits = c(\"apple\", \"mango\", NA))\ndf$select(\npl$col(\"fruits\"),\npl$col(\"fruits\")$str$starts_with(\"app\")$alias(\"has_suffix\")\n)\n</code></pre>"},{"location":"reference/#exprstr-strip","title":"ExprStr strip","text":""},{"location":"reference/#description_316","title":"Description","text":"<p>Remove leading and trailing characters.</p>"},{"location":"reference/#arguments_178","title":"Arguments","text":"<code>matches</code> <p>The set of characters to be removed. All combinations of this set of characters will be stripped. If set to NULL (default), all whitespace is removed instead.</p>"},{"location":"reference/#details_105","title":"Details","text":"<p>will not strip anyt chars beyond the first char not matched. <code>strip()</code> starts from both left and right. Whereas <code>lstrip()</code>and <code>rstrip()</code> starts from left and right respectively.</p>"},{"location":"reference/#value_299","title":"Value","text":"<p>Expr of Utf8 lowercase chars</p>"},{"location":"reference/#examples_292","title":"Examples","text":"<pre><code>df = pl$DataFrame(foo = c(\" hello\", \"\\tworld\"))\ndf$select(pl$col(\"foo\")$str$strip())\ndf$select(pl$col(\"foo\")$str$strip(\" hel rld\"))\ndf$select(pl$col(\"foo\")$str$lstrip(\" hel rld\"))\ndf$select(pl$col(\"foo\")$str$rstrip(\" hel\\trld\"))\ndf$select(pl$col(\"foo\")$str$rstrip(\"rldhel\\t \"))\n</code></pre>"},{"location":"reference/#exprstr-strptime","title":"ExprStr strptime","text":""},{"location":"reference/#description_317","title":"Description","text":"<p>Parse a Series of dtype Utf8 to a Date/Datetime Series.</p>"},{"location":"reference/#arguments_179","title":"Arguments","text":"<code>datatype</code> <p>a temporal data type either pl$Date, pl$Time or pl$Datetime</p> <code>fmt</code> <p>fmt string for parsenig see see details here https://docs.rs/chrono/latest/chrono/format/strftime/index.html#fn6 Notice time_zone %Z is not supported and will just ignore timezones. Numeric tz like %z, %:z .... are supported.</p> <code>strict</code> <p>bool, if true raise error if a single string cannot be parsed, else produce a polars <code>null</code>.</p> <code>exact</code> <p>bool , If True, require an exact format match. If False, allow the format to match anywhere in the target string.</p> <code>cache</code> <p>Use a cache of unique, converted dates to apply the datetime conversion.</p> <code>tz_aware</code> <p>bool, Parse timezone aware datetimes. This may be automatically toggled by the \u2018fmt\u2019 given.</p> <code>utc</code> <p>bool Parse timezone aware datetimes as UTC. This may be useful if you have data with mixed offsets.</p>"},{"location":"reference/#details_106","title":"Details","text":"<p>Notes When parsing a Datetime the column precision will be inferred from the format string, if given, eg: \u201c%F %T%.3f\u201d =&gt; Datetime(\u201cms\u201d). If no fractional second component is found then the default is \u201cus\u201d.</p>"},{"location":"reference/#value_300","title":"Value","text":"<p>Expr of a Data, Datetime or Time Series</p>"},{"location":"reference/#examples_293","title":"Examples","text":"<pre><code>s = pl$Series(c(\n\"2021-04-22\",\n\"2022-01-04 00:00:00\",\n\"01/31/22\",\n\"Sun Jul  8 00:34:60 2001\"\n),\n\"date\"\n)\n#' #join multiple passes with different fmt\ns$to_frame()$with_columns(\npl$col(\"date\")\n$str$strptime(pl$Date, \"%F\", strict=FALSE)\n$fill_null(pl$col(\"date\")$str$strptime(pl$Date, \"%F %T\", strict=FALSE))\n$fill_null(pl$col(\"date\")$str$strptime(pl$Date, \"%D\", strict=FALSE))\n$fill_null(pl$col(\"date\")$str$strptime(pl$Date, \"%c\", strict=FALSE))\n)\ntxt_datetimes = c(\n\"2023-01-01 11:22:33 -0100\",\n\"2023-01-01 11:22:33 +0300\",\n\"invalid time\"\n)\npl$lit(txt_datetimes)$str$strptime(\npl$Datetime(\"ns\"),fmt = \"%Y-%m-%d %H:%M:%S %z\", strict = FALSE,\ntz_aware = TRUE, utc =TRUE\n)$lit_to_s()\n</code></pre>"},{"location":"reference/#exprstr-to-lowercase","title":"ExprStr to lowercase","text":""},{"location":"reference/#description_318","title":"Description","text":"<p>Transform to lowercase variant.</p>"},{"location":"reference/#value_301","title":"Value","text":"<p>Expr of Utf8 lowercase chars</p>"},{"location":"reference/#examples_294","title":"Examples","text":"<pre><code>pl$lit(c(\"A\",\"b\", \"c\", \"1\", NA))$str$to_lowercase()$lit_to_s()\n</code></pre>"},{"location":"reference/#exprstr-to-uppercase","title":"ExprStr to uppercase","text":""},{"location":"reference/#description_319","title":"Description","text":"<p>Transform to uppercase variant.</p>"},{"location":"reference/#value_302","title":"Value","text":"<p>Expr of Utf8 uppercase chars</p>"},{"location":"reference/#examples_295","title":"Examples","text":"<pre><code>pl$lit(c(\"A\",\"b\", \"c\", \"1\", NA))$str$to_uppercase()$lit_to_s()\n</code></pre>"},{"location":"reference/#exprstr-zfill","title":"ExprStr zfill","text":""},{"location":"reference/#description_320","title":"Description","text":"<p>Fills the string with zeroes.</p>"},{"location":"reference/#arguments_180","title":"Arguments","text":"<code>alignment</code> <p>Fill the value up to this length</p>"},{"location":"reference/#details_107","title":"Details","text":"<p>Return a copy of the string left filled with ASCII '0' digits to make a string of length width.</p> <p>A leading sign prefix ('+'/'-') is handled by inserting the padding after the sign character rather than before. The original string is returned if width is less than or equal to <code>len(s)</code>.</p>"},{"location":"reference/#value_303","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_296","title":"Examples","text":"<pre><code>some_floats_expr = pl$lit(c(0,10,-5,5))\n#cast to Utf8 and ljust alignment = 5, and view as R char vector\nsome_floats_expr$cast(pl$Utf8)$str$zfill(5)$to_r()\n#cast to int and the to utf8 and then ljust alignment = 5, and view as R char vector\nsome_floats_expr$cast(pl$Int64)$cast(pl$Utf8)$str$zfill(5)$to_r()\n</code></pre>"},{"location":"reference/#exprstruct-field","title":"ExprStruct field","text":""},{"location":"reference/#description_321","title":"Description","text":"<p>Retrieve a <code>Struct</code> field as a new Series. By default base 2.</p>"},{"location":"reference/#arguments_181","title":"Arguments","text":"<code>name</code> <p>string, the Name of the struct field to retrieve.</p>"},{"location":"reference/#value_304","title":"Value","text":"<p>Expr: Series of same and name selected field.</p>"},{"location":"reference/#examples_297","title":"Examples","text":"<pre><code>df = pl$DataFrame(\naaa = c(1, 2),\nbbb = c(\"ab\", \"cd\"),\nccc = c(TRUE, NA),\nddd = list(c(1, 2), 3)\n)$select(\npl$struct(pl$all())$alias(\"struct_col\")\n)\n#struct field into a new Series\ndf$select(\npl$col(\"struct_col\")$struct$field(\"bbb\"),\npl$col(\"struct_col\")$struct$field(\"ddd\")\n)\n</code></pre>"},{"location":"reference/#exprstruct-rename-fields","title":"ExprStruct rename fields","text":""},{"location":"reference/#description_322","title":"Description","text":"<p>Rename the fields of the struct. By default base 2.</p>"},{"location":"reference/#arguments_182","title":"Arguments","text":"<code>names</code> <p>char vec or list of strings given in the same order as the struct's fields. Providing fewer names will drop the latter fields. Providing too many names is ignored.</p>"},{"location":"reference/#value_305","title":"Value","text":"<p>Expr: struct-series with new names for the fields</p>"},{"location":"reference/#examples_298","title":"Examples","text":"<pre><code>df = pl$DataFrame(\naaa = 1:2,\nbbb = c(\"ab\", \"cd\"),\nccc = c(TRUE, NA),\nddd = list(1:2, 3L)\n)$select(\npl$struct(pl$all())$alias(\"struct_col\")\n)$select(\npl$col(\"struct_col\")$struct$rename_fields(c(\"www\", \"xxx\", \"yyy\", \"zzz\"))\n)\ndf$unnest()\n</code></pre>"},{"location":"reference/#extendr-method-to-pure-functions","title":"Extendr method to pure functions","text":""},{"location":"reference/#description_323","title":"Description","text":"<p>self is a global of extendr wrapper methods this function copies the function into a new environment and modify formals to have a self argument</p>"},{"location":"reference/#usage_213","title":"Usage","text":"<pre><code>extendr_method_to_pure_functions(env)\n</code></pre>"},{"location":"reference/#arguments_183","title":"Arguments","text":"<code>env</code> <p>environment object output from extendr-wrappers.R classes</p>"},{"location":"reference/#value_306","title":"Value","text":"<p>env of pure function calls to rust</p>"},{"location":"reference/#extra-auto-completion","title":"Extra auto completion","text":""},{"location":"reference/#description_324","title":"Description","text":"<p>Extra polars auto completion</p>"},{"location":"reference/#arguments_184","title":"Arguments","text":"<code>activate</code> <p>bool default TRUE, enable chained auto-completion</p>"},{"location":"reference/#details_108","title":"Details","text":"<p>polars always supports auto completetion via .DollarNames. However chained methods like x$a()$b()$? are not supported vi .DollarNames.</p> <p>This feature experimental and not perfect. Any feedback is appreciated. Currently does not play that nice with Rstudio, as Rstudio backtick quotes any custom suggestions.</p>"},{"location":"reference/#examples_299","title":"Examples","text":"<pre><code>#auto completion via .DollarNames method\ne = pl$lit(42) # to autocomplete pl$lit(42) save to variable\n# then write `e$`  and press tab to see available methods\n# polars has experimental auto completetion for chain of methods if all on the same line\npl$extra_auto_completion() #first activate feature (this will 'annoy' the Rstudio auto-completer)\npl$lit(42)$lit_to_s() # add a $ and press tab 1-3 times\npl$extra_auto_completion(activate = FALSE) #deactivate\n</code></pre>"},{"location":"reference/#filter-open-paren-close-paren","title":"Filter-open-paren-close-paren","text":""},{"location":"reference/#description_325","title":"Description","text":"<p>DataFrame$filter(bool_expr)</p>"},{"location":"reference/#usage_214","title":"Usage","text":"<pre><code>DataFrame_filter(bool_expr)\n</code></pre>"},{"location":"reference/#arguments_185","title":"Arguments","text":"<code>bool_expr</code> <p>Polars expression which will evaluate to a bool pl$Series</p>"},{"location":"reference/#value_307","title":"Value","text":"<p>filtered DataFrame</p>"},{"location":"reference/#examples_300","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$lazy()$filter(pl$col(\"Sepal.Length\") &gt; 5)$collect()\n</code></pre>"},{"location":"reference/#get-method-usages","title":"Get method usages","text":""},{"location":"reference/#description_326","title":"Description","text":"<p>Generate autocompletion suggestions for object</p>"},{"location":"reference/#usage_215","title":"Usage","text":"<pre><code>get_method_usages(env, pattern = \"\")\n</code></pre>"},{"location":"reference/#arguments_186","title":"Arguments","text":"<code>env</code> <p>environment to extract usages from</p> <code>pattern</code> <p>string passed to ls(pattern) to subset methods by pattern</p>"},{"location":"reference/#details_109","title":"Details","text":"<p>used internally for auto completion in .DollarNames methods</p>"},{"location":"reference/#value_308","title":"Value","text":"<p>method usages</p>"},{"location":"reference/#examples_301","title":"Examples","text":"<pre><code>polars:::get_method_usages(polars:::DataFrame, pattern=\"col\")\n</code></pre>"},{"location":"reference/#groupby-agg","title":"GroupBy agg","text":""},{"location":"reference/#description_327","title":"Description","text":"<p>Aggregatete a DataFrame over a groupby</p>"},{"location":"reference/#usage_216","title":"Usage","text":"<pre><code>GroupBy_agg(...)\n</code></pre>"},{"location":"reference/#arguments_187","title":"Arguments","text":"<code>...</code> <p>exprs to aggregate</p>"},{"location":"reference/#value_309","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/#examples_302","title":"Examples","text":"<pre><code>pl$DataFrame(\nlist(\nfoo = c(\"one\", \"two\", \"two\", \"one\", \"two\"),\nbar = c(5, 3, 2, 4, 1)\n)\n)$groupby(\n\"foo\"\n)$agg(\npl$col(\"bar\")$sum()$alias(\"bar_sum\"),\npl$col(\"bar\")$mean()$alias(\"bar_tail_sum\")\n)\n</code></pre>"},{"location":"reference/#groupby-as-data-frame","title":"GroupBy as data frame","text":""},{"location":"reference/#description_328","title":"Description","text":"<p>convert to data.frame</p>"},{"location":"reference/#usage_217","title":"Usage","text":"<pre><code>GroupBy_as_data_frame(...)\n</code></pre>"},{"location":"reference/#arguments_188","title":"Arguments","text":"<code>...</code> <p>any opt param passed to R as.data.frame</p>"},{"location":"reference/#value_310","title":"Value","text":"<p>R data.frame</p>"},{"location":"reference/#examples_303","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$as_data_frame() #R-polars back and forth\n</code></pre>"},{"location":"reference/#groupby-first","title":"GroupBy first","text":""},{"location":"reference/#description_329","title":"Description","text":"<p>Reduce the groups to the first value.</p>"},{"location":"reference/#usage_218","title":"Usage","text":"<pre><code>GroupBy_first()\n</code></pre>"},{"location":"reference/#value_311","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/#examples_304","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$first()\n</code></pre>"},{"location":"reference/#groupby-last","title":"GroupBy last","text":""},{"location":"reference/#description_330","title":"Description","text":"<p>Reduce the groups to the last value.</p>"},{"location":"reference/#usage_219","title":"Usage","text":"<pre><code>GroupBy_last()\n</code></pre>"},{"location":"reference/#value_312","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/#examples_305","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$last()\n</code></pre>"},{"location":"reference/#groupby-max","title":"GroupBy max","text":""},{"location":"reference/#description_331","title":"Description","text":"<p>Reduce the groups to the maximum value.</p>"},{"location":"reference/#usage_220","title":"Usage","text":"<pre><code>GroupBy_max()\n</code></pre>"},{"location":"reference/#value_313","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/#examples_306","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$max()\n</code></pre>"},{"location":"reference/#groupby-mean","title":"GroupBy mean","text":""},{"location":"reference/#description_332","title":"Description","text":"<p>Reduce the groups to the mean value.</p>"},{"location":"reference/#usage_221","title":"Usage","text":"<pre><code>GroupBy_mean()\n</code></pre>"},{"location":"reference/#value_314","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/#examples_307","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$mean()\n</code></pre>"},{"location":"reference/#groupby-median","title":"GroupBy median","text":""},{"location":"reference/#description_333","title":"Description","text":"<p>Reduce the groups to the median value.</p>"},{"location":"reference/#usage_222","title":"Usage","text":"<pre><code>GroupBy_median()\n</code></pre>"},{"location":"reference/#value_315","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/#examples_308","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$median()\n</code></pre>"},{"location":"reference/#groupby-min","title":"GroupBy min","text":""},{"location":"reference/#description_334","title":"Description","text":"<p>Reduce the groups to the minimum value.</p>"},{"location":"reference/#usage_223","title":"Usage","text":"<pre><code>GroupBy_min()\n</code></pre>"},{"location":"reference/#value_316","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/#examples_309","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$min()\n</code></pre>"},{"location":"reference/#groupby-null-count","title":"GroupBy null count","text":""},{"location":"reference/#description_335","title":"Description","text":"<p>Create a new DataFrame that shows the null counts per column.</p>"},{"location":"reference/#usage_224","title":"Usage","text":"<pre><code>GroupBy_null_count()\n</code></pre>"},{"location":"reference/#value_317","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/#examples_310","title":"Examples","text":"<pre><code>x = mtcars\nx[1:10, 3:5] = NA\npl$DataFrame(x)$groupby(\"cyl\")$null_count()\n</code></pre>"},{"location":"reference/#groupby-std","title":"GroupBy std","text":""},{"location":"reference/#description_336","title":"Description","text":"<p>Reduce the groups to the standard deviation value.</p>"},{"location":"reference/#usage_225","title":"Usage","text":"<pre><code>GroupBy_std()\n</code></pre>"},{"location":"reference/#value_318","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/#examples_311","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$std()\n</code></pre>"},{"location":"reference/#groupby-sum","title":"GroupBy sum","text":""},{"location":"reference/#description_337","title":"Description","text":"<p>Reduce the groups to the sum value.</p>"},{"location":"reference/#usage_226","title":"Usage","text":"<pre><code>GroupBy_sum()\n</code></pre>"},{"location":"reference/#value_319","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/#examples_312","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$sum()\n</code></pre>"},{"location":"reference/#groupby-var","title":"GroupBy var","text":""},{"location":"reference/#description_338","title":"Description","text":"<p>Reduce the groups to the variance value.</p>"},{"location":"reference/#usage_227","title":"Usage","text":"<pre><code>GroupBy_var()\n</code></pre>"},{"location":"reference/#value_320","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/#examples_313","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$var()\n</code></pre>"},{"location":"reference/#is-dataframe-data-input","title":"Is DataFrame data input","text":""},{"location":"reference/#description_339","title":"Description","text":"<p>The Dataframe constructors accepts data.frame inheritors or list of vectors and/or Series.</p>"},{"location":"reference/#usage_228","title":"Usage","text":"<pre><code>is_DataFrame_data_input(x)\n</code></pre>"},{"location":"reference/#arguments_189","title":"Arguments","text":"<code>x</code> <p>any R object to test if suitable as input to DataFrame</p>"},{"location":"reference/#value_321","title":"Value","text":"<p>bool</p>"},{"location":"reference/#examples_314","title":"Examples","text":"<pre><code>polars:::is_DataFrame_data_input(iris)\npolars:::is_DataFrame_data_input(list(1:5,pl$Series(1:5),letters[1:5]))\n</code></pre>"},{"location":"reference/#is-err","title":"Is err","text":""},{"location":"reference/#description_340","title":"Description","text":"<p>check if x ss a result and an err</p>"},{"location":"reference/#usage_229","title":"Usage","text":"<pre><code>is_err(x)\n</code></pre>"},{"location":"reference/#arguments_190","title":"Arguments","text":"<code>x</code> <p>R object which could be a rust-like result of a list with two elements, ok and err</p>"},{"location":"reference/#value_322","title":"Value","text":"<p>bool if is a result object which is an err</p>"},{"location":"reference/#is-ok","title":"Is ok","text":""},{"location":"reference/#description_341","title":"Description","text":"<p>check if x ss a result and an ok</p>"},{"location":"reference/#usage_230","title":"Usage","text":"<pre><code>is_ok(x)\n</code></pre>"},{"location":"reference/#arguments_191","title":"Arguments","text":"<code>x</code> <p>R object which could be a rust-like result of a list with two elements, ok and err</p>"},{"location":"reference/#value_323","title":"Value","text":"<p>bool if is a result object which is an ok</p>"},{"location":"reference/#is-polars-dtype","title":"Is polars dtype","text":""},{"location":"reference/#description_342","title":"Description","text":"<p>chek if x is a valid RPolarsDataType</p>"},{"location":"reference/#usage_231","title":"Usage","text":"<pre><code>is_polars_dtype(x, include_unknown = FALSE)\n</code></pre>"},{"location":"reference/#arguments_192","title":"Arguments","text":"<code>x</code> <p>a candidate</p>"},{"location":"reference/#value_324","title":"Value","text":"<p>a list DataType with an inner DataType</p>"},{"location":"reference/#examples_315","title":"Examples","text":"<pre><code>polars:::is_polars_dtype(pl$Int64)\n</code></pre>"},{"location":"reference/#is-result","title":"Is result","text":""},{"location":"reference/#description_343","title":"Description","text":"<p>check if z is a result</p>"},{"location":"reference/#usage_232","title":"Usage","text":"<pre><code>is_result(x)\n</code></pre>"},{"location":"reference/#arguments_193","title":"Arguments","text":"<code>x</code> <p>R object which could be a rust-like result of a list with two elements, ok and err</p>"},{"location":"reference/#details_110","title":"Details","text":"<p>both ok and err being NULL encodes ok-value NULL. No way to encode an err-value NULL If both ok and err has value then this is an invalid result</p>"},{"location":"reference/#value_325","title":"Value","text":"<p>bool if is a result object</p>"},{"location":"reference/#is-schema","title":"Is schema","text":""},{"location":"reference/#description_344","title":"Description","text":"<p>check if schema</p>"},{"location":"reference/#usage_233","title":"Usage","text":"<pre><code>is_schema(x)\n</code></pre>"},{"location":"reference/#arguments_194","title":"Arguments","text":"<code>x</code> <p>objet to test if schema</p>"},{"location":"reference/#format_164","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_326","title":"Value","text":"<p>bool</p>"},{"location":"reference/#examples_316","title":"Examples","text":"<pre><code>polars:::is_schema(pl$DataFrame(iris)$schema)\npl$is_schema(pl$DataFrame(iris)$schema)\npolars:::is_schema(list(\"alice\",\"bob\"))\n</code></pre>"},{"location":"reference/#l-to-vdf","title":"L to vdf","text":""},{"location":"reference/#description_345","title":"Description","text":"<p>lifecycle: DEPRECATE, imple on rust side as a function</p>"},{"location":"reference/#usage_234","title":"Usage","text":"<pre><code>l_to_vdf(l)\n</code></pre>"},{"location":"reference/#arguments_195","title":"Arguments","text":"<code>l</code> <p>list of DataFrame</p>"},{"location":"reference/#value_327","title":"Value","text":"<p>VecDataFrame</p>"},{"location":"reference/#lazy-csv-reader","title":"Lazy csv reader","text":""},{"location":"reference/#description_346","title":"Description","text":"<p>will scan the csv when collect(), not now</p>"},{"location":"reference/#usage_235","title":"Usage","text":"<pre><code>lazy_csv_reader(\n  path,\n  sep = \",\",\n  has_header = TRUE,\n  ignore_errors = FALSE,\n  skip_rows = 0,\n  n_rows = NULL,\n  cache = FALSE,\n  overwrite_dtype = NULL,\n  low_memory = FALSE,\n  comment_char = NULL,\n  quote_char = \"\\\"\",\n  null_values = NULL,\n  infer_schema_length = 100,\n  skip_rows_after_header = 0,\n  encoding = \"utf8\",\n  row_count_name = NULL,\n  row_count_offset = 0,\n  parse_dates = FALSE\n)\n\ncsv_reader(...)\n</code></pre>"},{"location":"reference/#arguments_196","title":"Arguments","text":"<code>path</code> <p>string, Path to a file</p> <code>sep</code> <p>Single char to use as delimiter in the file.</p> <code>has_header</code> <p>bool, indicate if the first row of dataset is a header or not. If set to False, column names will be autogenerated in the following format: column_x, with x being an enumeration over every column in the dataset starting at 1.</p> <code>ignore_errors</code> <p>bool, try to keep reading lines if some lines yield errors. First try infer_schema_length=0 to read all columns as pl.Utf8 to check which values might cause an issue.</p> <code>skip_rows</code> <p>integer, Start reading after skip_rows lines. The header will be parsed at this offset.</p> <code>n_rows</code> <p>int (NULL is disable),Stop reading from CSV file after reading n_rows.</p> <code>cache</code> <p>bool, cache the result after reading.</p> <code>overwrite_dtype</code> <p>(NULL is disable) named list of dtypes OR dtype-names, where name points to a column. Can overwrite dtypes during inference. Supported types so far are: name | alias | polars side dtype \"Boolean\" | \"logical\" =&gt; DataType::Boolean, \"Float32\" | \"double\" =&gt; DataType::Float32, \"Float64\" | \"float64\" =&gt; DataType::Float64, \"Int32\" | \"integer\" =&gt; DataType::Int32, \"Int64\" | \"integer64\" =&gt; DataType::Int64, \"Utf8\" | \"character\" =&gt; DataType::Utf8,</p> <code>low_memory</code> <p>bool, reduce memory usage in expense of performance</p> <code>comment_char</code> <p>(NULL is disable) Single byte character that indicates the start of a comment line, for instance #.</p> <code>quote_char</code> <p>(NULL is disable) Single byte character used for csv quoting, default = \". Set to None to turn off special handling and escaping of quotes.</p> <code>null_values</code> <p>(NULL is disable) Values to interpret as null values. You can provide a String : All values equal to this string will be null. Unnamed char vector: A null value per column. Named char vector. A mapping from (names)column to a null value string(values).</p> <code>infer_schema_length</code> <p>Maximum number of rows to read to infer the column types. If set to 0, all columns will be read as UTF-8. If <code>NULL</code>, a full table scan will be done (slow).</p> <code>skip_rows_after_header</code> <p>bool Skip this number of rows when the header is parsed.</p> <code>encoding</code> <p>either \"utf8\" or \"utf8-lossy\". Lossy means that invalid utf8 values are replaced with \"?\" characters.</p> <code>row_count_name</code> <p>String(NULL is disable), name of a added row count column</p> <code>row_count_offset</code> <p>integer, Offset to start the row_count column (only used if the name is set).</p> <code>parse_dates</code> <p>bool Try to automatically parse dates. If this does not succeed, the column remains of data type pl.Utf8.</p> <code>...</code> <p>any argument passed to lazy_csv_reader</p>"},{"location":"reference/#details_111","title":"Details","text":"<p>Read a file from path into a polars lazy frame. Not yet supporting eol_char and with_column_names</p>"},{"location":"reference/#value_328","title":"Value","text":"<p>lazyframe</p> <p>DataFrame</p>"},{"location":"reference/#examples_317","title":"Examples","text":"<pre><code>my_file = tempfile()\nwrite.csv(iris,my_file)\nlazy_frame = polars:::lazy_csv_reader(path=my_file)\nlazy_frame$collect()\nunlink(my_file)\n</code></pre>"},{"location":"reference/#lazyframe-class","title":"LazyFrame class","text":""},{"location":"reference/#description_347","title":"Description","text":"<p>The <code>LazyFrame</code>-class is simply two environments of respectively the public and private methods/function calls to the polars rust side. The instanciated <code>LazyFrame</code>-object is an <code>externalptr</code> to a lowlevel rust polars LazyFrame object. The pointer address is the only statefullness of the LazyFrame object on the R side. Any other state resides on the rust side. The S3 method <code>.DollarNames.LazyFrame</code> exposes all public <code>\u2060$foobar()\u2060</code>-methods which are callable onto the object. Most methods return another <code>LazyFrame</code>-class instance or similar which allows for method chaining. This class system in lack of a better name could be called \"environment classes\" and is the same class system extendr provides, except here there is both a public and private set of methods. For implementation reasons, the private methods are external and must be called from polars:::.pr.$LazyFrame$methodname(), also all private methods must take any self as an argument, thus they are pure functions. Having the private methods as pure functions solved/simplified self-referential complications.</p> <p><code>DataFrame</code> and <code>LazyFrame</code> can both be said to be a <code>Frame</code>. To convert use <code>DataFrame_object$lazy() -&gt; LazyFrame_object</code> and <code>LazyFrame_object$collect() -&gt; DataFrame_object</code>. This is quite similar to the lazy-collect syntax of the dplyrpackage to interact with database connections such as SQL variants. Most SQL databases would be able to perform the same otimizations as polars such Predicate Pushdown and Projection. However polars can intertact and optimize queries with both SQL DBs and other data sources such parquet files simultanously. (#TODO implement r-polars SQL ;)</p>"},{"location":"reference/#details_112","title":"Details","text":"<p>Check out the source code in R/LazyFrame__lazy.R how public methods are derived from private methods. Check out extendr-wrappers.R to see the extendr-auto-generated methods. These are moved to .pr and converted into pure external functions in after-wrappers.R. In zzz.R (named zzz to be last file sourced) the extendr-methods are removed and replaced by any function prefixed <code>LazyFrame_</code>.</p>"},{"location":"reference/#examples_318","title":"Examples","text":"<pre><code>#see all exported methods\nls(polars:::LazyFrame)\n#see all private methods (not intended for regular use)\nls(polars:::.pr$LazyFrame)\n## Practical example ##\n# First writing R iris dataset to disk, to illustrte a difference\ntemp_filepath = tempfile()\nwrite.csv(iris, temp_filepath,row.names = FALSE)\n# Following example illustrates 2 ways to obtain a LazyFrame\n# The-Okay-way: convert an in-memory DataFrame to LazyFrame\n#eager in-mem R data.frame\nRdf = read.csv(temp_filepath)\n#eager in-mem polars DataFrame\nPdf = pl$DataFrame(Rdf)\n#lazy frame starting from in-mem DataFrame\nLdf_okay = Pdf$lazy()\n#The-Best-Way:  LazyFrame created directly from a data source is best...\nLdf_best = pl$lazy_csv_reader(temp_filepath)\n# ... as if to e.g. filter the LazyFrame, that filtering also caleld predicate will be\n# pushed down in the executation stack to the csv_reader, and thereby only bringing into\n# memory the rows matching to filter.\n# apply filter:\nfilter_expr = pl$col(\"Species\") == \"setosa\" #get only rows where Species is setosa\nLdf_okay = Ldf_okay$filter(filter_expr) #overwrite LazyFrame with new\nLdf_best = Ldf_best$filter(filter_expr)\n# the non optimized plans are similar, on entire in-mem csv, apply filter\nLdf_okay$describe_plan()\nLdf_best$describe_plan()\n# NOTE For Ldf_okay, the full time to load csv alrady paid when creating Rdf and Pdf\n#The optimized plan are quite different, Ldf_best will read csv and perform filter simultanously\nLdf_okay$describe_optimized_plan()\nLdf_best$describe_optimized_plan()\n#To acquire result in-mem use $colelct()\nPdf_okay = Ldf_okay$collect()\nPdf_best = Ldf_best$collect()\n#verify tables would be the same\nall.equal(\nPdf_okay$as_data_frame(),\nPdf_best$as_data_frame()\n)\n#a user might write it as a one-liner like so:\nPdf_best2 = pl$lazy_csv_reader(temp_filepath)$filter(pl$col(\"Species\") == \"setosa\")\n</code></pre>"},{"location":"reference/#lazyframe-collect-background","title":"LazyFrame collect background","text":""},{"location":"reference/#description_348","title":"Description","text":"<p>collect DataFrame by lazy query</p>"},{"location":"reference/#usage_236","title":"Usage","text":"<pre><code>LazyFrame_collect_background()\n</code></pre>"},{"location":"reference/#value_329","title":"Value","text":"<p>collected <code>DataFrame</code></p>"},{"location":"reference/#examples_319","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$lazy()$filter(pl$col(\"Species\")==\"setosa\")$collect()\n</code></pre>"},{"location":"reference/#lazyframe-collect","title":"LazyFrame collect","text":""},{"location":"reference/#description_349","title":"Description","text":"<p>collect DataFrame by lazy query</p>"},{"location":"reference/#usage_237","title":"Usage","text":"<pre><code>LazyFrame_collect()\n</code></pre>"},{"location":"reference/#value_330","title":"Value","text":"<p>collected <code>DataFrame</code></p>"},{"location":"reference/#examples_320","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$lazy()$filter(pl$col(\"Species\")==\"setosa\")$collect()\n</code></pre>"},{"location":"reference/#lazyframe-describe-optimized-plan","title":"LazyFrame describe optimized plan","text":""},{"location":"reference/#description_350","title":"Description","text":"<p>select on a LazyFrame</p>"},{"location":"reference/#usage_238","title":"Usage","text":"<pre><code>LazyFrame_describe_optimized_plan()\n</code></pre>"},{"location":"reference/#lazyframe-describe-plan","title":"LazyFrame describe plan","text":""},{"location":"reference/#description_351","title":"Description","text":"<p>select on a LazyFrame</p>"},{"location":"reference/#usage_239","title":"Usage","text":"<pre><code>LazyFrame_describe_plan\n</code></pre>"},{"location":"reference/#format_165","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#lazyframe-filter","title":"LazyFrame filter","text":""},{"location":"reference/#description_352","title":"Description","text":"<p>Filter rows with an Expression definining a boolean column</p>"},{"location":"reference/#usage_240","title":"Usage","text":"<pre><code>LazyFrame_filter(expr)\n</code></pre>"},{"location":"reference/#arguments_197","title":"Arguments","text":"<code>expr</code> <p>one Expr or string naming a column</p>"},{"location":"reference/#format_166","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_331","title":"Value","text":"<p>A new <code>LazyFrame</code> object with add/modified column.</p>"},{"location":"reference/#examples_321","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$lazy()$filter(pl$col(\"Species\")==\"setosa\")$collect()\n</code></pre>"},{"location":"reference/#lazyframe-first","title":"LazyFrame first","text":""},{"location":"reference/#description_353","title":"Description","text":"<p>Get the first row of the DataFrame.</p>"},{"location":"reference/#usage_241","title":"Usage","text":"<pre><code>LazyFrame_first\n</code></pre>"},{"location":"reference/#format_167","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_332","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied filter.</p>"},{"location":"reference/#examples_322","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$first()$collect()\n</code></pre>"},{"location":"reference/#lazyframe-groupby","title":"LazyFrame groupby","text":""},{"location":"reference/#description_354","title":"Description","text":"<p>apply groupby on LazyFrame, return LazyGroupBy</p>"},{"location":"reference/#usage_242","title":"Usage","text":"<pre><code>LazyFrame_groupby(..., maintain_order = FALSE)\n</code></pre>"},{"location":"reference/#arguments_198","title":"Arguments","text":"<code>...</code> <p>any single Expr or string naming a column</p> <code>maintain_order</code> <p>bool should an aggregate of groupby retain order of groups or FALSE = random, slightly faster?</p>"},{"location":"reference/#value_333","title":"Value","text":"<p>A new <code>LazyGroupBy</code> object with applied groups.</p>"},{"location":"reference/#lazyframe-join","title":"LazyFrame join","text":""},{"location":"reference/#description_355","title":"Description","text":"<p>join a LazyFrame</p>"},{"location":"reference/#usage_243","title":"Usage","text":"<pre><code>LazyFrame_join(\n  other,\n  left_on = NULL,\n  right_on = NULL,\n  on = NULL,\n  how = c(\"inner\", \"left\", \"outer\", \"semi\", \"anti\", \"cross\"),\n  suffix = \"_right\",\n  allow_parallel = TRUE,\n  force_parallel = FALSE\n)\n</code></pre>"},{"location":"reference/#arguments_199","title":"Arguments","text":"<code>other</code> <p>LazyFrame</p> <code>left_on</code> <p>names of columns in self LazyFrame, order should match. Type, see on param.</p> <code>right_on</code> <p>names of columns in other LazyFrame, order should match. Type, see on param.</p> <code>on</code> <p>named columns as char vector of named columns, or list of expressions and/or strings.</p> <code>how</code> <p>a string selecting one of the following methods: inner, left, outer, semi, anti, cross</p> <code>suffix</code> <p>name to added right table</p> <code>allow_parallel</code> <p>bool</p> <code>force_parallel</code> <p>bool</p>"},{"location":"reference/#value_334","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied join.</p>"},{"location":"reference/#lazyframe-last","title":"LazyFrame last","text":""},{"location":"reference/#description_356","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their maximum value.</p>"},{"location":"reference/#usage_244","title":"Usage","text":"<pre><code>LazyFrame_last\n</code></pre>"},{"location":"reference/#format_168","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_335","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied aggregation.</p>"},{"location":"reference/#examples_323","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$last()$collect()\n</code></pre>"},{"location":"reference/#lazyframe-limit","title":"LazyFrame limit","text":""},{"location":"reference/#description_357","title":"Description","text":"<p>take limit of n rows of query</p>"},{"location":"reference/#usage_245","title":"Usage","text":"<pre><code>LazyFrame_limit(n)\n</code></pre>"},{"location":"reference/#arguments_200","title":"Arguments","text":"<code>n</code> <p>positive numeric or integer number not larger than 2^32</p>"},{"location":"reference/#details_113","title":"Details","text":"<p>any number will converted to u32. Negative raises error</p>"},{"location":"reference/#value_336","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied filter.</p>"},{"location":"reference/#examples_324","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$limit(4)$collect()\n</code></pre>"},{"location":"reference/#lazyframe-max","title":"LazyFrame max","text":""},{"location":"reference/#description_358","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their maximum value.</p>"},{"location":"reference/#usage_246","title":"Usage","text":"<pre><code>LazyFrame_max\n</code></pre>"},{"location":"reference/#format_169","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_337","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied aggregation.</p>"},{"location":"reference/#examples_325","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$max()$collect()\n</code></pre>"},{"location":"reference/#lazyframe-mean","title":"LazyFrame mean","text":""},{"location":"reference/#description_359","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their mean value.</p>"},{"location":"reference/#usage_247","title":"Usage","text":"<pre><code>LazyFrame_mean\n</code></pre>"},{"location":"reference/#format_170","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_338","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied aggregation.</p>"},{"location":"reference/#examples_326","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$mean()$collect()\n</code></pre>"},{"location":"reference/#lazyframe-median","title":"LazyFrame median","text":""},{"location":"reference/#description_360","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their median value.</p>"},{"location":"reference/#usage_248","title":"Usage","text":"<pre><code>LazyFrame_median\n</code></pre>"},{"location":"reference/#format_171","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_339","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied aggregation.</p>"},{"location":"reference/#examples_327","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$median()$collect()\n</code></pre>"},{"location":"reference/#lazyframe-min","title":"LazyFrame min","text":""},{"location":"reference/#description_361","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their minimum value.</p>"},{"location":"reference/#usage_249","title":"Usage","text":"<pre><code>LazyFrame_min\n</code></pre>"},{"location":"reference/#format_172","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_340","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied aggregation.</p>"},{"location":"reference/#examples_328","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$min()$collect()\n</code></pre>"},{"location":"reference/#lazyframe-print","title":"LazyFrame print","text":""},{"location":"reference/#description_362","title":"Description","text":"<p>can be used i the middle of a method chain</p>"},{"location":"reference/#usage_250","title":"Usage","text":"<pre><code>LazyFrame_print(x)\n</code></pre>"},{"location":"reference/#arguments_201","title":"Arguments","text":"<code>x</code> <p>LazyFrame</p>"},{"location":"reference/#format_173","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_341","title":"Value","text":"<p>self</p>"},{"location":"reference/#examples_329","title":"Examples","text":"<pre><code> pl$DataFrame(iris)$lazy()$print()\n</code></pre>"},{"location":"reference/#lazyframe-reverse","title":"LazyFrame reverse","text":""},{"location":"reference/#description_363","title":"Description","text":"<p>Reverse the DataFrame.</p>"},{"location":"reference/#usage_251","title":"Usage","text":"<pre><code>LazyFrame_reverse\n</code></pre>"},{"location":"reference/#format_174","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_342","title":"Value","text":"<p>LazyFrame</p>"},{"location":"reference/#examples_330","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$reverse()$collect()\n</code></pre>"},{"location":"reference/#lazyframe-select","title":"LazyFrame select","text":""},{"location":"reference/#description_364","title":"Description","text":"<p>select on a LazyFrame</p>"},{"location":"reference/#usage_252","title":"Usage","text":"<pre><code>LazyFrame_select(...)\n</code></pre>"},{"location":"reference/#arguments_202","title":"Arguments","text":"<code>...</code> <p>any single Expr or string naming a column</p>"},{"location":"reference/#value_343","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied filter.</p>"},{"location":"reference/#lazyframe-slice","title":"LazyFrame slice","text":""},{"location":"reference/#description_365","title":"Description","text":"<p>Get a slice of this DataFrame.</p>"},{"location":"reference/#usage_253","title":"Usage","text":"<pre><code>LazyFrame_slice(offset, length = NULL)\n</code></pre>"},{"location":"reference/#arguments_203","title":"Arguments","text":"<code>offset</code> <p>integer</p> <code>length</code> <p>integer or NULL</p>"},{"location":"reference/#value_344","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/#examples_331","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$slice(2, 4)$collect()\npl$DataFrame(mtcars)$lazy()$slice(30)$collect()\nmtcars[2:6,]\n</code></pre>"},{"location":"reference/#lazyframe-std","title":"LazyFrame std","text":""},{"location":"reference/#description_366","title":"Description","text":"<p>Aggregate the columns of this LazyFrame to their standard deviation values.</p>"},{"location":"reference/#usage_254","title":"Usage","text":"<pre><code>LazyFrame_std(ddof = 1)\n</code></pre>"},{"location":"reference/#arguments_204","title":"Arguments","text":"<code>ddof</code> <p>integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1.</p>"},{"location":"reference/#value_345","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied aggregation.</p>"},{"location":"reference/#examples_332","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$std()$collect()\n</code></pre>"},{"location":"reference/#lazyframe-sum","title":"LazyFrame sum","text":""},{"location":"reference/#description_367","title":"Description","text":"<p>Aggregate the columns of this DataFrame to their sum values.</p>"},{"location":"reference/#usage_255","title":"Usage","text":"<pre><code>LazyFrame_sum\n</code></pre>"},{"location":"reference/#format_175","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_346","title":"Value","text":"<p>LazyFrame</p>"},{"location":"reference/#examples_333","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$sum()$collect()\n</code></pre>"},{"location":"reference/#lazyframe-tail","title":"LazyFrame tail","text":""},{"location":"reference/#description_368","title":"Description","text":"<p>take last n rows of query</p>"},{"location":"reference/#usage_256","title":"Usage","text":"<pre><code>LazyFrame_tail(n)\n</code></pre>"},{"location":"reference/#arguments_205","title":"Arguments","text":"<code>n</code> <p>positive numeric or integer number not larger than 2^32</p>"},{"location":"reference/#details_114","title":"Details","text":"<p>any number will converted to u32. Negative raises error</p>"},{"location":"reference/#value_347","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied filter.</p>"},{"location":"reference/#examples_334","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$tail(2)$collect()\n</code></pre>"},{"location":"reference/#lazyframe-var","title":"LazyFrame var","text":""},{"location":"reference/#description_369","title":"Description","text":"<p>Aggregate the columns of this LazyFrame to their variance values.</p>"},{"location":"reference/#usage_257","title":"Usage","text":"<pre><code>LazyFrame_var(ddof = 1)\n</code></pre>"},{"location":"reference/#arguments_206","title":"Arguments","text":"<code>ddof</code> <p>integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1.</p>"},{"location":"reference/#value_348","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied aggregation.</p>"},{"location":"reference/#examples_335","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$var()$collect()\n</code></pre>"},{"location":"reference/#lazyframe-with-column","title":"LazyFrame with column","text":""},{"location":"reference/#description_370","title":"Description","text":"<p>add or replace columns of LazyFrame</p>"},{"location":"reference/#usage_258","title":"Usage","text":"<pre><code>LazyFrame_with_column(expr)\n</code></pre>"},{"location":"reference/#arguments_207","title":"Arguments","text":"<code>expr</code> <p>one Expr or string naming a column</p>"},{"location":"reference/#format_176","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_349","title":"Value","text":"<p>A new <code>LazyFrame</code> object with add/modified column.</p>"},{"location":"reference/#lazyframe-with-columns","title":"LazyFrame with columns","text":""},{"location":"reference/#description_371","title":"Description","text":"<p>add or replace columns of LazyFrame</p>"},{"location":"reference/#usage_259","title":"Usage","text":"<pre><code>LazyFrame_with_columns(...)\n</code></pre>"},{"location":"reference/#arguments_208","title":"Arguments","text":"<code>...</code> <p>any single Expr or string naming a column</p>"},{"location":"reference/#value_350","title":"Value","text":"<p>A new <code>LazyFrame</code> object with added/modified columns.</p>"},{"location":"reference/#lazyframe-describe-optimized-plan_1","title":"LazyFrame-describe optimized plan","text":""},{"location":"reference/#description_372","title":"Description","text":"<p>Describe the optimized collect plan of a Polars LazyFrame</p>"},{"location":"reference/#usage_260","title":"Usage","text":"<pre><code>&lt;LazyFrame&gt;$describe_optimized_plan()\n</code></pre>"},{"location":"reference/#lazyframe-describe-plan_1","title":"LazyFrame-describe plan","text":""},{"location":"reference/#description_373","title":"Description","text":"<p>Describe the collect plan of a Polars LazyFrame</p>"},{"location":"reference/#usage_261","title":"Usage","text":"<pre><code>&lt;LazyFrame&gt;$describe_plan()\n</code></pre>"},{"location":"reference/#lazyframe-print_1","title":"LazyFrame-print","text":""},{"location":"reference/#description_374","title":"Description","text":"<p>Print a Polars LazyFrame</p>"},{"location":"reference/#usage_262","title":"Usage","text":"<pre><code>&lt;LazyFrame&gt;$print()\n</code></pre>"},{"location":"reference/#lazygroupby-agg","title":"LazyGroupBy agg","text":""},{"location":"reference/#description_375","title":"Description","text":"<p>aggregate a polar_lazy_groupby</p>"},{"location":"reference/#usage_263","title":"Usage","text":"<pre><code>LazyGroupBy_agg(...)\n</code></pre>"},{"location":"reference/#arguments_209","title":"Arguments","text":"<code>...</code> <p>any Expr or string</p>"},{"location":"reference/#value_351","title":"Value","text":"<p>A new <code>LazyFrame</code> object.</p>"},{"location":"reference/#lazygroupby-apply","title":"LazyGroupBy apply","text":""},{"location":"reference/#description_376","title":"Description","text":"<p>one day this will apply</p>"},{"location":"reference/#usage_264","title":"Usage","text":"<pre><code>LazyGroupBy_apply(f)\n</code></pre>"},{"location":"reference/#arguments_210","title":"Arguments","text":"<code>f</code> <p>R function to apply</p>"},{"location":"reference/#value_352","title":"Value","text":"<p>A new <code>LazyFrame</code> object.</p>"},{"location":"reference/#lazygroupby-head","title":"LazyGroupBy head","text":""},{"location":"reference/#description_377","title":"Description","text":"<p>get n rows of head of group</p>"},{"location":"reference/#usage_265","title":"Usage","text":"<pre><code>LazyGroupBy_head(n = 1L)\n</code></pre>"},{"location":"reference/#arguments_211","title":"Arguments","text":"<code>n</code> <p>integer number of rows to get</p>"},{"location":"reference/#value_353","title":"Value","text":"<p>A new <code>LazyFrame</code> object.</p>"},{"location":"reference/#lazygroupby-print","title":"LazyGroupBy print","text":""},{"location":"reference/#description_378","title":"Description","text":"<p>prints opague groupby, not much to show</p>"},{"location":"reference/#usage_266","title":"Usage","text":"<pre><code>LazyGroupBy_print()\n</code></pre>"},{"location":"reference/#lazygroupby-tail","title":"LazyGroupBy tail","text":""},{"location":"reference/#description_379","title":"Description","text":"<p>get n tail rows of group</p>"},{"location":"reference/#usage_267","title":"Usage","text":"<pre><code>LazyGroupBy_tail(n = 1L)\n</code></pre>"},{"location":"reference/#arguments_212","title":"Arguments","text":"<code>n</code> <p>integer number of rows to get</p>"},{"location":"reference/#value_354","title":"Value","text":"<p>A new <code>LazyFrame</code> object.</p>"},{"location":"reference/#lengthseries","title":"Length.Series","text":""},{"location":"reference/#description_380","title":"Description","text":"<p>Length of series</p>"},{"location":"reference/#usage_268","title":"Usage","text":"<pre><code>## S3 method for class 'Series'\nlength(x)\n</code></pre>"},{"location":"reference/#arguments_213","title":"Arguments","text":"<code>x</code> <p>a Series</p>"},{"location":"reference/#value_355","title":"Value","text":"<p>the length as a double</p>"},{"location":"reference/#macro-add-syntax-check-to-class","title":"Macro add syntax check to class","text":""},{"location":"reference/#description_381","title":"Description","text":"<p>add syntax verification to class</p>"},{"location":"reference/#usage_269","title":"Usage","text":"<pre><code>macro_add_syntax_check_to_class(Class_name)\n</code></pre>"},{"location":"reference/#arguments_214","title":"Arguments","text":"<code>Class_name</code> <p>string name of env class</p>"},{"location":"reference/#details_115","title":"Details","text":"<p>this function overrides dollarclass method of a extendr env_class to run first verify_method_call() to check for syntax error and return more user friendly error if issues</p> <p>All R functions coined 'macro'-functions use eval(parse()) but only at package build time to solve some tricky self-referential problem. If possible to deprecate a macro in a clean way , go ahead.</p> <p>see zzz.R for usage examples</p>"},{"location":"reference/#value_356","title":"Value","text":"<p>dollarsign method with syntax verification</p>"},{"location":"reference/#see-also_2","title":"See Also","text":"<p>verify_method_call</p>"},{"location":"reference/#macro-new-subnamespace","title":"Macro new subnamespace","text":""},{"location":"reference/#description_382","title":"Description","text":"<p>Bundle class methods into an environment (subname space)</p>"},{"location":"reference/#usage_270","title":"Usage","text":"<pre><code>macro_new_subnamespace(class_pattern, subclass_env = NULL, remove_f = TRUE)\n</code></pre>"},{"location":"reference/#arguments_215","title":"Arguments","text":"<code>class_pattern</code> <p>regex to select functions</p> <code>subclass_env</code> <p>optional subclass of</p> <code>remove_f</code> <p>drop sourced functions from package ns after bundling into sub ns</p>"},{"location":"reference/#details_116","title":"Details","text":"<p>This function is used to emulate py-polars subnamespace-methods All R functions coined 'macro_'-functions use eval(parse()) but only at package build time to solve some tricky self-referential problem. If possible to deprecate a macro in a clean way , go ahead.</p>"},{"location":"reference/#value_357","title":"Value","text":"<p>A function which returns a subclass environment of bundled class functions.</p>"},{"location":"reference/#examples_336","title":"Examples","text":"<pre><code>#macro_new_subnamespace() is not exported, export for this toy example\n#macro_new_subnamespace = polars:::macro_new_subnamespace\n##define some new methods prefixed 'MyClass_'\n#MyClass_add2 = function() self + 2\n#MyClass_mul2 = function() self * 2\n##grab any sourced function prefixed 'MyClass_'\n#my_class_sub_ns = macro_new_subnamespace(\"^MyClass_\", \"myclass_sub_ns\")\n#here adding sub-namespace as a expr-class property/method during session-time,\n#which only is for this demo.\n#instead sourced method like Expr_arr() at package build time instead\n#env = polars:::Expr #get env of the Expr Class\n#env$my_sub_ns = method_as_property(function() { #add a property/method\n# my_class_sub_ns(self)\n#})\n#rm(env) #optional clean up\n#add user defined S3 method the subclass 'myclass_sub_ns'\n#print.myclass_sub_ns = function(x, ...) { #add ... even if not used\n#   print(\"hello world, I'm myclass_sub_ns\")\n#   print(\"methods in sub namespace are:\")\n#  print(ls(x))\n#  }\n#test\n# e = pl$lit(1:5)  #make an Expr\n#print(e$my_sub_ns) #inspect\n#e$my_sub_ns$add2() #use the sub namespace\n#e$my_sub_ns$mul2()\n</code></pre>"},{"location":"reference/#map-err","title":"Map err","text":""},{"location":"reference/#description_383","title":"Description","text":"<p>map an Err part of Result</p>"},{"location":"reference/#usage_271","title":"Usage","text":"<pre><code>map_err(x, f)\n</code></pre>"},{"location":"reference/#arguments_216","title":"Arguments","text":"<code>x</code> <p>any R object</p> <code>f</code> <p>a closure that takes the err part as input</p>"},{"location":"reference/#value_358","title":"Value","text":"<p>same R object wrapped in a Err-result</p>"},{"location":"reference/#map","title":"Map","text":""},{"location":"reference/#description_384","title":"Description","text":"<p>map an Err part of Result</p>"},{"location":"reference/#usage_272","title":"Usage","text":"<pre><code>map(x, f)\n</code></pre>"},{"location":"reference/#arguments_217","title":"Arguments","text":"<code>x</code> <p>any R object</p> <code>f</code> <p>a closure that takes the ok part as input</p>"},{"location":"reference/#value_359","title":"Value","text":"<p>same R object wrapped in a Err-result</p>"},{"location":"reference/#max","title":"Max","text":""},{"location":"reference/#description_385","title":"Description","text":"<p>Folds the expressions from left to right, keeping the first non-null value.</p>"},{"location":"reference/#arguments_218","title":"Arguments","text":"<code>...</code> <p>is a: If one arg:</p> <ul> <li><p>Series or Expr, same as <code>column$sum()</code></p></li> <li><p>string, same as <code>pl$col(column)$sum()</code></p></li> <li><p>numeric, same as <code>pl$lit(column)$sum()</code></p></li> <li><p>list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ...</p></li> </ul> <p>If several args, then wrapped in a list and handled as above.</p>"},{"location":"reference/#value_360","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_337","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = NA_real_,\nb = c(1:2,NA_real_,NA_real_),\nc = c(1:3,NA_real_)\n)\n#use coalesce to get first non Null value for each row, otherwise insert 99.9\ndf$with_column(\npl$coalesce(\"a\", \"b\", \"c\", 99.9)$alias(\"d\")\n)\n</code></pre>"},{"location":"reference/#mem-address","title":"Mem address","text":""},{"location":"reference/#description_386","title":"Description","text":"<p>mimics pl$mem_address</p>"},{"location":"reference/#arguments_219","title":"Arguments","text":"<code>robj</code> <p>an R object</p>"},{"location":"reference/#value_361","title":"Value","text":"<p>String of mem address</p>"},{"location":"reference/#examples_338","title":"Examples","text":"<pre><code>pl$mem_address(pl$Series(1:3))\n</code></pre>"},{"location":"reference/#method-as-property","title":"Method as property","text":""},{"location":"reference/#description_387","title":"Description","text":"<p>Internal function, see use in source</p>"},{"location":"reference/#usage_273","title":"Usage","text":"<pre><code>method_as_property(f, setter = FALSE)\n</code></pre>"},{"location":"reference/#arguments_220","title":"Arguments","text":"<code>f</code> <p>a function</p> <code>setter</code> <p>bool, if true a property method can be modified by user</p>"},{"location":"reference/#value_362","title":"Value","text":"<p>function subclassed into c(\"property\",\"function\") or c(\"setter\",\"property\",\"function\")</p>"},{"location":"reference/#min","title":"Min","text":""},{"location":"reference/#description_388","title":"Description","text":"<p>Folds the expressions from left to right, keeping the first non-null value.</p>"},{"location":"reference/#arguments_221","title":"Arguments","text":"<code>...</code> <p>is a: If one arg:</p> <ul> <li><p>Series or Expr, same as <code>column$sum()</code></p></li> <li><p>string, same as <code>pl$col(column)$sum()</code></p></li> <li><p>numeric, same as <code>pl$lit(column)$sum()</code></p></li> <li><p>list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ...</p></li> </ul> <p>If several args, then wrapped in a list and handled as above.</p>"},{"location":"reference/#value_363","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_339","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = NA_real_,\nb = c(2:1,NA_real_,NA_real_),\nc = c(1:3,NA_real_),\nd = c(1:2,NA_real_,-Inf)\n)\n#use min to get first non Null value for each row, otherwise insert 99.9\ndf$with_column(\npl$min(\"a\", \"b\", \"c\", 99.9)$alias(\"d\")\n)\n</code></pre>"},{"location":"reference/#move-env-elements","title":"Move env elements","text":""},{"location":"reference/#description_389","title":"Description","text":"<p>Move environment elements from one env to another</p>"},{"location":"reference/#usage_274","title":"Usage","text":"<pre><code>move_env_elements(from_env, to_env, element_names, remove = TRUE)\n</code></pre>"},{"location":"reference/#arguments_222","title":"Arguments","text":"<code>from_env</code> <p>env from</p> <code>to_env</code> <p>env to</p> <code>element_names</code> <p>names of elements to move, if named names, then name of name is to_env name</p> <code>remove</code> <p>bool, actually remove element in from_env</p>"},{"location":"reference/#nanoarrow","title":"Nanoarrow","text":""},{"location":"reference/#description_390","title":"Description","text":"<p>Conversion via native apache arrow array stream (fast), THIS REQUIRES \u00b4nanoarrow\u00b4</p>"},{"location":"reference/#usage_275","title":"Usage","text":"<pre><code>as_nanoarrow_array_stream.DataFrame(x, ..., schema = NULL)\n\ninfer_nanoarrow_schema.DataFrame(x, ...)\n\nas_arrow_table.DataFrame(x, ...)\n\nas_record_batch_reader.DataFrame(x, ..., schema = NULL)\n</code></pre>"},{"location":"reference/#arguments_223","title":"Arguments","text":"<code>x</code> <p>a polars DataFrame</p> <code>...</code> <p>not used right now</p> <code>schema</code> <p>must stay at default value NULL</p>"},{"location":"reference/#details_117","title":"Details","text":"<p>The following functions enable conversion to <code>nanoarrow</code> and <code>arrow</code>. Conversion kindly provided by \"paleolimbot / Dewey Dunnington\" Author of <code>nanoarrow</code>. Currently these conversions are the fastest way to convert from polars to R.</p>"},{"location":"reference/#value_364","title":"Value","text":"<ul> <li>a nanoarrow array stream</li> </ul> <ul> <li>a nanoarrow array schema</li> </ul> <ul> <li>an arrow table</li> </ul> <ul> <li>an arrow record batch reader</li> </ul>"},{"location":"reference/#examples_340","title":"Examples","text":"<pre><code>library(nanoarrow)\ndf = pl$DataFrame(mtcars)\nnanoarrow_array_stream = as_nanoarrow_array_stream(df)\nrdf = as.data.frame(nanoarrow_array_stream)\nprint(head(rdf))\nnanoarrow_array_schema = infer_nanoarrow_schema(df)\nprint(nanoarrow_array_schema)\nlibrary(arrow)\narrow_table = as_arrow_table(df)\nprint(arrow_table)\narrow_record_batch_reader = as_record_batch_reader(df) #requires arrow\nprint(arrow_record_batch_reader)\n</code></pre>"},{"location":"reference/#object","title":"Object","text":""},{"location":"reference/#description_391","title":"Description","text":"<p>One SEXP of Rtype: \"externalptr\" + a class attribute</p>"},{"location":"reference/#usage_276","title":"Usage","text":"<pre><code>object\n</code></pre>"},{"location":"reference/#format_177","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#details_118","title":"Details","text":"<ul> <li> <p><code>object$method()</code> calls are facilitated by a <code>\u2060$.ClassName\u2060</code>- s3method     see 'R/after-wrappers.R'</p> </li> <li> <p>Code completion is facilitted by <code>.DollarNames.ClassName</code>-s3method     see e.g. 'R/dataframe__frame.R'</p> </li> <li> <p>Implementation of property-methods as DataFrame_columns() and     syntax checking is an extension to <code>\u2060$.ClassName\u2060</code> See function     macro_add_syntax_check_to_class().</p> </li> </ul>"},{"location":"reference/#examples_341","title":"Examples","text":"<pre><code>#all a polars object is made of:\nsome_polars_object = pl$DataFrame(iris)\nstr(some_polars_object) #External Pointer tagged with a class attribute.\n</code></pre>"},{"location":"reference/#ok","title":"Ok","text":""},{"location":"reference/#description_392","title":"Description","text":"<p>Wrap in Ok</p>"},{"location":"reference/#usage_277","title":"Usage","text":"<pre><code>Ok(x)\n</code></pre>"},{"location":"reference/#arguments_224","title":"Arguments","text":"<code>x</code> <p>any R object</p>"},{"location":"reference/#value_365","title":"Value","text":"<p>same R object wrapped in a Ok-result</p>"},{"location":"reference/#or-else","title":"Or else","text":""},{"location":"reference/#description_393","title":"Description","text":"<p>map an Err part of Result</p>"},{"location":"reference/#usage_278","title":"Usage","text":"<pre><code>or_else(x, f)\n</code></pre>"},{"location":"reference/#arguments_225","title":"Arguments","text":"<code>x</code> <p>any R object</p> <code>f</code> <p>a closure that takes the ok part as input, must return a result itself</p>"},{"location":"reference/#value_366","title":"Value","text":"<p>same R object wrapped in a Err-result</p>"},{"location":"reference/#pcase","title":"Pcase","text":""},{"location":"reference/#description_394","title":"Description","text":"<p>Inspired by data.table::fcase + dplyr::case_when. Used instead of base::switch internally.</p>"},{"location":"reference/#usage_279","title":"Usage","text":"<pre><code>pcase(..., or_else = NULL)\n</code></pre>"},{"location":"reference/#arguments_226","title":"Arguments","text":"<code>...</code> <p>odd arugments are bool statements, a next even argument is returned if prior bool statement is the first true</p> <code>or_else</code> <p>return this if no bool statements were true</p>"},{"location":"reference/#details_119","title":"Details","text":"<p>Lifecycle: perhaps replace with something written in rust to speed up a bit</p>"},{"location":"reference/#value_367","title":"Value","text":"<p>any return given first true bool statement otherwise value of or_else</p>"},{"location":"reference/#examples_342","title":"Examples","text":"<pre><code>n = 7\npolars:::pcase(\nn&lt;5,\"nope\",\nn&gt;6,\"yeah\",\nor_else = stopf(\"failed to have a case for n=%s\",n)\n)\n</code></pre>"},{"location":"reference/#pl-concat","title":"Pl concat","text":""},{"location":"reference/#description_395","title":"Description","text":"<p>Concat polars objects</p>"},{"location":"reference/#arguments_227","title":"Arguments","text":"<code>l</code> <p>list of DataFrame, or Series, LazyFrame or Expr</p> <code>rechunk</code> <p>perform a rechunk at last</p> <code>how</code> <p>choice of bind direction \"vertical\"(rbind) \"horizontal\"(cbind) \"diagnoal\" diagonally</p> <code>parallel</code> <p>BOOL default TRUE, only used for LazyFrames</p>"},{"location":"reference/#value_368","title":"Value","text":"<p>DataFrame, or Series, LazyFrame or Expr</p>"},{"location":"reference/#examples_343","title":"Examples","text":"<pre><code>#vertical\nl_ver = lapply(1:10, function(i) {\nl_internal = list(\na = 1:5,\nb = letters[1:5]\n)\npl$DataFrame(l_internal)\n})\npl$concat(l_ver, how=\"vertical\")\n#horizontal\nl_hor = lapply(1:10, function(i) {\nl_internal = list(\n1:5,\nletters[1:5]\n)\nnames(l_internal) = paste0(c(\"a\",\"b\"),i)\npl$DataFrame(l_internal)\n})\npl$concat(l_hor, how = \"horizontal\")\n#diagonal\npl$concat(l_hor, how = \"diagonal\")\n</code></pre>"},{"location":"reference/#pl-date-range","title":"Pl date range","text":""},{"location":"reference/#description_396","title":"Description","text":"<p>new date_range</p>"},{"location":"reference/#arguments_228","title":"Arguments","text":"<code>low</code> <p>POSIXt or Date preferably with time_zone or double or integer</p> <code>high</code> <p>POSIXt or Date preferably with time_zone or double or integer. If high is and interval are missing, then single datetime is constructed.</p> <code>interval</code> <p>string pl_duration or R difftime. Can be missing if high is missing also.</p> <code>lazy</code> <p>bool, if TRUE return expression</p> <code>closed</code> <p>option one of 'both'(default), 'left', 'none' or 'right'</p> <code>name</code> <p>name of series</p> <code>time_unit</code> <p>option string (\"ns\" \"us\" \"ms\") duration of one int64 value on polars side</p> <code>time_zone</code> <p>optional string describing a timezone.</p>"},{"location":"reference/#details_120","title":"Details","text":"<p>If param time_zone is not defined the Series will have no time zone.</p> <p>NOTICE: R POSIXt without defined timezones(tzone/tz), so called naive datetimes, are counter intuitive in R. It is recommended to always set the timezone of low and high. If not output will vary between local machine timezone, R and polars.</p> <p>In R/r-polars it is perfectly fine to mix timezones of params time_zone, low and high.</p>"},{"location":"reference/#value_369","title":"Value","text":"<p>a datetime</p>"},{"location":"reference/#examples_344","title":"Examples","text":"<pre><code># All in GMT, straight forward, no mental confusion\ns_gmt = pl$date_range(\nas.POSIXct(\"2022-01-01\",tz = \"GMT\"),\nas.POSIXct(\"2022-01-02\",tz = \"GMT\"),\ninterval = \"6h\", time_unit = \"ms\", time_zone = \"GMT\"\n)\ns_gmt\ns_gmt$to_r() #printed same way in R and polars becuase tagged with a time_zone/tzone\n# polars assumes any input in GMT if time_zone = NULL, set GMT on low high to see same print\ns_null = pl$date_range(\nas.POSIXct(\"2022-01-01\",tz = \"GMT\"),\nas.POSIXct(\"2022-01-02\",tz = \"GMT\"),\ninterval = \"6h\", time_unit = \"ms\", time_zone = NULL\n)\ns_null$to_r() #back to R POSIXct. R prints non tzone tagged POSIXct in local timezone.\n#Any mixing of timezones is fine, just set them all, and it works as expected.\nt1 = as.POSIXct(\"2022-01-01\", tz = \"Etc/GMT+2\")\nt2 = as.POSIXct(\"2022-01-01 08:00:00\", tz = \"Etc/GMT-2\")\ns_mix = pl$date_range(low = t1, high = t2, interval = \"1h\", time_unit = \"ms\", time_zone = \"CET\")\ns_mix\ns_mix$to_r()\n#use of ISOdate\nt1 = ISOdate(2022,1,1,0) #preset GMT\nt2 = ISOdate(2022,1,2,0) #preset GMT\npl$date_range(t1,t2,interval = \"4h\", time_unit = \"ms\", time_zone = \"GMT\")\n</code></pre>"},{"location":"reference/#pl-datetime","title":"Pl Datetime","text":""},{"location":"reference/#description_397","title":"Description","text":"<p>Datetime DataType constructor</p>"},{"location":"reference/#arguments_229","title":"Arguments","text":"<code>tu</code> <p>string option either \"ms\", \"us\" or \"ns\"</p> <code>tz</code> <p>string the Time Zone, see details</p>"},{"location":"reference/#format_178","title":"Format","text":"<p>function</p>"},{"location":"reference/#details_121","title":"Details","text":"<p>all allowed TimeZone designations can be found in <code>base::OlsonNames()</code></p>"},{"location":"reference/#value_370","title":"Value","text":"<p>Datetime DataType</p>"},{"location":"reference/#examples_345","title":"Examples","text":"<pre><code>pl$Datetime(\"ns\",\"Pacific/Samoa\")\n</code></pre>"},{"location":"reference/#pl-field","title":"Pl Field","text":""},{"location":"reference/#description_398","title":"Description","text":"<p>Create Field</p>"},{"location":"reference/#arguments_230","title":"Arguments","text":"<code>name</code> <p>string name</p> <code>datatype</code> <p>DataType</p>"},{"location":"reference/#details_122","title":"Details","text":"<p>A Field is not a DataType but a name + DataType Fields are used in Structs-datatypes and Schemas to represent everything of the Series/Column except the raw values.</p>"},{"location":"reference/#value_371","title":"Value","text":"<p>a list DataType with an inner DataType</p>"},{"location":"reference/#examples_346","title":"Examples","text":"<pre><code>#make a struct\npl$Field(\"city_names\",pl$Utf8)\n# find any DataType bundled pl$dtypes\nprint(pl$dtypes)\n</code></pre>"},{"location":"reference/#pl-list","title":"Pl List","text":""},{"location":"reference/#description_399","title":"Description","text":"<p>Create List DataType</p>"},{"location":"reference/#arguments_231","title":"Arguments","text":"<code>datatype</code> <p>an inner DataType</p>"},{"location":"reference/#format_179","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_372","title":"Value","text":"<p>a list DataType with an inner DataType</p>"},{"location":"reference/#examples_347","title":"Examples","text":"<pre><code>pl$List(pl$List(pl$Boolean))\n</code></pre>"},{"location":"reference/#pl-ptime","title":"Pl PTime","text":""},{"location":"reference/#description_400","title":"Description","text":"<p>Store Time in R</p>"},{"location":"reference/#arguments_232","title":"Arguments","text":"<code>x</code> <p>an integer or double vector of n epochs since midnight OR a char vector of char times passed to as.POSIXct converted to seconds.</p> <code>tu</code> <p>timeunit either \"s\",\"ms\",\"us\",\"ns\"</p> <code>fmt</code> <p>a format string passed to as.POSIXct format via ...</p>"},{"location":"reference/#details_123","title":"Details","text":"<p>PTime should probably be replaced with package nanotime or similar.</p> <p>base R is missing encoding of Time since midnight \"s\" \"ms\", \"us\" and \"ns\". The latter \"ns\" is the standard for the polars Time type.</p> <p>Use PTime to convert R doubles and integers and use as input to polars functions which needs a time.</p> <p>Loosely inspired by data.table::ITime which is i32 only. PTime must support polars native timeunit is nanoseconds. The R double(float64) can imitate a i64 ns with full precision within the full range of 24 hours.</p> <p>PTime does not have a time zone and always prints the time as is no matter local machine time zone.</p> <p>An essential difference between R and polars is R prints POSIXct/lt without a timezone in local time. Polars prints Datetime without a timezone label as is (GMT). For POSIXct/lt taged with a timexone(tzone) and Datetime with a timezone(tz) the behavior is the same conversion is intuitive.</p> <p>It appears behavior of R timezones is subject to change a bit in R 4.3.0, see polars unit test test-expr_datetime.R/\"pl$date_range Date lazy/eager\".</p>"},{"location":"reference/#value_373","title":"Value","text":"<p>a PTime vector either double or integer, with class \"PTime\" and attribute \"tu\" being either \"s\",\"ms\",\"us\" or \"ns\"</p>"},{"location":"reference/#examples_348","title":"Examples","text":"<pre><code>#make PTime in all time units\npl$PTime(runif(5)*3600*24*1E0, tu = \"s\")\npl$PTime(runif(5)*3600*24*1E3, tu = \"ms\")\npl$PTime(runif(5)*3600*24*1E6, tu = \"us\")\npl$PTime(runif(5)*3600*24*1E9, tu = \"ns\")\npl$PTime(\"23:59:59\")\npl$Series(pl$PTime(runif(5)*3600*24*1E0, tu = \"s\"))\npl$lit(pl$PTime(\"23:59:59\"))$lit_to_s()\npl$lit(pl$PTime(\"23:59:59\"))$to_r()\n</code></pre>"},{"location":"reference/#pl-select","title":"Pl select","text":""},{"location":"reference/#description_401","title":"Description","text":"<p>Select from an empty DataFrame</p>"},{"location":"reference/#format_180","title":"Format","text":"<p>method</p>"},{"location":"reference/#details_124","title":"Details","text":"<p>param ... expressions passed to select <code>pl$select</code> is a shorthand for <code>pl$DataFrame(list())$select</code></p> <p>NB param of this function</p>"},{"location":"reference/#value_374","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/#examples_349","title":"Examples","text":"<pre><code>pl$select(\npl$lit(1:4)$alias(\"ints\"),\npl$lit(letters[1:4])$alias(\"letters\")\n)\n</code></pre>"},{"location":"reference/#pl-struct","title":"Pl Struct","text":""},{"location":"reference/#description_402","title":"Description","text":"<p>Struct DataType Constructor</p>"},{"location":"reference/#arguments_233","title":"Arguments","text":"<code>datatype</code> <p>an inner DataType</p>"},{"location":"reference/#format_181","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_375","title":"Value","text":"<p>a list DataType with an inner DataType</p>"},{"location":"reference/#examples_350","title":"Examples","text":"<pre><code># create a Struct-DataType\npl$List(pl$List(pl$Boolean))\n# Find any DataType via pl$dtypes\nprint(pl$dtypes)\n</code></pre>"},{"location":"reference/#pl-cash-from-arrow","title":"Pl-cash-from arrow","text":""},{"location":"reference/#description_403","title":"Description","text":"<p>import Arrow Table or Array</p>"},{"location":"reference/#arguments_234","title":"Arguments","text":"<code>data</code> <p>arrow Table or Array or ChunkedArray</p> <code>rechunk</code> <p>bool rewrite in one array per column, Implemented for ChunkedArray Array is already contiguous. Not implemented for Table. C</p> <code>schema</code> <p>named list of DataTypes or char vec of names. Same length as arrow table. If schema names or types do not match arrow table, the columns will be renamed/recasted. NULL default is to import columns as is. Takes no effect for Array or ChunkedArray</p> <code>schema_overrides</code> <p>named list of DataTypes. Name some columns to recast by the DataType. Takes not effect for Array or ChunkedArray</p>"},{"location":"reference/#value_376","title":"Value","text":"<p>DataFrame or Series</p>"},{"location":"reference/#examples_351","title":"Examples","text":"<pre><code>pl$from_arrow(\ndata = arrow::arrow_table(iris),\nschema_overrides = list(Sepal.Length=pl$Float32, Species = pl$Utf8)\n)\nchar_schema = names(iris)\nchar_schema[1] = \"Alice\"\npl$from_arrow(\ndata = arrow::arrow_table(iris),\nschema = char_schema\n)\n</code></pre>"},{"location":"reference/#pl","title":"Pl","text":""},{"location":"reference/#description_404","title":"Description","text":"<p><code>pl</code>-object is a environment of all public functions and class constructors. Public functions are not exported as a normal package as it would be huge namespace collision with base:: and other functions. All object-methods are accessed with object$method() via the new class functions.</p> <p>Having all functions in an namespace is similar to the rust- and python- polars api.</p>"},{"location":"reference/#usage_280","title":"Usage","text":"<pre><code>pl\n</code></pre>"},{"location":"reference/#format_182","title":"Format","text":"<p>An object of class <code>environment</code> of length 57.</p>"},{"location":"reference/#details_125","title":"Details","text":"<p>If someone do not particularly like the letter combination <code>pl</code>, they are free to bind the environment to another variable name as <code>simon_says = pl</code> or even do <code>attach(pl)</code></p>"},{"location":"reference/#examples_352","title":"Examples","text":"<pre><code>#how to use polars via `pl`\npl$col(\"colname\")$sum() / pl$lit(42L)  #expression ~ chain-method / literal-expression\n#pl inventory\npolars:::print_env(pl,\"polars public functions\")\n#all accessible classes and their public methods\npolars:::print_env(\npolars:::pl_pub_class_env,\n\"polars public class methods, access via object$method()\"\n)\n</code></pre>"},{"location":"reference/#polars-options","title":"Polars options","text":""},{"location":"reference/#description_405","title":"Description","text":"<p>get, set, reset polars options</p>"},{"location":"reference/#arguments_235","title":"Arguments","text":"<code>strictly_immutable</code> <p>bool, default = TRUE, keep polars strictly immutable. Polars/arrow is in general pro \"immutable objects\". However pypolars API has some minor exceptions. All settable property elements of classes are mutable. Why?, I guess python just do not have strong stance on immutability. R strongly suggests immutable objects, so why not make polars strictly immutable where little performance costs? However, if to mimic pypolars as much as possible, set this to FALSE.</p> <code>named_exprs</code> <p>bool, default = FALSE, allow named exprs in e.g. select, with_columns, groupby, join. a named expresion will be extended with $alias(name) wildcards or expression producing multiple are problematic due to name collision the related option in py-polars is currently called 'pl.Config.with_columns_kwargs' and only allow named exprs in with_columns (or potentially any method derived there of)</p> <code>no_messages</code> <p>bool, default = FALSE, turn of messages</p> <code>do_not_repeat_call</code> <p>bool, default = FALSE, turn of messages</p> <code>...</code> <p>any options to modify</p> <code>return_replaced_options</code> <p>return previous state of modified options Convenient for temporarily swapping of options during testing.</p>"},{"location":"reference/#details_126","title":"Details","text":"<p>who likes polars package messages? use this option to turn them off.</p> <p>do not print the call causing the error in error messages</p> <p>modifing list takes no effect, pass it to pl$set_polars_options get/set/resest interact with internal env <code>polars:::polars_optenv</code></p> <p>setting an options may be rejected if not passing opt_requirements</p>"},{"location":"reference/#value_377","title":"Value","text":"<p>current settings as list</p> <p>current settings as list</p> <p>list named by options of requirement function input must satisfy</p>"},{"location":"reference/#examples_353","title":"Examples","text":"<pre><code>#rename columns by naming expression, experimental requires option named_exprs = TRUE\npl$set_polars_options(named_exprs = TRUE)\npl$DataFrame(iris)$with_columns(\npl$col(\"Sepal.Length\")$abs(), #not named expr will keep name \"Sepal.Length\"\nSW_add_2 = (pl$col(\"Sepal.Width\")+2)\n)\npl$get_polars_options()\npl$set_polars_options(strictly_immutable = FALSE)\npl$get_polars_options()\n#setting strictly_immutable = 42 will be rejected as\ntryCatch(\npl$set_polars_options(strictly_immutable = 42),\nerror= function(e) print(e)\n)\n#reset options like this\npl$reset_polars_options()\n#use get_polars_opt_requirements() to requirements\npl$get_polars_opt_requirements()\n</code></pre>"},{"location":"reference/#polars-runtime-flags","title":"Polars runtime flags","text":""},{"location":"reference/#description_406","title":"Description","text":"<p>This environment is used internally for the package to remember what has been going on. Currently only used to throw one-time warnings()</p>"},{"location":"reference/#usage_281","title":"Usage","text":"<pre><code>runtime_state\n</code></pre>"},{"location":"reference/#format_183","title":"Format","text":"<p>An object of class <code>environment</code> of length 0.</p>"},{"location":"reference/#polarsbackgroundhandle-is-exhausted","title":"PolarsBackgroundHandle is exhausted","text":""},{"location":"reference/#description_407","title":"Description","text":"<p>PolarsBackgroundHandle</p>"},{"location":"reference/#usage_282","title":"Usage","text":"<pre><code>PolarsBackgroundHandle_is_exhausted()\n</code></pre>"},{"location":"reference/#value_378","title":"Value","text":"<p>Bool</p>"},{"location":"reference/#examples_354","title":"Examples","text":"<pre><code>lazy_df = pl$DataFrame(iris[,1:3])$lazy()$select(pl$all()$first())\nhandle = lazy_df$collect_background()\nhandle$is_exhausted()\ndf = handle$join()\nhandle$is_exhausted()\n</code></pre>"},{"location":"reference/#polarsbackgroundhandle-join","title":"PolarsBackgroundHandle join","text":""},{"location":"reference/#description_408","title":"Description","text":"<p>PolarsBackgroundHandle</p>"},{"location":"reference/#usage_283","title":"Usage","text":"<pre><code>PolarsBackgroundHandle_join()\n</code></pre>"},{"location":"reference/#value_379","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/#examples_355","title":"Examples","text":"<pre><code>lazy_df = pl$DataFrame(iris[,1:3])$lazy()$select(pl$all()$first())\nhandle = lazy_df$collect_background()\ndf = handle$join()\n</code></pre>"},{"location":"reference/#prepare-alpha","title":"Prepare alpha","text":""},{"location":"reference/#description_409","title":"Description","text":"<p>internal function for emw_x expressions</p>"},{"location":"reference/#usage_284","title":"Usage","text":"<pre><code>prepare_alpha(com = NULL, span = NULL, half_life = NULL, alpha = NULL)\n</code></pre>"},{"location":"reference/#arguments_236","title":"Arguments","text":"<code>com</code> <p>numeric or NULL</p> <code>span</code> <p>numeric or NULL</p> <code>half_life</code> <p>numeric or NULL</p> <code>alpha</code> <p>numeric or NULL</p>"},{"location":"reference/#value_380","title":"Value","text":"<p>numeric</p>"},{"location":"reference/#print-env","title":"Print env","text":""},{"location":"reference/#description_410","title":"Description","text":"<p>print recursively an environment, used in some documentation</p>"},{"location":"reference/#usage_285","title":"Usage","text":"<pre><code>print_env(api, name, max_depth = 10)\n</code></pre>"},{"location":"reference/#arguments_237","title":"Arguments","text":"<code>api</code> <p>env</p> <code>name</code> <p>name of env</p> <code>max_depth</code> <p>numeric/int max levels to recursive iterate through</p>"},{"location":"reference/#print-open-paren-close-paren","title":"Print-open-paren-close-paren","text":""},{"location":"reference/#description_411","title":"Description","text":"<p>s3 method print DataFrame</p>"},{"location":"reference/#usage_286","title":"Usage","text":"<pre><code>## S3 method for class 'DataFrame'\nprint(x, ...)\n</code></pre>"},{"location":"reference/#arguments_238","title":"Arguments","text":"<code>x</code> <p>DataFrame</p> <code>...</code> <p>not used</p>"},{"location":"reference/#value_381","title":"Value","text":"<p>self</p>"},{"location":"reference/#examples_356","title":"Examples","text":"<pre><code>pl$DataFrame(iris)\n</code></pre>"},{"location":"reference/#printexpr","title":"Print.Expr","text":""},{"location":"reference/#description_412","title":"Description","text":"<p>Print expr</p>"},{"location":"reference/#usage_287","title":"Usage","text":"<pre><code>## S3 method for class 'Expr'\nprint(x, ...)\n</code></pre>"},{"location":"reference/#arguments_239","title":"Arguments","text":"<code>x</code> <p>Expr</p> <code>...</code> <p>not used</p>"},{"location":"reference/#value_382","title":"Value","text":"<p>self</p>"},{"location":"reference/#examples_357","title":"Examples","text":"<pre><code>pl$col(\"some_column\")$sum()$over(\"some_other_column\")\n</code></pre>"},{"location":"reference/#printgroupby","title":"Print.GroupBy","text":""},{"location":"reference/#description_413","title":"Description","text":"<p>print GroupBy</p>"},{"location":"reference/#usage_288","title":"Usage","text":"<pre><code>## S3 method for class 'GroupBy'\nprint(x, ...)\n</code></pre>"},{"location":"reference/#arguments_240","title":"Arguments","text":"<code>x</code> <p>DataFrame</p> <code>...</code> <p>not used</p>"},{"location":"reference/#value_383","title":"Value","text":"<p>self</p>"},{"location":"reference/#examples_358","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$groupby(\"Species\")\n</code></pre>"},{"location":"reference/#printlazyframe","title":"Print.LazyFrame","text":""},{"location":"reference/#description_414","title":"Description","text":"<p>print LazyFrame s3 method</p>"},{"location":"reference/#usage_289","title":"Usage","text":"<pre><code>## S3 method for class 'LazyFrame'\nprint(x, ...)\n</code></pre>"},{"location":"reference/#arguments_241","title":"Arguments","text":"<code>x</code> <p>DataFrame</p> <code>...</code> <p>not used</p>"},{"location":"reference/#value_384","title":"Value","text":"<p>self</p>"},{"location":"reference/#examples_359","title":"Examples","text":"<pre><code>print(pl$DataFrame(iris)$lazy())\n</code></pre>"},{"location":"reference/#printlazygroupby","title":"Print.LazyGroupBy","text":""},{"location":"reference/#description_415","title":"Description","text":"<p>print LazyGroupBy</p>"},{"location":"reference/#usage_290","title":"Usage","text":"<pre><code>## S3 method for class 'LazyGroupBy'\nprint(x, ...)\n</code></pre>"},{"location":"reference/#arguments_242","title":"Arguments","text":"<code>x</code> <p>LazyGroupBy</p> <code>...</code> <p>not used</p>"},{"location":"reference/#value_385","title":"Value","text":"<p>self</p>"},{"location":"reference/#printpolarsbackgroundhandle","title":"Print.PolarsBackgroundHandle","text":""},{"location":"reference/#description_416","title":"Description","text":"<p>print LazyFrame s3 method</p>"},{"location":"reference/#usage_291","title":"Usage","text":"<pre><code>## S3 method for class 'PolarsBackgroundHandle'\nprint(x, ...)\n</code></pre>"},{"location":"reference/#arguments_243","title":"Arguments","text":"<code>x</code> <p>DataFrame</p> <code>...</code> <p>not used</p>"},{"location":"reference/#value_386","title":"Value","text":"<p>self</p>"},{"location":"reference/#examples_360","title":"Examples","text":"<pre><code>lazy_df = pl$DataFrame(iris[,1:3])$lazy()$select(pl$all()$first())\nhandle = lazy_df$collect_background()\nhandle$is_exhausted()\ndf = handle$join()\nhandle$is_exhausted()\n</code></pre>"},{"location":"reference/#printptime","title":"Print.PTime","text":""},{"location":"reference/#description_417","title":"Description","text":"<p>print PTime</p>"},{"location":"reference/#usage_292","title":"Usage","text":"<pre><code>## S3 method for class 'PTime'\nprint(x, ...)\n</code></pre>"},{"location":"reference/#arguments_244","title":"Arguments","text":"<code>x</code> <p>a PTime vector</p> <code>...</code> <p>not used</p>"},{"location":"reference/#value_387","title":"Value","text":"<p>invisible x</p>"},{"location":"reference/#printrfield","title":"Print.RField","text":""},{"location":"reference/#description_418","title":"Description","text":"<p>Print a polars Field</p>"},{"location":"reference/#usage_293","title":"Usage","text":"<pre><code>## S3 method for class 'RField'\nprint(x, ...)\n</code></pre>"},{"location":"reference/#arguments_245","title":"Arguments","text":"<code>x</code> <p>DataType</p> <code>...</code> <p>not used</p>"},{"location":"reference/#value_388","title":"Value","text":"<p>self</p>"},{"location":"reference/#examples_361","title":"Examples","text":"<pre><code>print(pl$Field(\"foo\",pl$List(pl$UInt64)))\n</code></pre>"},{"location":"reference/#printrpolarsdatatype","title":"Print.RPolarsDataType","text":""},{"location":"reference/#description_419","title":"Description","text":"<p>print a polars datatype</p>"},{"location":"reference/#usage_294","title":"Usage","text":"<pre><code>## S3 method for class 'RPolarsDataType'\nprint(x, ...)\n</code></pre>"},{"location":"reference/#arguments_246","title":"Arguments","text":"<code>x</code> <p>DataType</p> <code>...</code> <p>not used</p>"},{"location":"reference/#value_389","title":"Value","text":"<p>self</p>"},{"location":"reference/#examples_362","title":"Examples","text":"<pre><code>pl$dtypes$Boolean #implicit print\n</code></pre>"},{"location":"reference/#printwhen","title":"Print.When","text":""},{"location":"reference/#description_420","title":"Description","text":"<p>print When</p>"},{"location":"reference/#usage_295","title":"Usage","text":"<pre><code>## S3 method for class 'When'\nprint(x, ...)\n</code></pre>"},{"location":"reference/#arguments_247","title":"Arguments","text":"<code>x</code> <p>When object</p> <code>...</code> <p>not used</p>"},{"location":"reference/#value_390","title":"Value","text":"<p>self</p>"},{"location":"reference/#examples_363","title":"Examples","text":"<pre><code>print(pl$when(pl$col(\"a\")&gt;2))\n</code></pre>"},{"location":"reference/#printwhenthen","title":"Print.WhenThen","text":""},{"location":"reference/#description_421","title":"Description","text":"<p>print When</p>"},{"location":"reference/#usage_296","title":"Usage","text":"<pre><code>## S3 method for class 'WhenThen'\nprint(x, ...)\n</code></pre>"},{"location":"reference/#arguments_248","title":"Arguments","text":"<code>x</code> <p>When object</p> <code>...</code> <p>not used</p>"},{"location":"reference/#value_391","title":"Value","text":"<p>self</p>"},{"location":"reference/#examples_364","title":"Examples","text":"<pre><code>print(pl$when(pl$col(\"a\")&gt;2)$then(pl$lit(\"more than two\")))\n</code></pre>"},{"location":"reference/#printwhenthenthen","title":"Print.WhenThenThen","text":""},{"location":"reference/#description_422","title":"Description","text":"<p>print When</p>"},{"location":"reference/#usage_297","title":"Usage","text":"<pre><code>## S3 method for class 'WhenThenThen'\nprint(x, ...)\n</code></pre>"},{"location":"reference/#arguments_249","title":"Arguments","text":"<code>x</code> <p>When object</p> <code>...</code> <p>not used</p>"},{"location":"reference/#value_392","title":"Value","text":"<p>self</p>"},{"location":"reference/#examples_365","title":"Examples","text":"<pre><code>#\nprint(pl$when(pl$col(\"a\")&gt;2)$then(pl$lit(\"more than two\"))$when(pl$col(\"b\")&lt;5))\n</code></pre>"},{"location":"reference/#pstop","title":"Pstop","text":""},{"location":"reference/#description_423","title":"Description","text":"<p>DEPRECATED USE stopf instead</p>"},{"location":"reference/#usage_298","title":"Usage","text":"<pre><code>pstop(err, call = sys.call(1L))\n</code></pre>"},{"location":"reference/#arguments_250","title":"Arguments","text":"<code>err</code> <p>error msg string</p> <code>call</code> <p>calling context</p>"},{"location":"reference/#value_393","title":"Value","text":"<p>throws an error</p>"},{"location":"reference/#examples_366","title":"Examples","text":"<pre><code>f = function() polars:::pstop(\"this aint right!!\")\ntryCatch(f(), error = \\(e) as.character(e))\n</code></pre>"},{"location":"reference/#read-csv","title":"Read csv","text":""},{"location":"reference/#description_424","title":"Description","text":"<p>high level csv_reader, will download if path is url</p>"},{"location":"reference/#usage_299","title":"Usage","text":"<pre><code>read_csv_(path, lazy = FALSE, reuse_downloaded = TRUE, ...)\n</code></pre>"},{"location":"reference/#arguments_251","title":"Arguments","text":"<code>path</code> <p>file or url</p> <code>lazy</code> <p>bool default FALSE, read csv lazy</p> <code>reuse_downloaded</code> <p>bool default TRUE, cache url downloaded files in session an reuse</p> <code>...</code> <p>arguments forwarded to csv_reader or lazy_csv_reader</p>"},{"location":"reference/#value_394","title":"Value","text":"<p>polars_DataFrame or polars_lazy_DataFrame</p>"},{"location":"reference/#examples_367","title":"Examples","text":"<pre><code>df = pl$read_csv(\"https://j.mp/iriscsv\")\n</code></pre>"},{"location":"reference/#replace-private-with-pub-methods","title":"Replace private with pub methods","text":""},{"location":"reference/#description_425","title":"Description","text":"<p>extendr places the naked internal calls to rust in env-classes. This function can be used to delete them and replaces them with the public methods. Which are any function matching pattern typically '^CLASSNAME' e.g. '^DataFrame_' or '^Series_'. Likely only used in zzz.R</p>"},{"location":"reference/#usage_300","title":"Usage","text":"<pre><code>replace_private_with_pub_methods(\n  env,\n  class_pattern,\n  keep = c(),\n  remove_f = FALSE\n)\n</code></pre>"},{"location":"reference/#arguments_252","title":"Arguments","text":"<code>env</code> <p>class envrionment to modify. Envs are mutable so no return needed</p> <code>class_pattern</code> <p>a regex string matching declared public functions of that class</p> <code>keep</code> <p>list of unmentioned methods to keep in public api</p> <code>remove_f</code> <p>bool if true, will move methods, not copy</p>"},{"location":"reference/#value_395","title":"Value","text":"<p>side effects only</p>"},{"location":"reference/#restruct-list","title":"Restruct list","text":""},{"location":"reference/#description_426","title":"Description","text":"<p>lifecycle:: Deprecate Restruct an object where structs where previously unnested</p>"},{"location":"reference/#usage_301","title":"Usage","text":"<pre><code>restruct_list(l)\n</code></pre>"},{"location":"reference/#arguments_253","title":"Arguments","text":"<code>l</code> <p>list</p>"},{"location":"reference/#details_127","title":"Details","text":"<p>It was much easier impl export unnested struct from polars. This function restructs exported unnested structs. This function should be repalced with rust code writing this output directly before nesting. This hack relies on rust uses the tag \"is_struct\" to mark what should be re-structed.</p>"},{"location":"reference/#value_396","title":"Value","text":"<p>restructed list</p>"},{"location":"reference/#rfield-name","title":"RField name","text":""},{"location":"reference/#description_427","title":"Description","text":"<p>get/set Field name</p>"},{"location":"reference/#usage_302","title":"Usage","text":"<pre><code>RField_name()\n</code></pre>"},{"location":"reference/#value_397","title":"Value","text":"<p>name</p>"},{"location":"reference/#examples_368","title":"Examples","text":"<pre><code>field = pl$Field(\"Cities\",pl$Utf8)\n#get name / datatype\nfield$name\nfield$datatype\n#set + get values\nfield$name = \"CityPoPulations\" #&lt;- is fine too\nfield$datatype = pl$UInt32\nprint(field)\n</code></pre>"},{"location":"reference/#rfield-print","title":"RField print","text":""},{"location":"reference/#description_428","title":"Description","text":"<p>Print a polars Field</p>"},{"location":"reference/#usage_303","title":"Usage","text":"<pre><code>RField_print()\n</code></pre>"},{"location":"reference/#value_398","title":"Value","text":"<p>self</p>"},{"location":"reference/#examples_369","title":"Examples","text":"<pre><code>print(pl$Field(\"foo\",pl$List(pl$UInt64)))\n</code></pre>"},{"location":"reference/#same-outer-datatype","title":"Same outer datatype","text":""},{"location":"reference/#description_429","title":"Description","text":"<p>check if x is a valid RPolarsDataType</p>"},{"location":"reference/#arguments_254","title":"Arguments","text":"<code>lhs</code> <p>an RPolarsDataType</p> <code>rhs</code> <p>an RPolarsDataType</p>"},{"location":"reference/#value_399","title":"Value","text":"<p>bool TRUE if outer datatype is the same.</p>"},{"location":"reference/#examples_370","title":"Examples","text":"<pre><code># TRUE\npl$same_outer_dt(pl$Datetime(\"us\"),pl$Datetime(\"ms\"))\npl$same_outer_dt(pl$List(pl$Int64),pl$List(pl$Float32))\n#FALSE\npl$same_outer_dt(pl$Int64,pl$Float64)\n</code></pre>"},{"location":"reference/#scan-arrow-ipc","title":"Scan arrow ipc","text":""},{"location":"reference/#description_430","title":"Description","text":"<p>Import data in Apache Arrow IPC format</p>"},{"location":"reference/#usage_304","title":"Usage","text":"<pre><code>scan_arrow_ipc(\n  path,\n  n_rows = NULL,\n  cache = TRUE,\n  rechunk = TRUE,\n  row_count_name = NULL,\n  row_count_offset = 0L,\n  memmap = TRUE\n)\n</code></pre>"},{"location":"reference/#arguments_255","title":"Arguments","text":"<code>path</code> <p>string, path</p> <code>n_rows</code> <p>integer, limit rows to scan</p> <code>cache</code> <p>bool, use cache</p> <code>rechunk</code> <p>bool, rechunk reorganize memory layout, potentially make future operations faster, however perform reallocation now.</p> <code>row_count_name</code> <p>NULL or string, if a string add a rowcount column named by this string</p> <code>row_count_offset</code> <p>integer, the rowcount column can be offst by this value</p> <code>memmap</code> <p>bool, mapped memory</p>"},{"location":"reference/#details_128","title":"Details","text":"<p>Create new LazyFrame from Apache Arrow IPC file or stream</p>"},{"location":"reference/#value_400","title":"Value","text":"<p>LazyFrame</p>"},{"location":"reference/#scan-parquet","title":"Scan parquet","text":""},{"location":"reference/#description_431","title":"Description","text":"<p>new LazyFrame from parquet file</p>"},{"location":"reference/#usage_305","title":"Usage","text":"<pre><code>scan_parquet(\n  file,\n  n_rows = NULL,\n  cache = TRUE,\n  parallel = c(\"Auto\", \"None\", \"Columns\", \"RowGroups\"),\n  rechunk = TRUE,\n  row_count_name = NULL,\n  row_count_offset = 0L,\n  low_memory = FALSE\n)\n</code></pre>"},{"location":"reference/#arguments_256","title":"Arguments","text":"<code>file</code> <p>string filepath</p> <code>n_rows</code> <p>limit rows to scan</p> <code>cache</code> <p>bool use cache</p> <code>parallel</code> <p>String either Auto, None, Columns or RowGroups. The way to parralize the scan.</p> <code>rechunk</code> <p>bool rechunk reorganize memory layout, potentially make future operations faster , however perform reallocation now.</p> <code>row_count_name</code> <p>NULL or string, if a string add a rowcount column named by this string</p> <code>row_count_offset</code> <p>integer, the rowcount column can be offst by this value</p> <code>low_memory</code> <p>bool, try reduce memory footprint</p>"},{"location":"reference/#value_401","title":"Value","text":"<p>LazyFrame</p>"},{"location":"reference/#examples_371","title":"Examples","text":"<pre><code>#TODO write parquet example\n</code></pre>"},{"location":"reference/#series-abs","title":"Series abs","text":""},{"location":"reference/#description_432","title":"Description","text":"<p>Take absolute value of Series</p>"},{"location":"reference/#usage_306","title":"Usage","text":"<pre><code>Series_abs()\n</code></pre>"},{"location":"reference/#value_402","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_372","title":"Examples","text":"<pre><code>pl$Series(-2:2)$abs()\n</code></pre>"},{"location":"reference/#series-add","title":"Series add","text":""},{"location":"reference/#description_433","title":"Description","text":"<p>Series arithmetics</p>"},{"location":"reference/#usage_307","title":"Usage","text":"<pre><code>Series_add(other)\n\n## S3 method for class 'Series'\ns1 + s2\n</code></pre>"},{"location":"reference/#arguments_257","title":"Arguments","text":"<code>other</code> <p>Series or into Series</p> <code>s1</code> <p>lhs Series</p> <code>s2</code> <p>rhs Series or any into Series</p>"},{"location":"reference/#value_403","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_373","title":"Examples","text":"<pre><code>pl$Series(1:3)$add(11:13)\npl$Series(1:3)$add(pl$Series(11:13))\npl$Series(1:3)$add(1L)\n1L + pl$Series(1:3)\npl$Series(1:3) + 1L\n</code></pre>"},{"location":"reference/#series-alias","title":"Series alias","text":""},{"location":"reference/#description_434","title":"Description","text":"<p>Change name of Series</p>"},{"location":"reference/#usage_308","title":"Usage","text":"<pre><code>Series_alias(name)\n</code></pre>"},{"location":"reference/#arguments_258","title":"Arguments","text":"<code>name</code> <p>a String as the new name</p>"},{"location":"reference/#format_184","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_404","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_374","title":"Examples","text":"<pre><code>pl$Series(1:3,name = \"alice\")$alias(\"bob\")\n</code></pre>"},{"location":"reference/#series-all","title":"Series all","text":""},{"location":"reference/#description_435","title":"Description","text":"<p>Reduce Boolean Series with ALL</p>"},{"location":"reference/#usage_309","title":"Usage","text":"<pre><code>Series_all()\n</code></pre>"},{"location":"reference/#value_405","title":"Value","text":"<p>bool</p>"},{"location":"reference/#examples_375","title":"Examples","text":"<pre><code>pl$Series(c(TRUE,TRUE,NA))$all()\n</code></pre>"},{"location":"reference/#series-any","title":"Series any","text":""},{"location":"reference/#description_436","title":"Description","text":"<p>Reduce Boolean Series with ANY</p>"},{"location":"reference/#usage_310","title":"Usage","text":"<pre><code>Series_any()\n</code></pre>"},{"location":"reference/#value_406","title":"Value","text":"<p>bool</p>"},{"location":"reference/#examples_376","title":"Examples","text":"<pre><code>pl$Series(c(TRUE,FALSE,NA))$any()\n</code></pre>"},{"location":"reference/#series-append","title":"Series append","text":""},{"location":"reference/#description_437","title":"Description","text":"<p>append two Series, see details for mutability</p>"},{"location":"reference/#usage_311","title":"Usage","text":"<pre><code>Series_append(other, immutable = TRUE)\n</code></pre>"},{"location":"reference/#arguments_259","title":"Arguments","text":"<code>other</code> <p>Series to append</p> <code>immutable</code> <p>bool should append be immutable, default TRUE as mutable operations should be avoided in plain R API's.</p>"},{"location":"reference/#details_129","title":"Details","text":"<p>if immutable = FLASE, the Series object will not behave as immutable. This mean appending to this Series will affect any variable pointing to this memory location. This will break normal scoping rules of R. Polars-clones are cheap. Mutable operations are likely never needed in any sense.</p>"},{"location":"reference/#value_407","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_377","title":"Examples","text":"<pre><code>#default immutable behaviour, s_imut and s_imut_copy stay the same\ns_imut = pl$Series(1:3)\ns_imut_copy = s_imut\ns_new = s_imut$append(pl$Series(1:3))\nidentical(s_imut$to_r_vector(),s_imut_copy$to_r_vector())\n#pypolars-like mutable behaviour,s_mut_copy become the same as s_new\ns_mut = pl$Series(1:3)\ns_mut_copy = s_mut\n#must deactivate this to allow to use immutable=FALSE\npl$set_polars_options(strictly_immutable = FALSE)\ns_new = s_mut$append(pl$Series(1:3),immutable= FALSE)\nidentical(s_new$to_r_vector(),s_mut_copy$to_r_vector())\n</code></pre>"},{"location":"reference/#series-apply","title":"Series apply","text":""},{"location":"reference/#description_438","title":"Description","text":"<p>About as slow as regular non-vectorized R. Similar to using R sapply on a vector.</p>"},{"location":"reference/#usage_312","title":"Usage","text":"<pre><code>Series_apply(\n  fun,\n  datatype = NULL,\n  strict_return_type = TRUE,\n  allow_fail_eval = FALSE\n)\n</code></pre>"},{"location":"reference/#arguments_260","title":"Arguments","text":"<code>fun</code> <p>r function, should take a scalar value as input and return one.</p> <code>datatype</code> <p>DataType of return value. Default NULL means same as input.</p> <code>strict_return_type</code> <p>bool, default TRUE: fail on wrong return type, FALSE: convert to polars Null</p> <code>allow_fail_eval</code> <p>bool, default FALSE: raise R fun error, TRUE: convert to polars Null</p>"},{"location":"reference/#value_408","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_378","title":"Examples","text":"<pre><code>s = pl$Series(letters[1:5],\"ltrs\")\nf = \\(x) paste(x,\":\",as.integer(charToRaw(x)))\ns$apply(f,pl$Utf8)\n#same as\npl$Series(sapply(s$to_r(),f),s$name)\n</code></pre>"},{"location":"reference/#series-arg-max","title":"Series arg max","text":""},{"location":"reference/#description_439","title":"Description","text":"<p>idx to max value</p>"},{"location":"reference/#usage_313","title":"Usage","text":"<pre><code>Series_arg_max\n</code></pre>"},{"location":"reference/#format_185","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_409","title":"Value","text":"<p>bool</p>"},{"location":"reference/#examples_379","title":"Examples","text":"<pre><code>pl$Series(c(5,1))$arg_max()\n</code></pre>"},{"location":"reference/#series-arg-min","title":"Series arg min","text":""},{"location":"reference/#description_440","title":"Description","text":"<p>idx to min value</p>"},{"location":"reference/#usage_314","title":"Usage","text":"<pre><code>Series_arg_min\n</code></pre>"},{"location":"reference/#format_186","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_410","title":"Value","text":"<p>bool</p>"},{"location":"reference/#examples_380","title":"Examples","text":"<pre><code>pl$Series(c(5,1))$arg_min()\n</code></pre>"},{"location":"reference/#series-arr","title":"Series arr","text":""},{"location":"reference/#description_441","title":"Description","text":"<p>Create an object namespace of all list related methods. See the individual method pages for full details</p>"},{"location":"reference/#usage_315","title":"Usage","text":"<pre><code>Series_arr()\n</code></pre>"},{"location":"reference/#value_411","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_381","title":"Examples","text":"<pre><code>s = pl$Series(list(1:3,1:2,NULL))\ns\ns$arr$first()\n</code></pre>"},{"location":"reference/#series-ceil","title":"Series ceil","text":""},{"location":"reference/#description_442","title":"Description","text":"<p>Ceil of this Series</p>"},{"location":"reference/#usage_316","title":"Usage","text":"<pre><code>Series_ceil()\n</code></pre>"},{"location":"reference/#value_412","title":"Value","text":"<p>bool</p>"},{"location":"reference/#examples_382","title":"Examples","text":"<pre><code>pl$Series(c(.5,1.999))$ceil()\n</code></pre>"},{"location":"reference/#series-chunk-lengths","title":"Series chunk lengths","text":""},{"location":"reference/#description_443","title":"Description","text":"<p>Get the Lengths of Series memory chunks as vector.</p>"},{"location":"reference/#usage_317","title":"Usage","text":"<pre><code>Series_chunk_lengths\n</code></pre>"},{"location":"reference/#format_187","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_413","title":"Value","text":"<p>numeric vector. Length is number of chunks. Sum of lengths is equal to size of Series.</p>"},{"location":"reference/#examples_383","title":"Examples","text":"<pre><code>chunked_series = c(pl$Series(1:3),pl$Series(1:10))\nchunked_series$chunk_lengths()\n</code></pre>"},{"location":"reference/#series-class","title":"Series class","text":""},{"location":"reference/#description_444","title":"Description","text":"<p>The <code>Series</code>-class is simply two environments of respectively the public and private methods/function calls to the polars rust side. The instanciated <code>Series</code>-object is an <code>externalptr</code> to a lowlevel rust polars Series object. The pointer address is the only statefullness of the Series object on the R side. Any other state resides on the rust side. The S3 method <code>.DollarNames.Series</code> exposes all public <code>\u2060$foobar()\u2060</code>-methods which are callable onto the object. Most methods return another <code>Series</code>-class instance or similar which allows for method chaining. This class system in lack of a better name could be called \"environment classes\" and is the same class system extendr provides, except here there is both a public and private set of methods. For implementation reasons, the private methods are external and must be called from polars:::.pr.$Series$methodname(), also all private methods must take any self as an argument, thus they are pure functions. Having the private methods as pure functions solved/simplified self-referential complications.</p>"},{"location":"reference/#details_130","title":"Details","text":"<p>Check out the source code in R/Series_frame.R how public methods are derived from private methods. Check out extendr-wrappers.R to see the extendr-auto-generated methods. These are moved to .pr and converted into pure external functions in after-wrappers.R. In zzz.R (named zzz to be last file sourced) the extendr-methods are removed and replaced by any function prefixed <code>Series_</code>.</p>"},{"location":"reference/#examples_384","title":"Examples","text":"<pre><code>#see all exported methods\nls(polars:::Series)\n#see all private methods (not intended for regular use)\nls(polars:::.pr$Series)\n#make an object\ns = pl$Series(1:3)\n#use a public method/property\ns$shape\n#use a private method (mutable append not allowed in public api)\ns_copy = s\n.pr$Series$append_mut(s, pl$Series(5:1))\nidentical(s_copy$to_r(), s$to_r()) # s_copy was modified when s was modified\n</code></pre>"},{"location":"reference/#series-clone","title":"Series clone","text":""},{"location":"reference/#description_445","title":"Description","text":"<p>Rarely useful as Series are nearly 100% immutable Any modification of a Series should lead to a clone anyways.</p>"},{"location":"reference/#usage_318","title":"Usage","text":"<pre><code>Series_clone\n</code></pre>"},{"location":"reference/#format_188","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_414","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_385","title":"Examples","text":"<pre><code>s1 = pl$Series(1:3);\ns2 =  s1$clone();\ns3 = s1\npl$mem_address(s1) != pl$mem_address(s2)\npl$mem_address(s1) == pl$mem_address(s3)\n</code></pre>"},{"location":"reference/#series-compare","title":"Series compare","text":""},{"location":"reference/#description_446","title":"Description","text":"<p>compare two Series</p>"},{"location":"reference/#usage_319","title":"Usage","text":"<pre><code>Series_compare(other, op)\n\n## S3 method for class 'Series'\ns1 == s2\n\n## S3 method for class 'Series'\ns1 != s2\n\n## S3 method for class 'Series'\ns1 &lt; s2\n\n## S3 method for class 'Series'\ns1 &gt; s2\n\n## S3 method for class 'Series'\ns1 &lt;= s2\n\n## S3 method for class 'Series'\ns1 &gt;= s2\n</code></pre>"},{"location":"reference/#arguments_261","title":"Arguments","text":"<code>other</code> <p>A Series or something a Series can be created from</p> <code>op</code> <p>the chosen operator a String either: 'equal', 'not_equal', 'lt', 'gt', 'lt_eq' or 'gt_eq'</p> <code>s1</code> <p>lhs Series</p> <code>s2</code> <p>rhs Series or any into Series</p>"},{"location":"reference/#value_415","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_386","title":"Examples","text":"<pre><code>pl$Series(1:5) == pl$Series(c(1:3,NA_integer_,10L))\n</code></pre>"},{"location":"reference/#series-cumsum","title":"Series cumsum","text":""},{"location":"reference/#description_447","title":"Description","text":"<p>Get an array with the cumulative sum computed at every element.</p>"},{"location":"reference/#usage_320","title":"Usage","text":"<pre><code>Series_cumsum(reverse = FALSE)\n</code></pre>"},{"location":"reference/#arguments_262","title":"Arguments","text":"<code>reverse</code> <p>bool, default FALSE, if true roll over vector from back to forth</p>"},{"location":"reference/#details_131","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues.</p>"},{"location":"reference/#value_416","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_387","title":"Examples","text":"<pre><code>pl$Series(c(1:2,NA,3,NaN,4,Inf))$cumsum()\npl$Series(c(1:2,NA,3,Inf,4,-Inf,5))$cumsum()\n</code></pre>"},{"location":"reference/#series-div","title":"Series div","text":""},{"location":"reference/#description_448","title":"Description","text":"<p>Series arithmetics</p>"},{"location":"reference/#usage_321","title":"Usage","text":"<pre><code>Series_div(other)\n\n## S3 method for class 'Series'\ns1 / s2\n</code></pre>"},{"location":"reference/#arguments_263","title":"Arguments","text":"<code>other</code> <p>Series or into Series</p> <code>s1</code> <p>lhs Series</p> <code>s2</code> <p>rhs Series or any into Series</p>"},{"location":"reference/#value_417","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_388","title":"Examples","text":"<pre><code>pl$Series(1:3)$div(11:13)\npl$Series(1:3)$div(pl$Series(11:13))\npl$Series(1:3)$div(1L)\n2L / pl$Series(1:3)\npl$Series(1:3) / 2L\n</code></pre>"},{"location":"reference/#series-dtype","title":"Series dtype","text":""},{"location":"reference/#description_449","title":"Description","text":"<p>Get data type of Series</p> <p>Get data type of Series</p>"},{"location":"reference/#usage_322","title":"Usage","text":"<pre><code>Series_dtype()\n\nSeries_flags()\n</code></pre>"},{"location":"reference/#details_132","title":"Details","text":"<p>property sorted flags are not settable, use set_sorted</p>"},{"location":"reference/#value_418","title":"Value","text":"<p>DataType</p> <p>DataType</p>"},{"location":"reference/#examples_389","title":"Examples","text":"<pre><code>pl$Series(1:4)$dtype\npl$Series(c(1,2))$dtype\npl$Series(letters)$dtype\npl$Series(1:4)$sort()$flags\n</code></pre>"},{"location":"reference/#series-expr","title":"Series expr","text":""},{"location":"reference/#description_450","title":"Description","text":"<p>Call an expression on a Series See the individual Expr method pages for full details</p>"},{"location":"reference/#usage_323","title":"Usage","text":"<pre><code>Series_expr()\n</code></pre>"},{"location":"reference/#details_133","title":"Details","text":"<p>This is a shorthand of writing something like <code>pl$DataFrame(s)$select(pl$col(\"sname\")$expr)$to_series(0)</code></p> <p>This subnamespace is experimental. Submit an issue if anything unexpected happend.</p>"},{"location":"reference/#value_419","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_390","title":"Examples","text":"<pre><code>s = pl$Series(list(1:3,1:2,NULL))\ns$expr$first()\ns$expr$alias(\"alice\")\n</code></pre>"},{"location":"reference/#series-floor","title":"Series floor","text":""},{"location":"reference/#description_451","title":"Description","text":"<p>Floor of this Series</p>"},{"location":"reference/#usage_324","title":"Usage","text":"<pre><code>Series_floor()\n</code></pre>"},{"location":"reference/#value_420","title":"Value","text":"<p>numeric</p>"},{"location":"reference/#examples_391","title":"Examples","text":"<pre><code>pl$Series(c(.5,1.999))$floor()\n</code></pre>"},{"location":"reference/#series-is-numeric","title":"Series is numeric","text":""},{"location":"reference/#description_452","title":"Description","text":"<p>return bool whether series is numeric</p>"},{"location":"reference/#usage_325","title":"Usage","text":"<pre><code>Series_is_numeric()\n</code></pre>"},{"location":"reference/#format_189","title":"Format","text":"<p>method</p>"},{"location":"reference/#details_134","title":"Details","text":"<p>true of series dtype is member of pl$numeric_dtypes</p>"},{"location":"reference/#value_421","title":"Value","text":"<p>bool</p>"},{"location":"reference/#examples_392","title":"Examples","text":"<pre><code> pl$Series(1:4)$is_numeric()\npl$Series(c(\"a\",\"b\",\"c\"))$is_numeric()\npl$numeric_dtypes\n</code></pre>"},{"location":"reference/#series-is-sorted","title":"Series is sorted","text":""},{"location":"reference/#description_453","title":"Description","text":"<p>is_sorted</p>"},{"location":"reference/#usage_326","title":"Usage","text":"<pre><code>Series_is_sorted(reverse = FALSE, nulls_last = NULL)\n</code></pre>"},{"location":"reference/#arguments_264","title":"Arguments","text":"<code>reverse</code> <p>order sorted</p> <code>nulls_last</code> <p>bool where to keep nulls, default same as reverse</p>"},{"location":"reference/#details_135","title":"Details","text":"<p>property sorted flags are not settable, use set_sorted</p>"},{"location":"reference/#value_422","title":"Value","text":"<p>DataType</p>"},{"location":"reference/#examples_393","title":"Examples","text":"<pre><code>pl$Series(1:4)$sort()$is_sorted()\n</code></pre>"},{"location":"reference/#series-len","title":"Series len","text":""},{"location":"reference/#description_454","title":"Description","text":"<p>Length of this Series.</p>"},{"location":"reference/#usage_327","title":"Usage","text":"<pre><code>Series_len\n</code></pre>"},{"location":"reference/#format_190","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#value_423","title":"Value","text":"<p>numeric</p>"},{"location":"reference/#examples_394","title":"Examples","text":"<pre><code>pl$Series(1:10)$len()\n</code></pre>"},{"location":"reference/#series-max","title":"Series max","text":""},{"location":"reference/#description_455","title":"Description","text":"<p>Reduce Series with max</p>"},{"location":"reference/#usage_328","title":"Usage","text":"<pre><code>Series_max\n</code></pre>"},{"location":"reference/#format_191","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#details_136","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before maxming to prevent overflow issues.</p>"},{"location":"reference/#value_424","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_395","title":"Examples","text":"<pre><code>pl$Series(c(1:2,NA,3,5))$max() # a NA is dropped always\npl$Series(c(1:2,NA,3,NaN,4,Inf))$max() # NaN carries / poisons\npl$Series(c(1:2,3,Inf,4,-Inf,5))$max() # Inf-Inf is NaN\n</code></pre>"},{"location":"reference/#series-min","title":"Series min","text":""},{"location":"reference/#description_456","title":"Description","text":"<p>Reduce Series with min</p>"},{"location":"reference/#usage_329","title":"Usage","text":"<pre><code>Series_min\n</code></pre>"},{"location":"reference/#format_192","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#details_137","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before minming to prevent overflow issues.</p>"},{"location":"reference/#value_425","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_396","title":"Examples","text":"<pre><code>pl$Series(c(1:2,NA,3,5))$min() # a NA is dropped always\npl$Series(c(1:2,NA,3,NaN,4,Inf))$min() # NaN carries / poisons\npl$Series(c(1:2,3,Inf,4,-Inf,5))$min() # Inf-Inf is NaN\n</code></pre>"},{"location":"reference/#series-mul","title":"Series mul","text":""},{"location":"reference/#description_457","title":"Description","text":"<p>Series arithmetics</p>"},{"location":"reference/#usage_330","title":"Usage","text":"<pre><code>Series_mul(other)\n\n## S3 method for class 'Series'\ns1 * s2\n</code></pre>"},{"location":"reference/#arguments_265","title":"Arguments","text":"<code>other</code> <p>Series or into Series</p> <code>s1</code> <p>lhs Series</p> <code>s2</code> <p>rhs Series or any into Series</p>"},{"location":"reference/#value_426","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_397","title":"Examples","text":"<pre><code>pl$Series(1:3)$mul(11:13)\npl$Series(1:3)$mul(pl$Series(11:13))\npl$Series(1:3)$mul(1L)\n2L * pl$Series(1:3)\npl$Series(1:3) * 2L\n</code></pre>"},{"location":"reference/#series-name","title":"Series name","text":""},{"location":"reference/#description_458","title":"Description","text":"<p>Get name of Series</p>"},{"location":"reference/#usage_331","title":"Usage","text":"<pre><code>Series_name()\n</code></pre>"},{"location":"reference/#value_427","title":"Value","text":"<p>String the name</p>"},{"location":"reference/#examples_398","title":"Examples","text":"<pre><code>pl$Series(1:3,name = \"alice\")$name\n</code></pre>"},{"location":"reference/#series-print","title":"Series print","text":""},{"location":"reference/#description_459","title":"Description","text":"<p>Print Series</p> <p>Print Series</p>"},{"location":"reference/#usage_332","title":"Usage","text":"<pre><code>## S3 method for class 'Series'\nprint(x, ...)\n\nSeries_print()\n</code></pre>"},{"location":"reference/#arguments_266","title":"Arguments","text":"<code>x</code> <p>Series</p> <code>...</code> <p>not used</p>"},{"location":"reference/#value_428","title":"Value","text":"<p>invisible(self)</p> <p>self</p>"},{"location":"reference/#examples_399","title":"Examples","text":"<pre><code>print(pl$Series(1:3))\npl$Series(1:3)\n</code></pre>"},{"location":"reference/#series-rem","title":"Series rem","text":""},{"location":"reference/#description_460","title":"Description","text":"<p>Series arithmetics, remainder</p>"},{"location":"reference/#usage_333","title":"Usage","text":"<pre><code>Series_rem(other)\n</code></pre>"},{"location":"reference/#arguments_267","title":"Arguments","text":"<code>other</code> <p>Series or into Series</p>"},{"location":"reference/#value_429","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_400","title":"Examples","text":"<pre><code>pl$Series(1:4)$rem(2L)\npl$Series(1:3)$rem(pl$Series(11:13))\npl$Series(1:3)$rem(1L)\n</code></pre>"},{"location":"reference/#series-rename","title":"Series rename","text":""},{"location":"reference/#description_461","title":"Description","text":"<p>Rename a series</p>"},{"location":"reference/#usage_334","title":"Usage","text":"<pre><code>Series_rename(name, in_place = FALSE)\n</code></pre>"},{"location":"reference/#arguments_268","title":"Arguments","text":"<code>name</code> <p>string the new name</p> <code>in_place</code> <p>bool rename in-place, breaks immutability If true will throw an error unless this option has been set: <code>pl$set_polars_options(strictly_immutable = FALSE)</code></p>"},{"location":"reference/#format_193","title":"Format","text":"<p>method</p>"},{"location":"reference/#value_430","title":"Value","text":"<p>bool</p>"},{"location":"reference/#examples_401","title":"Examples","text":"<pre><code>pl$Series(1:4,\"bob\")$rename(\"alice\")\n</code></pre>"},{"location":"reference/#series-rep","title":"Series rep","text":""},{"location":"reference/#description_462","title":"Description","text":"<p>duplicate and concatenate a series</p>"},{"location":"reference/#usage_335","title":"Usage","text":"<pre><code>Series_rep(n, rechunk = TRUE)\n</code></pre>"},{"location":"reference/#arguments_269","title":"Arguments","text":"<code>n</code> <p>number of times to repeat</p> <code>rechunk</code> <p>bool default true, reallocate object in memory. If FALSE the Series will take up less space, If TRUE calculations might be faster.</p>"},{"location":"reference/#format_194","title":"Format","text":"<p>method</p>"},{"location":"reference/#details_138","title":"Details","text":"<p>This function in not implemented in pypolars</p>"},{"location":"reference/#value_431","title":"Value","text":"<p>bool</p>"},{"location":"reference/#examples_402","title":"Examples","text":"<pre><code>pl$Series(1:2,\"bob\")$rep(3)\n</code></pre>"},{"location":"reference/#series-series-equal","title":"Series series equal","text":""},{"location":"reference/#description_463","title":"Description","text":"<p>Check if series is equal with another Series.</p>"},{"location":"reference/#usage_336","title":"Usage","text":"<pre><code>Series_series_equal(other, null_equal = FALSE, strict = FALSE)\n</code></pre>"},{"location":"reference/#arguments_270","title":"Arguments","text":"<code>other</code> <p>Series to compare with</p> <code>null_equal</code> <p>bool if TRUE, (Null==Null) is true and not Null/NA. Overridden by strict.</p> <code>strict</code> <p>bool if TRUE, do not allow similar DataType comparison. Overrides null_equal.</p>"},{"location":"reference/#format_195","title":"Format","text":"<p>method</p>"},{"location":"reference/#value_432","title":"Value","text":"<p>bool</p>"},{"location":"reference/#examples_403","title":"Examples","text":"<pre><code>pl$Series(1:4,\"bob\")$series_equal(pl$Series(1:4))\n</code></pre>"},{"location":"reference/#series-set-sorted","title":"Series set sorted","text":""},{"location":"reference/#description_464","title":"Description","text":"<p>Set sorted</p>"},{"location":"reference/#usage_337","title":"Usage","text":"<pre><code>Series_set_sorted(reverse = FALSE, in_place = FALSE)\n</code></pre>"},{"location":"reference/#arguments_271","title":"Arguments","text":"<code>reverse</code> <p>bool if TRUE, signals series is Descendingly sorted, otherwise Ascendingly.</p> <code>in_place</code> <p>if TRUE, will set flag mutably and return NULL. Remember to use pl$set_polars_options(strictly_immutable = FALSE) otherwise an error will be thrown. If FALSE will return a cloned Series with set_flag which in the very most cases should be just fine.</p>"},{"location":"reference/#value_433","title":"Value","text":"<p>Series invisible</p>"},{"location":"reference/#examples_404","title":"Examples","text":"<pre><code>s = pl$Series(1:4)$set_sorted()\ns$flags\n</code></pre>"},{"location":"reference/#series-shape","title":"Series shape","text":""},{"location":"reference/#description_465","title":"Description","text":"<p>Shape of series</p>"},{"location":"reference/#usage_338","title":"Usage","text":"<pre><code>Series_shape()\n</code></pre>"},{"location":"reference/#value_434","title":"Value","text":"<p>dimension vector of Series</p>"},{"location":"reference/#examples_405","title":"Examples","text":"<pre><code>identical(pl$Series(1:2)$shape, 2:1)\n</code></pre>"},{"location":"reference/#series-sort","title":"Series sort","text":""},{"location":"reference/#description_466","title":"Description","text":"<p>Sort this Series</p>"},{"location":"reference/#usage_339","title":"Usage","text":"<pre><code>Series_sort(reverse = FALSE, in_place = FALSE)\n</code></pre>"},{"location":"reference/#arguments_272","title":"Arguments","text":"<code>reverse</code> <p>bool reverse(descending) sort</p> <code>in_place</code> <p>bool sort mutable in-place, breaks immutability If true will throw an error unless this option has been set: <code>pl$set_polars_options(strictly_immutable = FALSE)</code></p>"},{"location":"reference/#value_435","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_406","title":"Examples","text":"<pre><code>pl$Series(c(1,NA,NaN,Inf,-Inf))$sort()\n</code></pre>"},{"location":"reference/#series-std","title":"Series std","text":""},{"location":"reference/#description_467","title":"Description","text":"<p>Get the standard deviation of this Series.</p>"},{"location":"reference/#usage_340","title":"Usage","text":"<pre><code>Series_std(ddof = 1)\n</code></pre>"},{"location":"reference/#arguments_273","title":"Arguments","text":"<code>ddof</code> <p>\u201cDelta Degrees of Freedom\u201d: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1.</p>"},{"location":"reference/#format_196","title":"Format","text":"<p>method</p>"},{"location":"reference/#value_436","title":"Value","text":"<p>bool</p>"},{"location":"reference/#examples_407","title":"Examples","text":"<pre><code>pl$Series(1:4,\"bob\")$std()\n</code></pre>"},{"location":"reference/#series-sub","title":"Series sub","text":""},{"location":"reference/#description_468","title":"Description","text":"<p>Series arithmetics</p>"},{"location":"reference/#usage_341","title":"Usage","text":"<pre><code>Series_sub(other)\n\n## S3 method for class 'Series'\ns1 - s2\n</code></pre>"},{"location":"reference/#arguments_274","title":"Arguments","text":"<code>other</code> <p>Series or into Series</p> <code>s1</code> <p>lhs Series</p> <code>s2</code> <p>rhs Series or any into Series</p>"},{"location":"reference/#value_437","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_408","title":"Examples","text":"<pre><code>pl$Series(1:3)$sub(11:13)\npl$Series(1:3)$sub(pl$Series(11:13))\npl$Series(1:3)$sub(1L)\n1L - pl$Series(1:3)\npl$Series(1:3) - 1L\n</code></pre>"},{"location":"reference/#series-sum","title":"Series sum","text":""},{"location":"reference/#description_469","title":"Description","text":"<p>Reduce Series with sum</p>"},{"location":"reference/#usage_342","title":"Usage","text":"<pre><code>Series_sum\n</code></pre>"},{"location":"reference/#format_197","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/#details_139","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues.</p>"},{"location":"reference/#value_438","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_409","title":"Examples","text":"<pre><code>pl$Series(c(1:2,NA,3,5))$sum() # a NA is dropped always\npl$Series(c(1:2,NA,3,NaN,4,Inf))$sum() # NaN carries / poisons\npl$Series(c(1:2,3,Inf,4,-Inf,5))$sum() # Inf-Inf is NaN\n</code></pre>"},{"location":"reference/#series-to-frames","title":"Series to frames","text":""},{"location":"reference/#description_470","title":"Description","text":"<p>Series to DataFrame</p>"},{"location":"reference/#usage_343","title":"Usage","text":"<pre><code>Series_to_frame()\n</code></pre>"},{"location":"reference/#format_198","title":"Format","text":"<p>method</p>"},{"location":"reference/#value_439","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_410","title":"Examples","text":"<pre><code>pl$Series(1:4,\"bob\")$to_frame()\n</code></pre>"},{"location":"reference/#series-to-lit","title":"Series to lit","text":""},{"location":"reference/#description_471","title":"Description","text":"<p>convert Series to literal to perform modification and return</p>"},{"location":"reference/#usage_344","title":"Usage","text":"<pre><code>Series_to_lit()\n</code></pre>"},{"location":"reference/#value_440","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_411","title":"Examples","text":"<pre><code>(\npl$Series(list(1:1, 1:2, 1:3, 1:4))\n$print()\n$to_lit()\n$arr$lengths()\n$sum()\n$cast(pl$dtypes$Int8)\n$lit_to_s()\n)\n</code></pre>"},{"location":"reference/#series-to-r","title":"Series to r","text":""},{"location":"reference/#description_472","title":"Description","text":"<p>return R list (if polars Series is list) or vector (any other polars Series type)</p> <p>return R vector (implicit unlist)</p> <p>return R list (implicit as.list)</p>"},{"location":"reference/#usage_345","title":"Usage","text":"<pre><code>Series_to_r()\n\nSeries_to_r_vector()\n\nSeries_to_r_list()\n</code></pre>"},{"location":"reference/#details_140","title":"Details","text":"<p>Fun fact: Nested polars Series list must have same inner type, e.g. List(List(Int32)) Thus every leaf(non list type) will be placed on the same depth of the tree, and be the same type.</p>"},{"location":"reference/#value_441","title":"Value","text":"<p>R list or vector</p> <p>R vector</p> <p>R list</p>"},{"location":"reference/#examples_412","title":"Examples","text":"<pre><code>#make polars Series_Utf8\nseries_vec = pl$Series(letters[1:3])\n#Series_non_list\nseries_vec$to_r() #as vector because Series DataType is not list (is Utf8)\nseries_vec$to_r_list() #implicit call as.list(), convert to list\nseries_vec$to_r_vector() #implicit call unlist(), same as to_r() as already vector\n#make nested Series_list of Series_list of Series_Int32\n#using Expr syntax because currently more complete translated\nseries_list = pl$DataFrame(list(a=c(1:5,NA_integer_)))$select(\npl$col(\"a\")$list()$list()$append(\n(\npl$col(\"a\")$head(2)$list()$append(\npl$col(\"a\")$tail(1)$list()\n)\n)$list()\n)\n)$get_column(\"a\") # get series from DataFrame\n#Series_list\nseries_list$to_r() #as list because Series DataType is list\nseries_list$to_r_list() #implicit call as.list(), same as to_r() as already list\nseries_list$to_r_vector() #implicit call unlist(), append into a vector\n#\n#\n</code></pre>"},{"location":"reference/#series-value-count","title":"Series value count","text":""},{"location":"reference/#description_473","title":"Description","text":"<p>Value Counts as DataFrame</p>"},{"location":"reference/#usage_346","title":"Usage","text":"<pre><code>Series_value_counts(sorted = TRUE, multithreaded = FALSE)\n</code></pre>"},{"location":"reference/#arguments_275","title":"Arguments","text":"<code>sorted</code> <p>bool, default TRUE: sort table by value; FALSE: random</p> <code>multithreaded</code> <p>bool, default FALSE, process multithreaded. Likely faster to have TRUE for a big Series. If called within an already multithreaded context such calling apply on a GroupBy with many groups, then likely slightly faster to leave FALSE.</p>"},{"location":"reference/#value_442","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/#examples_413","title":"Examples","text":"<pre><code>pl$Series(iris$Species,\"flower species\")$value_counts()\n</code></pre>"},{"location":"reference/#series-var","title":"Series var","text":""},{"location":"reference/#description_474","title":"Description","text":"<p>Get the standard deviation of this Series.</p>"},{"location":"reference/#usage_347","title":"Usage","text":"<pre><code>Series_var(ddof = 1)\n</code></pre>"},{"location":"reference/#arguments_276","title":"Arguments","text":"<code>ddof</code> <p>\u201cDelta Degrees of Freedom\u201d: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1.</p>"},{"location":"reference/#format_199","title":"Format","text":"<p>method</p>"},{"location":"reference/#value_443","title":"Value","text":"<p>bool</p>"},{"location":"reference/#examples_414","title":"Examples","text":"<pre><code>pl$Series(1:4,\"bob\")$var()\n</code></pre>"},{"location":"reference/#series","title":"Series","text":""},{"location":"reference/#description_475","title":"Description","text":"<p>found in api as pl$Series named Series_constructor internally</p>"},{"location":"reference/#arguments_277","title":"Arguments","text":"<code>x</code> <p>any vector</p> <code>name</code> <p>string</p>"},{"location":"reference/#value_444","title":"Value","text":"<p>Series</p>"},{"location":"reference/#examples_415","title":"Examples","text":"<pre><code>{\npl$Series(1:4)\n}\n</code></pre>"},{"location":"reference/#str-string","title":"Str string","text":""},{"location":"reference/#description_476","title":"Description","text":"<p>Simple viewer of an R object based on str()</p>"},{"location":"reference/#usage_348","title":"Usage","text":"<pre><code>str_string(x, collapse = \" \")\n</code></pre>"},{"location":"reference/#arguments_278","title":"Arguments","text":"<code>x</code> <p>object to view.</p> <code>collapse</code> <p>word to glue possible multilines with</p>"},{"location":"reference/#value_445","title":"Value","text":"<p>string</p>"},{"location":"reference/#examples_416","title":"Examples","text":"<pre><code>polars:::str_string(list(a=42,c(1,2,3,NA)))\n</code></pre>"},{"location":"reference/#struct","title":"Struct","text":""},{"location":"reference/#description_477","title":"Description","text":"<p>Collect several columns into a Series of dtype Struct.</p>"},{"location":"reference/#arguments_279","title":"Arguments","text":"<code>exprs</code> <p>Columns/Expressions to collect into a Struct.</p> <code>eager</code> <p>Evaluate immediately.</p> <code>schema</code> <p>Optional schema named list that explicitly defines the struct field dtypes. Each name must match a column name wrapped in the struct. Can only be used to cast some or all dtypes, not to change the names. NULL means to include keep columns into the struct by their current DataType. If a column is not included in the schema it is removed from the final struct.</p>"},{"location":"reference/#details_141","title":"Details","text":"<p>pl$struct creates Expr or Series of DataType Struct() pl$Struct creates the DataType Struct() In polars a schema is a named list of DataTypes. #' A schema describes e.g. a DataFrame. More formally schemas consist of Fields. A Field is an object describing the name and DataType of a column/Series, but same same. A struct is a DataFrame wrapped into a Series, the DataType is Struct, and each sub-datatype within are Fields. In a dynamic language schema and a Struct (the DataType) are quite the same, except schemas describe DataFrame and Struct's describe some Series.</p>"},{"location":"reference/#value_446","title":"Value","text":"<p>Eager=FALSE: Expr of Series with dtype Struct | Eager=TRUE: Series with dtype Struct</p>"},{"location":"reference/#examples_417","title":"Examples","text":"<pre><code>#isolated expression to wrap all columns in a struct aliased 'my_struct'\npl$struct(pl$all())$alias(\"my_struct\")\n#wrap all column into on column/Series\ndf = pl$DataFrame(\nint = 1:2,\nstr = c(\"a\", \"b\"),\nbool = c(TRUE, NA),\nlist = list(1:2, 3L)\n)$select(\npl$struct(pl$all())$alias(\"my_struct\")\n)\nprint(df)\nprint(df$schema) #returns a schema, a named list containing one element a Struct named my_struct\n# wrap two columns in a struct and provide a schema to set all or some DataTypes by name\ne1 = pl$struct(\npl$col(c(\"int\",\"str\")),\nschema = list(int=pl$Int64, str=pl$Utf8)\n)$alias(\"my_struct\")\n# same result as e.g. wrapping the columns in a struct and casting afterwards\ne2 = pl$struct(\nlist(pl$col(\"int\"),pl$col(\"str\"))\n)$cast(\npl$Struct(int=pl$Int64,str=pl$Utf8)\n)$alias(\"my_struct\")\ndf = pl$DataFrame(\nint = 1:2,\nstr = c(\"a\", \"b\"),\nbool = c(TRUE, NA),\nlist = list(1:2, 3L)\n)\n#verify equality in R\nidentical(df$select(e1)$to_list(),df$select(e2)$to_list())\ndf$select(e2)\ndf$select(e2)$as_data_frame()\n</code></pre>"},{"location":"reference/#sum","title":"Sum","text":""},{"location":"reference/#description_478","title":"Description","text":"<p>syntactic sugar for starting a expression with sum</p>"},{"location":"reference/#arguments_280","title":"Arguments","text":"<code>...</code> <p>is a: If one arg:</p> <ul> <li><p>Series or Expr, same as <code>column$sum()</code></p></li> <li><p>string, same as <code>pl$col(column)$sum()</code></p></li> <li><p>numeric, same as <code>pl$lit(column)$sum()</code></p></li> <li><p>list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ...</p></li> </ul> <p>If several args, then wrapped in a list and handled as above.</p>"},{"location":"reference/#value_447","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_418","title":"Examples","text":"<pre><code>#column as string\npl$DataFrame(iris)$select(pl$sum(\"Petal.Width\"))\n#column as Expr (prefer pl$col(\"Petal.Width\")$sum())\npl$DataFrame(iris)$select(pl$sum(pl$col(\"Petal.Width\")))\n#column as numeric\npl$DataFrame()$select(pl$sum(1:5))\n#column as list\npl$DataFrame(a=1:2,b=3:4,c=5:6)$with_column(pl$sum(list(\"a\",\"c\")))\npl$DataFrame(a=1:2,b=3:4,c=5:6)$with_column(pl$sum(list(\"a\",\"c\", 42L)))\n#three eqivalent lines\npl$DataFrame(a=1:2,b=3:4,c=5:6)$with_column(pl$sum(list(\"a\",\"c\", pl$sum(list(\"a\",\"b\",\"c\")))))\npl$DataFrame(a=1:2,b=3:4,c=5:6)$with_column(pl$sum(list(pl$col(\"a\")+pl$col(\"b\"),\"c\")))\npl$DataFrame(a=1:2,b=3:4,c=5:6)$with_column(pl$sum(list(\"*\")))\n</code></pre>"},{"location":"reference/#to-list","title":"To list","text":""},{"location":"reference/#description_479","title":"Description","text":"<p>return polars DataFrame as R lit of vectors</p>"},{"location":"reference/#usage_349","title":"Usage","text":"<pre><code>DataFrame_to_list(unnest_structs = TRUE)\n</code></pre>"},{"location":"reference/#arguments_281","title":"Arguments","text":"<code>unnest_structs</code> <p>bool default true, as calling $unnest() on any struct column</p>"},{"location":"reference/#details_142","title":"Details","text":"<p>This implementation for simplicity reasons relies on unnesting all structs before exporting to R. unnest_structs = FALSE, the previous struct columns will be re- nested. A struct in a R is a lists of lists, where each row is a list of values. Such a structure is not very typical or efficient in R.</p>"},{"location":"reference/#value_448","title":"Value","text":"<p>R list of vectors</p>"},{"location":"reference/#examples_419","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$to_list()\n</code></pre>"},{"location":"reference/#unasis","title":"UnAsIs","text":""},{"location":"reference/#description_480","title":"Description","text":"<p>Reverts wrapping in I</p>"},{"location":"reference/#usage_350","title":"Usage","text":"<pre><code>unAsIs(X)\n</code></pre>"},{"location":"reference/#arguments_282","title":"Arguments","text":"<code>X</code> <p>any Robj wrapped in 'I()\u201c</p>"},{"location":"reference/#details_143","title":"Details","text":"<p>https://stackoverflow.com/questions/12865218/getting-rid-of-asis-class-attribute</p>"},{"location":"reference/#value_449","title":"Value","text":"<p>X without any AsIs subclass</p>"},{"location":"reference/#unwrap","title":"Unwrap","text":""},{"location":"reference/#description_481","title":"Description","text":"<p>rust-like unwrapping of result. Useful to keep error handling on the R side.</p>"},{"location":"reference/#usage_351","title":"Usage","text":"<pre><code>unwrap(result, context = NULL, call = sys.call(1L))\n</code></pre>"},{"location":"reference/#arguments_283","title":"Arguments","text":"<code>result</code> <p>a list here either element ok or err is NULL, or both if ok is litteral NULL</p> <code>context</code> <p>a msg to prefix a raised error with</p> <code>call</code> <p>context of error or string</p>"},{"location":"reference/#value_450","title":"Value","text":"<p>the ok-element of list , or a error will be thrown</p>"},{"location":"reference/#examples_420","title":"Examples","text":"<pre><code>structure(list(ok = \"foo\", err = NULL), class = \"extendr_result\")\ntryCatch(\nunwrap(\nstructure(\nlist(ok = NULL, err = \"something happen on the rust side\"),\nclass = \"extendr_result\"\n)\n),\nerror = function(err) as.character(err)\n)\n</code></pre>"},{"location":"reference/#verify-method-call","title":"Verify method call","text":""},{"location":"reference/#description_482","title":"Description","text":"<p>internal function to check method call of env_classes</p>"},{"location":"reference/#usage_352","title":"Usage","text":"<pre><code>verify_method_call(\n  Class_env,\n  Method_name,\n  call = sys.call(1L),\n  class_name = NULL\n)\n</code></pre>"},{"location":"reference/#arguments_284","title":"Arguments","text":"<code>Class_env</code> <p>env_class object (the classes created by extendr-wrappers.R)</p> <code>Method_name</code> <p>name of method requested by user</p> <code>call</code> <p>context to throw user error, just use default</p> <code>class_name</code> <p>NULLs</p>"},{"location":"reference/#value_451","title":"Value","text":"<p>invisible(NULL)</p>"},{"location":"reference/#when-then-otherwise","title":"When then otherwise","text":""},{"location":"reference/#description_483","title":"Description","text":"<p>Start a \u201cwhen, then, otherwise\u201d expression.</p>"},{"location":"reference/#arguments_285","title":"Arguments","text":"<code>predicate</code> <p>Into Expr into a boolean mask to branch by</p> <code>expr</code> <p>Into Expr value to insert in when() or otherwise()</p>"},{"location":"reference/#details_144","title":"Details","text":"<p>For the impl nerds: pl$when returns a whenthen object and whenthen returns whenthenthen, except for otherwise(), which will terminate and return an Expr. Otherwise may fail to return an Expr if e.g. two consecutive <code>when(x)$when(y)</code></p>"},{"location":"reference/#value_452","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_421","title":"Examples","text":"<pre><code>  df = pl$DataFrame(mtcars)\nwtt =\npl$when(pl$col(\"cyl\")&lt;=4)$then(\"&lt;=4cyl\")$\nwhen(pl$col(\"cyl\")&lt;=6)$then(\"&lt;=6cyl\")$\notherwise(\"&gt;6cyl\")$alias(\"cyl_groups\")\nprint(wtt)\ndf$with_columns(wtt)\n</code></pre>"},{"location":"reference/#wrap-e-result","title":"Wrap e result","text":""},{"location":"reference/#description_484","title":"Description","text":"<p>wrap as Expression capture ok/err as result</p>"},{"location":"reference/#usage_353","title":"Usage","text":"<pre><code>wrap_e_result(e, str_to_lit = TRUE, argname = NULL)\n</code></pre>"},{"location":"reference/#arguments_286","title":"Arguments","text":"<code>e</code> <p>an Expr(polars) or any R expression</p> <code>str_to_lit</code> <p>bool should string become a column name or not, then a literal string</p> <code>argname</code> <p>if error, blame argument of this name</p>"},{"location":"reference/#details_145","title":"Details","text":"<p>used internally to ensure an object is an expression and to catch any error</p>"},{"location":"reference/#value_453","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_422","title":"Examples","text":"<pre><code>pl$col(\"foo\") &lt; 5\n</code></pre>"},{"location":"reference/#wrap-e","title":"Wrap e","text":""},{"location":"reference/#description_485","title":"Description","text":"<p>wrap as literal</p>"},{"location":"reference/#usage_354","title":"Usage","text":"<pre><code>wrap_e(e, str_to_lit = TRUE)\n</code></pre>"},{"location":"reference/#arguments_287","title":"Arguments","text":"<code>e</code> <p>an Expr(polars) or any R expression</p>"},{"location":"reference/#details_146","title":"Details","text":"<p>used internally to ensure an object is an expression</p>"},{"location":"reference/#value_454","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_423","title":"Examples","text":"<pre><code>pl$col(\"foo\") &lt; 5\n</code></pre>"},{"location":"reference/#wrap-elist-result","title":"Wrap elist result","text":""},{"location":"reference/#description_486","title":"Description","text":"<p>make sure all elementsof a list is wrapped as Expr Capture any conversion error in the result</p>"},{"location":"reference/#usage_355","title":"Usage","text":"<pre><code>wrap_elist_result(elist, str_to_lit = TRUE)\n</code></pre>"},{"location":"reference/#arguments_288","title":"Arguments","text":"<code>elist</code> <p>a list Expr or any R object Into (passable to pl$lit)</p>"},{"location":"reference/#details_147","title":"Details","text":"<p>Used internally to ensure an object is a list of expression The output is wrapped in a result, which can contain an ok or err value.</p>"},{"location":"reference/#value_455","title":"Value","text":"<p>Expr</p>"},{"location":"reference/#examples_424","title":"Examples","text":"<pre><code>polars:::wrap_elist_result(list(pl$lit(42),42,1:3))\n</code></pre>"},{"location":"reference/#wrap-proto-schema","title":"Wrap proto schema","text":""},{"location":"reference/#description_487","title":"Description","text":"<p>wrap proto schema</p>"},{"location":"reference/#usage_356","title":"Usage","text":"<pre><code>wrap_proto_schema(x)\n</code></pre>"},{"location":"reference/#arguments_289","title":"Arguments","text":"<code>x</code> <p>either schema, or incomplete schema where dataType can be NULL or schema is just char vec, implicitly the same as if all DataType are NULL, mean undefinesd.</p>"},{"location":"reference/#format_200","title":"Format","text":"<p>function</p>"},{"location":"reference/#value_456","title":"Value","text":"<p>bool</p>"},{"location":"reference/#examples_425","title":"Examples","text":"<pre><code>polars:::wrap_proto_schema(c(\"alice\",\"bob\"))\npolars:::wrap_proto_schema(list(\"alice\"=pl$Int64,\"bob\"=NULL))\n</code></pre>"},{"location":"reference/#wrap-s","title":"Wrap s","text":""},{"location":"reference/#description_488","title":"Description","text":"<p>input is either already a Series of will be passed to the Series constructor</p>"},{"location":"reference/#usage_357","title":"Usage","text":"<pre><code>wrap_s(x)\n</code></pre>"},{"location":"reference/#arguments_290","title":"Arguments","text":"<code>x</code> <p>a Series or something-turned-into-Series</p>"},{"location":"reference/#value_457","title":"Value","text":"<p>Series</p>"},{"location":"articles/polars/","title":"An Introduction to Polars from R","text":""},{"location":"articles/polars/#what-is-polars","title":"What is Polars?","text":"<p>Polars is a lightning fast Data Frame library. Its embarrassingly parallel execution, cache efficient algorithms and expressive API makes it perfect for efficient data wrangling, data pipelines, snappy APIs and so much more. Polars also supports \u201cstreaming mode\u201d for out-of-memory operations. This allows users to analyze datasets many times larger than RAM.</p> <p>The underlying computation engine is written in Rust and is built on the Apache Arrow columnar memory format. It can be used in Rust or via Python bindings. The polars R-package provides equivalent bindings from R. Within R, python and rust each polars package is just called polars. The implemention polars in the different languages can be called rust-polars, py-polars, r-polars, nodejs-polars\u2026</p> <p>polars users can expect orders of magnitude(s) improvement compared to dplyr for simple transformations on datasets &gt;500Mb. The automatic Polars optimization framework means that that this speed boost can be even greater for complex queries that chain together many operations. Performance is similar to that of data.table, although polars supports additional functionality via its relationship to the Apache Arrow memory model. For example, it can scan multiple Parquet files and datasets and selectively import random subsets without having to read all of the data.</p> <p>Polars syntax is similar to that of Spark, but the workflow is column-oriented rather than row-oriented. Since R is itself a column-oriented language, this should immediately feel familiar to most R users. Like Spark and modern SQL variants, Polars optimizes queries for memory consumption and speed, so you don\u2019t have to. However, unlike Spark, Polars is natively multithreaded instead of multinoded. This makes (r)polars much simpler to install and can be used as one would any other R package.</p> <p>This R port relies on the excellent extendr package, which is the R equivalent to pyo3+maturin. extendr is very convenient for calling Rust from R, and vice versa, and is what we use to build the polars package. Once built, however, polars has no other dependencies other than R itself. This makes it very fast and lightweight to install, and so polars can immediately be used to tackle your big (or small!) data wrangling tasks.</p>"},{"location":"articles/polars/#documentation-and-tutorials","title":"Documentation and tutorials","text":"<p>Users can find detailed documentation for all objects, functions, and methods on the Reference page of this website. This documentation can also be accessed from the R console using the typical <code>?</code> syntax. For example, we will later use the <code>DataFrame()</code> constructor function and apply the <code>groupby()</code> method to a <code>DataFrame</code> object. The documentation for these can be accessed by typing these commands:</p> <pre><code>?DataFrame\n?DataFrame_groupby\n</code></pre> <p>The Polars book offers a great introduction to the Polars data frame library, with a very large number of examples in Python and Rust. The syntax and expressions in the <code>polars</code> package for R are (deliberately) as close to the Python implementation as possible, so you can always refer to the polars book for more ideas. Just remember to switch out any \u201c.\u201d (Python) for a \u201c\\$\u201d (R) when chaining methods. For example, here are two equivalent lines of code for some hypothetical dataset.</p> <pre><code># Python\ndf.group_by(\"id\").mean()\n</code></pre> <pre><code># R\ndf$groupby(\"id\")$mean()\n</code></pre>"},{"location":"articles/polars/#series-and-dataframes","title":"<code>Series</code> and <code>DataFrames</code>","text":"<p>In <code>polars</code> objects of class <code>Series</code> are analogous to R vectors. Objects of class <code>DataFrame</code> are analogous to R data frames. To convert R vectors and data frames to Polars <code>Series</code> and <code>DataFrames</code>, we load the library and use constructor functions with the <code>pl$</code> prefix. This prefix is very important, as most of the <code>polars</code> functions are made available via <code>pl$</code>:</p> <pre><code>library(polars)\nser = pl$Series((1:5) * 5)\nser\n#&gt; polars Series: shape: (5,)\n#&gt; Series: '' [f64]\n#&gt; [\n#&gt;  5.0\n#&gt;  10.0\n#&gt;  15.0\n#&gt;  20.0\n#&gt;  25.0\n#&gt; ]\ndat = pl$DataFrame(mtcars)\ndat\n#&gt; polars DataFrame: shape: (32, 11)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 mpg  \u2506 cyl \u2506 disp  \u2506 hp    \u2506 ... \u2506 vs  \u2506 am  \u2506 gear \u2506 carb \u2502\n#&gt; \u2502 ---  \u2506 --- \u2506 ---   \u2506 ---   \u2506     \u2506 --- \u2506 --- \u2506 ---  \u2506 ---  \u2502\n#&gt; \u2502 f64  \u2506 f64 \u2506 f64   \u2506 f64   \u2506     \u2506 f64 \u2506 f64 \u2506 f64  \u2506 f64  \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0  \u2506 4.0  \u2502\n#&gt; \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0  \u2506 4.0  \u2502\n#&gt; \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0  \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0  \u2506 1.0  \u2502\n#&gt; \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0  \u2506 1.0  \u2502\n#&gt; \u2502 ...  \u2506 ... \u2506 ...   \u2506 ...   \u2506 ... \u2506 ... \u2506 ... \u2506 ...  \u2506 ...  \u2502\n#&gt; \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0  \u2506 4.0  \u2502\n#&gt; \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0  \u2506 6.0  \u2502\n#&gt; \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0  \u2506 8.0  \u2502\n#&gt; \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0  \u2506 2.0  \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Both Polars and R are column-orientated. So you can think of <code>DataFrames</code> (data.frames) as being made up of a collection of <code>Series</code> (vectors). In fact, you can create a new Polars <code>DataFrame</code> as a mix of <code>Series</code> and/or regular R vectors.</p> <pre><code>pl$DataFrame(\na = pl$Series((1:5) * 5),\nb = pl$Series(letters[1:5]),\nc = pl$Series(c(1, 2, 3, 4, 5)),\nd = c(15, 14, 13, 12, 11),\nc(5, 4, 3, 2, 1),\n1:5\n)\n#&gt; polars DataFrame: shape: (5, 6)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 a    \u2506 b   \u2506 c   \u2506 d    \u2506 new_column \u2506 new_column_1 \u2502\n#&gt; \u2502 ---  \u2506 --- \u2506 --- \u2506 ---  \u2506 ---        \u2506 ---          \u2502\n#&gt; \u2502 f64  \u2506 str \u2506 f64 \u2506 f64  \u2506 f64        \u2506 i32          \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 5.0  \u2506 a   \u2506 1.0 \u2506 15.0 \u2506 5.0        \u2506 1            \u2502\n#&gt; \u2502 10.0 \u2506 b   \u2506 2.0 \u2506 14.0 \u2506 4.0        \u2506 2            \u2502\n#&gt; \u2502 15.0 \u2506 c   \u2506 3.0 \u2506 13.0 \u2506 3.0        \u2506 3            \u2502\n#&gt; \u2502 20.0 \u2506 d   \u2506 4.0 \u2506 12.0 \u2506 2.0        \u2506 4            \u2502\n#&gt; \u2502 25.0 \u2506 e   \u2506 5.0 \u2506 11.0 \u2506 1.0        \u2506 5            \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p><code>Series</code> and <code>DataFrame</code> can be operated on using many standard R functions. For example:</p> <pre><code># Series\nlength(ser)\n#&gt; [1] 5\nmax(ser)\n#&gt; polars Series: shape: (1,)\n#&gt; Series: '' [f64]\n#&gt; [\n#&gt;  25.0\n#&gt; ]\n# DataFrame\nnames(dat)\n#&gt;  [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\" \"carb\"\ndim(dat)\n#&gt; [1] 32 11\nhead(dat, n = 2)\n#&gt; polars DataFrame: shape: (2, 11)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 mpg  \u2506 cyl \u2506 disp  \u2506 hp    \u2506 ... \u2506 vs  \u2506 am  \u2506 gear \u2506 carb \u2502\n#&gt; \u2502 ---  \u2506 --- \u2506 ---   \u2506 ---   \u2506     \u2506 --- \u2506 --- \u2506 ---  \u2506 ---  \u2502\n#&gt; \u2502 f64  \u2506 f64 \u2506 f64   \u2506 f64   \u2506     \u2506 f64 \u2506 f64 \u2506 f64  \u2506 f64  \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0  \u2506 4.0  \u2502\n#&gt; \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0  \u2506 4.0  \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"articles/polars/#methods-and-pipelines","title":"Methods and pipelines","text":"<p>Although some simple R functions work out of the box on polars objects, the full power of Polars is realized via methods. Polars methods are accessed using the <code>$</code> syntax. For example, to convert Polars <code>Series</code> and <code>DataFrames</code> back to standard R objects, we use the <code>$to_r_vector()</code> and <code>$as_data_frame()</code> methods:</p> <pre><code>ser$to_r_vector()\n#&gt; [1]  5 10 15 20 25\n</code></pre> <p>There are numerous methods designed to accomplish various tasks:</p> <pre><code>ser$max()\n#&gt; polars Series: shape: (1,)\n#&gt; Series: '' [f64]\n#&gt; [\n#&gt;  25.0\n#&gt; ]\ndat$slice(offset = 2, length = 3)  #&gt; polars DataFrame: shape: (3, 11)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 mpg  \u2506 cyl \u2506 disp  \u2506 hp    \u2506 ... \u2506 vs  \u2506 am  \u2506 gear \u2506 carb \u2502\n#&gt; \u2502 ---  \u2506 --- \u2506 ---   \u2506 ---   \u2506     \u2506 --- \u2506 --- \u2506 ---  \u2506 ---  \u2502\n#&gt; \u2502 f64  \u2506 f64 \u2506 f64   \u2506 f64   \u2506     \u2506 f64 \u2506 f64 \u2506 f64  \u2506 f64  \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0  \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0  \u2506 1.0  \u2502\n#&gt; \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0  \u2506 1.0  \u2502\n#&gt; \u2502 18.7 \u2506 8.0 \u2506 360.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 0.0 \u2506 3.0  \u2506 2.0  \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>One advantage of using methods is that many more operations are possible on Polars objects using methods than through base R functions.</p> <p>A second advantage is Methods Chaining, a core part of the Polars workflow. If you are coming from one of the other popular data wrangling libraries in R, then you probably already have an innate sense of what this means. For instance,</p> <ul> <li>In dplyr we use a pipe operator,   e.g.\u00a0<code>dat |&gt; filter(...) |&gt; select(...)</code></li> <li>In data.table we use its indexing syntax, e.g.\u00a0<code>DT[i, j, by][...]</code></li> <li>Etc.</li> </ul> <p>In polars our method chaining syntax takes the form <code>object$m1()$m2()</code>, where <code>object</code> is our data object, and <code>m1()</code> and <code>m2()</code> are appropriate methods, like subsetting or aggregation expressions.</p> <p>This might all seem a little abstract, so let\u2019s walk through some quick examples to help make things concrete. We use the <code>mtcars</code> dataset that we coerced to a <code>DataFrame</code> in introduction.[^1] We use the <code>$max</code> method to compute the maximum value in each column:</p> <pre><code>dat$max()\n#&gt; polars DataFrame: shape: (1, 11)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 mpg  \u2506 cyl \u2506 disp  \u2506 hp    \u2506 ... \u2506 vs  \u2506 am  \u2506 gear \u2506 carb \u2502\n#&gt; \u2502 ---  \u2506 --- \u2506 ---   \u2506 ---   \u2506     \u2506 --- \u2506 --- \u2506 ---  \u2506 ---  \u2502\n#&gt; \u2502 f64  \u2506 f64 \u2506 f64   \u2506 f64   \u2506     \u2506 f64 \u2506 f64 \u2506 f64  \u2506 f64  \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 33.9 \u2506 8.0 \u2506 472.0 \u2506 335.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 5.0  \u2506 8.0  \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Now, we first use the <code>$tail</code> method to select the last 10 rows of the dataset, and then use the <code>$max</code> method to compute the maximums in those 10 rows:</p> <pre><code>dat$tail(10)$max()\n#&gt; polars DataFrame: shape: (1, 11)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 mpg  \u2506 cyl \u2506 disp  \u2506 hp    \u2506 ... \u2506 vs  \u2506 am  \u2506 gear \u2506 carb \u2502\n#&gt; \u2502 ---  \u2506 --- \u2506 ---   \u2506 ---   \u2506     \u2506 --- \u2506 --- \u2506 ---  \u2506 ---  \u2502\n#&gt; \u2502 f64  \u2506 f64 \u2506 f64   \u2506 f64   \u2506     \u2506 f64 \u2506 f64 \u2506 f64  \u2506 f64  \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 30.4 \u2506 8.0 \u2506 400.0 \u2506 335.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 5.0  \u2506 8.0  \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Finally, we convert the result to a standard R data frame:</p> <pre><code>dat$tail(10)$max()$as_data_frame()\n#&gt;    mpg cyl disp  hp drat    wt qsec vs am gear carb\n#&gt; 1 30.4   8  400 335 4.43 3.845 18.9  1  1    5    8\n</code></pre> <p>Below, we will introduce several other methods, including <code>$select</code>, <code>$filter</code>, and <code>$groupby</code> which allow us to do powerful data manipulations easily. To give you a small taste, we now take group-wise means:</p> <pre><code>dat$groupby(\"cyl\")$mean()\n#&gt; polars DataFrame: shape: (3, 11)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 cyl \u2506 mpg       \u2506 disp       \u2506 hp         \u2506 ... \u2506 vs       \u2506 am       \u2506 gear     \u2506 carb     \u2502\n#&gt; \u2502 --- \u2506 ---       \u2506 ---        \u2506 ---        \u2506     \u2506 ---      \u2506 ---      \u2506 ---      \u2506 ---      \u2502\n#&gt; \u2502 f64 \u2506 f64       \u2506 f64        \u2506 f64        \u2506     \u2506 f64      \u2506 f64      \u2506 f64      \u2506 f64      \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 4.0 \u2506 26.663636 \u2506 105.136364 \u2506 82.636364  \u2506 ... \u2506 0.909091 \u2506 0.727273 \u2506 4.090909 \u2506 1.545455 \u2502\n#&gt; \u2502 6.0 \u2506 19.742857 \u2506 183.314286 \u2506 122.285714 \u2506 ... \u2506 0.571429 \u2506 0.428571 \u2506 3.857143 \u2506 3.428571 \u2502\n#&gt; \u2502 8.0 \u2506 15.1      \u2506 353.1      \u2506 209.214286 \u2506 ... \u2506 0.0      \u2506 0.142857 \u2506 3.285714 \u2506 3.5      \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"articles/polars/#select-columns-and-filter-rows","title":"<code>select</code> columns and <code>filter</code> rows","text":"<p>We can now start chaining together various methods (expressions) to manipulate it in different ways. For example, we can subset the data by rows (<code>filter()</code>) and also columns (<code>select()</code>):</p> <pre><code>dat$filter(pl$col(\"cyl\") == 6)\n#&gt; polars DataFrame: shape: (7, 11)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 mpg  \u2506 cyl \u2506 disp  \u2506 hp    \u2506 ... \u2506 vs  \u2506 am  \u2506 gear \u2506 carb \u2502\n#&gt; \u2502 ---  \u2506 --- \u2506 ---   \u2506 ---   \u2506     \u2506 --- \u2506 --- \u2506 ---  \u2506 ---  \u2502\n#&gt; \u2502 f64  \u2506 f64 \u2506 f64   \u2506 f64   \u2506     \u2506 f64 \u2506 f64 \u2506 f64  \u2506 f64  \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0  \u2506 4.0  \u2502\n#&gt; \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0  \u2506 4.0  \u2502\n#&gt; \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0  \u2506 1.0  \u2502\n#&gt; \u2502 18.1 \u2506 6.0 \u2506 225.0 \u2506 105.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0  \u2506 1.0  \u2502\n#&gt; \u2502 19.2 \u2506 6.0 \u2506 167.6 \u2506 123.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 4.0  \u2506 4.0  \u2502\n#&gt; \u2502 17.8 \u2506 6.0 \u2506 167.6 \u2506 123.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 4.0  \u2506 4.0  \u2502\n#&gt; \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0  \u2506 6.0  \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\ndat$filter(pl$col(\"cyl\") == 6 &amp; pl$col(\"am\") == 1)\n#&gt; polars DataFrame: shape: (3, 11)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 mpg  \u2506 cyl \u2506 disp  \u2506 hp    \u2506 ... \u2506 vs  \u2506 am  \u2506 gear \u2506 carb \u2502\n#&gt; \u2502 ---  \u2506 --- \u2506 ---   \u2506 ---   \u2506     \u2506 --- \u2506 --- \u2506 ---  \u2506 ---  \u2502\n#&gt; \u2502 f64  \u2506 f64 \u2506 f64   \u2506 f64   \u2506     \u2506 f64 \u2506 f64 \u2506 f64  \u2506 f64  \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0  \u2506 4.0  \u2502\n#&gt; \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0  \u2506 4.0  \u2502\n#&gt; \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0  \u2506 6.0  \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\ndat$select(pl$col(c(\"mpg\", \"hp\")))\n#&gt; polars DataFrame: shape: (32, 2)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 mpg  \u2506 hp    \u2502\n#&gt; \u2502 ---  \u2506 ---   \u2502\n#&gt; \u2502 f64  \u2506 f64   \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 21.0 \u2506 110.0 \u2502\n#&gt; \u2502 21.0 \u2506 110.0 \u2502\n#&gt; \u2502 22.8 \u2506 93.0  \u2502\n#&gt; \u2502 21.4 \u2506 110.0 \u2502\n#&gt; \u2502 ...  \u2506 ...   \u2502\n#&gt; \u2502 15.8 \u2506 264.0 \u2502\n#&gt; \u2502 19.7 \u2506 175.0 \u2502\n#&gt; \u2502 15.0 \u2506 335.0 \u2502\n#&gt; \u2502 21.4 \u2506 109.0 \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Of course, we can chain those methods to create a pipeline:</p> <pre><code>dat$filter(\npl$col(\"cyl\") == 6\n)$select(\npl$col(c(\"mpg\", \"hp\", \"cyl\"))\n)\n#&gt; polars DataFrame: shape: (7, 3)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 mpg  \u2506 hp    \u2506 cyl \u2502\n#&gt; \u2502 ---  \u2506 ---   \u2506 --- \u2502\n#&gt; \u2502 f64  \u2506 f64   \u2506 f64 \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 21.0 \u2506 110.0 \u2506 6.0 \u2502\n#&gt; \u2502 21.0 \u2506 110.0 \u2506 6.0 \u2502\n#&gt; \u2502 21.4 \u2506 110.0 \u2506 6.0 \u2502\n#&gt; \u2502 18.1 \u2506 105.0 \u2506 6.0 \u2502\n#&gt; \u2502 19.2 \u2506 123.0 \u2506 6.0 \u2502\n#&gt; \u2502 17.8 \u2506 123.0 \u2506 6.0 \u2502\n#&gt; \u2502 19.7 \u2506 175.0 \u2506 6.0 \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"articles/polars/#aggregations-and-modifications","title":"Aggregations and modifications","text":"<p>The <code>select()</code> method that we introduced above also supports data modification, so you can simultaneously transform it while you are subsetting. However, the result will exclude any columns that weren\u2019t specified as part of the expression. To modify or add some columns\u2014whilst preserving all others in the dataset\u2014it is therefore better to use the <code>with_columns()</code> method. This next code chunk is equivalent to <code>mtcars |&gt; dplyr::mutate(sum_mpg=sum(mpg), sum_hp=sum(hp), .by = cyl)</code>.</p> <pre><code># Add the grouped sums of some selected columns.\ndat$with_columns(\npl$col(\"mpg\")$sum()$over(\"cyl\")$alias(\"sum_mpg\"),\npl$col(\"hp\")$sum()$over(\"cyl\")$alias(\"sum_hp\")\n)\n#&gt; polars DataFrame: shape: (32, 13)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 mpg  \u2506 cyl \u2506 disp  \u2506 hp    \u2506 ... \u2506 gear \u2506 carb \u2506 sum_mpg \u2506 sum_hp \u2502\n#&gt; \u2502 ---  \u2506 --- \u2506 ---   \u2506 ---   \u2506     \u2506 ---  \u2506 ---  \u2506 ---     \u2506 ---    \u2502\n#&gt; \u2502 f64  \u2506 f64 \u2506 f64   \u2506 f64   \u2506     \u2506 f64  \u2506 f64  \u2506 f64     \u2506 f64    \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 4.0  \u2506 4.0  \u2506 138.2   \u2506 856.0  \u2502\n#&gt; \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 4.0  \u2506 4.0  \u2506 138.2   \u2506 856.0  \u2502\n#&gt; \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0  \u2506 ... \u2506 4.0  \u2506 1.0  \u2506 293.3   \u2506 909.0  \u2502\n#&gt; \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 3.0  \u2506 1.0  \u2506 138.2   \u2506 856.0  \u2502\n#&gt; \u2502 ...  \u2506 ... \u2506 ...   \u2506 ...   \u2506 ... \u2506 ...  \u2506 ...  \u2506 ...     \u2506 ...    \u2502\n#&gt; \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 5.0  \u2506 4.0  \u2506 211.4   \u2506 2929.0 \u2502\n#&gt; \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 5.0  \u2506 6.0  \u2506 138.2   \u2506 856.0  \u2502\n#&gt; \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 5.0  \u2506 8.0  \u2506 211.4   \u2506 2929.0 \u2502\n#&gt; \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 4.0  \u2506 2.0  \u2506 293.3   \u2506 909.0  \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>For what it\u2019s worth, the previous query could have been written more concisely as:</p> <pre><code>dat$with_columns(\npl$col(c(\"mpg\", \"hp\"))$sum()$over(\"cyl\")$prefix(\"sum_\")\n)\n#&gt; polars DataFrame: shape: (32, 13)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 mpg  \u2506 cyl \u2506 disp  \u2506 hp    \u2506 ... \u2506 gear \u2506 carb \u2506 sum_mpg \u2506 sum_hp \u2502\n#&gt; \u2502 ---  \u2506 --- \u2506 ---   \u2506 ---   \u2506     \u2506 ---  \u2506 ---  \u2506 ---     \u2506 ---    \u2502\n#&gt; \u2502 f64  \u2506 f64 \u2506 f64   \u2506 f64   \u2506     \u2506 f64  \u2506 f64  \u2506 f64     \u2506 f64    \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 4.0  \u2506 4.0  \u2506 138.2   \u2506 856.0  \u2502\n#&gt; \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 4.0  \u2506 4.0  \u2506 138.2   \u2506 856.0  \u2502\n#&gt; \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0  \u2506 ... \u2506 4.0  \u2506 1.0  \u2506 293.3   \u2506 909.0  \u2502\n#&gt; \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 3.0  \u2506 1.0  \u2506 138.2   \u2506 856.0  \u2502\n#&gt; \u2502 ...  \u2506 ... \u2506 ...   \u2506 ...   \u2506 ... \u2506 ...  \u2506 ...  \u2506 ...     \u2506 ...    \u2502\n#&gt; \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 5.0  \u2506 4.0  \u2506 211.4   \u2506 2929.0 \u2502\n#&gt; \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 5.0  \u2506 6.0  \u2506 138.2   \u2506 856.0  \u2502\n#&gt; \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 5.0  \u2506 8.0  \u2506 211.4   \u2506 2929.0 \u2502\n#&gt; \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 4.0  \u2506 2.0  \u2506 293.3   \u2506 909.0  \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Similarly, here\u2019s how we could have aggregated (i.e., collapsed) the dataset by groups instead of modifying them. We need simply invoke the <code>groupby()</code> and <code>agg()</code> methods.</p> <pre><code>dat$groupby(\n\"cyl\",\nmaintain_order = TRUE\n)$agg(\npl$col(c(\"mpg\", \"hp\"))$sum()\n)\n#&gt; polars DataFrame: shape: (3, 3)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 cyl \u2506 mpg   \u2506 hp     \u2502\n#&gt; \u2502 --- \u2506 ---   \u2506 ---    \u2502\n#&gt; \u2502 f64 \u2506 f64   \u2506 f64    \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 6.0 \u2506 138.2 \u2506 856.0  \u2502\n#&gt; \u2502 4.0 \u2506 293.3 \u2506 909.0  \u2502\n#&gt; \u2502 8.0 \u2506 211.4 \u2506 2929.0 \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>(arg <code>maintain_order = TRUE</code> is optional, since polars doesn\u2019t sort the results of grouped operations by default. This is similar to what data.table does and is also true for newer versions of dplyr.)</p> <p>The same principles of method chaining can be combined very flexibly to group by multiple variables and aggregation types.</p> <pre><code>dat$groupby(\n\"cyl\",\npl$col(\"am\")$cast(pl$Boolean)$alias(\"manual\")\n)$agg(\npl$col(\"mpg\")$mean()$alias(\"mean_mpg\"),\npl$col(\"hp\")$median()$alias(\"med_hp\")\n)\n#&gt; polars DataFrame: shape: (6, 4)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 cyl \u2506 manual \u2506 mean_mpg  \u2506 med_hp \u2502\n#&gt; \u2502 --- \u2506 ---    \u2506 ---       \u2506 ---    \u2502\n#&gt; \u2502 f64 \u2506 bool   \u2506 f64       \u2506 f64    \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 6.0 \u2506 false  \u2506 19.125    \u2506 116.5  \u2502\n#&gt; \u2502 8.0 \u2506 false  \u2506 15.05     \u2506 180.0  \u2502\n#&gt; \u2502 4.0 \u2506 false  \u2506 22.9      \u2506 95.0   \u2502\n#&gt; \u2502 6.0 \u2506 true   \u2506 20.566667 \u2506 110.0  \u2502\n#&gt; \u2502 4.0 \u2506 true   \u2506 28.075    \u2506 78.5   \u2502\n#&gt; \u2502 8.0 \u2506 true   \u2506 15.4      \u2506 299.5  \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Note that we used the <code>cast</code> method to convert the data type of the <code>am</code> column. See the section below for more details on data types.</p>"},{"location":"articles/polars/#join","title":"Join","text":"<p>As a final example of how polars can be used for standard data wrangling tasks, let\u2019s implement a (left) join. For this example, we\u2019ll borrow some datasets from the nycflights13 package.</p> <pre><code>data(\"flights\", \"planes\", package = \"nycflights13\")\nflights = pl$DataFrame(flights)\nplanes = pl$DataFrame(planes)\nflights$join(\nplanes, on = \"tailnum\", how = \"left\"\n)\n#&gt; polars DataFrame: shape: (336776, 27)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 year \u2506 month \u2506 day \u2506 dep_time \u2506 ... \u2506 engines \u2506 seats \u2506 speed \u2506 engine    \u2502\n#&gt; \u2502 ---  \u2506 ---   \u2506 --- \u2506 ---      \u2506     \u2506 ---     \u2506 ---   \u2506 ---   \u2506 ---       \u2502\n#&gt; \u2502 i32  \u2506 i32   \u2506 i32 \u2506 i32      \u2506     \u2506 i32     \u2506 i32   \u2506 i32   \u2506 str       \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 2013 \u2506 1     \u2506 1   \u2506 517      \u2506 ... \u2506 2       \u2506 149   \u2506 null  \u2506 Turbo-fan \u2502\n#&gt; \u2502 2013 \u2506 1     \u2506 1   \u2506 533      \u2506 ... \u2506 2       \u2506 149   \u2506 null  \u2506 Turbo-fan \u2502\n#&gt; \u2502 2013 \u2506 1     \u2506 1   \u2506 542      \u2506 ... \u2506 2       \u2506 178   \u2506 null  \u2506 Turbo-fan \u2502\n#&gt; \u2502 2013 \u2506 1     \u2506 1   \u2506 544      \u2506 ... \u2506 2       \u2506 200   \u2506 null  \u2506 Turbo-fan \u2502\n#&gt; \u2502 ...  \u2506 ...   \u2506 ... \u2506 ...      \u2506 ... \u2506 ...     \u2506 ...   \u2506 ...   \u2506 ...       \u2502\n#&gt; \u2502 2013 \u2506 9     \u2506 30  \u2506 null     \u2506 ... \u2506 null    \u2506 null  \u2506 null  \u2506 null      \u2502\n#&gt; \u2502 2013 \u2506 9     \u2506 30  \u2506 null     \u2506 ... \u2506 null    \u2506 null  \u2506 null  \u2506 null      \u2502\n#&gt; \u2502 2013 \u2506 9     \u2506 30  \u2506 null     \u2506 ... \u2506 null    \u2506 null  \u2506 null  \u2506 null      \u2502\n#&gt; \u2502 2013 \u2506 9     \u2506 30  \u2506 null     \u2506 ... \u2506 null    \u2506 null  \u2506 null  \u2506 null      \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>More information on the polars joining method can be found in the reference manual.</p> <p>The package supports many other data manipulation operations, which we won\u2019t cover here. Hopefully, you will already have a sense of the key syntax features. We now turn to another core idea of the Polars ecosystem: lazy execution.</p>"},{"location":"articles/polars/#lazy-execution","title":"Lazy execution","text":"<p>While the \u201ceager\u201d execution engine of polars works perfectly well\u2014as evidenced by all of the previous examples\u2014to get the most out of the package you need to go lazy. Lazy execution enables several benefits, but the most important is that it improves performance. Delaying execution until the last possible moment allows Polars to apply automatic optimization to every query. Let\u2019s take a quick look.</p> <p>To create a so-called \u201cLazyFrame\u201d from an existing object in memory, we can invoke the <code>lazy()</code> constructor.</p> <pre><code>ldat = dat$lazy()\nldat\n#&gt; [1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\"\n#&gt;   DF [\"mpg\", \"cyl\", \"disp\", \"hp\"]; PROJECT */11 COLUMNS; SELECTION: \"None\"\n</code></pre> <p>Now consider what happens when we run our subsetting query from earlier on this LazyFrame.</p> <pre><code>subset_query = ldat$filter(\npl$col(\"cyl\")==6\n)$select(\npl$col(c(\"mpg\", \"hp\", \"cyl\"))\n)\nsubset_query\n#&gt; [1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\"\n#&gt;    SELECT [col(\"mpg\"), col(\"hp\"), col(\"cyl\")] FROM\n#&gt;     FILTER [(col(\"cyl\")) == (6f64)] FROM\n#&gt;       DF [\"mpg\", \"cyl\", \"disp\", \"hp\"]; PROJECT */11 COLUMNS; SELECTION: \"None\"\n</code></pre> <p>Right now we only have a tree of instructions. But underneath the hood, Polars has already worked out a more optimized version of the query. We can view this optimized plan this by requesting it.</p> <pre><code>subset_query$describe_optimized_plan()\n#&gt;   FAST_PROJECT: [mpg, hp, cyl]\n#&gt;     DF [\"mpg\", \"cyl\", \"disp\", \"hp\"]; PROJECT 3/11 COLUMNS; SELECTION: \"[(col(\\\"cyl\\\")) == (6f64)]\"\n</code></pre> <p>Here we see a simple, but surprisingly effective component in query optimization: projection. Changing the order in which our subsetting operations occurs\u2014in this case, subsetting on columns first\u2014reduces the memory overhead of the overall query and leads to a downstream speedup. Of course, you would hardly notice a difference for this small dataset. But the same principles carry over to much bigger datasets and more complex queries.</p> <p>To actually execute the plan, we just need to invoke the <code>collect()</code> method. This should feel very familiar if you have previously used other lazy execution engines like those provided by arrow or dbplyr.</p> <pre><code>subset_query$collect()\n#&gt; polars DataFrame: shape: (7, 3)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 mpg  \u2506 hp    \u2506 cyl \u2502\n#&gt; \u2502 ---  \u2506 ---   \u2506 --- \u2502\n#&gt; \u2502 f64  \u2506 f64   \u2506 f64 \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 21.0 \u2506 110.0 \u2506 6.0 \u2502\n#&gt; \u2502 21.0 \u2506 110.0 \u2506 6.0 \u2502\n#&gt; \u2502 21.4 \u2506 110.0 \u2506 6.0 \u2502\n#&gt; \u2502 18.1 \u2506 105.0 \u2506 6.0 \u2502\n#&gt; \u2502 19.2 \u2506 123.0 \u2506 6.0 \u2502\n#&gt; \u2502 17.8 \u2506 123.0 \u2506 6.0 \u2502\n#&gt; \u2502 19.7 \u2506 175.0 \u2506 6.0 \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"articles/polars/#data-import","title":"Data import","text":"<p>polars supports data import of both CSV and Parquet files formats. Here we demonstrate using the <code>airquality</code> dataset that also comes bundled with base R.</p> <pre><code>write.csv(airquality, \"airquality.csv\")\npl$read_csv(\"airquality.csv\")\n#&gt; polars DataFrame: shape: (153, 7)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502     \u2506 Ozone \u2506 Solar.R \u2506 Wind \u2506 Temp \u2506 Month \u2506 Day \u2502\n#&gt; \u2502 --- \u2506 ---   \u2506 ---     \u2506 ---  \u2506 ---  \u2506 ---   \u2506 --- \u2502\n#&gt; \u2502 i64 \u2506 str   \u2506 str     \u2506 f64  \u2506 i64  \u2506 i64   \u2506 i64 \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 1   \u2506 41    \u2506 190     \u2506 7.4  \u2506 67   \u2506 5     \u2506 1   \u2502\n#&gt; \u2502 2   \u2506 36    \u2506 118     \u2506 8.0  \u2506 72   \u2506 5     \u2506 2   \u2502\n#&gt; \u2502 3   \u2506 12    \u2506 149     \u2506 12.6 \u2506 74   \u2506 5     \u2506 3   \u2502\n#&gt; \u2502 4   \u2506 18    \u2506 313     \u2506 11.5 \u2506 62   \u2506 5     \u2506 4   \u2502\n#&gt; \u2502 ... \u2506 ...   \u2506 ...     \u2506 ...  \u2506 ...  \u2506 ...   \u2506 ... \u2502\n#&gt; \u2502 150 \u2506 NA    \u2506 145     \u2506 13.2 \u2506 77   \u2506 9     \u2506 27  \u2502\n#&gt; \u2502 151 \u2506 14    \u2506 191     \u2506 14.3 \u2506 75   \u2506 9     \u2506 28  \u2502\n#&gt; \u2502 152 \u2506 18    \u2506 131     \u2506 8.0  \u2506 76   \u2506 9     \u2506 29  \u2502\n#&gt; \u2502 153 \u2506 20    \u2506 223     \u2506 11.5 \u2506 68   \u2506 9     \u2506 30  \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Again, however, the package works best if we take the lazy approach.</p> <pre><code>pl$lazy_csv_reader(\"airquality.csv\")\n#&gt; [1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\"\n#&gt;   CSV SCAN airquality.csv\n#&gt;   PROJECT */7 COLUMNS\n</code></pre> <p>We could obviously append a set of query operators to the above LazyFrame and then collect the results. However, this workflow is even better suited to Parquet files, since we can leverage their efficient storage format on disk. Let\u2019s see an example.</p> <pre><code>library(arrow)\nwrite_parquet(airquality, \"airquality.parquet\")\n# aq = read_parquet(\"airquality.parquet) # eager version (okay)\naq = scan_parquet(\"airquality.parquet\")  # lazy version (better)\naq$filter(\npl$col(\"Month\") &lt;= 6\n)$groupby(\n\"Month\"\n)$agg(\npl$col(c(\"Ozone\", \"Temp\"))$mean()\n)$collect()\n#&gt; polars DataFrame: shape: (2, 3)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 Month \u2506 Ozone     \u2506 Temp      \u2502\n#&gt; \u2502 ---   \u2506 ---       \u2506 ---       \u2502\n#&gt; \u2502 i32   \u2506 f64       \u2506 f64       \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 6     \u2506 29.444444 \u2506 79.1      \u2502\n#&gt; \u2502 5     \u2506 23.615385 \u2506 65.548387 \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Finally, can read/scan multiple files in the same directory through pattern globbing. However, please note that partition-aware scanning is not yet supported out of the box (e.g., Hive-style partitioned datasets). Follow this issue for more details about when this will be resolved.</p> <pre><code>dir.create(\"airquality-ds\")\nwrite_dataset(airquality, \"airquality-ds\", partitioning = \"Month\")\n# Use pattern globbing to scan all parquet files in the folder\naq2 = scan_parquet(\"airquality-ds/*/*.parquet\")\n# Just print the first two rows. But note that the Month column\n# (which we used for partitioning) is missing.\naq2$limit(2)$collect()\n#&gt; polars DataFrame: shape: (2, 5)\n#&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n#&gt; \u2502 Ozone \u2506 Solar.R \u2506 Wind \u2506 Temp \u2506 Day \u2502\n#&gt; \u2502 ---   \u2506 ---     \u2506 ---  \u2506 ---  \u2506 --- \u2502\n#&gt; \u2502 i32   \u2506 i32     \u2506 f64  \u2506 i32  \u2506 i32 \u2502\n#&gt; \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n#&gt; \u2502 41    \u2506 190     \u2506 7.4  \u2506 67   \u2506 1   \u2502\n#&gt; \u2502 36    \u2506 118     \u2506 8.0  \u2506 72   \u2506 2   \u2502\n#&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Before continuing, don\u2019t forget to clean up by removing the newly created temp files and directory on disk.</p> <pre><code>file.remove(c(\"airquality.csv\", \"airquality.parquet\"))\n#&gt; [1] TRUE TRUE\nunlink(\"airquality-ds\", recursive = TRUE)\n</code></pre>"},{"location":"articles/polars/#execute-r-functions-within-a-polars-query","title":"Execute R functions within a Polars query","text":"<p>It is possible to mix R code with Polars by passing R functions to polars. This can unlock a lot of flexibility, but note that it can inhibit performance. R functions are typically slower, so we recommend using native Polars functions and expressions wherever possible.</p> <pre><code>pl$DataFrame(iris)$select(\npl$col(\"Sepal.Length\")$map(\\(s) { # map with a R function\nx = s$to_r_vector() # convert from Polars Series to a native R vector\nx[x&gt;=5] = 10\nx[1:10] # if return is R vector, it will automatically be converted to Polars Series again\n})\n)$as_data_frame()\n#&gt;    Sepal.Length\n#&gt; 1          10.0\n#&gt; 2           4.9\n#&gt; 3           4.7\n#&gt; 4           4.6\n#&gt; 5          10.0\n#&gt; 6          10.0\n#&gt; 7           4.6\n#&gt; 8          10.0\n#&gt; 9           4.4\n#&gt; 10          4.9\n</code></pre>"},{"location":"articles/polars/#data-types","title":"Data types","text":"<p>Polars is strongly typed and new types can be created with the <code>dtypes</code> constructor. For example:</p> <pre><code>pl$dtypes$Float64\n#&gt; DataType: Float64\n</code></pre> <p>The full list of valid Polars types can be found by typing <code>pl$dtypes</code> into your R console. These include Boolean, Float32(64), Int32(64), Utf8, Categorical, Date, etc. Note that some type names differ from what they are called in R (e.g., Boolean in Polars is equivalent to <code>logical()</code> in R). This might occasionally require you to look up a specific type. But the good news is that polars generally does a good job of inferring types automatically.</p> <p>[^1]: Similar to how (most) data.table operations are limited to     objects of class <code>data.table</code>, we can only perform polars operations     on objects that have been converted to an appropriate polars     class. Later on, we\u2019ll see how to read data from disk directly in     Polars format.</p>"},{"location":"reference/DataFrame/","title":"<code>DataFrame</code>","text":"<p>Create new DataFrame</p>"},{"location":"reference/DataFrame/#description","title":"Description","text":"<p>Create new DataFrame</p>"},{"location":"reference/DataFrame/#arguments","title":"Arguments","text":"Argument Description <code>...</code> <ul> <li> <p>one data.frame or something that inherits data.frame or DataFrame </p> </li> <li> <p>one list of mixed vectors and Series of equal length </p> </li> <li> <p>mixed vectors and/or Series of equal length   Columns will be named as of named arguments or alternatively by names of Series or given a placeholder name. <code>make_names_unique</code>     |     default TRUE, any duplicated names will be prefixed a running number <code>parallel</code>     |     bool default FALSE, experimental multithreaded interpretation of R vectors into a polars DataFrame. This is experimental as multiple threads read from R mem simultaneously. So far no issues parallel read from R has been found.</p> </li> </ul>"},{"location":"reference/DataFrame/#value","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/DataFrame/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(\na = list(c(1,2,3,4,5)), #NB if first column should be a list, wrap it in a Series\nb = 1:5,\nc = letters[1:5],\nd = list(1:1,1:2,1:3,1:4,1:5)\n) #directly from vectors\n#from a list of vectors or data.frame\npl$DataFrame(list(\na= c(1,2,3,4,5),\nb=1:5,\nc = letters[1:5],\nd = list(1L,1:2,1:3,1:4,1:5)\n))\n</code></pre>"},{"location":"reference/DataFrame_as_data_frame/","title":"<code>as_data_frame</code>","text":"<p>return polars DataFrame as R data.frame</p>"},{"location":"reference/DataFrame_as_data_frame/#description","title":"Description","text":"<p>return polars DataFrame as R data.frame</p>"},{"location":"reference/DataFrame_as_data_frame/#usage","title":"Usage","text":"<pre><code>DataFrame_as_data_frame(...)\nlist(list(\"as.data.frame\"), list(\"DataFrame\"))(x, ...)\n</code></pre>"},{"location":"reference/DataFrame_as_data_frame/#arguments","title":"Arguments","text":"Argument Description <code>...</code> any params passed to as.data.frame <code>x</code> DataFrame"},{"location":"reference/DataFrame_as_data_frame/#value","title":"Value","text":"<p>data.frame</p> <p>data.frame</p>"},{"location":"reference/DataFrame_as_data_frame/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris[1:3,])\ndf$as_data_frame()\n</code></pre>"},{"location":"reference/DataFrame_class/","title":"<code>class</code>","text":"<p>Inner workings of the DataFrame-class</p>"},{"location":"reference/DataFrame_class/#description","title":"Description","text":"<p>The <code>DataFrame</code> -class is simply two environments of respectively the public and private methods/function calls to the polars rust side. The instanciated <code>DataFrame</code> -object is an <code>externalptr</code> to a lowlevel rust polars DataFrame  object. The pointer address is the only statefullness of the DataFrame object on the R side. Any other state resides on the rust side. The S3 method <code>.DollarNames.DataFrame</code> exposes all public $foobar() -methods which are callable onto the object. Most methods return another <code>DataFrame</code> -class instance or similar which allows for method chaining. This class system in lack of a better name could be called \"environment classes\" and is the same class system extendr provides, except here there is both a public and private set of methods. For implementation reasons, the private methods are external and must be called from polars:::.pr.$DataFrame$methodname(), also all private methods must take any self as an argument, thus they are pure functions. Having the private methods as pure functions solved/simplified self-referential complications.</p>"},{"location":"reference/DataFrame_class/#details","title":"Details","text":"<p>Check out the source code in R/dataframe_frame.R how public methods are derived from private methods. Check out  extendr-wrappers.R to see the extendr-auto-generated methods. These are moved to .pr and converted into pure external functions in after-wrappers.R. In zzz.R (named zzz to be last file sourced) the extendr-methods are removed and replaced by any function prefixed <code>DataFrame_</code> .</p>"},{"location":"reference/DataFrame_class/#examples","title":"Examples","text":"<pre><code>#see all exported methods\nls(polars:::DataFrame)\n#see all private methods (not intended for regular use)\nls(polars:::.pr$DataFrame)\n#make an object\ndf = pl$DataFrame(iris)\n#use a public method/property\ndf$shape\ndf2 = df\n#use a private method, which has mutability\nresult = polars:::.pr$DataFrame$set_column_from_robj(df,150:1,\"some_ints\")\n#column exists in both dataframes-objects now, as they are just pointers to the same object\n# there are no public methods with mutability\ndf$columns\ndf2$columns\n# set_column_from_robj-method is fallible and returned a result which could be ok or an err.\n# No public method or function will ever return a result.\n# The `result` is very close to the same as output from functions decorated with purrr::safely.\n# To use results on R side, these must be unwrapped first such that\n# potentially errors can be thrown. unwrap(result) is a way to\n# bridge rust not throwing errors with R. Extendr default behaviour is to use panic!(s) which\n# would case some unneccesary confusing and  some very verbose error messages on the inner\n# workings of rust. unwrap(result) #in this case no error, just a NULL because this mutable\n# method does not return any ok-value.\n#try unwrapping an error from polars due to unmatching column lengths\nerr_result = polars:::.pr$DataFrame$set_column_from_robj(df,1:10000,\"wrong_length\")\ntryCatch(unwrap(err_result,call=NULL),error=\\(e) cat(as.character(e)))\n</code></pre>"},{"location":"reference/DataFrame_clone/","title":"<code>clone</code>","text":"<p>Clone a DataFrame</p>"},{"location":"reference/DataFrame_clone/#description","title":"Description","text":"<p>Rarely useful as DataFrame is nearly 100% immutable Any modification of a DataFrame would lead to a clone anyways.</p>"},{"location":"reference/DataFrame_clone/#usage","title":"Usage","text":"<pre><code>DataFrame_clone()\n</code></pre>"},{"location":"reference/DataFrame_clone/#value","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/DataFrame_clone/#examples","title":"Examples","text":"<pre><code>df1 = pl$DataFrame(iris);\ndf2 =  df1$clone();\ndf3 = df1\npl$mem_address(df1) != pl$mem_address(df2)\npl$mem_address(df1) == pl$mem_address(df3)\n</code></pre>"},{"location":"reference/DataFrame_columns/","title":"<code>columns</code>","text":"<p>get/set columns (the names columns)</p>"},{"location":"reference/DataFrame_columns/#description","title":"Description","text":"<p>get/set column names of DataFrame object</p> <p>get/set column names of DataFrame object</p>"},{"location":"reference/DataFrame_columns/#usage","title":"Usage","text":"<pre><code>RField_datatype()\nDataFrame_columns()\n</code></pre>"},{"location":"reference/DataFrame_columns/#value","title":"Value","text":"<p>char vec of column names</p> <p>char vec of column names</p>"},{"location":"reference/DataFrame_columns/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris)\n#get values\ndf$columns\n#set + get values\ndf$columns = letters[1:5] #&lt;- is fine too\ndf$columns\ndf = pl$DataFrame(iris)\n#get values\ndf$columns\n#set + get values\ndf$columns = letters[1:5] #&lt;- is fine too\ndf$columns\n</code></pre>"},{"location":"reference/DataFrame_dtypes/","title":"<code>dtypes</code>","text":"<p>DataFrame dtypes</p>"},{"location":"reference/DataFrame_dtypes/#description","title":"Description","text":"<p>Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame.</p> <p>Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame.</p>"},{"location":"reference/DataFrame_dtypes/#usage","title":"Usage","text":"<pre><code>DataFrame_dtypes()\nDataFrame_schema()\n</code></pre>"},{"location":"reference/DataFrame_dtypes/#value","title":"Value","text":"<p>width as numeric scalar</p> <p>width as numeric scalar</p>"},{"location":"reference/DataFrame_dtypes/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$dtypes\npl$DataFrame(iris)$schema\n</code></pre>"},{"location":"reference/DataFrame_estimated_size/","title":"<code>estimated_size</code>","text":"<p>Estimated size</p>"},{"location":"reference/DataFrame_estimated_size/#description","title":"Description","text":"<p>Return an estimation of the total (heap) allocated size of the DataFrame.</p>"},{"location":"reference/DataFrame_estimated_size/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/DataFrame_estimated_size/#usage","title":"Usage","text":"<pre><code>DataFrame_estimated_size\n</code></pre>"},{"location":"reference/DataFrame_estimated_size/#value","title":"Value","text":"<p>Bytes</p>"},{"location":"reference/DataFrame_estimated_size/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$estimated_size()\n</code></pre>"},{"location":"reference/DataFrame_first/","title":"<code>first</code>","text":"<p>First</p>"},{"location":"reference/DataFrame_first/#description","title":"Description","text":"<p>Get the first row of the DataFrame.</p>"},{"location":"reference/DataFrame_first/#usage","title":"Usage","text":"<pre><code>DataFrame_first()\n</code></pre>"},{"location":"reference/DataFrame_first/#value","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied filter.</p>"},{"location":"reference/DataFrame_first/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$first()\n</code></pre>"},{"location":"reference/DataFrame_get_column/","title":"<code>get_column</code>","text":"<p>Get Column (as one Series)</p>"},{"location":"reference/DataFrame_get_column/#description","title":"Description","text":"<p>get one column by name as series</p>"},{"location":"reference/DataFrame_get_column/#usage","title":"Usage","text":"<pre><code>DataFrame_get_column(name)\n</code></pre>"},{"location":"reference/DataFrame_get_column/#arguments","title":"Arguments","text":"Argument Description <code>name</code> name of column to extract as Series"},{"location":"reference/DataFrame_get_column/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/DataFrame_get_column/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris[1,])\ndf$get_column(\"Species\")\n</code></pre>"},{"location":"reference/DataFrame_get_columns/","title":"<code>get_columns</code>","text":"<p>Get columns (as Series)</p>"},{"location":"reference/DataFrame_get_columns/#description","title":"Description","text":"<p>get columns as list of series</p>"},{"location":"reference/DataFrame_get_columns/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/DataFrame_get_columns/#usage","title":"Usage","text":"<pre><code>DataFrame_get_columns\n</code></pre>"},{"location":"reference/DataFrame_get_columns/#value","title":"Value","text":"<p>list of series</p>"},{"location":"reference/DataFrame_get_columns/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris[1,])\ndf$get_columns()\n</code></pre>"},{"location":"reference/DataFrame_groupby/","title":"<code>groupby</code>","text":"<p>groupby DataFrame</p>"},{"location":"reference/DataFrame_groupby/#description","title":"Description","text":"<p>DataFrame$groupby(..., maintain_order = FALSE)</p>"},{"location":"reference/DataFrame_groupby/#usage","title":"Usage","text":"<pre><code>DataFrame_groupby(..., maintain_order = FALSE)\n</code></pre>"},{"location":"reference/DataFrame_groupby/#arguments","title":"Arguments","text":"Argument Description <code>...</code> any expression <code>maintain_order</code> bool"},{"location":"reference/DataFrame_groupby/#value","title":"Value","text":"<p>GroupBy (subclass of DataFrame)</p>"},{"location":"reference/DataFrame_height/","title":"<code>height</code>","text":"<p>Height of DataFrame</p>"},{"location":"reference/DataFrame_height/#description","title":"Description","text":"<p>Get height(nrow) of DataFrame</p>"},{"location":"reference/DataFrame_height/#usage","title":"Usage","text":"<pre><code>DataFrame_height()\n</code></pre>"},{"location":"reference/DataFrame_height/#value","title":"Value","text":"<p>height as numeric</p>"},{"location":"reference/DataFrame_height/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$height\n</code></pre>"},{"location":"reference/DataFrame_join/","title":"<code>join</code>","text":"<p>join DataFrame with other DataFrame</p>"},{"location":"reference/DataFrame_join/#description","title":"Description","text":"<p>join DataFrame with other DataFrame</p>"},{"location":"reference/DataFrame_join/#usage","title":"Usage","text":"<pre><code>DataFrame_join(\nother,\nleft_on = NULL,\nright_on = NULL,\non = NULL,\nhow = c(\"inner\", \"left\", \"outer\", \"semi\", \"anti\", \"cross\"),\nsuffix = \"_right\",\nallow_parallel = TRUE,\nforce_parallel = FALSE\n)\n</code></pre>"},{"location":"reference/DataFrame_join/#arguments","title":"Arguments","text":"Argument Description <code>other</code> DataFrame <code>left_on</code> names of columns in self LazyFrame, order should match. Type, see on param. <code>right_on</code> names of columns in other LazyFrame, order should match. Type, see on param. <code>on</code> named columns as char vector of named columns, or list of expressions and/or strings. <code>how</code> a string selecting one of the following methods: inner, left, outer, semi, anti, cross <code>suffix</code> name to added right table <code>allow_parallel</code> bool <code>force_parallel</code> bool"},{"location":"reference/DataFrame_join/#value","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/DataFrame_join/#examples","title":"Examples","text":"<pre><code>print(df1 &lt;- pl$DataFrame(list(key=1:3,payload=c('f','i',NA))))\nprint(df2 &lt;- pl$DataFrame(list(key=c(3L,4L,5L,NA_integer_))))\ndf1$join(other = df2,on = 'key')\n</code></pre>"},{"location":"reference/DataFrame_last/","title":"<code>last</code>","text":"<p>Last</p>"},{"location":"reference/DataFrame_last/#description","title":"Description","text":"<p>Get the last row of the DataFrame.</p>"},{"location":"reference/DataFrame_last/#usage","title":"Usage","text":"<pre><code>DataFrame_last()\n</code></pre>"},{"location":"reference/DataFrame_last/#value","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied filter.</p>"},{"location":"reference/DataFrame_last/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$last()\n</code></pre>"},{"location":"reference/DataFrame_lazy/","title":"<code>lazy</code>","text":"<p>New LazyFrame from DataFrame_object$lazy()</p>"},{"location":"reference/DataFrame_lazy/#description","title":"Description","text":"<p>Start a new lazy query from a DataFrame</p>"},{"location":"reference/DataFrame_lazy/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/DataFrame_lazy/#usage","title":"Usage","text":"<pre><code>DataFrame_lazy\n</code></pre>"},{"location":"reference/DataFrame_lazy/#value","title":"Value","text":"<p>a LazyFrame</p>"},{"location":"reference/DataFrame_lazy/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$lazy()\n#use of lazy method\npl$DataFrame(iris)$lazy()$filter(pl$col(\"Sepal.Length\") &gt;= 7.7)$collect()\n</code></pre>"},{"location":"reference/DataFrame_limit/","title":"<code>limit</code>","text":"<p>Limit a DataFrame</p>"},{"location":"reference/DataFrame_limit/#description","title":"Description","text":"<p>take limit of n rows of query</p>"},{"location":"reference/DataFrame_limit/#usage","title":"Usage","text":"<pre><code>DataFrame_limit(n)\n</code></pre>"},{"location":"reference/DataFrame_limit/#arguments","title":"Arguments","text":"Argument Description <code>n</code> positive numeric or integer number not larger than 2^32"},{"location":"reference/DataFrame_limit/#details","title":"Details","text":"<p>any number will converted to u32. Negative raises error</p>"},{"location":"reference/DataFrame_limit/#value","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/DataFrame_max/","title":"<code>max</code>","text":"<p>Max</p>"},{"location":"reference/DataFrame_max/#description","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their maximum value.</p>"},{"location":"reference/DataFrame_max/#usage","title":"Usage","text":"<pre><code>DataFrame_max()\n</code></pre>"},{"location":"reference/DataFrame_max/#value","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied aggregation.</p>"},{"location":"reference/DataFrame_max/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$max()\n</code></pre>"},{"location":"reference/DataFrame_mean/","title":"<code>mean</code>","text":"<p>Mean</p>"},{"location":"reference/DataFrame_mean/#description","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their mean value.</p>"},{"location":"reference/DataFrame_mean/#usage","title":"Usage","text":"<pre><code>DataFrame_mean()\n</code></pre>"},{"location":"reference/DataFrame_mean/#value","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied aggregation.</p>"},{"location":"reference/DataFrame_mean/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$mean()\n</code></pre>"},{"location":"reference/DataFrame_median/","title":"<code>median</code>","text":"<p>Median</p>"},{"location":"reference/DataFrame_median/#description","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their median value.</p>"},{"location":"reference/DataFrame_median/#usage","title":"Usage","text":"<pre><code>DataFrame_median()\n</code></pre>"},{"location":"reference/DataFrame_median/#value","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied aggregation.</p>"},{"location":"reference/DataFrame_median/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$median()\n</code></pre>"},{"location":"reference/DataFrame_min/","title":"<code>min</code>","text":"<p>Min</p>"},{"location":"reference/DataFrame_min/#description","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their minimum value.</p>"},{"location":"reference/DataFrame_min/#usage","title":"Usage","text":"<pre><code>DataFrame_min()\n</code></pre>"},{"location":"reference/DataFrame_min/#value","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied aggregation.</p>"},{"location":"reference/DataFrame_min/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$min()\n</code></pre>"},{"location":"reference/DataFrame_null_count/","title":"<code>null_count</code>","text":"<p>Null count</p>"},{"location":"reference/DataFrame_null_count/#description","title":"Description","text":"<p>Create a new DataFrame that shows the null counts per column.</p>"},{"location":"reference/DataFrame_null_count/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/DataFrame_null_count/#usage","title":"Usage","text":"<pre><code>DataFrame_null_count\n</code></pre>"},{"location":"reference/DataFrame_null_count/#value","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/DataFrame_null_count/#examples","title":"Examples","text":"<pre><code>x = mtcars\nx[1, 2:3] = NA\npl$DataFrame(x)$null_count()\n</code></pre>"},{"location":"reference/DataFrame_print/","title":"<code>print</code>","text":"<p>internal method print DataFrame</p>"},{"location":"reference/DataFrame_print/#description","title":"Description","text":"<p>internal method print DataFrame</p>"},{"location":"reference/DataFrame_print/#usage","title":"Usage","text":"<pre><code>DataFrame_print()\n</code></pre>"},{"location":"reference/DataFrame_print/#value","title":"Value","text":"<p>self</p>"},{"location":"reference/DataFrame_print/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)\n</code></pre>"},{"location":"reference/DataFrame_reverse/","title":"<code>reverse</code>","text":"<p>Reverse</p>"},{"location":"reference/DataFrame_reverse/#description","title":"Description","text":"<p>Reverse the DataFrame.</p>"},{"location":"reference/DataFrame_reverse/#usage","title":"Usage","text":"<pre><code>DataFrame_reverse()\n</code></pre>"},{"location":"reference/DataFrame_reverse/#value","title":"Value","text":"<p>LazyFrame</p>"},{"location":"reference/DataFrame_reverse/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$reverse()\n</code></pre>"},{"location":"reference/DataFrame_select/","title":"<code>select</code>","text":"<p>perform select on DataFrame</p>"},{"location":"reference/DataFrame_select/#description","title":"Description","text":"<p>related to dplyr <code>mutate()</code> However discards unmentioned columns as data.table <code>.()</code> .</p>"},{"location":"reference/DataFrame_select/#usage","title":"Usage","text":"<pre><code>DataFrame_select(...)\n</code></pre>"},{"location":"reference/DataFrame_select/#arguments","title":"Arguments","text":"Argument Description <code>...</code> expresssions or strings defining columns to select(keep) in context the DataFrame"},{"location":"reference/DataFrame_shape/","title":"<code>shape</code>","text":"<p>Shape of  DataFrame</p>"},{"location":"reference/DataFrame_shape/#description","title":"Description","text":"<p>Get shape/dimensions of DataFrame</p>"},{"location":"reference/DataFrame_shape/#usage","title":"Usage","text":"<pre><code>DataFrame_shape()\n</code></pre>"},{"location":"reference/DataFrame_shape/#value","title":"Value","text":"<p>two length numeric vector of c(nrows,ncols)</p>"},{"location":"reference/DataFrame_shape/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris)$shape\n</code></pre>"},{"location":"reference/DataFrame_slice/","title":"<code>slice</code>","text":"<p>Slice</p>"},{"location":"reference/DataFrame_slice/#description","title":"Description","text":"<p>Get a slice of this DataFrame.</p>"},{"location":"reference/DataFrame_slice/#usage","title":"Usage","text":"<pre><code>DataFrame_slice(offset, length = NULL)\n</code></pre>"},{"location":"reference/DataFrame_slice/#arguments","title":"Arguments","text":"Argument Description <code>offset</code> integer <code>length</code> integer or NULL"},{"location":"reference/DataFrame_slice/#value","title":"Value","text":"<p>LazyFrame</p>"},{"location":"reference/DataFrame_slice/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$slice(2, 4)\nmtcars[2:6,]\n</code></pre>"},{"location":"reference/DataFrame_std/","title":"<code>std</code>","text":"<p>Std</p>"},{"location":"reference/DataFrame_std/#description","title":"Description","text":"<p>Aggregate the columns of this DataFrame to their standard deviation values.</p>"},{"location":"reference/DataFrame_std/#usage","title":"Usage","text":"<pre><code>DataFrame_std(ddof = 1)\n</code></pre>"},{"location":"reference/DataFrame_std/#arguments","title":"Arguments","text":"Argument Description <code>ddof</code> integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1."},{"location":"reference/DataFrame_std/#value","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied aggregation.</p>"},{"location":"reference/DataFrame_std/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$std()\n</code></pre>"},{"location":"reference/DataFrame_sum/","title":"<code>sum</code>","text":"<p>Sum</p>"},{"location":"reference/DataFrame_sum/#description","title":"Description","text":"<p>Aggregate the columns of this DataFrame to their sum values.</p>"},{"location":"reference/DataFrame_sum/#usage","title":"Usage","text":"<pre><code>DataFrame_sum()\n</code></pre>"},{"location":"reference/DataFrame_sum/#value","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied aggregation.</p>"},{"location":"reference/DataFrame_sum/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$sum()\n</code></pre>"},{"location":"reference/DataFrame_tail/","title":"<code>tail</code>","text":"<p>Tail a DataFrame</p>"},{"location":"reference/DataFrame_tail/#description","title":"Description","text":"<p>Get the last n rows.</p>"},{"location":"reference/DataFrame_tail/#usage","title":"Usage","text":"<pre><code>DataFrame_tail(n)\n</code></pre>"},{"location":"reference/DataFrame_tail/#arguments","title":"Arguments","text":"Argument Description <code>n</code> positive numeric of integer number not larger than 2^32"},{"location":"reference/DataFrame_tail/#details","title":"Details","text":"<p>any number will converted to u32. Negative raises error</p>"},{"location":"reference/DataFrame_tail/#value","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/DataFrame_to_Struct_unnest/","title":"<code>to_Struct_unnest</code>","text":"<p>to_struct and unnest again</p>"},{"location":"reference/DataFrame_to_Struct_unnest/#description","title":"Description","text":"<p>to_struct and unnest again</p> <p>Unnest a DataFrame struct columns.</p>"},{"location":"reference/DataFrame_to_Struct_unnest/#usage","title":"Usage","text":"<pre><code>DataFrame_to_struct(name = \"\")\nDataFrame_unnest(names = NULL)\n</code></pre>"},{"location":"reference/DataFrame_to_Struct_unnest/#arguments","title":"Arguments","text":"Argument Description <code>name</code> name of new Series <code>names</code> names of struct columns to unnest, default NULL unnest any struct column"},{"location":"reference/DataFrame_to_Struct_unnest/#value","title":"Value","text":"<p>@to_struct() returns a Series</p> <p>$unnest() returns a DataFrame with all column including any that has been unnested</p>"},{"location":"reference/DataFrame_to_Struct_unnest/#examples","title":"Examples","text":"<pre><code>#round-trip conversion from DataFrame with two columns\ndf = pl$DataFrame(a=1:5,b=c(\"one\",\"two\",\"three\",\"four\",\"five\"))\ns = df$to_struct()\ns\ns$to_r() # to r list\ndf_s = s$to_frame() #place series in a new DataFrame\ndf_s$unnest() # back to starting df\n</code></pre>"},{"location":"reference/DataFrame_to_series/","title":"<code>to_series</code>","text":"<p>Get Series by idx, if there</p>"},{"location":"reference/DataFrame_to_series/#description","title":"Description","text":"<p>get one column by idx as series from DataFrame. Unlike get_column this method will not fail if no series found at idx but return a NULL, idx is zero idx.</p>"},{"location":"reference/DataFrame_to_series/#usage","title":"Usage","text":"<pre><code>DataFrame_to_series(idx = 0)\n</code></pre>"},{"location":"reference/DataFrame_to_series/#arguments","title":"Arguments","text":"Argument Description <code>idx</code> numeric default 0, zero-index of what column to return as Series"},{"location":"reference/DataFrame_to_series/#value","title":"Value","text":"<p>Series or NULL</p>"},{"location":"reference/DataFrame_to_series/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a=1:4)$to_series()\n</code></pre>"},{"location":"reference/DataFrame_var/","title":"<code>var</code>","text":"<p>Var</p>"},{"location":"reference/DataFrame_var/#description","title":"Description","text":"<p>Aggregate the columns of this DataFrame to their variance values.</p>"},{"location":"reference/DataFrame_var/#usage","title":"Usage","text":"<pre><code>DataFrame_var(ddof = 1)\n</code></pre>"},{"location":"reference/DataFrame_var/#arguments","title":"Arguments","text":"Argument Description <code>ddof</code> integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1."},{"location":"reference/DataFrame_var/#value","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied aggregation.</p>"},{"location":"reference/DataFrame_var/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$var()\n</code></pre>"},{"location":"reference/DataFrame_width/","title":"<code>width</code>","text":"<p>Width of DataFrame</p>"},{"location":"reference/DataFrame_width/#description","title":"Description","text":"<p>Get width(ncol) of DataFrame</p>"},{"location":"reference/DataFrame_width/#usage","title":"Usage","text":"<pre><code>DataFrame_width()\n</code></pre>"},{"location":"reference/DataFrame_width/#value","title":"Value","text":"<p>width as numeric scalar</p>"},{"location":"reference/DataFrame_width/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$width\n</code></pre>"},{"location":"reference/DataFrame_with_columns/","title":"<code>with_columns</code>","text":"<p>modify/append column(s)</p>"},{"location":"reference/DataFrame_with_columns/#description","title":"Description","text":"<p>add or modify columns with expressions</p>"},{"location":"reference/DataFrame_with_columns/#usage","title":"Usage","text":"<pre><code>DataFrame_with_columns(...)\nDataFrame_with_column(expr)\n</code></pre>"},{"location":"reference/DataFrame_with_columns/#arguments","title":"Arguments","text":"Argument Description <code>...</code> any expressions or string column name, or same wrapped in a list <code>expr</code> a single expression or string"},{"location":"reference/DataFrame_with_columns/#details","title":"Details","text":"<p>Like dplyr <code>mutate()</code> as it keeps unmentioned columns unlike $select().</p> <p>with_column is derived from with_columns but takes only one expression argument</p>"},{"location":"reference/DataFrame_with_columns/#value","title":"Value","text":"<p>DataFrame</p> <p>DataFrame</p>"},{"location":"reference/DataFrame_with_columns/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$with_columns(\npl$col(\"Sepal.Length\")$abs()$alias(\"abs_SL\"),\n(pl$col(\"Sepal.Length\")+2)$alias(\"add_2_SL\")\n)\n#rename columns by naming expression is concidered experimental\npl$set_polars_options(named_exprs = TRUE) #unlock\npl$DataFrame(iris)$with_columns(\npl$col(\"Sepal.Length\")$abs(), #not named expr will keep name \"Sepal.Length\"\nSW_add_2 = (pl$col(\"Sepal.Width\")+2)\n)\n</code></pre>"},{"location":"reference/DataType/","title":"<code>DataType</code>","text":"<p>DataTypes polars types</p>"},{"location":"reference/DataType/#description","title":"Description","text":"<p><code>DataType</code> any polars type (ported so far)</p>"},{"location":"reference/DataType/#examples","title":"Examples","text":"<pre><code>print(ls(pl$dtypes))\npl$dtypes$Float64\npl$dtypes$Utf8\npl$List(pl$List(pl$UInt64))\npl$Struct(pl$Field(\"CityNames\", pl$Utf8))\n# Some DataType use case, this user function fails because....\npl$Series(1:4)$apply(\\(x) letters[x])\n#The function changes type from Integer(Int32)[Integers] to char(Utf8)[Strings]\n#specifying the output DataType: Utf8 solves the problem\npl$Series(1:4)$apply(\\(x) letters[x],datatype = pl$dtypes$Utf8)\n</code></pre>"},{"location":"reference/DataType_constructors/","title":"<code>DataType_constructors</code>","text":"<p>DataType_constructors (composite DataType's)</p>"},{"location":"reference/DataType_constructors/#description","title":"Description","text":"<p>List of all composite DataType constructors</p>"},{"location":"reference/DataType_constructors/#format","title":"Format","text":"<p>An object of class <code>list</code> of length 3.</p>"},{"location":"reference/DataType_constructors/#usage","title":"Usage","text":"<pre><code>DataType_constructors\n</code></pre>"},{"location":"reference/DataType_constructors/#details","title":"Details","text":"<p>This list is mainly used in <code>zzz.R</code> <code>.onLoad</code> to instantiate singletons of all  flag-like DataTypes.</p> <p>Non-flag like DataType called composite DataTypes also carries extra information  e.g. Datetime a timeunit and a TimeZone, or List which recursively carries another DataType  inside. Composite DataTypes use DataType constructors.</p> <p>Any DataType can be found in pl$dtypes</p>"},{"location":"reference/DataType_constructors/#value","title":"Value","text":"<p>DataType</p>"},{"location":"reference/DataType_constructors/#examples","title":"Examples","text":"<pre><code>#constructors are finally available via pl$... or pl$dtypes$...\npl$List(pl$List(pl$Int64))\n</code></pre>"},{"location":"reference/DataType_new/","title":"<code>DataType_new</code>","text":"<p>DataType_new (simple DataType's)</p>"},{"location":"reference/DataType_new/#description","title":"Description","text":"<p>Create a new flag like DataType</p>"},{"location":"reference/DataType_new/#usage","title":"Usage","text":"<pre><code>DataType_new(str)\n</code></pre>"},{"location":"reference/DataType_new/#arguments","title":"Arguments","text":"Argument Description <code>str</code> name of DataType to create"},{"location":"reference/DataType_new/#details","title":"Details","text":"<p>This function is mainly used in <code>zzz.R</code> <code>.onLoad</code> to instantiate singletons of all  flag-like DataType.</p> <p>Non-flag like DataType called composite DataTypes also carries extra information  e.g. Datetime a timeunit and a TimeZone, or List which recursively carries another DataType  inside. Composite DataTypes use DataType constructors.</p> <p>Any DataType can be found in pl$dtypes</p>"},{"location":"reference/DataType_new/#value","title":"Value","text":"<p>DataType</p>"},{"location":"reference/DataType_new/#examples","title":"Examples","text":"<pre><code>polars:::DataType_new(\"Int64\")\n</code></pre>"},{"location":"reference/Err/","title":"<code>Err</code>","text":"<p>Wrap in Err</p>"},{"location":"reference/Err/#description","title":"Description","text":"<p>Wrap in Err</p>"},{"location":"reference/Err/#usage","title":"Usage","text":"<pre><code>Err(x)\n</code></pre>"},{"location":"reference/Err/#arguments","title":"Arguments","text":"Argument Description <code>x</code> any R object"},{"location":"reference/Err/#value","title":"Value","text":"<p>same R object wrapped in a Err-result</p>"},{"location":"reference/Expr-cash-print-open-paren-close-paren/","title":"<code>Expr$print()</code>","text":"<p>internal method print Expr</p>"},{"location":"reference/Expr-cash-print-open-paren-close-paren/#description","title":"Description","text":"<p>internal method print Expr</p>"},{"location":"reference/Expr-cash-print-open-paren-close-paren/#usage","title":"Usage","text":"<pre><code>Expr_print()\n</code></pre>"},{"location":"reference/Expr-cash-print-open-paren-close-paren/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)\n</code></pre>"},{"location":"reference/Expr/","title":"<code>Expr</code>","text":"<p>Polars Expr</p>"},{"location":"reference/Expr/#description","title":"Description","text":"<p>Polars pl$Expr</p>"},{"location":"reference/Expr/#usage","title":"Usage","text":"<pre><code>Expr_lit(x)\nExpr_suffix(suffix)\nExpr_prefix(prefix)\nExpr_reverse()\n</code></pre>"},{"location":"reference/Expr/#arguments","title":"Arguments","text":"Argument Description <code>x</code> an R Scalar, or R vector/list (via Series) into Expr <code>suffix</code> string suffix to be added to a name <code>prefix</code> string suffix to be added to a name"},{"location":"reference/Expr/#details","title":"Details","text":"<p>pl$lit(NULL) translates into a typeless polars Null</p>"},{"location":"reference/Expr/#value","title":"Value","text":"<p>Expr, literal of that value</p> <p>Expr</p> <p>Expr</p> <p>Expr</p>"},{"location":"reference/Expr/#examples","title":"Examples","text":"<pre><code>2+2\n#Expr has the following methods/constructors\nls(polars:::Expr)\npl$col(\"this_column\")$sum()$over(\"that_column\")\n#scalars to literal, explit `pl$lit(42)` implicit `+ 2`\npl$col(\"some_column\") / pl$lit(42) + 2\n#vector to literal explicitly via Series and back again\n#R vector to expression and back again\npl$select(pl$lit(pl$Series(1:4)))$to_list()[[1L]]\n#r vecot to literal and back r vector\npl$lit(1:4)$to_r()\n#r vector to literal to dataframe\npl$select(pl$lit(1:4))\n#r vector to literal to Series\npl$lit(1:4)$lit_to_s()\n#vectors to literal implicitly\n(pl$lit(2) + 1:4 ) / 4:1\npl$col(\"some\")$suffix(\"_column\")\npl$col(\"some\")$suffix(\"_column\")\npl$DataFrame(list(a=1:5))$select(pl$col(\"a\")$reverse())\n</code></pre>"},{"location":"reference/ExprBin_contains/","title":"<code>ExprBin_contains</code>","text":"<p>contains</p>"},{"location":"reference/ExprBin_contains/#description","title":"Description","text":"<p>R Check if binaries in Series contain a binary substring.</p>"},{"location":"reference/ExprBin_contains/#arguments","title":"Arguments","text":"Argument Description <code>lit</code> The binary substring to look for"},{"location":"reference/ExprBin_contains/#value","title":"Value","text":"<p>Expr returning a Boolean</p>"},{"location":"reference/ExprBin_decode/","title":"<code>ExprBin_decode</code>","text":"<p>decode</p>"},{"location":"reference/ExprBin_decode/#description","title":"Description","text":"<p>Decode a value using the provided encoding.</p>"},{"location":"reference/ExprBin_decode/#arguments","title":"Arguments","text":"Argument Description <code>encoding</code> binary choice either 'hex' or 'base64' <code>strict</code> Raise an error if the underlying value cannot be decoded, otherwise mask out with a null value."},{"location":"reference/ExprBin_decode/#value","title":"Value","text":"<p>binary array with values decoded using provided encoding</p>"},{"location":"reference/ExprBin_encode/","title":"<code>ExprBin_encode</code>","text":"<p>encode</p>"},{"location":"reference/ExprBin_encode/#description","title":"Description","text":"<p>Encode a value using the provided encoding.</p>"},{"location":"reference/ExprBin_encode/#arguments","title":"Arguments","text":"Argument Description <code>encoding</code> binary choice either 'hex' or 'base64'"},{"location":"reference/ExprBin_encode/#value","title":"Value","text":"<p>binary array with values encoded using provided encoding</p>"},{"location":"reference/ExprBin_ends_with/","title":"<code>ExprBin_ends_with</code>","text":"<p>ends_with</p>"},{"location":"reference/ExprBin_ends_with/#description","title":"Description","text":"<p>Check if string values end with a binary substring.</p>"},{"location":"reference/ExprBin_ends_with/#value","title":"Value","text":"<p>Expr returning a Boolean</p>"},{"location":"reference/ExprBin_starts_with/","title":"<code>ExprBin_starts_with</code>","text":"<p>starts_with</p>"},{"location":"reference/ExprBin_starts_with/#description","title":"Description","text":"<p>Check if values starts with a binary substring.</p>"},{"location":"reference/ExprBin_starts_with/#arguments","title":"Arguments","text":"Argument Description <code>sub</code> Prefix substring."},{"location":"reference/ExprCat_set_ordering/","title":"<code>ExprCat_set_ordering</code>","text":"<p>Set Ordering</p>"},{"location":"reference/ExprCat_set_ordering/#description","title":"Description","text":"<p>Determine how this categorical series should be sorted.</p>"},{"location":"reference/ExprCat_set_ordering/#arguments","title":"Arguments","text":"Argument Description <code>ordering</code> string either 'physical' or 'lexical' <ul> <li> <p>'physical' -&gt; Use the physical representation of the categories to determine the order (default). </p> </li> <li> <p>'lexical' -&gt; Use the string values to determine the ordering.</p> </li> </ul>"},{"location":"reference/ExprCat_set_ordering/#value","title":"Value","text":"<p>bool: TRUE if equal</p>"},{"location":"reference/ExprCat_set_ordering/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ncats =  c(\"z\", \"z\", \"k\", \"a\", \"b\"),\nvals =  c(3, 1, 2, 2, 3)\n)$with_columns(\npl$col(\"cats\")$cast(pl$Categorical)$cat$set_ordering(\"physical\")\n)\ndf$select(pl$all()$sort())\n</code></pre>"},{"location":"reference/ExprDT_cast_time_unit/","title":"<code>ExprDT_cast_time_unit</code>","text":"<p>cast_time_unit</p>"},{"location":"reference/ExprDT_cast_time_unit/#description","title":"Description","text":"<p>Cast the underlying data to another time unit. This may lose precision.  The corresponding global timepoint will stay unchanged +/- precision.</p>"},{"location":"reference/ExprDT_cast_time_unit/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_cast_time_unit/#arguments","title":"Arguments","text":"Argument Description <code>tu</code> string option either 'ns', 'us', or 'ms'"},{"location":"reference/ExprDT_cast_time_unit/#value","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/ExprDT_cast_time_unit/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2001-1-1\"), high = as.Date(\"2001-1-3\"), interval = \"1d\")\n)\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$dt$cast_time_unit()$alias(\"cast_time_unit_ns\"),\npl$col(\"date\")$dt$cast_time_unit(tu=\"ms\")$alias(\"cast_time_unit_ms\")\n)\n</code></pre>"},{"location":"reference/ExprDT_combine/","title":"<code>ExprDT_combine</code>","text":"<p>Combine Data and Time</p>"},{"location":"reference/ExprDT_combine/#description","title":"Description","text":"<p>Create a naive Datetime from an existing Date/Datetime expression and a Time.  Each date/datetime in the first half of the interval  is mapped to the start of its bucket.  Each date/datetime in the second half of the interval  is mapped to the end of its bucket.</p>"},{"location":"reference/ExprDT_combine/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_combine/#arguments","title":"Arguments","text":"Argument Description <code>tm</code> Expr or numeric or PTime, the number of epoch since or before(if negative) the Date or tm is an Expr e.g. a column of DataType 'Time' or something into an Expr. <code>tu</code> time unit of epochs, default is \"us\", if tm is a PTime, then tz passed via PTime."},{"location":"reference/ExprDT_combine/#details","title":"Details","text":"<p>The <code>tu</code> allows the following time time units  the following string language:</p> <ul> <li> <p>1ns # 1 nanosecond </p> </li> <li> <p>1us # 1 microsecond </p> </li> <li> <p>1ms # 1 millisecond</p> </li> </ul>"},{"location":"reference/ExprDT_combine/#value","title":"Value","text":"<p>Date/Datetime expr</p>"},{"location":"reference/ExprDT_combine/#examples","title":"Examples","text":"<pre><code>#Using pl$PTime\npl$lit(as.Date(\"2021-01-01\"))$dt$combine(pl$PTime(\"02:34:12\"))$lit_to_s()\npl$lit(as.Date(\"2021-01-01\"))$dt$combine(pl$PTime(3600 * 1.5, tu=\"s\"))$lit_to_s()\npl$lit(as.Date(\"2021-01-01\"))$dt$combine(pl$PTime(3600 * 1.5E6 + 123, tu=\"us\"))$lit_to_s()\n#pass double and set tu manually\npl$lit(as.Date(\"2021-01-01\"))$dt$combine(3600 * 1.5E6 + 123, tu=\"us\")$lit_to_s()\n#if needed to convert back to R it is more intuitive to set a specific time zone\nexpr = pl$lit(as.Date(\"2021-01-01\"))$dt$combine(3600 * 1.5E6 + 123, tu=\"us\")\nexpr$cast(pl$Datetime(tu = \"us\", tz = \"GMT\"))$to_r()\n</code></pre>"},{"location":"reference/ExprDT_convert_time_zone/","title":"<code>ExprDT_convert_time_zone</code>","text":"<p>With Time Zone</p>"},{"location":"reference/ExprDT_convert_time_zone/#description","title":"Description","text":"<p>Set time zone for a Series of type Datetime.  Use to change time zone annotation, but keep the corresponding global timepoint.</p>"},{"location":"reference/ExprDT_convert_time_zone/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_convert_time_zone/#arguments","title":"Arguments","text":"Argument Description <code>tz</code> String time zone from base::OlsonNames()"},{"location":"reference/ExprDT_convert_time_zone/#details","title":"Details","text":"<p>corresponds to in R manually modifying the tzone attribute of POSIXt objects</p>"},{"location":"reference/ExprDT_convert_time_zone/#value","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/ExprDT_convert_time_zone/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2001-3-1\"), high = as.Date(\"2001-5-1\"), interval = \"1mo\")\n)\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")\n$dt$replace_time_zone(\"Europe/Amsterdam\")\n$dt$convert_time_zone(\"Europe/London\")\n$alias(\"London_with\"),\npl$col(\"date\")\n$dt$tz_localize(\"Europe/London\")\n$alias(\"London_localize\")\n)\n</code></pre>"},{"location":"reference/ExprDT_day/","title":"<code>ExprDT_day</code>","text":"<p>Day</p>"},{"location":"reference/ExprDT_day/#description","title":"Description","text":"<p>Extract day from underlying Date representation.  Applies to Date and Datetime columns.  Returns the day of month starting from 1.  The return value ranges from 1 to 31. (The last day of month differs by months.)</p>"},{"location":"reference/ExprDT_day/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_day/#value","title":"Value","text":"<p>Expr of day as UInt32</p>"},{"location":"reference/ExprDT_day/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$day()$alias(\"day\")\n)\n</code></pre>"},{"location":"reference/ExprDT_days/","title":"<code>ExprDT_days</code>","text":"<p>Days</p>"},{"location":"reference/ExprDT_days/#description","title":"Description","text":"<p>Extract the days from a Duration type.</p>"},{"location":"reference/ExprDT_days/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_days/#value","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/ExprDT_days/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2020-3-1\"), high = as.Date(\"2020-5-1\"), interval = \"1mo\")\n)\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$diff()$dt$days()$alias(\"days_diff\")\n)\n</code></pre>"},{"location":"reference/ExprDT_epoch/","title":"<code>ExprDT_epoch</code>","text":"<p>Epoch</p>"},{"location":"reference/ExprDT_epoch/#description","title":"Description","text":"<p>Get the time passed since the Unix EPOCH in the give time unit.</p>"},{"location":"reference/ExprDT_epoch/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_epoch/#arguments","title":"Arguments","text":"Argument Description <code>tu</code> string option either 'ns', 'us', 'ms', 's' or  'd'"},{"location":"reference/ExprDT_epoch/#details","title":"Details","text":"<p>ns and perhaps us will exceed integerish limit if returning to  R as flaot64/double.</p>"},{"location":"reference/ExprDT_epoch/#value","title":"Value","text":"<p>Expr of epoch as UInt32</p>"},{"location":"reference/ExprDT_epoch/#examples","title":"Examples","text":"<pre><code>pl$date_range(as.Date(\"2022-1-1\"),lazy = TRUE)$dt$epoch(\"ns\")$lit_to_s()\npl$date_range(as.Date(\"2022-1-1\"),lazy = TRUE)$dt$epoch(\"ms\")$lit_to_s()\npl$date_range(as.Date(\"2022-1-1\"),lazy = TRUE)$dt$epoch(\"s\")$lit_to_s()\npl$date_range(as.Date(\"2022-1-1\"),lazy = TRUE)$dt$epoch(\"d\")$lit_to_s()\n</code></pre>"},{"location":"reference/ExprDT_hour/","title":"<code>ExprDT_hour</code>","text":"<p>Hour</p>"},{"location":"reference/ExprDT_hour/#description","title":"Description","text":"<p>Extract hour from underlying Datetime representation.  Applies to Datetime columns.  Returns the hour number from 0 to 23.</p>"},{"location":"reference/ExprDT_hour/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_hour/#value","title":"Value","text":"<p>Expr of hour as UInt32</p>"},{"location":"reference/ExprDT_hour/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$hour()$alias(\"hour\")\n)\n</code></pre>"},{"location":"reference/ExprDT_hours/","title":"<code>ExprDT_hours</code>","text":"<p>Hours</p>"},{"location":"reference/ExprDT_hours/#description","title":"Description","text":"<p>Extract the hours from a Duration type.</p>"},{"location":"reference/ExprDT_hours/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_hours/#value","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/ExprDT_hours/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2020-1-1\"), high = as.Date(\"2020-1-4\"), interval = \"1d\")\n)\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$diff()$dt$hours()$alias(\"hours_diff\")\n)\n</code></pre>"},{"location":"reference/ExprDT_iso_year/","title":"<code>ExprDT_iso_year</code>","text":"<p>Iso-Year</p>"},{"location":"reference/ExprDT_iso_year/#description","title":"Description","text":"<p>Extract ISO year from underlying Date representation.  Applies to Date and Datetime columns.  Returns the year number in the ISO standard.  This may not correspond with the calendar year.</p>"},{"location":"reference/ExprDT_iso_year/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_iso_year/#value","title":"Value","text":"<p>Expr of iso_year as Int32</p>"},{"location":"reference/ExprDT_iso_year/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$year()$alias(\"year\"),\npl$col(\"date\")$dt$iso_year()$alias(\"iso_year\")\n)\n</code></pre>"},{"location":"reference/ExprDT_microsecond/","title":"<code>ExprDT_microsecond</code>","text":"<p>Microsecond</p>"},{"location":"reference/ExprDT_microsecond/#description","title":"Description","text":"<p>Extract microseconds from underlying Datetime representation.  Applies to Datetime columns.</p>"},{"location":"reference/ExprDT_microsecond/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_microsecond/#value","title":"Value","text":"<p>Expr of microsecond as Int64</p>"},{"location":"reference/ExprDT_microsecond/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(date = pl$date_range(\nas.numeric(as.POSIXct(\"2001-1-1\"))*1E6+456789, #manually convert to us\nas.numeric(as.POSIXct(\"2001-1-1 00:00:6\"))*1E6,\ninterval = \"2s654321us\",\ntime_unit = \"us\" #instruct polars input is us, and store as us\n))$with_columns(\npl$col(\"date\")$cast(pl$Int64)$alias(\"datetime int64\"),\npl$col(\"date\")$dt$microsecond()$alias(\"microsecond\")\n)\n</code></pre>"},{"location":"reference/ExprDT_microseconds/","title":"<code>ExprDT_microseconds</code>","text":"<p>microseconds</p>"},{"location":"reference/ExprDT_microseconds/#description","title":"Description","text":"<p>Extract the microseconds from a Duration type.</p>"},{"location":"reference/ExprDT_microseconds/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_microseconds/#value","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/ExprDT_microseconds/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(date = pl$date_range(\nlow = as.POSIXct(\"2020-1-1\", tz = \"GMT\"),\nhigh = as.POSIXct(\"2020-1-1 00:00:01\", tz = \"GMT\"),\ninterval = \"1ms\"\n))\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$diff()$dt$microseconds()$alias(\"seconds_diff\")\n)\n</code></pre>"},{"location":"reference/ExprDT_millisecond/","title":"<code>ExprDT_millisecond</code>","text":"<p>Millisecond</p>"},{"location":"reference/ExprDT_millisecond/#description","title":"Description","text":"<p>Extract milliseconds from underlying Datetime representation.  Applies to Datetime columns.</p>"},{"location":"reference/ExprDT_millisecond/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_millisecond/#value","title":"Value","text":"<p>Expr of millisecond as Int64</p>"},{"location":"reference/ExprDT_millisecond/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(date = pl$date_range(\nas.numeric(as.POSIXct(\"2001-1-1\"))*1E6+456789, #manually convert to us\nas.numeric(as.POSIXct(\"2001-1-1 00:00:6\"))*1E6,\ninterval = \"2s654321us\",\ntime_unit = \"us\" #instruct polars input is us, and store as us\n))$with_columns(\npl$col(\"date\")$cast(pl$Int64)$alias(\"datetime int64\"),\npl$col(\"date\")$dt$millisecond()$alias(\"millisecond\")\n)\n</code></pre>"},{"location":"reference/ExprDT_milliseconds/","title":"<code>ExprDT_milliseconds</code>","text":"<p>milliseconds</p>"},{"location":"reference/ExprDT_milliseconds/#description","title":"Description","text":"<p>Extract the milliseconds from a Duration type.</p>"},{"location":"reference/ExprDT_milliseconds/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_milliseconds/#value","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/ExprDT_milliseconds/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(date = pl$date_range(\nlow = as.POSIXct(\"2020-1-1\", tz = \"GMT\"),\nhigh = as.POSIXct(\"2020-1-1 00:00:01\", tz = \"GMT\"),\ninterval = \"1ms\"\n))\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$diff()$dt$milliseconds()$alias(\"seconds_diff\")\n)\n</code></pre>"},{"location":"reference/ExprDT_minute/","title":"<code>ExprDT_minute</code>","text":"<p>Minute</p>"},{"location":"reference/ExprDT_minute/#description","title":"Description","text":"<p>Extract minutes from underlying Datetime representation.  Applies to Datetime columns.  Returns the minute number from 0 to 59.</p>"},{"location":"reference/ExprDT_minute/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_minute/#value","title":"Value","text":"<p>Expr of minute as UInt32</p>"},{"location":"reference/ExprDT_minute/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$minute()$alias(\"minute\")\n)\n</code></pre>"},{"location":"reference/ExprDT_minutes/","title":"<code>ExprDT_minutes</code>","text":"<p>Minutes</p>"},{"location":"reference/ExprDT_minutes/#description","title":"Description","text":"<p>Extract the minutes from a Duration type.</p>"},{"location":"reference/ExprDT_minutes/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_minutes/#value","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/ExprDT_minutes/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2020-1-1\"), high = as.Date(\"2020-1-4\"), interval = \"1d\")\n)\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$diff()$dt$minutes()$alias(\"minutes_diff\")\n)\n</code></pre>"},{"location":"reference/ExprDT_month/","title":"<code>ExprDT_month</code>","text":"<p>Month</p>"},{"location":"reference/ExprDT_month/#description","title":"Description","text":"<p>Extract month from underlying Date representation.  Applies to Date and Datetime columns.  Returns the month number starting from 1.  The return value ranges from 1 to 12.</p>"},{"location":"reference/ExprDT_month/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_month/#value","title":"Value","text":"<p>Expr of month as UInt32</p>"},{"location":"reference/ExprDT_month/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$month()$alias(\"month\")\n)\n</code></pre>"},{"location":"reference/ExprDT_nanosecond/","title":"<code>ExprDT_nanosecond</code>","text":"<p>Nanosecond</p>"},{"location":"reference/ExprDT_nanosecond/#description","title":"Description","text":"<p>Extract seconds from underlying Datetime representation.  Applies to Datetime columns.  Returns the integer second number from 0 to 59, or a floating  point number from 0 &lt; 60 if <code>fractional=True</code> that includes  any milli/micro/nanosecond component.</p>"},{"location":"reference/ExprDT_nanosecond/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_nanosecond/#value","title":"Value","text":"<p>Expr of second as Int64</p>"},{"location":"reference/ExprDT_nanosecond/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(date = pl$date_range(\nas.numeric(as.POSIXct(\"2001-1-1\"))*1E9+123456789, #manually convert to us\nas.numeric(as.POSIXct(\"2001-1-1 00:00:6\"))*1E9,\ninterval = \"1s987654321ns\",\ntime_unit = \"ns\" #instruct polars input is us, and store as us\n))$with_columns(\npl$col(\"date\")$cast(pl$Int64)$alias(\"datetime int64\"),\npl$col(\"date\")$dt$nanosecond()$alias(\"nanosecond\")\n)\n</code></pre>"},{"location":"reference/ExprDT_nanoseconds/","title":"<code>ExprDT_nanoseconds</code>","text":"<p>nanoseconds</p>"},{"location":"reference/ExprDT_nanoseconds/#description","title":"Description","text":"<p>Extract the nanoseconds from a Duration type.</p>"},{"location":"reference/ExprDT_nanoseconds/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_nanoseconds/#value","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/ExprDT_nanoseconds/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(date = pl$date_range(\nlow = as.POSIXct(\"2020-1-1\", tz = \"GMT\"),\nhigh = as.POSIXct(\"2020-1-1 00:00:01\", tz = \"GMT\"),\ninterval = \"1ms\"\n))\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$diff()$dt$nanoseconds()$alias(\"seconds_diff\")\n)\n</code></pre>"},{"location":"reference/ExprDT_offset_by/","title":"<code>ExprDT_offset_by</code>","text":"<p>Offset By</p>"},{"location":"reference/ExprDT_offset_by/#description","title":"Description","text":"<p>Offset this date by a relative time offset.  This differs from <code>pl$col(\"foo_datetime_tu\") + value_tu</code> in that it can  take months and leap years into account. Note that only a single minus  sign is allowed in the <code>by</code> string, as the first character.</p>"},{"location":"reference/ExprDT_offset_by/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_offset_by/#arguments","title":"Arguments","text":"Argument Description <code>by</code> optional string encoding duration see details."},{"location":"reference/ExprDT_offset_by/#details","title":"Details","text":"<p>The <code>by</code> are created with the the following string language:</p> <ul> <li> <p>1ns # 1 nanosecond </p> </li> <li> <p>1us # 1 microsecond </p> </li> <li> <p>1ms # 1 millisecond </p> </li> <li> <p>1s  # 1 second </p> </li> <li> <p>1m  # 1 minute </p> </li> <li> <p>1h  # 1 hour </p> </li> <li> <p>1d  # 1 day </p> </li> <li> <p>1w  # 1 calendar week </p> </li> <li> <p>1mo # 1 calendar month </p> </li> <li> <p>1y  # 1 calendar year </p> </li> <li> <p>1i  # 1 index count </p> </li> </ul> <p>These strings can be combined:</p> <ul> <li>3d12h4m25s # 3 days, 12 hours, 4 minutes, and 25 seconds</li> </ul>"},{"location":"reference/ExprDT_offset_by/#value","title":"Value","text":"<p>Date/Datetime expr</p>"},{"location":"reference/ExprDT_offset_by/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndates = pl$date_range(as.Date(\"2000-1-1\"),as.Date(\"2005-1-1\"), \"1y\")\n)\ndf$select(\npl$col(\"dates\")$dt$offset_by(\"1y\")$alias(\"date_plus_1y\"),\npl$col(\"dates\")$dt$offset_by(\"-1y2mo\")$alias(\"date_min\")\n)\n</code></pre>"},{"location":"reference/ExprDT_ordinal_day/","title":"<code>ExprDT_ordinal_day</code>","text":"<p>Ordinal Day</p>"},{"location":"reference/ExprDT_ordinal_day/#description","title":"Description","text":"<p>Extract ordinal day from underlying Date representation.  Applies to Date and Datetime columns.  Returns the day of year starting from 1.  The return value ranges from 1 to 366. (The last day of year differs by years.)</p>"},{"location":"reference/ExprDT_ordinal_day/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_ordinal_day/#value","title":"Value","text":"<p>Expr of ordinal_day as UInt32</p>"},{"location":"reference/ExprDT_ordinal_day/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$ordinal_day()$alias(\"ordinal_day\")\n)\n</code></pre>"},{"location":"reference/ExprDT_quarter/","title":"<code>ExprDT_quarter</code>","text":"<p>Quarter</p>"},{"location":"reference/ExprDT_quarter/#description","title":"Description","text":"<p>Extract quarter from underlying Date representation.  Applies to Date and Datetime columns.  Returns the quarter ranging from 1 to 4.</p>"},{"location":"reference/ExprDT_quarter/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_quarter/#value","title":"Value","text":"<p>Expr of quater as UInt32</p>"},{"location":"reference/ExprDT_quarter/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$quarter()$alias(\"quarter\")\n)\n</code></pre>"},{"location":"reference/ExprDT_replace_time_zone/","title":"<code>ExprDT_replace_time_zone</code>","text":"<p>replace_time_zone</p>"},{"location":"reference/ExprDT_replace_time_zone/#description","title":"Description","text":"<p>Cast time zone for a Series of type Datetime.  Different from <code>convert_time_zone</code> , this will also modify the underlying timestamp.  Use to correct a wrong time zone annotation. This will change the corresponding global timepoint.</p>"},{"location":"reference/ExprDT_replace_time_zone/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_replace_time_zone/#arguments","title":"Arguments","text":"Argument Description <code>tz</code> Null or string time zone from base::OlsonNames()"},{"location":"reference/ExprDT_replace_time_zone/#value","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/ExprDT_replace_time_zone/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2001-3-1\"), high = as.Date(\"2001-7-1\"), interval = \"1mo\")\n)\ndf = df$with_columns(\npl$col(\"date\")\n$dt$replace_time_zone(\"Europe/Amsterdam\")\n$dt$convert_time_zone(\"Europe/London\")\n$alias(\"london_timezone\")\n)\ndf2 = df$with_columns(\npl$col(\"london_timezone\")\n$dt$replace_time_zone(\"Europe/Amsterdam\")\n$alias(\"cast London_to_Amsterdam\"),\npl$col(\"london_timezone\")\n$dt$convert_time_zone(\"Europe/Amsterdam\")\n$alias(\"with London_to_Amsterdam\"),\npl$col(\"london_timezone\")\n$dt$convert_time_zone(\"Europe/Amsterdam\")\n$dt$replace_time_zone(NULL)\n$alias(\"strip tz from with-'Europe/Amsterdam'\")\n)\ndf2\n</code></pre>"},{"location":"reference/ExprDT_round/","title":"<code>ExprDT_round</code>","text":"<p>Round datetime</p>"},{"location":"reference/ExprDT_round/#description","title":"Description","text":"<p>Divide the date/datetime range into buckets.  Each date/datetime in the first half of the interval  is mapped to the start of its bucket.  Each date/datetime in the second half of the interval  is mapped to the end of its bucket.</p>"},{"location":"reference/ExprDT_round/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_round/#arguments","title":"Arguments","text":"Argument Description <code>every</code> string encoding duration see details. <code>ofset</code> optional string encoding duration see details."},{"location":"reference/ExprDT_round/#details","title":"Details","text":"<p>The <code>every</code> and <code>offset</code> argument are created with the  the following string language:</p> <ul> <li> <p>1ns # 1 nanosecond </p> </li> <li> <p>1us # 1 microsecond </p> </li> <li> <p>1ms # 1 millisecond </p> </li> <li> <p>1s  # 1 second </p> </li> <li> <p>1m  # 1 minute </p> </li> <li> <p>1h  # 1 hour </p> </li> <li> <p>1d  # 1 day </p> </li> <li> <p>1w  # 1 calendar week </p> </li> <li> <p>1mo # 1 calendar month </p> </li> <li> <p>1y  # 1 calendar year These strings can be combined:  </p> </li> <li> <p>3d12h4m25s # 3 days, 12 hours, 4 minutes, and 25 seconds  </p> </li> </ul> <p>This functionality is currently experimental and may  change without it being considered a breaking change.</p>"},{"location":"reference/ExprDT_round/#value","title":"Value","text":"<p>Date/Datetime expr</p>"},{"location":"reference/ExprDT_round/#examples","title":"Examples","text":"<pre><code>t1 = as.POSIXct(\"3040-01-01\",tz = \"GMT\")\nt2 = t1 + as.difftime(25,units = \"secs\")\ns = pl$date_range(t1, t2, interval = \"2s\", time_unit = \"ms\")\n#use a dt namespace function\ndf = pl$DataFrame(datetime = s)$with_columns(\npl$col(\"datetime\")$dt$truncate(\"4s\")$alias(\"truncated_4s\"),\npl$col(\"datetime\")$dt$truncate(\"4s\",offset(\"3s\"))$alias(\"truncated_4s_offset_2s\")\n)\ndf\n</code></pre>"},{"location":"reference/ExprDT_second/","title":"<code>ExprDT_second</code>","text":"<p>Second</p>"},{"location":"reference/ExprDT_second/#description","title":"Description","text":"<p>Extract seconds from underlying Datetime representation.  Applies to Datetime columns.  Returns the integer second number from 0 to 59, or a floating  point number from 0 &lt; 60 if <code>fractional=True</code> that includes  any milli/micro/nanosecond component.</p>"},{"location":"reference/ExprDT_second/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_second/#value","title":"Value","text":"<p>Expr of second as UInt32</p>"},{"location":"reference/ExprDT_second/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(date = pl$date_range(\nas.numeric(as.POSIXct(\"2001-1-1\"))*1E6+456789, #manually convert to us\nas.numeric(as.POSIXct(\"2001-1-1 00:00:6\"))*1E6,\ninterval = \"2s654321us\",\ntime_unit = \"us\" #instruct polars input is us, and store as us\n))$with_columns(\npl$col(\"date\")$dt$second()$alias(\"second\"),\npl$col(\"date\")$dt$second(fractional = TRUE)$alias(\"second_frac\")\n)\n</code></pre>"},{"location":"reference/ExprDT_seconds/","title":"<code>ExprDT_seconds</code>","text":"<p>Seconds</p>"},{"location":"reference/ExprDT_seconds/#description","title":"Description","text":"<p>Extract the seconds from a Duration type.</p>"},{"location":"reference/ExprDT_seconds/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_seconds/#value","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/ExprDT_seconds/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(date = pl$date_range(\nlow = as.POSIXct(\"2020-1-1\", tz = \"GMT\"),\nhigh = as.POSIXct(\"2020-1-1 00:04:00\", tz = \"GMT\"),\ninterval = \"1m\"\n))\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$diff()$dt$seconds()$alias(\"seconds_diff\")\n)\n</code></pre>"},{"location":"reference/ExprDT_strftime/","title":"<code>ExprDT_strftime</code>","text":"<p>strftime</p>"},{"location":"reference/ExprDT_strftime/#description","title":"Description","text":"<p>Format Date/Datetime with a formatting rule.  See chrono strftime/strptime https://docs.rs/chrono/latest/chrono/format/strftime/index.html _.</p>"},{"location":"reference/ExprDT_strftime/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_strftime/#arguments","title":"Arguments","text":"Argument Description <code>fmt</code> string format very much like in R passed to chrono"},{"location":"reference/ExprDT_strftime/#value","title":"Value","text":"<p>Date/Datetime expr</p>"},{"location":"reference/ExprDT_strftime/#examples","title":"Examples","text":"<pre><code>pl$lit(as.POSIXct(\"2021-01-02 12:13:14\",tz=\"GMT\"))$dt$strftime(\"this is the year: %Y\")$to_r()\n</code></pre>"},{"location":"reference/ExprDT_timestamp/","title":"<code>ExprDT_timestamp</code>","text":"<p>timestamp</p>"},{"location":"reference/ExprDT_timestamp/#description","title":"Description","text":"<p>Return a timestamp in the given time unit.</p>"},{"location":"reference/ExprDT_timestamp/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_timestamp/#arguments","title":"Arguments","text":"Argument Description <code>tu</code> string option either 'ns', 'us', or 'ms'"},{"location":"reference/ExprDT_timestamp/#value","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/ExprDT_timestamp/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2001-1-1\"), high = as.Date(\"2001-1-3\"), interval = \"1d\")\n)\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$dt$timestamp()$alias(\"timestamp_ns\"),\npl$col(\"date\")$dt$timestamp(tu=\"ms\")$alias(\"timestamp_ms\")\n)\n</code></pre>"},{"location":"reference/ExprDT_truncate/","title":"<code>ExprDT_truncate</code>","text":"<p>Truncate datetime</p>"},{"location":"reference/ExprDT_truncate/#description","title":"Description","text":"<p>Divide the date/datetime range into buckets.  Each date/datetime is mapped to the start of its bucket.</p>"},{"location":"reference/ExprDT_truncate/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_truncate/#arguments","title":"Arguments","text":"Argument Description <code>every</code> string encoding duration see details. <code>ofset</code> optional string encoding duration see details."},{"location":"reference/ExprDT_truncate/#details","title":"Details","text":"<p>The <code>every</code> and <code>offset</code> argument are created with the  the following string language:</p> <ul> <li> <p>1ns # 1 nanosecond </p> </li> <li> <p>1us # 1 microsecond </p> </li> <li> <p>1ms # 1 millisecond </p> </li> <li> <p>1s  # 1 second </p> </li> <li> <p>1m  # 1 minute </p> </li> <li> <p>1h  # 1 hour </p> </li> <li> <p>1d  # 1 day </p> </li> <li> <p>1w  # 1 calendar week </p> </li> <li> <p>1mo # 1 calendar month </p> </li> <li> <p>1y  # 1 calendar year These strings can be combined:  </p> </li> <li> <p>3d12h4m25s # 3 days, 12 hours, 4 minutes, and 25 seconds</p> </li> </ul>"},{"location":"reference/ExprDT_truncate/#value","title":"Value","text":"<p>Date/Datetime expr</p>"},{"location":"reference/ExprDT_truncate/#examples","title":"Examples","text":"<pre><code>t1 = as.POSIXct(\"3040-01-01\",tz = \"GMT\")\nt2 = t1 + as.difftime(25,units = \"secs\")\ns = pl$date_range(t1, t2, interval = \"2s\", time_unit = \"ms\")\n#use a dt namespace function\ndf = pl$DataFrame(datetime = s)$with_columns(\npl$col(\"datetime\")$dt$truncate(\"4s\")$alias(\"truncated_4s\"),\npl$col(\"datetime\")$dt$truncate(\"4s\",offset(\"3s\"))$alias(\"truncated_4s_offset_2s\")\n)\ndf\n</code></pre>"},{"location":"reference/ExprDT_tz_localize/","title":"<code>ExprDT_tz_localize</code>","text":"<p>Localize time zone</p>"},{"location":"reference/ExprDT_tz_localize/#description","title":"Description","text":"<p>Localize tz-naive Datetime Series to tz-aware Datetime Series.  This method takes a naive Datetime Series and makes this time zone aware.  It does not move the time to another time zone.</p>"},{"location":"reference/ExprDT_tz_localize/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_tz_localize/#arguments","title":"Arguments","text":"Argument Description <code>tz</code> string of time zone (no NULL allowed) see allowed timezone in base::OlsonNames()"},{"location":"reference/ExprDT_tz_localize/#details","title":"Details","text":"<p>In R as modifying tzone attribute manually but takes into account summertime.  See unittest \"dt$convert_time_zone dt$tz_localize\" for a more detailed comparison to base R.</p>"},{"location":"reference/ExprDT_tz_localize/#value","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/ExprDT_tz_localize/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2001-3-1\"), high = as.Date(\"2001-7-1\"), interval = \"1mo\")\n)\ndf = df$with_columns(\npl$col(\"date\")\n$dt$replace_time_zone(\"Europe/Amsterdam\")\n$dt$convert_time_zone(\"Europe/London\")\n$alias(\"london_timezone\"),\npl$col(\"date\")\n$dt$tz_localize(\"Europe/London\")\n$alias(\"tz_loc_london\")\n)\ndf2 = df$with_columns(\npl$col(\"london_timezone\")\n$dt$replace_time_zone(\"Europe/Amsterdam\")\n$alias(\"cast London_to_Amsterdam\"),\npl$col(\"london_timezone\")\n$dt$convert_time_zone(\"Europe/Amsterdam\")\n$alias(\"with London_to_Amsterdam\"),\npl$col(\"london_timezone\")\n$dt$convert_time_zone(\"Europe/Amsterdam\")\n$dt$replace_time_zone(NULL)\n$alias(\"strip tz from with-'Europe/Amsterdam'\")\n)\ndf2\n</code></pre>"},{"location":"reference/ExprDT_week/","title":"<code>ExprDT_week</code>","text":"<p>Week</p>"},{"location":"reference/ExprDT_week/#description","title":"Description","text":"<p>Extract the week from the underlying Date representation.  Applies to Date and Datetime columns.  Returns the ISO week number starting from 1.  The return value ranges from 1 to 53. (The last week of year differs by years.)</p>"},{"location":"reference/ExprDT_week/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_week/#value","title":"Value","text":"<p>Expr of week as UInt32</p>"},{"location":"reference/ExprDT_week/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$week()$alias(\"week\")\n)\n</code></pre>"},{"location":"reference/ExprDT_weekday/","title":"<code>ExprDT_weekday</code>","text":"<p>Weekday</p>"},{"location":"reference/ExprDT_weekday/#description","title":"Description","text":"<p>Extract the week day from the underlying Date representation.  Applies to Date and Datetime columns.  Returns the ISO weekday number where monday = 1 and sunday = 7</p>"},{"location":"reference/ExprDT_weekday/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_weekday/#value","title":"Value","text":"<p>Expr of weekday as UInt32</p>"},{"location":"reference/ExprDT_weekday/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$weekday()$alias(\"weekday\")\n)\n</code></pre>"},{"location":"reference/ExprDT_with_time_unit/","title":"<code>ExprDT_with_time_unit</code>","text":"<p>with_time_unit</p>"},{"location":"reference/ExprDT_with_time_unit/#description","title":"Description","text":"<p>Set time unit of a Series of dtype Datetime or Duration.  This does not modify underlying data, and should be used to fix an incorrect time unit.  The corresponding global timepoint will change.</p>"},{"location":"reference/ExprDT_with_time_unit/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_with_time_unit/#arguments","title":"Arguments","text":"Argument Description <code>tu</code> string option either 'ns', 'us', or 'ms'"},{"location":"reference/ExprDT_with_time_unit/#value","title":"Value","text":"<p>Expr of i64</p>"},{"location":"reference/ExprDT_with_time_unit/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(low = as.Date(\"2001-1-1\"), high = as.Date(\"2001-1-3\"), interval = \"1d\")\n)\ndf$select(\npl$col(\"date\"),\npl$col(\"date\")$dt$with_time_unit()$alias(\"with_time_unit_ns\"),\npl$col(\"date\")$dt$with_time_unit(tu=\"ms\")$alias(\"with_time_unit_ms\")\n)\n</code></pre>"},{"location":"reference/ExprDT_year/","title":"<code>ExprDT_year</code>","text":"<p>Year</p>"},{"location":"reference/ExprDT_year/#description","title":"Description","text":"<p>Extract year from underlying Date representation.  Applies to Date and Datetime columns.  Returns the year number in the calendar date.</p>"},{"location":"reference/ExprDT_year/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprDT_year/#value","title":"Value","text":"<p>Expr of Year as Int32</p>"},{"location":"reference/ExprDT_year/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\ndate = pl$date_range(\nas.Date(\"2020-12-25\"),\nas.Date(\"2021-1-05\"),\ninterval = \"1d\",\ntime_zone = \"GMT\"\n)\n)\ndf$with_columns(\npl$col(\"date\")$dt$year()$alias(\"year\"),\npl$col(\"date\")$dt$iso_year()$alias(\"iso_year\")\n)\n</code></pre>"},{"location":"reference/ExprMeta_eq/","title":"<code>ExprMeta_eq</code>","text":"<p>Meta Equal</p>"},{"location":"reference/ExprMeta_eq/#description","title":"Description","text":"<p>Are two expressions on a meta level equal</p>"},{"location":"reference/ExprMeta_eq/#arguments","title":"Arguments","text":"Argument Description <code>other</code> Expr to compare with"},{"location":"reference/ExprMeta_eq/#value","title":"Value","text":"<p>bool: TRUE if equal</p>"},{"location":"reference/ExprMeta_eq/#examples","title":"Examples","text":"<pre><code>#three naive expression literals\ne1 = pl$lit(40) + 2\ne2 = pl$lit(42)\ne3 = pl$lit(40) +2\n#e1 and e3 are identical expressions\ne1$meta$eq(e3)\n#e_test is an expression testing whether e1 and e2 evaluates to the same value.\ne_test = e1 == e2 # or e_test = e1$eq(e2)\n#direct evaluate e_test, possible because only made up of literals\ne_test$to_r()\n#e1 and e2 are on the meta-level NOT identical expressions\ne1$meta$neq(e2)\n</code></pre>"},{"location":"reference/ExprMeta_has_multiple_outputs/","title":"<code>ExprMeta_has_multiple_outputs</code>","text":"<p>Has multiple outputs</p>"},{"location":"reference/ExprMeta_has_multiple_outputs/#description","title":"Description","text":"<p>Whether this expression expands into multiple expressions.</p>"},{"location":"reference/ExprMeta_has_multiple_outputs/#value","title":"Value","text":"<p>Bool</p>"},{"location":"reference/ExprMeta_has_multiple_outputs/#examples","title":"Examples","text":"<pre><code>pl$all()$meta$has_multiple_outputs()\npl$col(\"some_colname\")$meta$has_multiple_outputs()\n</code></pre>"},{"location":"reference/ExprMeta_is_regex_projection/","title":"<code>ExprMeta_is_regex_projection</code>","text":"<p>Is regex projecion.</p>"},{"location":"reference/ExprMeta_is_regex_projection/#description","title":"Description","text":"<p>Whether this expression expands to columns that match a regex pattern.</p>"},{"location":"reference/ExprMeta_is_regex_projection/#value","title":"Value","text":"<p>Bool</p>"},{"location":"reference/ExprMeta_is_regex_projection/#examples","title":"Examples","text":"<pre><code>pl$col(\"^Sepal.*$\")$meta$is_regex_projection()\npl$col(\"Sepal.Length\")$meta$is_regex_projection()\n</code></pre>"},{"location":"reference/ExprMeta_neq/","title":"<code>ExprMeta_neq</code>","text":"<p>Meta Not Equal</p>"},{"location":"reference/ExprMeta_neq/#description","title":"Description","text":"<p>Are two expressions on a meta level NOT equal</p>"},{"location":"reference/ExprMeta_neq/#arguments","title":"Arguments","text":"Argument Description <code>other</code> Expr to compare with"},{"location":"reference/ExprMeta_neq/#value","title":"Value","text":"<p>bool: TRUE if NOT equal</p>"},{"location":"reference/ExprMeta_neq/#examples","title":"Examples","text":"<pre><code>#three naive expression literals\ne1 = pl$lit(40) + 2\ne2 = pl$lit(42)\ne3 = pl$lit(40) +2\n#e1 and e3 are identical expressions\ne1$meta$eq(e3)\n#e_test is an expression testing whether e1 and e2 evaluates to the same value.\ne_test = e1 == e2 # or e_test = e1$eq(e2)\n#direct evaluate e_test, possible because only made up of literals\ne_test$to_r()\n#e1 and e2 are on the meta-level NOT identical expressions\ne1$meta$neq(e2)\n</code></pre>"},{"location":"reference/ExprMeta_output_name/","title":"<code>ExprMeta_output_name</code>","text":"<p>Output Name</p>"},{"location":"reference/ExprMeta_output_name/#description","title":"Description","text":"<p>Get the column name that this expression would produce.  It might not always be possible to determine the output name  as it might depend on the schema of the context. In that case  this will raise an error.</p>"},{"location":"reference/ExprMeta_output_name/#value","title":"Value","text":"<p>R charvec of output names.</p>"},{"location":"reference/ExprMeta_output_name/#examples","title":"Examples","text":"<pre><code>e = pl$col(\"alice\")$alias(\"bob\")\ne$meta$root_names() == \"alice\"\ne$meta$output_name() == \"bob\"\ne$meta$undo_aliases()$meta$output_name() == \"alice\"\n</code></pre>"},{"location":"reference/ExprMeta_pop/","title":"<code>ExprMeta_pop</code>","text":"<p>Pop</p>"},{"location":"reference/ExprMeta_pop/#description","title":"Description","text":"<p>Pop the latest expression and return the input(s) of the popped expression.</p>"},{"location":"reference/ExprMeta_pop/#value","title":"Value","text":"<p>R list of Expr(s) usually one, only multiple if top Expr took more Expr as input.</p>"},{"location":"reference/ExprMeta_pop/#examples","title":"Examples","text":"<pre><code>e1 = pl$lit(40) + 2\ne2 = pl$lit(42)$sum()\ne1\ne1$meta$pop()\ne2\ne2$meta$pop()\n</code></pre>"},{"location":"reference/ExprMeta_root_names/","title":"<code>ExprMeta_root_names</code>","text":"<p>Root Name</p>"},{"location":"reference/ExprMeta_root_names/#description","title":"Description","text":"<p>Get a vector with the root column name</p>"},{"location":"reference/ExprMeta_root_names/#value","title":"Value","text":"<p>R charvec of root names.</p>"},{"location":"reference/ExprMeta_root_names/#examples","title":"Examples","text":"<pre><code>e = pl$col(\"alice\")$alias(\"bob\")\ne$meta$root_names() == \"alice\"\ne$meta$output_name() == \"bob\"\ne$meta$undo_aliases()$meta$output_name() == \"alice\"\n</code></pre>"},{"location":"reference/ExprMeta_undo_aliases/","title":"<code>ExprMeta_undo_aliases</code>","text":"<p>Undo aliases</p>"},{"location":"reference/ExprMeta_undo_aliases/#description","title":"Description","text":"<p>Undo any renaming operation like <code>alias</code> or <code>keep_name</code> .</p>"},{"location":"reference/ExprMeta_undo_aliases/#value","title":"Value","text":"<p>Expr with aliases undone</p>"},{"location":"reference/ExprMeta_undo_aliases/#examples","title":"Examples","text":"<pre><code>e = pl$col(\"alice\")$alias(\"bob\")\ne$meta$root_names() == \"alice\"\ne$meta$output_name() == \"bob\"\ne$meta$undo_aliases()$meta$output_name() == \"alice\"\n</code></pre>"},{"location":"reference/ExprStr_concat/","title":"<code>ExprStr_concat</code>","text":"<p>Concat</p>"},{"location":"reference/ExprStr_concat/#description","title":"Description","text":"<p>Vertically concat the values in the Series to a single string value.</p>"},{"location":"reference/ExprStr_concat/#arguments","title":"Arguments","text":"Argument Description <code>delimiter</code> string The delimiter to insert between consecutive string values."},{"location":"reference/ExprStr_concat/#value","title":"Value","text":"<p>Expr of Utf8 concatenated</p>"},{"location":"reference/ExprStr_concat/#examples","title":"Examples","text":"<pre><code>#concatenate a Series of strings to a single string\ndf = pl$DataFrame(foo = c(\"1\", NA, 2))\ndf$select(pl$col(\"foo\")$str$concat(\"-\"))\n#Series list of strings to Series of concatenated strings\ndf = pl$DataFrame(list(bar = list(c(\"a\",\"b\", \"c\"), c(\"1\",\"2\",NA))))\ndf$select(pl$col(\"bar\")$arr$eval(pl$col()$str$concat())$arr$first())\n</code></pre>"},{"location":"reference/ExprStr_contains/","title":"<code>ExprStr_contains</code>","text":"<p>contains</p>"},{"location":"reference/ExprStr_contains/#description","title":"Description","text":"<p>R Check if string contains a substring that matches a regex.</p>"},{"location":"reference/ExprStr_contains/#arguments","title":"Arguments","text":"Argument Description <code>pattern</code> String or Expr of a string, a valid regex pattern. <code>literal</code> bool, treat pattern as a literal string. NULL is aliased with FALSE. <code>strict</code> bool, raise an error if the underlying pattern is not a valid regex expression, otherwise mask out with a null value."},{"location":"reference/ExprStr_contains/#details","title":"Details","text":"<p>starts_with : Check if string values start with a substring.  ends_with : Check if string values end with a substring.</p>"},{"location":"reference/ExprStr_contains/#value","title":"Value","text":"<p>Expr returning a Boolean</p>"},{"location":"reference/ExprStr_contains/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(a = c(\"Crab\", \"cat and dog\", \"rab$bit\", NA))\ndf$select(\npl$col(\"a\"),\npl$col(\"a\")$str$contains(\"cat|bit\")$alias(\"regex\"),\npl$col(\"a\")$str$contains(\"rab$\", literal=TRUE)$alias(\"literal\")\n)\n</code></pre>"},{"location":"reference/ExprStr_count_match/","title":"<code>ExprStr_count_match</code>","text":"<p>count_match</p>"},{"location":"reference/ExprStr_count_match/#description","title":"Description","text":"<p>Count all successive non-overlapping regex matches.</p>"},{"location":"reference/ExprStr_count_match/#arguments","title":"Arguments","text":"Argument Description <code>pattern</code> A valid regex pattern"},{"location":"reference/ExprStr_count_match/#value","title":"Value","text":"<p>UInt32 array. Contain null if original value is null or regex capture nothing.</p>"},{"location":"reference/ExprStr_count_match/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame( foo = c(\"123 bla 45 asd\", \"xyz 678 910t\"))\ndf$select(\npl$col(\"foo\")$str$count_match(r\"{(\\d)}\")$alias(\"count digits\")\n)\n</code></pre>"},{"location":"reference/ExprStr_decode/","title":"<code>ExprStr_decode</code>","text":"<p>decode</p>"},{"location":"reference/ExprStr_decode/#description","title":"Description","text":"<p>Decode a value using the provided encoding.</p>"},{"location":"reference/ExprStr_decode/#arguments","title":"Arguments","text":"Argument Description <code>encoding</code> string choice either 'hex' or 'base64' <code>...</code> not used currently <code>strict</code> Raise an error if the underlying value cannot be decoded, otherwise mask out with a null value."},{"location":"reference/ExprStr_decode/#value","title":"Value","text":"<p>Utf8 array with values decoded using provided encoding</p>"},{"location":"reference/ExprStr_decode/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame( strings = c(\"foo\", \"bar\", NA))\ndf$select(pl$col(\"strings\")$str$encode(\"hex\"))\ndf$with_columns(\npl$col(\"strings\")$str$encode(\"base64\")$alias(\"base64\"), #notice DataType is not encoded\npl$col(\"strings\")$str$encode(\"hex\")$alias(\"hex\")       #... and must restored with cast\n)$with_columns(\npl$col(\"base64\")$str$decode(\"base64\")$alias(\"base64_decoded\")$cast(pl$Utf8),\npl$col(\"hex\")$str$decode(\"hex\")$alias(\"hex_decoded\")$cast(pl$Utf8)\n)\n</code></pre>"},{"location":"reference/ExprStr_encode/","title":"<code>ExprStr_encode</code>","text":"<p>encode</p>"},{"location":"reference/ExprStr_encode/#description","title":"Description","text":"<p>Encode a value using the provided encoding.</p>"},{"location":"reference/ExprStr_encode/#arguments","title":"Arguments","text":"Argument Description <code>encoding</code> string choice either 'hex' or 'base64'"},{"location":"reference/ExprStr_encode/#value","title":"Value","text":"<p>Utf8 array with values encoded using provided encoding</p>"},{"location":"reference/ExprStr_encode/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame( strings = c(\"foo\", \"bar\", NA))\ndf$select(pl$col(\"strings\")$str$encode(\"hex\"))\ndf$with_columns(\npl$col(\"strings\")$str$encode(\"base64\")$alias(\"base64\"), #notice DataType is not encoded\npl$col(\"strings\")$str$encode(\"hex\")$alias(\"hex\")       #... and must restored with cast\n)$with_columns(\npl$col(\"base64\")$str$decode(\"base64\")$alias(\"base64_decoded\")$cast(pl$Utf8),\npl$col(\"hex\")$str$decode(\"hex\")$alias(\"hex_decoded\")$cast(pl$Utf8)\n)\n</code></pre>"},{"location":"reference/ExprStr_ends_with/","title":"<code>ExprStr_ends_with</code>","text":"<p>ends_with</p>"},{"location":"reference/ExprStr_ends_with/#description","title":"Description","text":"<p>Check if string values end with a substring.</p>"},{"location":"reference/ExprStr_ends_with/#arguments","title":"Arguments","text":"Argument Description <code>sub</code> Suffix substring or Expr."},{"location":"reference/ExprStr_ends_with/#details","title":"Details","text":"<p>contains : Check if string contains a substring that matches a regex.  starts_with : Check if string values start with a substring.</p>"},{"location":"reference/ExprStr_ends_with/#value","title":"Value","text":"<p>Expr returning a Boolean</p>"},{"location":"reference/ExprStr_ends_with/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(fruits = c(\"apple\", \"mango\", NA))\ndf$select(\npl$col(\"fruits\"),\npl$col(\"fruits\")$str$ends_with(\"go\")$alias(\"has_suffix\")\n)\n</code></pre>"},{"location":"reference/ExprStr_explode/","title":"<code>ExprStr_explode</code>","text":"<p>explode</p>"},{"location":"reference/ExprStr_explode/#description","title":"Description","text":"<p>Returns a column with a separate row for every string character.</p>"},{"location":"reference/ExprStr_explode/#value","title":"Value","text":"<p>Expr: Series of dtype Utf8.</p>"},{"location":"reference/ExprStr_explode/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(a = c(\"foo\", \"bar\"))\ndf$select(pl$col(\"a\")$str$explode())\n</code></pre>"},{"location":"reference/ExprStr_extract/","title":"<code>ExprStr_extract</code>","text":"<p>extract</p>"},{"location":"reference/ExprStr_extract/#description","title":"Description","text":"<p>Extract the target capture group from provided patterns.</p>"},{"location":"reference/ExprStr_extract/#arguments","title":"Arguments","text":"Argument Description <code>pattern</code> A valid regex pattern <code>group_index</code> Index of the targeted capture group. Group 0 mean the whole pattern, first group begin at index 1. Default to the first capture group."},{"location":"reference/ExprStr_extract/#value","title":"Value","text":"<p>Utf8 array. Contain null if original value is null or regex capture nothing.</p>"},{"location":"reference/ExprStr_extract/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na =  c(\n\"http://vote.com/ballon_dor?candidate=messi&amp;ref=polars\",\n\"http://vote.com/ballon_dor?candidat=jorginho&amp;ref=polars\",\n\"http://vote.com/ballon_dor?candidate=ronaldo&amp;ref=polars\"\n)\n)\ndf$select(\npl$col(\"a\")$str$extract(r\"(candidate=(\\w+))\", 1)\n)\n</code></pre>"},{"location":"reference/ExprStr_extract_all/","title":"<code>ExprStr_extract_all</code>","text":"<p>extract_all</p>"},{"location":"reference/ExprStr_extract_all/#description","title":"Description","text":"<p>Extracts all matches for the given regex pattern. Extracts each successive  non-overlapping regex match in an individual string as an array.</p>"},{"location":"reference/ExprStr_extract_all/#arguments","title":"Arguments","text":"Argument Description <code>pattern</code> A valid regex pattern"},{"location":"reference/ExprStr_extract_all/#value","title":"Value","text":"<p><code>List[Utf8]</code> array. Contain null if original value is null or regex capture nothing.</p>"},{"location":"reference/ExprStr_extract_all/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame( foo = c(\"123 bla 45 asd\", \"xyz 678 910t\"))\ndf$select(\npl$col(\"foo\")$str$extract_all(r\"((\\d+))\")$alias(\"extracted_nrs\")\n)\n</code></pre>"},{"location":"reference/ExprStr_json_extract/","title":"<code>ExprStr_json_extract</code>","text":"<p>json_extract</p>"},{"location":"reference/ExprStr_json_extract/#description","title":"Description","text":"<p>Parse string values as JSON.</p>"},{"location":"reference/ExprStr_json_extract/#arguments","title":"Arguments","text":"Argument Description <code>dtype</code> The dtype to cast the extracted value to. If None, the dtype will be inferred from the JSON value."},{"location":"reference/ExprStr_json_extract/#details","title":"Details","text":"<p>Throw errors if encounter invalid json strings.</p>"},{"location":"reference/ExprStr_json_extract/#value","title":"Value","text":"<p>Expr returning a boolean</p>"},{"location":"reference/ExprStr_json_extract/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\njson_val =  c('{\"a\":1, \"b\": true}', NA, '{\"a\":2, \"b\": false}')\n)\ndtype = pl$Struct(pl$Field(\"a\", pl$Int64), pl$Field(\"b\", pl$Boolean))\ndf$select(pl$col(\"json_val\")$str$json_extract(dtype))\n</code></pre>"},{"location":"reference/ExprStr_json_path_match/","title":"<code>ExprStr_json_path_match</code>","text":"<p>json_path_match</p>"},{"location":"reference/ExprStr_json_path_match/#description","title":"Description","text":"<p>Extract the first match of json string with provided JSONPath expression.</p>"},{"location":"reference/ExprStr_json_path_match/#arguments","title":"Arguments","text":"Argument Description <code>json_path</code> A valid JSON path query string."},{"location":"reference/ExprStr_json_path_match/#details","title":"Details","text":"<p>Throw errors if encounter invalid json strings.  All return value will be casted to Utf8 regardless of the original value.  Documentation on JSONPath standard can be found  here https://goessner.net/articles/JsonPath/ _.</p>"},{"location":"reference/ExprStr_json_path_match/#value","title":"Value","text":"<p>Utf8 array. Contain null if original value is null or the json_path return nothing.</p>"},{"location":"reference/ExprStr_json_path_match/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\njson_val =  c('{\"a\":\"1\"}', NA, '{\"a\":2}', '{\"a\":2.1}', '{\"a\":true}')\n)\ndf$select(pl$col(\"json_val\")$str$json_path_match(\"$.a\"))\n</code></pre>"},{"location":"reference/ExprStr_lengths/","title":"<code>ExprStr_lengths</code>","text":"<p>lengths</p>"},{"location":"reference/ExprStr_lengths/#description","title":"Description","text":"<p>Get length of the strings as UInt32 (as number of bytes).</p>"},{"location":"reference/ExprStr_lengths/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprStr_lengths/#details","title":"Details","text":"<p>The returned lengths are equal to the number of bytes in the UTF8 string. If you  need the length in terms of the number of characters, use <code>n_chars</code> instead.</p>"},{"location":"reference/ExprStr_lengths/#value","title":"Value","text":"<p>Expr of u32 lengths</p>"},{"location":"reference/ExprStr_lengths/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(\ns = c(\"Caf\u00e9\", NA, \"345\", \"\u00e6\u00f8\u00e5\")\n)$select(\npl$col(\"s\"),\npl$col(\"s\")$str$lengths()$alias(\"lengths\"),\npl$col(\"s\")$str$n_chars()$alias(\"n_chars\")\n)\n</code></pre>"},{"location":"reference/ExprStr_ljust/","title":"<code>ExprStr_ljust</code>","text":"<p>ljust</p>"},{"location":"reference/ExprStr_ljust/#description","title":"Description","text":"<p>Return the string left justified in a string of length <code>width</code> .</p>"},{"location":"reference/ExprStr_ljust/#arguments","title":"Arguments","text":"Argument Description <code>width</code> Justify left to this length. <code>fillchar</code> Fill with this ASCII character."},{"location":"reference/ExprStr_ljust/#details","title":"Details","text":"<p>Padding is done using the specified <code>fillchar</code> . The original string is returned if  <code>width</code> is less than or equal to <code>len(s)</code> .</p>"},{"location":"reference/ExprStr_ljust/#value","title":"Value","text":"<p>Expr of Utf8</p>"},{"location":"reference/ExprStr_ljust/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(a = c(\"cow\", \"monkey\", NA, \"hippopotamus\"))\ndf$select(pl$col(\"a\")$str$ljust(8, \"*\"))\n</code></pre>"},{"location":"reference/ExprStr_lstrip/","title":"<code>ExprStr_lstrip</code>","text":"<p>lstrip</p>"},{"location":"reference/ExprStr_lstrip/#description","title":"Description","text":"<p>Remove leading characters.</p>"},{"location":"reference/ExprStr_lstrip/#arguments","title":"Arguments","text":"Argument Description <code>matches</code> The set of characters to be removed. All combinations of this set of characters will be stripped. If set to NULL (default), all whitespace is removed instead."},{"location":"reference/ExprStr_lstrip/#details","title":"Details","text":"<p>will not strip anyt chars beyond the first char not matched. <code>strip()</code> starts from  both left and right. Whereas <code>lstrip()</code> and <code>rstrip()</code> starts from left and right respectively.</p>"},{"location":"reference/ExprStr_lstrip/#value","title":"Value","text":"<p>Expr of Utf8 lowercase chars</p>"},{"location":"reference/ExprStr_lstrip/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(foo = c(\" hello\", \"\\tworld\"))\ndf$select(pl$col(\"foo\")$str$strip())\ndf$select(pl$col(\"foo\")$str$strip(\" hel rld\"))\ndf$select(pl$col(\"foo\")$str$lstrip(\" hel rld\"))\ndf$select(pl$col(\"foo\")$str$rstrip(\" hel\\trld\"))\ndf$select(pl$col(\"foo\")$str$rstrip(\"rldhel\\t \"))\n</code></pre>"},{"location":"reference/ExprStr_n_chars/","title":"<code>ExprStr_n_chars</code>","text":"<p>n_chars</p>"},{"location":"reference/ExprStr_n_chars/#description","title":"Description","text":"<p>Get length of the strings as UInt32 (as number of chars).</p>"},{"location":"reference/ExprStr_n_chars/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/ExprStr_n_chars/#details","title":"Details","text":"<p>If you know that you are working with ASCII text, <code>lengths</code> will be  equivalent, and faster (returns length in terms of the number of bytes).</p>"},{"location":"reference/ExprStr_n_chars/#value","title":"Value","text":"<p>Expr of u32 n_chars</p>"},{"location":"reference/ExprStr_n_chars/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(\ns = c(\"Caf\u00e9\", NA, \"345\", \"\u00e6\u00f8\u00e5\")\n)$select(\npl$col(\"s\"),\npl$col(\"s\")$str$lengths()$alias(\"lengths\"),\npl$col(\"s\")$str$n_chars()$alias(\"n_chars\")\n)\n</code></pre>"},{"location":"reference/ExprStr_parse_int/","title":"<code>ExprStr_parse_int</code>","text":"<p>parse_int</p>"},{"location":"reference/ExprStr_parse_int/#description","title":"Description","text":"<p>Parse integers with base radix from strings.  By default base 2.</p>"},{"location":"reference/ExprStr_parse_int/#arguments","title":"Arguments","text":"Argument Description <code>radix</code> Positive integer which is the base of the string we are parsing. Default: 2"},{"location":"reference/ExprStr_parse_int/#value","title":"Value","text":"<p>Expr: Series of dtype i32.</p>"},{"location":"reference/ExprStr_parse_int/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(bin = c(\"110\", \"101\", \"010\"))\ndf$select(pl$col(\"bin\")$str$parse_int(2))\n</code></pre>"},{"location":"reference/ExprStr_replace/","title":"<code>ExprStr_replace</code>","text":"<p>replace</p>"},{"location":"reference/ExprStr_replace/#description","title":"Description","text":"<p>Replace first matching regex/literal substring with a new string value.</p>"},{"location":"reference/ExprStr_replace/#arguments","title":"Arguments","text":"Argument Description <code>pattern</code> Into list(list(\"html\"), list(list(\"\"))) , regex pattern <code>value</code> Into list(list(\"html\"), list(list(\"\"))) replcacement <code>literal</code> bool, Treat pattern as a literal string."},{"location":"reference/ExprStr_replace/#value","title":"Value","text":"<p>Expr of Utf8 Series</p>"},{"location":"reference/ExprStr_replace/#seealso","title":"Seealso","text":"<p>replace_all : Replace all matching regex/literal substrings.</p>"},{"location":"reference/ExprStr_replace/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(id = c(1, 2), text = c(\"123abc\", \"abc456\"))\ndf$with_columns(\npl$col(\"text\")$str$replace(r\"{abc\\b}\", \"ABC\")\n)\n</code></pre>"},{"location":"reference/ExprStr_replace_all/","title":"<code>ExprStr_replace_all</code>","text":"<p>replace_all</p>"},{"location":"reference/ExprStr_replace_all/#description","title":"Description","text":"<p>Replace all matching regex/literal substrings with a new string value.</p>"},{"location":"reference/ExprStr_replace_all/#arguments","title":"Arguments","text":"Argument Description <code>pattern</code> Into list(list(\"html\"), list(list(\"\"))) , regex pattern <code>value</code> Into list(list(\"html\"), list(list(\"\"))) replcacement <code>literal</code> bool, treat pattern as a literal string."},{"location":"reference/ExprStr_replace_all/#value","title":"Value","text":"<p>Expr of Utf8 Series</p>"},{"location":"reference/ExprStr_replace_all/#seealso","title":"Seealso","text":"<p>replace : Replace first matching regex/literal substring.</p>"},{"location":"reference/ExprStr_replace_all/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(id = c(1, 2), text = c(\"abcabc\", \"123a123\"))\ndf$with_columns(\npl$col(\"text\")$str$replace_all(\"a\", \"-\")\n)\n</code></pre>"},{"location":"reference/ExprStr_rjust/","title":"<code>ExprStr_rjust</code>","text":"<p>rjust</p>"},{"location":"reference/ExprStr_rjust/#description","title":"Description","text":"<p>Return the string left justified in a string of length <code>width</code> .</p>"},{"location":"reference/ExprStr_rjust/#arguments","title":"Arguments","text":"Argument Description <code>width</code> Justify left to this length. <code>fillchar</code> Fill with this ASCII character."},{"location":"reference/ExprStr_rjust/#details","title":"Details","text":"<p>Padding is done using the specified <code>fillchar</code> . The original string is returned if  <code>width</code> is less than or equal to <code>len(s)</code> .</p>"},{"location":"reference/ExprStr_rjust/#value","title":"Value","text":"<p>Expr of Utf8</p>"},{"location":"reference/ExprStr_rjust/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(a = c(\"cow\", \"monkey\", NA, \"hippopotamus\"))\ndf$select(pl$col(\"a\")$str$rjust(8, \"*\"))\n</code></pre>"},{"location":"reference/ExprStr_rstrip/","title":"<code>ExprStr_rstrip</code>","text":"<p>rstrip</p>"},{"location":"reference/ExprStr_rstrip/#description","title":"Description","text":"<p>Remove leading characters.</p>"},{"location":"reference/ExprStr_rstrip/#arguments","title":"Arguments","text":"Argument Description <code>matches</code> The set of characters to be removed. All combinations of this set of characters will be stripped. If set to NULL (default), all whitespace is removed instead."},{"location":"reference/ExprStr_rstrip/#details","title":"Details","text":"<p>will not strip anyt chars beyond the first char not matched. <code>strip()</code> starts from  both left and right. Whereas <code>rstrip()</code> and <code>rstrip()</code> starts from left and right respectively.</p>"},{"location":"reference/ExprStr_rstrip/#value","title":"Value","text":"<p>Expr of Utf8 lowercase chars</p>"},{"location":"reference/ExprStr_rstrip/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(foo = c(\" hello\", \"\\tworld\"))\ndf$select(pl$col(\"foo\")$str$strip())\ndf$select(pl$col(\"foo\")$str$strip(\" hel rld\"))\ndf$select(pl$col(\"foo\")$str$lstrip(\" hel rld\"))\ndf$select(pl$col(\"foo\")$str$rstrip(\" hel\\trld\"))\ndf$select(pl$col(\"foo\")$str$rstrip(\"rldhel\\t \"))\n</code></pre>"},{"location":"reference/ExprStr_slice/","title":"<code>ExprStr_slice</code>","text":"<p>slice</p>"},{"location":"reference/ExprStr_slice/#description","title":"Description","text":"<p>Create subslices of the string values of a Utf8 Series.</p>"},{"location":"reference/ExprStr_slice/#arguments","title":"Arguments","text":"Argument Description <code>pattern</code> Into list(list(\"html\"), list(list(\"\"))) , regex pattern <code>value</code> Into list(list(\"html\"), list(list(\"\"))) replcacement <code>literal</code> bool, treat pattern as a literal string."},{"location":"reference/ExprStr_slice/#value","title":"Value","text":"<p>Expr: Series of dtype Utf8.</p>"},{"location":"reference/ExprStr_slice/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(s = c(\"pear\", NA, \"papaya\", \"dragonfruit\"))\ndf$with_columns(\npl$col(\"s\")$str$slice(-3)$alias(\"s_sliced\")\n)\n</code></pre>"},{"location":"reference/ExprStr_split/","title":"<code>ExprStr_split</code>","text":"<p>split</p>"},{"location":"reference/ExprStr_split/#description","title":"Description","text":"<p>Split the string by a substring.</p>"},{"location":"reference/ExprStr_split/#arguments","title":"Arguments","text":"Argument Description <code>by</code> Substring to split by. <code>inclusive</code> If True, include the split character/string in the results."},{"location":"reference/ExprStr_split/#value","title":"Value","text":"<p>List of Utf8 type</p>"},{"location":"reference/ExprStr_split/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(s = c(\"foo bar\", \"foo-bar\", \"foo bar baz\"))\ndf$select( pl$col(\"s\")$str$split(by=\" \"))\n</code></pre>"},{"location":"reference/ExprStr_split_exact/","title":"<code>ExprStr_split_exact</code>","text":"<p>split_exact</p>"},{"location":"reference/ExprStr_split_exact/#description","title":"Description","text":"<p>Split the string by a substring using <code>n</code> splits.  Results in a struct of <code>n+1</code> fields.  If it cannot make <code>n</code> splits, the remaining field elements will be null.</p>"},{"location":"reference/ExprStr_split_exact/#arguments","title":"Arguments","text":"Argument Description <code>by</code> Substring to split by. <code>n</code> Number of splits to make. <code>inclusive</code> If True, include the split_exact character/string in the results."},{"location":"reference/ExprStr_split_exact/#value","title":"Value","text":"<p>Struct where each of n+1 fields is of Utf8 type</p>"},{"location":"reference/ExprStr_split_exact/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(s = c(\"a_1\", NA, \"c\", \"d_4\"))\ndf$select( pl$col(\"s\")$str$split_exact(by=\"_\",1))\n</code></pre>"},{"location":"reference/ExprStr_splitn/","title":"<code>ExprStr_splitn</code>","text":"<p>splitn</p>"},{"location":"reference/ExprStr_splitn/#description","title":"Description","text":"<p>Split the string by a substring, restricted to returning at most <code>n</code> items.  If the number of possible splits is less than <code>n-1</code> , the remaining field  elements will be null. If the number of possible splits is <code>n-1</code> or greater,  the last (nth) substring will contain the remainder of the string.</p>"},{"location":"reference/ExprStr_splitn/#arguments","title":"Arguments","text":"Argument Description <code>by</code> Substring to split by. <code>n</code> Number of splits to make."},{"location":"reference/ExprStr_splitn/#value","title":"Value","text":"<p>Struct where each of n+1 fields is of Utf8 type</p>"},{"location":"reference/ExprStr_splitn/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(s = c(\"a_1\", NA, \"c\", \"d_4\"))\ndf$select( pl$col(\"s\")$str$splitn(by=\"_\",0))\ndf$select( pl$col(\"s\")$str$splitn(by=\"_\",1))\ndf$select( pl$col(\"s\")$str$splitn(by=\"_\",2))\n</code></pre>"},{"location":"reference/ExprStr_starts_with/","title":"<code>ExprStr_starts_with</code>","text":"<p>starts_with</p>"},{"location":"reference/ExprStr_starts_with/#description","title":"Description","text":"<p>Check if string values starts with a substring.</p>"},{"location":"reference/ExprStr_starts_with/#arguments","title":"Arguments","text":"Argument Description <code>sub</code> Prefix substring or Expr."},{"location":"reference/ExprStr_starts_with/#details","title":"Details","text":"<p>contains : Check if string contains a substring that matches a regex.  ends_with : Check if string values end with a substring.</p>"},{"location":"reference/ExprStr_starts_with/#value","title":"Value","text":"<p>Expr returning a Boolean</p>"},{"location":"reference/ExprStr_starts_with/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(fruits = c(\"apple\", \"mango\", NA))\ndf$select(\npl$col(\"fruits\"),\npl$col(\"fruits\")$str$starts_with(\"app\")$alias(\"has_suffix\")\n)\n</code></pre>"},{"location":"reference/ExprStr_strip/","title":"<code>ExprStr_strip</code>","text":"<p>Strip</p>"},{"location":"reference/ExprStr_strip/#description","title":"Description","text":"<p>Remove leading and trailing characters.</p>"},{"location":"reference/ExprStr_strip/#arguments","title":"Arguments","text":"Argument Description <code>matches</code> The set of characters to be removed. All combinations of this set of characters will be stripped. If set to NULL (default), all whitespace is removed instead."},{"location":"reference/ExprStr_strip/#details","title":"Details","text":"<p>will not strip anyt chars beyond the first char not matched. <code>strip()</code> starts from  both left and right. Whereas <code>lstrip()</code> and <code>rstrip()</code> starts from left and right respectively.</p>"},{"location":"reference/ExprStr_strip/#value","title":"Value","text":"<p>Expr of Utf8 lowercase chars</p>"},{"location":"reference/ExprStr_strip/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(foo = c(\" hello\", \"\\tworld\"))\ndf$select(pl$col(\"foo\")$str$strip())\ndf$select(pl$col(\"foo\")$str$strip(\" hel rld\"))\ndf$select(pl$col(\"foo\")$str$lstrip(\" hel rld\"))\ndf$select(pl$col(\"foo\")$str$rstrip(\" hel\\trld\"))\ndf$select(pl$col(\"foo\")$str$rstrip(\"rldhel\\t \"))\n</code></pre>"},{"location":"reference/ExprStr_strptime/","title":"<code>ExprStr_strptime</code>","text":"<p>strptime</p>"},{"location":"reference/ExprStr_strptime/#description","title":"Description","text":"<p>Parse a Series of dtype Utf8 to a Date/Datetime Series.</p>"},{"location":"reference/ExprStr_strptime/#arguments","title":"Arguments","text":"Argument Description <code>datatype</code> a temporal data type either pl$Date, pl$Time or pl$Datetime <code>fmt</code> fmt string for parsenig see see details here https://docs.rs/chrono/latest/chrono/format/strftime/index.html#fn6 Notice time_zone %Z is not supported and will just ignore timezones. Numeric tz  like %z, %:z  .... are supported. <code>strict</code> bool, if true raise error if a single string cannot be parsed, else produce a polars <code>null</code> . <code>exact</code> bool , If True, require an exact format match. If False, allow the format to match anywhere in the target string. <code>cache</code> Use a cache of unique, converted dates to apply the datetime conversion. <code>tz_aware</code> bool, Parse timezone aware datetimes. This may be automatically toggled by the \u2018fmt\u2019 given. <code>utc</code> bool Parse timezone aware datetimes as UTC. This may be useful if you have data with mixed offsets."},{"location":"reference/ExprStr_strptime/#details","title":"Details","text":"<p>Notes When parsing a Datetime the column precision will be inferred from the format  string, if given, eg: \u201c%F %T%.3f\u201d =&gt; Datetime(\u201cms\u201d). If no fractional second component is found  then the default is \u201cus\u201d.</p>"},{"location":"reference/ExprStr_strptime/#value","title":"Value","text":"<p>Expr of a Data, Datetime or Time Series</p>"},{"location":"reference/ExprStr_strptime/#examples","title":"Examples","text":"<pre><code>s = pl$Series(c(\n\"2021-04-22\",\n\"2022-01-04 00:00:00\",\n\"01/31/22\",\n\"Sun Jul  8 00:34:60 2001\"\n),\n\"date\"\n)\n#' #join multiple passes with different fmt\ns$to_frame()$with_columns(\npl$col(\"date\")\n$str$strptime(pl$Date, \"%F\", strict=FALSE)\n$fill_null(pl$col(\"date\")$str$strptime(pl$Date, \"%F %T\", strict=FALSE))\n$fill_null(pl$col(\"date\")$str$strptime(pl$Date, \"%D\", strict=FALSE))\n$fill_null(pl$col(\"date\")$str$strptime(pl$Date, \"%c\", strict=FALSE))\n)\ntxt_datetimes = c(\n\"2023-01-01 11:22:33 -0100\",\n\"2023-01-01 11:22:33 +0300\",\n\"invalid time\"\n)\npl$lit(txt_datetimes)$str$strptime(\npl$Datetime(\"ns\"),fmt = \"%Y-%m-%d %H:%M:%S %z\", strict = FALSE,\ntz_aware = TRUE, utc =TRUE\n)$lit_to_s()\n</code></pre>"},{"location":"reference/ExprStr_to_lowercase/","title":"<code>ExprStr_to_lowercase</code>","text":"<p>To lowercase</p>"},{"location":"reference/ExprStr_to_lowercase/#description","title":"Description","text":"<p>Transform to lowercase variant.</p>"},{"location":"reference/ExprStr_to_lowercase/#value","title":"Value","text":"<p>Expr of Utf8 lowercase chars</p>"},{"location":"reference/ExprStr_to_lowercase/#examples","title":"Examples","text":"<pre><code>pl$lit(c(\"A\",\"b\", \"c\", \"1\", NA))$str$to_lowercase()$lit_to_s()\n</code></pre>"},{"location":"reference/ExprStr_to_uppercase/","title":"<code>ExprStr_to_uppercase</code>","text":"<p>To uppercase</p>"},{"location":"reference/ExprStr_to_uppercase/#description","title":"Description","text":"<p>Transform to uppercase variant.</p>"},{"location":"reference/ExprStr_to_uppercase/#value","title":"Value","text":"<p>Expr of Utf8 uppercase chars</p>"},{"location":"reference/ExprStr_to_uppercase/#examples","title":"Examples","text":"<pre><code>pl$lit(c(\"A\",\"b\", \"c\", \"1\", NA))$str$to_uppercase()$lit_to_s()\n</code></pre>"},{"location":"reference/ExprStr_zfill/","title":"<code>ExprStr_zfill</code>","text":"<p>zfill</p>"},{"location":"reference/ExprStr_zfill/#description","title":"Description","text":"<p>Fills the string with zeroes.</p>"},{"location":"reference/ExprStr_zfill/#arguments","title":"Arguments","text":"Argument Description <code>alignment</code> Fill the value up to this length"},{"location":"reference/ExprStr_zfill/#details","title":"Details","text":"<p>Return a copy of the string left filled with ASCII '0' digits to make a string  of length width.</p> <p>A leading sign prefix ('+'/'-') is handled by inserting the padding after the  sign character rather than before. The original string is returned if width is  less than or equal to <code>len(s)</code> .</p>"},{"location":"reference/ExprStr_zfill/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/ExprStr_zfill/#examples","title":"Examples","text":"<pre><code>some_floats_expr = pl$lit(c(0,10,-5,5))\n#cast to Utf8 and ljust alignment = 5, and view as R char vector\nsome_floats_expr$cast(pl$Utf8)$str$zfill(5)$to_r()\n#cast to int and the to utf8 and then ljust alignment = 5, and view as R char vector\nsome_floats_expr$cast(pl$Int64)$cast(pl$Utf8)$str$zfill(5)$to_r()\n</code></pre>"},{"location":"reference/ExprStruct_field/","title":"<code>ExprStruct_field</code>","text":"<p>field</p>"},{"location":"reference/ExprStruct_field/#description","title":"Description","text":"<p>Retrieve a <code>Struct</code> field as a new Series.  By default base 2.</p>"},{"location":"reference/ExprStruct_field/#arguments","title":"Arguments","text":"Argument Description <code>name</code> string, the Name of the struct field to retrieve."},{"location":"reference/ExprStruct_field/#value","title":"Value","text":"<p>Expr: Series of same and name selected field.</p>"},{"location":"reference/ExprStruct_field/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\naaa = c(1, 2),\nbbb = c(\"ab\", \"cd\"),\nccc = c(TRUE, NA),\nddd = list(c(1, 2), 3)\n)$select(\npl$struct(pl$all())$alias(\"struct_col\")\n)\n#struct field into a new Series\ndf$select(\npl$col(\"struct_col\")$struct$field(\"bbb\"),\npl$col(\"struct_col\")$struct$field(\"ddd\")\n)\n</code></pre>"},{"location":"reference/ExprStruct_rename_fields/","title":"<code>ExprStruct_rename_fields</code>","text":"<p>rename fields</p>"},{"location":"reference/ExprStruct_rename_fields/#description","title":"Description","text":"<p>Rename the fields of the struct.  By default base 2.</p>"},{"location":"reference/ExprStruct_rename_fields/#arguments","title":"Arguments","text":"Argument Description <code>names</code> char vec or list of strings given in the same order as the struct's fields. Providing fewer names will drop the latter fields. Providing too many names is ignored."},{"location":"reference/ExprStruct_rename_fields/#value","title":"Value","text":"<p>Expr: struct-series with new names for the fields</p>"},{"location":"reference/ExprStruct_rename_fields/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\naaa = 1:2,\nbbb = c(\"ab\", \"cd\"),\nccc = c(TRUE, NA),\nddd = list(1:2, 3L)\n)$select(\npl$struct(pl$all())$alias(\"struct_col\")\n)$select(\npl$col(\"struct_col\")$struct$rename_fields(c(\"www\", \"xxx\", \"yyy\", \"zzz\"))\n)\ndf$unnest()\n</code></pre>"},{"location":"reference/Expr_abs/","title":"<code>Expr_abs</code>","text":"<p>Abs</p>"},{"location":"reference/Expr_abs/#description","title":"Description","text":"<p>Compute absolute values</p>"},{"location":"reference/Expr_abs/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_abs/#usage","title":"Usage","text":"<pre><code>Expr_abs\n</code></pre>"},{"location":"reference/Expr_abs/#value","title":"Value","text":"<p>Exprs abs</p>"},{"location":"reference/Expr_abs/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=-1:1))$select(pl$col(\"a\"),pl$col(\"a\")$abs()$alias(\"abs\"))\n</code></pre>"},{"location":"reference/Expr_add/","title":"<code>Expr_add</code>","text":"<p>Add</p>"},{"location":"reference/Expr_add/#description","title":"Description","text":"<p>Addition</p>"},{"location":"reference/Expr_add/#usage","title":"Usage","text":"<pre><code>Expr_add(other)\nlist(list(\"+\"), list(\"Expr\"))(e1, e2)\n</code></pre>"},{"location":"reference/Expr_add/#arguments","title":"Arguments","text":"Argument Description <code>other</code> literal or Robj which can become a literal <code>e1</code> lhs Expr <code>e2</code> rhs Expr or anything which can become a literal Expression"},{"location":"reference/Expr_add/#value","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/Expr_add/#examples","title":"Examples","text":"<pre><code>#three syntaxes same result\npl$lit(5) + 10\npl$lit(5) + pl$lit(10)\npl$lit(5)$add(pl$lit(10))\n+pl$lit(5) #unary use resolves to same as pl$lit(5)\n</code></pre>"},{"location":"reference/Expr_agg_groups/","title":"<code>Expr_agg_groups</code>","text":"<p>aggregate groups</p>"},{"location":"reference/Expr_agg_groups/#description","title":"Description","text":"<p>Get the group indexes of the group by operation.  Should be used in aggregation context only.</p>"},{"location":"reference/Expr_agg_groups/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_agg_groups/#usage","title":"Usage","text":"<pre><code>Expr_agg_groups\n</code></pre>"},{"location":"reference/Expr_agg_groups/#value","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/Expr_agg_groups/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(\ngroup = c(\"one\",\"one\",\"one\",\"two\",\"two\",\"two\"),\nvalue =  c(94, 95, 96, 97, 97, 99)\n))\ndf$groupby(\"group\", maintain_order=TRUE)$agg(pl$col(\"value\")$agg_groups())\n</code></pre>"},{"location":"reference/Expr_alias/","title":"<code>Expr_alias</code>","text":"<p>Rename Expr output</p>"},{"location":"reference/Expr_alias/#description","title":"Description","text":"<p>Rename the output of an expression.</p>"},{"location":"reference/Expr_alias/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_alias/#usage","title":"Usage","text":"<pre><code>Expr_alias(name)\n</code></pre>"},{"location":"reference/Expr_alias/#arguments","title":"Arguments","text":"Argument Description <code>name</code> string new name of output"},{"location":"reference/Expr_alias/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_alias/#examples","title":"Examples","text":"<pre><code>pl$col(\"bob\")$alias(\"alice\")\n</code></pre>"},{"location":"reference/Expr_all/","title":"<code>Expr_all</code>","text":"<p>All, is true</p>"},{"location":"reference/Expr_all/#description","title":"Description","text":"<p>Check if all boolean values in a Boolean column are <code>TRUE</code> .  This method is an expression - not to be confused with  <code>pl$all</code> which is a function to select all columns.</p>"},{"location":"reference/Expr_all/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_all/#usage","title":"Usage","text":"<pre><code>Expr_all\n</code></pre>"},{"location":"reference/Expr_all/#details","title":"Details","text":"<p>last <code>all()</code> in example is this Expr method, the first <code>pl$all()</code> refers  to \"all-columns\" and is an expression constructor</p>"},{"location":"reference/Expr_all/#value","title":"Value","text":"<p>Boolean literal</p>"},{"location":"reference/Expr_all/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(\nall=c(TRUE,TRUE),\nany=c(TRUE,FALSE),\nnone=c(FALSE,FALSE)\n)$select(\npl$all()$all()\n)\n</code></pre>"},{"location":"reference/Expr_and/","title":"<code>Expr_and</code>","text":"<p>And</p>"},{"location":"reference/Expr_and/#description","title":"Description","text":"<p>combine to boolean exprresions with AND</p>"},{"location":"reference/Expr_and/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_and/#usage","title":"Usage","text":"<pre><code>Expr_and(other)\n</code></pre>"},{"location":"reference/Expr_and/#arguments","title":"Arguments","text":"Argument Description <code>other</code> literal or Robj which can become a literal"},{"location":"reference/Expr_and/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_and/#examples","title":"Examples","text":"<pre><code>pl$lit(TRUE) &amp; TRUE\npl$lit(TRUE)$and(pl$lit(TRUE))\n</code></pre>"},{"location":"reference/Expr_any/","title":"<code>Expr_any</code>","text":"<p>Any (is true)</p>"},{"location":"reference/Expr_any/#description","title":"Description","text":"<p>Check if any boolean value in a Boolean column is <code>TRUE</code> .</p>"},{"location":"reference/Expr_any/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_any/#usage","title":"Usage","text":"<pre><code>Expr_any\n</code></pre>"},{"location":"reference/Expr_any/#value","title":"Value","text":"<p>Boolean literal</p>"},{"location":"reference/Expr_any/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(\nall=c(TRUE,TRUE),\nany=c(TRUE,FALSE),\nnone=c(FALSE,FALSE)\n)$select(\npl$all()$any()\n)\n</code></pre>"},{"location":"reference/Expr_append/","title":"<code>Expr_append</code>","text":"<p>Append expressions</p>"},{"location":"reference/Expr_append/#description","title":"Description","text":"<p>This is done by adding the chunks of <code>other</code> to this <code>output</code> .</p>"},{"location":"reference/Expr_append/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_append/#usage","title":"Usage","text":"<pre><code>Expr_append(other, upcast = TRUE)\n</code></pre>"},{"location":"reference/Expr_append/#arguments","title":"Arguments","text":"Argument Description <code>other</code> Expr, into Expr <code>upcast</code> bool upcast to, if any supertype of two non equal datatypes."},{"location":"reference/Expr_append/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_append/#examples","title":"Examples","text":"<pre><code>#append bottom to to row\ndf = pl$DataFrame(list(a = 1:3, b = c(NA_real_,4,5)))\ndf$select(pl$all()$head(1)$append(pl$all()$tail(1)))\n#implicit upcast, when default = TRUE\npl$DataFrame(list())$select(pl$lit(42)$append(42L))\npl$DataFrame(list())$select(pl$lit(42)$append(FALSE))\npl$DataFrame(list())$select(pl$lit(\"Bob\")$append(FALSE))\n</code></pre>"},{"location":"reference/Expr_apply/","title":"<code>Expr_apply</code>","text":"<p>Expr_apply</p>"},{"location":"reference/Expr_apply/#description","title":"Description","text":"<p>Apply a custom/user-defined function (UDF) in a GroupBy or Projection context.  Depending on the context it has the following behavior:  -Selection</p>"},{"location":"reference/Expr_apply/#usage","title":"Usage","text":"<pre><code>Expr_apply(\nf,\nreturn_type = NULL,\nstrict_return_type = TRUE,\nallow_fail_eval = FALSE\n)\n</code></pre>"},{"location":"reference/Expr_apply/#arguments","title":"Arguments","text":"Argument Description <code>f</code> r function see details depending on context <code>return_type</code> NULL or one of pl$dtypes, the output datatype, NULL is the same as input. <code>strict_return_type</code> bool (default TRUE), error if not correct datatype returned from R, if FALSE will convert to a Polars Null and carry on. <code>allow_fail_eval</code> bool (default FALSE), if TRUE will not raise user function error but convert result to a polars Null and carry on."},{"location":"reference/Expr_apply/#details","title":"Details","text":"<p>Apply a user function in a groupby or projection(select) context</p> <p>Depending on context the following behaviour:</p> <ul> <li> <p>Projection/Selection: Expects an <code>f</code> to operate on R scalar values. Polars will convert each element into an R value and pass it to the function The output of the user function will be converted back into a polars type. Return type must match. See param return type. Apply in selection context should be avoided as a <code>lapply()</code> has half the overhead. </p> </li> <li> <p>Groupby Expects a user function <code>f</code> to take a <code>Series</code> and return a <code>Series</code> or Robj convertable to <code>Series</code> , eg. R vector. GroupBy context much faster if number groups are quite fewer than number of rows, as the iteration is only across the groups. The r user function could e.g. do vectorized operations and stay quite performant. use <code>s$to_r()</code> to convert input Series to an r vector or list. use <code>s$to_r_vector</code> and <code>s$to_r_list()</code> to force conversion to vector or list. </p> </li> </ul> <p>Implementing logic using an R function is almost always significantly   slower and more memory intensive than implementing the same logic using  the native expression API because:  - The native expression engine runs in Rust; functions run in R.  - Use of R functions forces the DataFrame to be materialized in memory.  - Polars-native expressions can be parallelised (R functions cannot*).  - Polars-native expressions can be logically optimised (R functions cannot).  Wherever possible you should strongly prefer the native expression API  to achieve the best performance.</p>"},{"location":"reference/Expr_apply/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_apply/#examples","title":"Examples","text":"<pre><code>#apply over groups - normal usage\n# s is a series of all values for one column within group, here Species\ne_all =pl$all() #perform groupby agg on all columns otherwise e.g. pl$col(\"Sepal.Length\")\ne_sum  = e_all$apply(\\(s)  sum(s$to_r()))$suffix(\"_sum\")\ne_head = e_all$apply(\\(s) head(s$to_r(),2))$suffix(\"_head\")\npl$DataFrame(iris)$groupby(\"Species\")$agg(e_sum,e_head)\n# apply over single values (should be avoided as it takes ~2.5us overhead + R function exec time\n# on a 2015 MacBook Pro) x is an R scalar\n#perform on all Float64 columns, using pl$all requires user function can handle any input type\ne_all =pl$col(pl$dtypes$Float64)\ne_add10  = e_all$apply(\\(x)  {x+10})$suffix(\"_sum\")\n#quite silly index into alphabet(letters) by ceil of float value\n#must set return_type as not the same as input\ne_letter = e_all$apply(\\(x) letters[ceiling(x)], return_type = pl$dtypes$Utf8)$suffix(\"_letter\")\npl$DataFrame(iris)$select(e_add10,e_letter)\n##timing \"slow\" apply in select /with_columns context, this makes apply\nn = 1000000L\nset.seed(1)\ndf = pl$DataFrame(list(\na = 1:n,\nb = sample(letters,n,replace=TRUE)\n))\nprint(\"apply over 1 million values takes ~2.5 sec on 2015 MacBook Pro\")\nsystem.time({\nrdf = df$with_columns(\npl$col(\"a\")$apply(\\(x) {\nx*2L\n})$alias(\"bob\")\n)\n})\nprint(\"R lapply 1 million values take ~1sec on 2015 MacBook Pro\")\nsystem.time({\nlapply(df$get_column(\"a\")$to_r(),\\(x) x*2L )\n})\nprint(\"using polars syntax takes ~1ms\")\nsystem.time({\n(df$get_column(\"a\") * 2L)\n})\nprint(\"using R vector syntax takes ~4ms\")\nr_vec = df$get_column(\"a\")$to_r()\nsystem.time({\nr_vec * 2L\n})\n</code></pre>"},{"location":"reference/Expr_arccos/","title":"<code>Expr_arccos</code>","text":"<p>Arccos</p>"},{"location":"reference/Expr_arccos/#description","title":"Description","text":"<p>Compute the element-wise value for the inverse cosine.</p>"},{"location":"reference/Expr_arccos/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_arccos/#usage","title":"Usage","text":"<pre><code>Expr_arccos\n</code></pre>"},{"location":"reference/Expr_arccos/#details","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/Expr_arccos/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_arccos/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,cos(0.5),0,1,NA_real_))$select(pl$col(\"a\")$arccos())\n</code></pre>"},{"location":"reference/Expr_arccosh/","title":"<code>Expr_arccosh</code>","text":"<p>Arccosh</p>"},{"location":"reference/Expr_arccosh/#description","title":"Description","text":"<p>Compute the element-wise value for the inverse hyperbolic cosine.</p>"},{"location":"reference/Expr_arccosh/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_arccosh/#usage","title":"Usage","text":"<pre><code>Expr_arccosh\n</code></pre>"},{"location":"reference/Expr_arccosh/#details","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/Expr_arccosh/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_arccosh/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,cosh(0.5),0,1,NA_real_))$select(pl$col(\"a\")$arccosh())\n</code></pre>"},{"location":"reference/Expr_arcsin/","title":"<code>Expr_arcsin</code>","text":"<p>Arcsin</p>"},{"location":"reference/Expr_arcsin/#description","title":"Description","text":"<p>Compute the element-wise value for the inverse sine.</p>"},{"location":"reference/Expr_arcsin/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_arcsin/#usage","title":"Usage","text":"<pre><code>Expr_arcsin\n</code></pre>"},{"location":"reference/Expr_arcsin/#details","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/Expr_arcsin/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_arcsin/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,sin(0.5),0,1,NA_real_))$select(pl$col(\"a\")$arcsin())\n</code></pre>"},{"location":"reference/Expr_arcsinh/","title":"<code>Expr_arcsinh</code>","text":"<p>Arcsinh</p>"},{"location":"reference/Expr_arcsinh/#description","title":"Description","text":"<p>Compute the element-wise value for the inverse hyperbolic sine.</p>"},{"location":"reference/Expr_arcsinh/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_arcsinh/#usage","title":"Usage","text":"<pre><code>Expr_arcsinh\n</code></pre>"},{"location":"reference/Expr_arcsinh/#details","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/Expr_arcsinh/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_arcsinh/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,sinh(0.5),0,1,NA_real_))$select(pl$col(\"a\")$arcsinh())\n</code></pre>"},{"location":"reference/Expr_arctan/","title":"<code>Expr_arctan</code>","text":"<p>Arctan</p>"},{"location":"reference/Expr_arctan/#description","title":"Description","text":"<p>Compute the element-wise value for the inverse tangent.</p>"},{"location":"reference/Expr_arctan/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_arctan/#usage","title":"Usage","text":"<pre><code>Expr_arctan\n</code></pre>"},{"location":"reference/Expr_arctan/#details","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/Expr_arctan/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_arctan/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,tan(0.5),0,1,NA_real_))$select(pl$col(\"a\")$arctan())\n</code></pre>"},{"location":"reference/Expr_arctanh/","title":"<code>Expr_arctanh</code>","text":"<p>Arctanh</p>"},{"location":"reference/Expr_arctanh/#description","title":"Description","text":"<p>Compute the element-wise value for the inverse hyperbolic tangent.</p>"},{"location":"reference/Expr_arctanh/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_arctanh/#usage","title":"Usage","text":"<pre><code>Expr_arctanh\n</code></pre>"},{"location":"reference/Expr_arctanh/#details","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/Expr_arctanh/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_arctanh/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,tanh(0.5),0,1,NA_real_))$select(pl$col(\"a\")$arctanh())\n</code></pre>"},{"location":"reference/Expr_arg_max/","title":"<code>Expr_arg_max</code>","text":"<p>Index of min value</p>"},{"location":"reference/Expr_arg_max/#description","title":"Description","text":"<p>Get the index of the minimal value.</p>"},{"location":"reference/Expr_arg_max/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_arg_max/#usage","title":"Usage","text":"<pre><code>Expr_arg_max\n</code></pre>"},{"location":"reference/Expr_arg_max/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_arg_max/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_arg_max/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(6, 1, 0, NA, Inf, NaN)\n))$select(pl$col(\"a\")$arg_max())\n</code></pre>"},{"location":"reference/Expr_arg_min/","title":"<code>Expr_arg_min</code>","text":"<p>Index of min value</p>"},{"location":"reference/Expr_arg_min/#description","title":"Description","text":"<p>Get the index of the minimal value.</p>"},{"location":"reference/Expr_arg_min/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_arg_min/#usage","title":"Usage","text":"<pre><code>Expr_arg_min\n</code></pre>"},{"location":"reference/Expr_arg_min/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_arg_min/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_arg_min/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(6, 1, 0, NA, Inf, NaN)\n))$select(pl$col(\"a\")$arg_min())\n</code></pre>"},{"location":"reference/Expr_arg_sort/","title":"<code>Expr_arg_sort</code>","text":"<p>Index of a sort</p>"},{"location":"reference/Expr_arg_sort/#description","title":"Description","text":"<p>Get the index values that would sort this column.  If 'reverse=True` the smallest elements will be given.</p> <p>argsort is a alias for arg_sort</p>"},{"location":"reference/Expr_arg_sort/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_arg_sort/#usage","title":"Usage","text":"<pre><code>Expr_arg_sort(reverse = FALSE, nulls_last = FALSE)\nExpr_argsort(reverse = FALSE, nulls_last = FALSE)\n</code></pre>"},{"location":"reference/Expr_arg_sort/#arguments","title":"Arguments","text":"Argument Description <code>reverse</code> bool default FALSE, reverses sort <code>nulls_last</code> bool, default FALSE, place Nulls last"},{"location":"reference/Expr_arg_sort/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_arg_sort/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_arg_sort/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(6, 1, 0, NA, Inf, NaN)\n))$select(pl$col(\"a\")$arg_sort())\n</code></pre>"},{"location":"reference/Expr_arg_unique/","title":"<code>Expr_arg_unique</code>","text":"<p>Index of First Unique Value.</p>"},{"location":"reference/Expr_arg_unique/#description","title":"Description","text":"<p>Index of First Unique Value.</p>"},{"location":"reference/Expr_arg_unique/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_arg_unique/#usage","title":"Usage","text":"<pre><code>Expr_arg_unique\n</code></pre>"},{"location":"reference/Expr_arg_unique/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_arg_unique/#examples","title":"Examples","text":"<pre><code>pl$select(pl$lit(c(1:2,1:3))$arg_unique())\n</code></pre>"},{"location":"reference/Expr_arr/","title":"<code>Expr_arr</code>","text":"<p>arr: list related methods</p>"},{"location":"reference/Expr_arr/#description","title":"Description","text":"<p>Create an object namespace of all list related methods.  See the individual method pages for full details</p>"},{"location":"reference/Expr_arr/#usage","title":"Usage","text":"<pre><code>Expr_arr()\n</code></pre>"},{"location":"reference/Expr_arr/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_arr/#examples","title":"Examples","text":"<pre><code>df_with_list = pl$DataFrame(\ngroup = c(1,1,2,2,3),\nvalue = c(1:5)\n)$groupby(\n\"group\",maintain_order = TRUE\n)$agg(\npl$col(\"value\") * 3L\n)\ndf_with_list$with_column(\npl$col(\"value\")$arr$lengths()$alias(\"group_size\")\n)\n</code></pre>"},{"location":"reference/Expr_backward_fill/","title":"<code>Expr_backward_fill</code>","text":"<p>Fill Nulls Backward</p>"},{"location":"reference/Expr_backward_fill/#description","title":"Description","text":"<p>Fill missing values with the next to be seen values.</p>"},{"location":"reference/Expr_backward_fill/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_backward_fill/#usage","title":"Usage","text":"<pre><code>Expr_backward_fill(limit = NULL)\n</code></pre>"},{"location":"reference/Expr_backward_fill/#arguments","title":"Arguments","text":"Argument Description <code>limit</code> Expr or Into The number of consecutive null values to backward fill."},{"location":"reference/Expr_backward_fill/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_backward_fill/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_backward_fill/#examples","title":"Examples","text":"<pre><code>l = list(a=c(1L,rep(NA_integer_,3L),10))\npl$DataFrame(l)$select(\npl$col(\"a\")$backward_fill()$alias(\"bf_null\"),\npl$col(\"a\")$backward_fill(limit = 0)$alias(\"bf_l0\"),\npl$col(\"a\")$backward_fill(limit = 1)$alias(\"bf_l1\")\n)$to_list()\n</code></pre>"},{"location":"reference/Expr_bin/","title":"<code>Expr_bin</code>","text":"<p>bin: binary related methods</p>"},{"location":"reference/Expr_bin/#description","title":"Description","text":"<p>Create an object namespace of all binary related methods.  See the individual method pages for full details</p>"},{"location":"reference/Expr_bin/#usage","title":"Usage","text":"<pre><code>Expr_bin()\n</code></pre>"},{"location":"reference/Expr_bin/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_bin/#examples","title":"Examples","text":"<pre><code>#missing\n</code></pre>"},{"location":"reference/Expr_cast/","title":"<code>Expr_cast</code>","text":"<p>Cast between DataType(s)</p>"},{"location":"reference/Expr_cast/#description","title":"Description","text":"<p>Cast between DataType(s)</p>"},{"location":"reference/Expr_cast/#usage","title":"Usage","text":"<pre><code>Expr_cast(dtype, strict = TRUE)\n</code></pre>"},{"location":"reference/Expr_cast/#arguments","title":"Arguments","text":"Argument Description <code>dtype</code> DataType to cast to. <code>strict</code> bool if true an error will be thrown if cast failed at resolve time."},{"location":"reference/Expr_cast/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_cast/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = 1:3, b = 1:3))\ndf$with_columns(\npl$col(\"a\")$cast(pl$dtypes$Float64, TRUE),\npl$col(\"a\")$cast(pl$dtypes$Int32, TRUE)\n)\n</code></pre>"},{"location":"reference/Expr_cat/","title":"<code>Expr_cat</code>","text":"<p>cat: related methods</p>"},{"location":"reference/Expr_cat/#description","title":"Description","text":"<p>Create an object namespace of all cat related methods.  See the individual method pages for full details</p>"},{"location":"reference/Expr_cat/#usage","title":"Usage","text":"<pre><code>Expr_cat()\n</code></pre>"},{"location":"reference/Expr_cat/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_cat/#examples","title":"Examples","text":"<pre><code>#missing\n</code></pre>"},{"location":"reference/Expr_ceil/","title":"<code>Expr_ceil</code>","text":"<p>Ceiling</p>"},{"location":"reference/Expr_ceil/#description","title":"Description","text":"<p>Rounds up to the nearest integer value.  Only works on floating point Series.</p>"},{"location":"reference/Expr_ceil/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_ceil/#usage","title":"Usage","text":"<pre><code>Expr_ceil\n</code></pre>"},{"location":"reference/Expr_ceil/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_ceil/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(0.33, 0.5, 1.02, 1.5, NaN , NA, Inf, -Inf)\n))$select(\npl$col(\"a\")$ceil()\n)\n</code></pre>"},{"location":"reference/Expr_clip/","title":"<code>Expr_clip</code>","text":"<p>Clip</p>"},{"location":"reference/Expr_clip/#description","title":"Description","text":"<p>Clip (limit) the values in an array to a <code>min</code> and <code>max</code> boundary.</p>"},{"location":"reference/Expr_clip/#usage","title":"Usage","text":"<pre><code>Expr_clip(min, max)\nExpr_clip_min(min)\nExpr_clip_max(max)\n</code></pre>"},{"location":"reference/Expr_clip/#arguments","title":"Arguments","text":"Argument Description <code>min</code> Minimum Value, ints and floats or any literal expression of ints and floats <code>max</code> Maximum Value, ints and floats or any literal expression of ints and floats"},{"location":"reference/Expr_clip/#details","title":"Details","text":"<p>Only works for numerical types.  If you want to clip other dtypes, consider writing a \"when, then, otherwise\"  expression. See :func: <code>when</code> for more information.</p>"},{"location":"reference/Expr_clip/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_clip/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(foo = c(-50L, 5L, NA_integer_,50L))\ndf$with_column(pl$col(\"foo\")$clip(1L,10L)$alias(\"foo_clipped\"))\ndf$with_column(pl$col(\"foo\")$clip_min(1L)$alias(\"foo_clipped\"))\ndf$with_column(pl$col(\"foo\")$clip_max(10L)$alias(\"foo_clipped\"))\n</code></pre>"},{"location":"reference/Expr_cos/","title":"<code>Expr_cos</code>","text":"<p>Cos</p>"},{"location":"reference/Expr_cos/#description","title":"Description","text":"<p>Compute the element-wise value for the cosine.</p>"},{"location":"reference/Expr_cos/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_cos/#usage","title":"Usage","text":"<pre><code>Expr_cos\n</code></pre>"},{"location":"reference/Expr_cos/#details","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/Expr_cos/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_cos/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(0,pi/2,pi,NA_real_))$select(pl$col(\"a\")$cos())\n</code></pre>"},{"location":"reference/Expr_cosh/","title":"<code>Expr_cosh</code>","text":"<p>Cosh</p>"},{"location":"reference/Expr_cosh/#description","title":"Description","text":"<p>Compute the element-wise value for the hyperbolic cosine.</p>"},{"location":"reference/Expr_cosh/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_cosh/#usage","title":"Usage","text":"<pre><code>Expr_cosh\n</code></pre>"},{"location":"reference/Expr_cosh/#details","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/Expr_cosh/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_cosh/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,acosh(1.5),0,1,NA_real_))$select(pl$col(\"a\")$cosh())\n</code></pre>"},{"location":"reference/Expr_count/","title":"<code>Expr_count</code>","text":"<p>Count values (len is a alias)</p>"},{"location":"reference/Expr_count/#description","title":"Description","text":"<p>Count the number of values in this expression.  Similar to R length()</p>"},{"location":"reference/Expr_count/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p> <p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_count/#usage","title":"Usage","text":"<pre><code>Expr_count\nExpr_len\n</code></pre>"},{"location":"reference/Expr_count/#value","title":"Value","text":"<p>Expr</p> <p>Expr</p>"},{"location":"reference/Expr_count/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(\nall=c(TRUE,TRUE),\nany=c(TRUE,FALSE),\nnone=c(FALSE,FALSE)\n)$select(\npl$all()$count()\n)\npl$DataFrame(\nall=c(TRUE,TRUE),\nany=c(TRUE,FALSE),\nnone=c(FALSE,FALSE)\n)$select(\npl$all()$len(),\npl$col(\"all\")$first()$len()$alias(\"all_first\")\n)\n</code></pre>"},{"location":"reference/Expr_cumcount/","title":"<code>Expr_cumcount</code>","text":"<p>Cumulative count</p>"},{"location":"reference/Expr_cumcount/#description","title":"Description","text":"<p>Get an array with the cumulative count computed at every element.  Counting from 0 to len</p>"},{"location":"reference/Expr_cumcount/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_cumcount/#usage","title":"Usage","text":"<pre><code>Expr_cumcount(reverse = FALSE)\n</code></pre>"},{"location":"reference/Expr_cumcount/#arguments","title":"Arguments","text":"Argument Description <code>reverse</code> bool, default FALSE, if true roll over vector from back to forth"},{"location":"reference/Expr_cumcount/#details","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to  Int64 before summing to prevent overflow issues.</p> <p>cumcount does not seem to count within lists.</p>"},{"location":"reference/Expr_cumcount/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_cumcount/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:4))$select(\npl$col(\"a\")$cumcount()$alias(\"cumcount\"),\npl$col(\"a\")$cumcount(reverse=TRUE)$alias(\"cumcount_reversed\")\n)\n</code></pre>"},{"location":"reference/Expr_cummin/","title":"<code>Expr_cummin</code>","text":"<p>Cumulative minimum</p>"},{"location":"reference/Expr_cummin/#description","title":"Description","text":"<p>Get an array with the cumulative min computed at every element.</p> <p>Get an array with the cumulative max computed at every element.</p>"},{"location":"reference/Expr_cummin/#format","title":"Format","text":"<p>a method</p> <p>a method</p>"},{"location":"reference/Expr_cummin/#usage","title":"Usage","text":"<pre><code>Expr_cummin(reverse = FALSE)\nExpr_cummax(reverse = FALSE)\n</code></pre>"},{"location":"reference/Expr_cummin/#arguments","title":"Arguments","text":"Argument Description <code>reverse</code> bool, default FALSE, if true roll over vector from back to forth"},{"location":"reference/Expr_cummin/#details","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to  Int64 before summing to prevent overflow issues.</p> <p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code> </p> <p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to  Int64 before summing to prevent overflow issues.</p> <p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_cummin/#value","title":"Value","text":"<p>Expr</p> <p>Expr</p>"},{"location":"reference/Expr_cummin/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:4))$select(\npl$col(\"a\")$cummin()$alias(\"cummin\"),\npl$col(\"a\")$cummin(reverse=TRUE)$alias(\"cummin_reversed\")\n)\npl$DataFrame(list(a=1:4))$select(\npl$col(\"a\")$cummax()$alias(\"cummux\"),\npl$col(\"a\")$cummax(reverse=TRUE)$alias(\"cummax_reversed\")\n)\n</code></pre>"},{"location":"reference/Expr_cumprod/","title":"<code>Expr_cumprod</code>","text":"<p>Cumulative product</p>"},{"location":"reference/Expr_cumprod/#description","title":"Description","text":"<p>Get an array with the cumulative product computed at every element.</p>"},{"location":"reference/Expr_cumprod/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_cumprod/#usage","title":"Usage","text":"<pre><code>Expr_cumprod(reverse = FALSE)\n</code></pre>"},{"location":"reference/Expr_cumprod/#arguments","title":"Arguments","text":"Argument Description <code>reverse</code> bool, default FALSE, if true roll over vector from back to forth"},{"location":"reference/Expr_cumprod/#details","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to  Int64 before summing to prevent overflow issues.</p>"},{"location":"reference/Expr_cumprod/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_cumprod/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:4))$select(\npl$col(\"a\")$cumprod()$alias(\"cumprod\"),\npl$col(\"a\")$cumprod(reverse=TRUE)$alias(\"cumprod_reversed\")\n)\n</code></pre>"},{"location":"reference/Expr_cumsum/","title":"<code>Expr_cumsum</code>","text":"<p>Cumulative sum</p>"},{"location":"reference/Expr_cumsum/#description","title":"Description","text":"<p>Get an array with the cumulative sum computed at every element.</p>"},{"location":"reference/Expr_cumsum/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_cumsum/#usage","title":"Usage","text":"<pre><code>Expr_cumsum(reverse = FALSE)\n</code></pre>"},{"location":"reference/Expr_cumsum/#arguments","title":"Arguments","text":"Argument Description <code>reverse</code> bool, default FALSE, if true roll over vector from back to forth"},{"location":"reference/Expr_cumsum/#details","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to  Int64 before summing to prevent overflow issues.</p>"},{"location":"reference/Expr_cumsum/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_cumsum/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:4))$select(\npl$col(\"a\")$cumsum()$alias(\"cumsum\"),\npl$col(\"a\")$cumsum(reverse=TRUE)$alias(\"cumsum_reversed\")\n)\n</code></pre>"},{"location":"reference/Expr_cumulative_eval/","title":"<code>Expr_cumulative_eval</code>","text":"<p>Cumulative eval</p>"},{"location":"reference/Expr_cumulative_eval/#description","title":"Description","text":"<p>Run an expression over a sliding window that increases <code>1</code> slot every iteration.</p>"},{"location":"reference/Expr_cumulative_eval/#usage","title":"Usage","text":"<pre><code>Expr_cumulative_eval(expr, min_periods = 1L, parallel = FALSE)\n</code></pre>"},{"location":"reference/Expr_cumulative_eval/#arguments","title":"Arguments","text":"Argument Description <code>expr</code> Expression to evaluate <code>min_periods</code> Number of valid values there should be in the window before the expression is evaluated. valid values = <code>length - null_count</code> <code>parallel</code> Run in parallel. Don't do this in a groupby or another operation that already has much parallelization."},{"location":"reference/Expr_cumulative_eval/#details","title":"Details","text":"<p>Warnings</p> <p>This functionality is experimental and may change without it being considered a  breaking change.  This can be really slow as it can have <code>O(n^2)</code> complexity. Don't use this  for operations that visit all elements.</p>"},{"location":"reference/Expr_cumulative_eval/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_cumulative_eval/#examples","title":"Examples","text":"<pre><code>pl$lit(1:5)$cumulative_eval(pl$element()$first()-pl$element()$last() ** 2)$to_r()\n</code></pre>"},{"location":"reference/Expr_diff/","title":"<code>Expr_diff</code>","text":"<p>Diff</p>"},{"location":"reference/Expr_diff/#description","title":"Description","text":"<p>Calculate the n-th discrete difference.</p>"},{"location":"reference/Expr_diff/#usage","title":"Usage","text":"<pre><code>Expr_diff(n = 1, null_behavior = \"ignore\")\n</code></pre>"},{"location":"reference/Expr_diff/#arguments","title":"Arguments","text":"Argument Description <code>n</code> Integerish Number of slots to shift. <code>null_behavior</code> option default 'ignore', else 'drop'"},{"location":"reference/Expr_diff/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_diff/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list( a=c(20L,10L,30L,40L)))$select(\npl$col(\"a\")$diff()$alias(\"diff_default\"),\npl$col(\"a\")$diff(2,\"ignore\")$alias(\"diff_2_ignore\")\n)\n</code></pre>"},{"location":"reference/Expr_div/","title":"<code>Expr_div</code>","text":"<p>Div</p>"},{"location":"reference/Expr_div/#description","title":"Description","text":"<p>Divide</p>"},{"location":"reference/Expr_div/#usage","title":"Usage","text":"<pre><code>Expr_div(other)\nlist(list(\"/\"), list(\"Expr\"))(e1, e2)\n</code></pre>"},{"location":"reference/Expr_div/#arguments","title":"Arguments","text":"Argument Description <code>other</code> literal or Robj which can become a literal <code>e1</code> lhs Expr <code>e2</code> rhs Expr or anything which can become a literal Expression"},{"location":"reference/Expr_div/#value","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/Expr_div/#examples","title":"Examples","text":"<pre><code>#three syntaxes same result\npl$lit(5) / 10\npl$lit(5) / pl$lit(10)\npl$lit(5)$div(pl$lit(10))\n</code></pre>"},{"location":"reference/Expr_dot/","title":"<code>Expr_dot</code>","text":"<p>Dot product</p>"},{"location":"reference/Expr_dot/#description","title":"Description","text":"<p>Compute the dot/inner product between two Expressions.</p>"},{"location":"reference/Expr_dot/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_dot/#usage","title":"Usage","text":"<pre><code>Expr_dot(other)\n</code></pre>"},{"location":"reference/Expr_dot/#arguments","title":"Arguments","text":"Argument Description <code>other</code> Expr to compute dot product with."},{"location":"reference/Expr_dot/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_dot/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(\na=1:4,b=c(1,2,3,4),c=\"bob\"\n)$select(\npl$col(\"a\")$dot(pl$col(\"b\"))$alias(\"a dot b\"),\npl$col(\"a\")$dot(pl$col(\"a\"))$alias(\"a dot a\")\n)\n</code></pre>"},{"location":"reference/Expr_drop_nans/","title":"<code>Expr_drop_nans</code>","text":"<p>Drop NaN(s)</p>"},{"location":"reference/Expr_drop_nans/#description","title":"Description","text":"<p>Drop floating point NaN values.  Similar to R syntax <code>x[!is.nan(x)]</code></p>"},{"location":"reference/Expr_drop_nans/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_drop_nans/#usage","title":"Usage","text":"<pre><code>Expr_drop_nans\n</code></pre>"},{"location":"reference/Expr_drop_nans/#details","title":"Details","text":"<p>Note that NaN values are not null values! (null corrosponds to R NA, not R NULL)  To drop null values, use method <code>drop_nulls</code> .</p> <p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_drop_nans/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_drop_nans/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,2,NaN,NA)))$select(pl$col(\"x\")$drop_nans())\n</code></pre>"},{"location":"reference/Expr_drop_nulls/","title":"<code>Expr_drop_nulls</code>","text":"<p>Drop null(s)</p>"},{"location":"reference/Expr_drop_nulls/#description","title":"Description","text":"<p>Drop null values.  Similar to R syntax <code>x[!(is.na(x) &amp; !is.nan(x))]</code></p>"},{"location":"reference/Expr_drop_nulls/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_drop_nulls/#usage","title":"Usage","text":"<pre><code>Expr_drop_nulls\n</code></pre>"},{"location":"reference/Expr_drop_nulls/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_drop_nulls/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_drop_nulls/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,2,NaN,NA)))$select(pl$col(\"x\")$drop_nulls())\n</code></pre>"},{"location":"reference/Expr_dt/","title":"<code>Expr_dt</code>","text":"<p>dt: datetime related methods</p>"},{"location":"reference/Expr_dt/#description","title":"Description","text":"<p>Create an object namespace of all datetime related methods.  See the individual method pages for full details</p>"},{"location":"reference/Expr_dt/#usage","title":"Usage","text":"<pre><code>Expr_dt()\n</code></pre>"},{"location":"reference/Expr_dt/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_dt/#examples","title":"Examples","text":"<pre><code>#missing\n</code></pre>"},{"location":"reference/Expr_entropy/","title":"<code>Expr_entropy</code>","text":"<p>Entropy</p>"},{"location":"reference/Expr_entropy/#description","title":"Description","text":"<p>Computes the entropy.  Uses the formula <code>-sum(pk * log(pk))</code> where <code>pk</code> are discrete probabilities.  Return Null if input is not values</p>"},{"location":"reference/Expr_entropy/#usage","title":"Usage","text":"<pre><code>Expr_entropy(base = base::exp(1), normalize = TRUE)\n</code></pre>"},{"location":"reference/Expr_entropy/#arguments","title":"Arguments","text":"Argument Description <code>base</code> Given exponential base, defaults to <code>e</code> <code>normalize</code> Normalize pk if it doesn't sum to 1."},{"location":"reference/Expr_entropy/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_entropy/#examples","title":"Examples","text":"<pre><code>pl$select(pl$lit(c(\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"))$unique_counts()$entropy(base=2))\n</code></pre>"},{"location":"reference/Expr_eq/","title":"<code>Expr_eq</code>","text":"<p>Equal ==</p>"},{"location":"reference/Expr_eq/#description","title":"Description","text":"<p>eq method and operator</p>"},{"location":"reference/Expr_eq/#usage","title":"Usage","text":"<pre><code>Expr_eq(other)\nlist(list(\"==\"), list(\"Expr\"))(e1, e2)\n</code></pre>"},{"location":"reference/Expr_eq/#arguments","title":"Arguments","text":"Argument Description <code>other</code> literal or Robj which can become a literal <code>e1</code> lhs Expr <code>e2</code> rhs Expr or anything which can become a literal Expression"},{"location":"reference/Expr_eq/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_eq/#value","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/Expr_eq/#examples","title":"Examples","text":"<pre><code>#' #three syntaxes same result\npl$lit(2) == 2\npl$lit(2) ==  pl$lit(2)\npl$lit(2)$eq(pl$lit(2))\n</code></pre>"},{"location":"reference/Expr_ewm_mean_std_var/","title":"<code>Expr_ewm_mean_std_var</code>","text":"<p>Exponentially-weighted moving average/std/var.</p>"},{"location":"reference/Expr_ewm_mean_std_var/#description","title":"Description","text":"<p>Exponentially-weighted moving average/std/var.</p> <p>Ewm_std</p> <p>Ewm_var</p>"},{"location":"reference/Expr_ewm_mean_std_var/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_ewm_mean_std_var/#usage","title":"Usage","text":"<pre><code>Expr_ewm_mean(\ncom = NULL,\nspan = NULL,\nhalf_life = NULL,\nalpha = NULL,\nadjust = TRUE,\nmin_periods = 1L,\nignore_nulls = TRUE\n)\nExpr_ewm_std(\ncom = NULL,\nspan = NULL,\nhalf_life = NULL,\nalpha = NULL,\nadjust = TRUE,\nbias = FALSE,\nmin_periods = 1L,\nignore_nulls = TRUE\n)\nExpr_ewm_var(\ncom = NULL,\nspan = NULL,\nhalf_life = NULL,\nalpha = NULL,\nadjust = TRUE,\nbias = FALSE,\nmin_periods = 1L,\nignore_nulls = TRUE\n)\n</code></pre>"},{"location":"reference/Expr_ewm_mean_std_var/#arguments","title":"Arguments","text":"Argument Description <code>com</code> Specify decay in terms of center of mass, $\\gamma$ , with $$$  \\alpha = \\frac{1}{1 + \\gamma} \\; \\forall \\; \\gamma \\geq 0$$  $ <code>span</code> Specify decay in terms of span, $\\theta$ , with $\\alpha = \\frac{2}{\\theta + 1} \\; \\forall \\; \\theta \\geq 1 $ <code>half_life</code> Specify decay in terms of half-life, :math: \\lambda , with $ \\alpha = 1 - \\exp \\left{ \\frac{ -\\ln(2) }{ \\lambda } \\right} $  $ \\forall \\; \\lambda &gt; 0$ <code>alpha</code> Specify smoothing factor alpha directly, $0 &lt; \\alpha \\leq 1$ . <code>adjust</code> Divide by decaying adjustment factor in beginning periods to account for imbalance in relative weightings <ul> <li> <p>When <code>adjust=TRUE</code> the EW function is calculated using weights $w_i = (1 - \\alpha)^i  $  </p> </li> <li> <p>When <code>adjust=FALSE</code> the EW function is calculated recursively by $$$  y_0 = x_0 \\$$  y_t = (1 - \\alpha)y_{t - 1} + \\alpha x_t$  <code>min_periods</code>     |     Minimum number of observations in window required to have a value (otherwise result is null). <code>ignore_nulls</code>     |     ignore_nulls Ignore missing values when calculating weights.  </p> </li> <li> <p>When <code>ignore_nulls=FALSE</code> (default), weights are based on absolute positions. For example, the weights of :math: <code>x_0</code> and :math: <code>x_2</code> used in calculating the final weighted average of <code>[</code>  $x_0$ , None, $x_2$ \\ ] are $1-\\alpha)^2$ and $1$ if <code>adjust=TRUE</code> , and $(1-\\alpha)^2$ and $\\alpha$ if <code>adjust=FALSE</code> . </p> </li> <li> <p>When <code>ignore_nulls=TRUE</code> , weights are based on relative positions. For example, the weights of $x_0$ and $x_2$ used in calculating the final weighted average of <code>[</code>  $x_0$ , None, $x_2$ ] are $1-\\alpha$ and $1$ if <code>adjust=TRUE</code> , and $1-\\alpha$ and $\\alpha$ if <code>adjust=FALSE</code> . <code>bias</code>     |     When bias=FALSE`, apply a correction to make the estimate statistically unbiased.</p> </li> </ul>"},{"location":"reference/Expr_ewm_mean_std_var/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_ewm_mean_std_var/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a = 1:3)$select(pl$col(\"a\")$ewm_mean(com=1))\npl$DataFrame(a = 1:3)$select(pl$col(\"a\")$ewm_std(com=1))\npl$DataFrame(a = 1:3)$select(pl$col(\"a\")$ewm_std(com=1))\n</code></pre>"},{"location":"reference/Expr_exclude/","title":"<code>Expr_exclude</code>","text":"<p>Exclude certain columns from a wildcard/regex selection.</p>"},{"location":"reference/Expr_exclude/#description","title":"Description","text":"<p>You may also use regexes in the exclude list. They must start with <code>^</code> and end with <code>$</code> .</p>"},{"location":"reference/Expr_exclude/#usage","title":"Usage","text":"<pre><code>Expr_exclude(columns)\n</code></pre>"},{"location":"reference/Expr_exclude/#arguments","title":"Arguments","text":"Argument Description <code>columns</code> given param type: <ul> <li> <p>string: exclude name of column or exclude regex starting with ^and ending with$ </p> </li> <li> <p>character vector: exclude all these column names, no regex allowed </p> </li> <li> <p>DataType: Exclude any of this DataType </p> </li> <li> <p>List(DataType): Excldue any of these DataType(s)</p> </li> </ul>"},{"location":"reference/Expr_exclude/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_exclude/#examples","title":"Examples","text":"<pre><code>#make DataFrame\ndf = pl$DataFrame(iris)\n#by name(s)\ndf$select(pl$all()$exclude(\"Species\"))\n#by type\ndf$select(pl$all()$exclude(pl$Categorical))\ndf$select(pl$all()$exclude(list(pl$Categorical,pl$Float64)))\n#by regex\ndf$select(pl$all()$exclude(\"^Sepal.*$\"))\n</code></pre>"},{"location":"reference/Expr_exp/","title":"<code>Expr_exp</code>","text":"<p>Compute the exponential, element-wise.</p>"},{"location":"reference/Expr_exp/#description","title":"Description","text":"<p>Compute the exponential, element-wise.</p>"},{"location":"reference/Expr_exp/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_exp/#usage","title":"Usage","text":"<pre><code>Expr_exp\n</code></pre>"},{"location":"reference/Expr_exp/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_exp/#examples","title":"Examples","text":"<pre><code>log10123 = suppressWarnings(log(-1:3))\nall.equal(\npl$DataFrame(list(a = log10123))$select(pl$col(\"a\")$exp())$as_data_frame()$a,\nexp(1)^log10123\n)\n</code></pre>"},{"location":"reference/Expr_explode/","title":"<code>Expr_explode</code>","text":"<p>Explode a list or utf8 Series.</p>"},{"location":"reference/Expr_explode/#description","title":"Description","text":"<p>This means that every item is expanded to a new row.</p> <p>( flatten is an alias for explode )</p>"},{"location":"reference/Expr_explode/#format","title":"Format","text":"<p>a method</p> <p>a method</p>"},{"location":"reference/Expr_explode/#usage","title":"Usage","text":"<pre><code>Expr_explode\nExpr_flatten\n</code></pre>"},{"location":"reference/Expr_explode/#details","title":"Details","text":"<p>explode/flatten does not support categorical</p>"},{"location":"reference/Expr_explode/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_explode/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=letters))$select(pl$col(\"a\")$explode()$take(0:5))\nlisted_group_df =  pl$DataFrame(iris[c(1:3,51:53),])$groupby(\"Species\")$agg(pl$all())\nprint(listed_group_df)\nvectors_df = listed_group_df$select(\npl$col(c(\"Sepal.Width\",\"Sepal.Length\"))$explode()\n)\nprint(vectors_df)\n</code></pre>"},{"location":"reference/Expr_extend_constant/","title":"<code>Expr_extend_constant</code>","text":"<p>Extend_constant</p>"},{"location":"reference/Expr_extend_constant/#description","title":"Description","text":"<p>Extend the Series with given number of values.</p>"},{"location":"reference/Expr_extend_constant/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_extend_constant/#usage","title":"Usage","text":"<pre><code>Expr_extend_constant(value, n)\n</code></pre>"},{"location":"reference/Expr_extend_constant/#arguments","title":"Arguments","text":"Argument Description <code>value</code> The value to extend the Series with. This value may be None to fill with nulls. <code>n</code> The number of values to extend."},{"location":"reference/Expr_extend_constant/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_extend_constant/#examples","title":"Examples","text":"<pre><code>pl$select(\npl$lit(c(\"5\",\"Bob_is_not_a_number\"))\n$cast(pl$dtypes$UInt64, strict = FALSE)\n$extend_constant(10.1, 2)\n)\npl$select(\npl$lit(c(\"5\",\"Bob_is_not_a_number\"))\n$cast(pl$dtypes$Utf8, strict = FALSE)\n$extend_constant(\"chuchu\", 2)\n)\n</code></pre>"},{"location":"reference/Expr_extend_expr/","title":"<code>Expr_extend_expr</code>","text":"<p>Extend_expr</p>"},{"location":"reference/Expr_extend_expr/#description","title":"Description","text":"<p>Extend the Series with a expression repeated a number of times</p>"},{"location":"reference/Expr_extend_expr/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_extend_expr/#usage","title":"Usage","text":"<pre><code>Expr_extend_expr(value, n)\n</code></pre>"},{"location":"reference/Expr_extend_expr/#arguments","title":"Arguments","text":"Argument Description <code>value</code> The expr to extend the Series with. This value may be None to fill with nulls. <code>n</code> The number of values to extend."},{"location":"reference/Expr_extend_expr/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_extend_expr/#examples","title":"Examples","text":"<pre><code>pl$select(\npl$lit(c(\"5\",\"Bob_is_not_a_number\"))\n$cast(pl$dtypes$UInt64, strict = FALSE)\n$extend_expr(10.1, 2)\n)\npl$select(\npl$lit(c(\"5\",\"Bob_is_not_a_number\"))\n$cast(pl$dtypes$Utf8, strict = FALSE)\n$extend_expr(\"chuchu\", 2)\n)\n</code></pre>"},{"location":"reference/Expr_fill_nan/","title":"<code>Expr_fill_nan</code>","text":"<p>Fill Nulls Forward</p>"},{"location":"reference/Expr_fill_nan/#description","title":"Description","text":"<p>Fill missing values with last seen values.</p>"},{"location":"reference/Expr_fill_nan/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_fill_nan/#usage","title":"Usage","text":"<pre><code>Expr_fill_nan(expr = NULL)\n</code></pre>"},{"location":"reference/Expr_fill_nan/#arguments","title":"Arguments","text":"Argument Description <code>expr</code> Expr or into Expr, value to fill NaNs with"},{"location":"reference/Expr_fill_nan/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_fill_nan/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_fill_nan/#examples","title":"Examples","text":"<pre><code>l = list(a=c(1,NaN,NaN,3))\npl$DataFrame(l)$select(\npl$col(\"a\")$fill_nan()$alias(\"fill_default\"),\npl$col(\"a\")$fill_nan(pl$lit(NA))$alias(\"fill_NA\"), #same as default\npl$col(\"a\")$fill_nan(2)$alias(\"fill_float2\"),\npl$col(\"a\")$fill_nan(\"hej\")$alias(\"fill_str\") #implicit cast to Utf8\n)$to_list()\n</code></pre>"},{"location":"reference/Expr_fill_null/","title":"<code>Expr_fill_null</code>","text":"<p>Fill Nulls with a value or strategy.</p>"},{"location":"reference/Expr_fill_null/#description","title":"Description","text":"<p>Shift the values by value or as strategy.</p>"},{"location":"reference/Expr_fill_null/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_fill_null/#usage","title":"Usage","text":"<pre><code>Expr_fill_null(value = NULL, strategy = NULL, limit = NULL)\n</code></pre>"},{"location":"reference/Expr_fill_null/#arguments","title":"Arguments","text":"Argument Description <code>value</code> Expr or Into to fill Null values with <code>strategy</code> default NULL else 'forward', 'backward', 'min', 'max', 'mean', 'zero', 'one' <code>limit</code> Number of consecutive null values to fill when using the 'forward' or 'backward' strategy."},{"location":"reference/Expr_fill_null/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_fill_null/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_fill_null/#examples","title":"Examples","text":"<pre><code>pl$select(\npl$lit(0:3)$shift_and_fill(-2, fill_value = 42)$alias(\"shift-2\"),\npl$lit(0:3)$shift_and_fill(2, fill_value = pl$lit(42)/2)$alias(\"shift+2\")\n)\n</code></pre>"},{"location":"reference/Expr_filter/","title":"<code>Expr_filter</code>","text":"<p>Filter a single column.</p>"},{"location":"reference/Expr_filter/#description","title":"Description","text":"<p>Mostly useful in an aggregation context. If you want to filter on a DataFrame  level, use <code>LazyFrame.filter</code> .</p> <p>where() is an alias for pl$filter</p>"},{"location":"reference/Expr_filter/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_filter/#usage","title":"Usage","text":"<pre><code>Expr_filter(predicate)\nExpr_where(predicate)\n</code></pre>"},{"location":"reference/Expr_filter/#arguments","title":"Arguments","text":"Argument Description <code>predicate</code> Expr or something Into . Should be a boolean expression."},{"location":"reference/Expr_filter/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_filter/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(\ngroup_col =  c(\"g1\", \"g1\", \"g2\"),\nb = c(1, 2, 3)\n))\ndf$groupby(\"group_col\")$agg(\npl$col(\"b\")$filter(pl$col(\"b\") &lt; 2)$sum()$alias(\"lt\"),\npl$col(\"b\")$filter(pl$col(\"b\") &gt;= 2)$sum()$alias(\"gte\")\n)\n</code></pre>"},{"location":"reference/Expr_first/","title":"<code>Expr_first</code>","text":"<p>First</p>"},{"location":"reference/Expr_first/#description","title":"Description","text":"<p>Get the first value.  Similar to R head(x,1)</p>"},{"location":"reference/Expr_first/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_first/#usage","title":"Usage","text":"<pre><code>Expr_first\n</code></pre>"},{"location":"reference/Expr_first/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_first/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,2,3)))$select(pl$col(\"x\")$first())\n</code></pre>"},{"location":"reference/Expr_floor/","title":"<code>Expr_floor</code>","text":"<p>Floor</p>"},{"location":"reference/Expr_floor/#description","title":"Description","text":"<p>Rounds down to the nearest integer value.  Only works on floating point Series.</p>"},{"location":"reference/Expr_floor/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_floor/#usage","title":"Usage","text":"<pre><code>Expr_floor\n</code></pre>"},{"location":"reference/Expr_floor/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_floor/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(0.33, 0.5, 1.02, 1.5, NaN , NA, Inf, -Inf)\n))$select(\npl$col(\"a\")$floor()\n)\n</code></pre>"},{"location":"reference/Expr_forward_fill/","title":"<code>Expr_forward_fill</code>","text":"<p>Fill Nulls Forward</p>"},{"location":"reference/Expr_forward_fill/#description","title":"Description","text":"<p>Fill missing values with last seen values.</p>"},{"location":"reference/Expr_forward_fill/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_forward_fill/#usage","title":"Usage","text":"<pre><code>Expr_forward_fill(limit = NULL)\n</code></pre>"},{"location":"reference/Expr_forward_fill/#arguments","title":"Arguments","text":"Argument Description <code>limit</code> Expr or Into The number of consecutive null values to forward fill."},{"location":"reference/Expr_forward_fill/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_forward_fill/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_forward_fill/#examples","title":"Examples","text":"<pre><code>l = list(a=c(1L,rep(NA_integer_,3L),10))\npl$DataFrame(l)$select(\npl$col(\"a\")$forward_fill()$alias(\"ff_null\"),\npl$col(\"a\")$forward_fill(limit = 0)$alias(\"ff_l0\"),\npl$col(\"a\")$forward_fill(limit = 1)$alias(\"ff_l1\")\n)$to_list()\n</code></pre>"},{"location":"reference/Expr_gt/","title":"<code>Expr_gt</code>","text":"<p>GreaterThan &lt;</p>"},{"location":"reference/Expr_gt/#description","title":"Description","text":"<p>gt method and operator</p>"},{"location":"reference/Expr_gt/#usage","title":"Usage","text":"<pre><code>Expr_gt(other)\nlist(list(\"&gt;\"), list(\"Expr\"))(e1, e2)\n</code></pre>"},{"location":"reference/Expr_gt/#arguments","title":"Arguments","text":"Argument Description <code>other</code> literal or Robj which can become a literal <code>e1</code> lhs Expr <code>e2</code> rhs Expr or anything which can become a literal Expression"},{"location":"reference/Expr_gt/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_gt/#value","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/Expr_gt/#examples","title":"Examples","text":"<pre><code>#' #three syntaxes same result\npl$lit(2) &gt; 1\npl$lit(2) &gt; pl$lit(1)\npl$lit(2)$gt(pl$lit(1))\n</code></pre>"},{"location":"reference/Expr_gt_eq/","title":"<code>Expr_gt_eq</code>","text":"<p>Greater Than Or Equal &lt;=</p>"},{"location":"reference/Expr_gt_eq/#description","title":"Description","text":"<p>gt_eq method and operator</p>"},{"location":"reference/Expr_gt_eq/#usage","title":"Usage","text":"<pre><code>Expr_gt_eq(other)\nlist(list(\"&gt;=\"), list(\"Expr\"))(e1, e2)\n</code></pre>"},{"location":"reference/Expr_gt_eq/#arguments","title":"Arguments","text":"Argument Description <code>other</code> literal or Robj which can become a literal <code>e1</code> lhs Expr <code>e2</code> rhs Expr or anything which can become a literal Expression"},{"location":"reference/Expr_gt_eq/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_gt_eq/#value","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/Expr_gt_eq/#examples","title":"Examples","text":"<pre><code>#' #three syntaxes same result\npl$lit(2) &gt;= 2\npl$lit(2) &gt;=  pl$lit(2)\npl$lit(2)$gt_eq(pl$lit(2))\n</code></pre>"},{"location":"reference/Expr_hash/","title":"<code>Expr_hash</code>","text":"<p>hash</p>"},{"location":"reference/Expr_hash/#description","title":"Description","text":"<p>Hash the elements in the selection.  The hash value is of type <code>UInt64</code> .</p>"},{"location":"reference/Expr_hash/#usage","title":"Usage","text":"<pre><code>Expr_hash(seed = 0, seed_1 = NULL, seed_2 = NULL, seed_3 = NULL)\n</code></pre>"},{"location":"reference/Expr_hash/#arguments","title":"Arguments","text":"Argument Description <code>seed</code> Random seed parameter. Defaults to 0. <code>seed_1</code> Random seed parameter. Defaults to arg seed. <code>seed_2</code> Random seed parameter. Defaults to arg seed. <code>seed_3</code> Random seed parameter. Defaults to arg seed. The column will be coerced to UInt32. Give this dtype to make the coercion a no-op."},{"location":"reference/Expr_hash/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_hash/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris)\ndf$select(pl$all()$head(2)$hash(1234)$cast(pl$Utf8))$to_list()\n</code></pre>"},{"location":"reference/Expr_head/","title":"<code>Expr_head</code>","text":"<p>Head</p>"},{"location":"reference/Expr_head/#description","title":"Description","text":"<p>Get the head n elements.  Similar to R head(x)</p>"},{"location":"reference/Expr_head/#usage","title":"Usage","text":"<pre><code>Expr_head(n = 10)\n</code></pre>"},{"location":"reference/Expr_head/#arguments","title":"Arguments","text":"Argument Description <code>n</code> numeric number of elements to select from head"},{"location":"reference/Expr_head/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_head/#examples","title":"Examples","text":"<pre><code>#get 3 first elements\npl$DataFrame(list(x=1:11))$select(pl$col(\"x\")$head(3))\n</code></pre>"},{"location":"reference/Expr_inspect/","title":"<code>Expr_inspect</code>","text":"<p>Inspect evaluated Series</p>"},{"location":"reference/Expr_inspect/#description","title":"Description","text":"<p>Print the value that this expression evaluates to and pass on the value.  The printing will happen when the expression evaluates, not when it is formed.</p>"},{"location":"reference/Expr_inspect/#usage","title":"Usage","text":"<pre><code>Expr_inspect(fmt = \"{}\")\n</code></pre>"},{"location":"reference/Expr_inspect/#arguments","title":"Arguments","text":"Argument Description <code>fmt</code> format string, should contain one set of <code>{}</code> where object will be printed This formatting mimics python \"string\".format() use in pypolars. The string can contain any thing but should have exactly one set of curly bracket list() ."},{"location":"reference/Expr_inspect/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_inspect/#examples","title":"Examples","text":"<pre><code>pl$select(pl$lit(1:5)$inspect(\n\"before dropping half the column it was:{}and not it is dropped\")$head(2)\n)\n</code></pre>"},{"location":"reference/Expr_interpolate/","title":"<code>Expr_interpolate</code>","text":"<p>Interpolate <code>Nulls</code></p>"},{"location":"reference/Expr_interpolate/#description","title":"Description","text":"<p>Fill nulls with linear interpolation over missing values.  Can also be used to regrid data to a new grid - see examples below.</p>"},{"location":"reference/Expr_interpolate/#usage","title":"Usage","text":"<pre><code>Expr_interpolate(method = \"linear\")\n</code></pre>"},{"location":"reference/Expr_interpolate/#arguments","title":"Arguments","text":"Argument Description <code>method</code> string 'linear' or 'nearest', default \"linear\""},{"location":"reference/Expr_interpolate/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_interpolate/#examples","title":"Examples","text":"<pre><code>pl$select(pl$lit(c(1,NA,4,NA,100,NaN,150))$interpolate())\n#x, y interpolation over a grid\ndf_original_grid = pl$DataFrame(list(\ngrid_points = c(1, 3, 10),\nvalues = c(2.0, 6.0, 20.0)\n))\ndf_new_grid = pl$DataFrame(list(grid_points = (1:10)*1.0))\n# Interpolate from this to the new grid\ndf_new_grid$join(\ndf_original_grid, on=\"grid_points\", how=\"left\"\n)$with_columns(pl$col(\"values\")$interpolate())\n</code></pre>"},{"location":"reference/Expr_is_between/","title":"<code>Expr_is_between</code>","text":"<p>is in between</p>"},{"location":"reference/Expr_is_between/#description","title":"Description","text":"<p>Check if this expression is between start and end.</p>"},{"location":"reference/Expr_is_between/#usage","title":"Usage","text":"<pre><code>Expr_is_between(start, end, include_bounds = FALSE)\n</code></pre>"},{"location":"reference/Expr_is_between/#arguments","title":"Arguments","text":"Argument Description <code>start</code> Lower bound as primitive or datetime <code>end</code> Lower bound as primitive or datetime <code>include_bounds</code> bool vector or scalar: FALSE:           Exclude both start and end (default). TRUE:            Include both start and end. c(FALSE, FALSE):  Exclude start and exclude end. c(TRUE, TRUE):    Include start and include end. c(FALSE, TRUE):   Exclude start and include end. c(TRUE, FALSE):   Include start and exclude end."},{"location":"reference/Expr_is_between/#details","title":"Details","text":"<p>alias the column to 'in_between'  This function is equivalent to a combination of &lt; &lt;= &gt;= and the &amp;-and operator.</p>"},{"location":"reference/Expr_is_between/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_is_between/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(num = 1:5))\ndf$select(pl$col(\"num\")$is_between(2,4))\ndf$select(pl$col(\"num\")$is_between(2,4,TRUE))\ndf$select(pl$col(\"num\")$is_between(2,4,c(FALSE, TRUE)))\n#start end can be a vector/expr with same length as column\ndf$select(pl$col(\"num\")$is_between(c(0,2,3,3,3),6))\n</code></pre>"},{"location":"reference/Expr_is_duplicated/","title":"<code>Expr_is_duplicated</code>","text":"<p>Get mask of duplicated values.</p>"},{"location":"reference/Expr_is_duplicated/#description","title":"Description","text":"<p>Get mask of duplicated values.</p>"},{"location":"reference/Expr_is_duplicated/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_is_duplicated/#usage","title":"Usage","text":"<pre><code>Expr_is_duplicated\n</code></pre>"},{"location":"reference/Expr_is_duplicated/#details","title":"Details","text":"<p>is_duplicated is the opposite of <code>is_unique()</code>   Looking for R like <code>duplicated()</code> ?, use <code>some_expr$is_first()$is_not()</code></p>"},{"location":"reference/Expr_is_duplicated/#value","title":"Value","text":"<p>Expr (boolean)</p>"},{"location":"reference/Expr_is_duplicated/#examples","title":"Examples","text":"<pre><code>v = c(1,1,2,2,3,NA,NaN,Inf)\nall.equal(\npl$select(\npl$lit(v)$is_unique()$alias(\"is_unique\"),\npl$lit(v)$is_first()$alias(\"is_first\"),\npl$lit(v)$is_duplicated()$alias(\"is_duplicated\"),\npl$lit(v)$is_first()$is_not()$alias(\"R_duplicated\")\n)$to_list(),\nlist(\nis_unique = !v %in% v[duplicated(v)],\nis_first  = !duplicated(v),\nis_duplicated = v %in% v[duplicated(v)],\nR_duplicated = duplicated(v)\n)\n)\n</code></pre>"},{"location":"reference/Expr_is_finite/","title":"<code>Expr_is_finite</code>","text":"<p>Are elements finite</p>"},{"location":"reference/Expr_is_finite/#description","title":"Description","text":"<p>Returns a boolean output indicating which values are finite.</p>"},{"location":"reference/Expr_is_finite/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_is_finite/#usage","title":"Usage","text":"<pre><code>Expr_is_finite\n</code></pre>"},{"location":"reference/Expr_is_finite/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_is_finite/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_is_finite/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(alice=c(0,NaN,NA,Inf,-Inf)))$select(pl$col(\"alice\")$is_finite())\n</code></pre>"},{"location":"reference/Expr_is_first/","title":"<code>Expr_is_first</code>","text":"<p>Get a mask of the first unique value.</p>"},{"location":"reference/Expr_is_first/#description","title":"Description","text":"<p>Get a mask of the first unique value.</p>"},{"location":"reference/Expr_is_first/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_is_first/#usage","title":"Usage","text":"<pre><code>Expr_is_first\n</code></pre>"},{"location":"reference/Expr_is_first/#value","title":"Value","text":"<p>Expr (boolean)</p>"},{"location":"reference/Expr_is_first/#examples","title":"Examples","text":"<pre><code>v = c(1,1,2,2,3,NA,NaN,Inf)\nall.equal(\npl$select(\npl$lit(v)$is_unique()$alias(\"is_unique\"),\npl$lit(v)$is_first()$alias(\"is_first\"),\npl$lit(v)$is_duplicated()$alias(\"is_duplicated\"),\npl$lit(v)$is_first()$is_not()$alias(\"R_duplicated\")\n)$to_list(),\nlist(\nis_unique = !v %in% v[duplicated(v)],\nis_first  = !duplicated(v),\nis_duplicated = v %in% v[duplicated(v)],\nR_duplicated = duplicated(v)\n)\n)\n</code></pre>"},{"location":"reference/Expr_is_in/","title":"<code>Expr_is_in</code>","text":"<p>is_in</p>"},{"location":"reference/Expr_is_in/#description","title":"Description","text":"<p>combine to boolean expresions with similar to <code>%in%</code></p>"},{"location":"reference/Expr_is_in/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_is_in/#usage","title":"Usage","text":"<pre><code>Expr_is_in(other)\n</code></pre>"},{"location":"reference/Expr_is_in/#arguments","title":"Arguments","text":"Argument Description <code>other</code> literal or Robj which can become a literal"},{"location":"reference/Expr_is_in/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_is_in/#examples","title":"Examples","text":"<pre><code>#R Na_integer -&gt; polars Null(Int32) is in polars Null(Int32)\npl$DataFrame(list(a=c(1:4,NA_integer_)))$select(\npl$col(\"a\")$is_in(pl$lit(NA_real_))\n)$as_data_frame()[[1L]]\n</code></pre>"},{"location":"reference/Expr_is_infinite/","title":"<code>Expr_is_infinite</code>","text":"<p>Are elements infinite</p>"},{"location":"reference/Expr_is_infinite/#description","title":"Description","text":"<p>Returns a boolean output indicating which values are infinite.</p>"},{"location":"reference/Expr_is_infinite/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_is_infinite/#usage","title":"Usage","text":"<pre><code>Expr_is_infinite\n</code></pre>"},{"location":"reference/Expr_is_infinite/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_is_infinite/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_is_infinite/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(alice=c(0,NaN,NA,Inf,-Inf)))$select(pl$col(\"alice\")$is_infinite())\n</code></pre>"},{"location":"reference/Expr_is_nan/","title":"<code>Expr_is_nan</code>","text":"<p>Are elements NaN's</p>"},{"location":"reference/Expr_is_nan/#description","title":"Description","text":"<p>Returns a boolean Series indicating which values are NaN.</p>"},{"location":"reference/Expr_is_nan/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_is_nan/#usage","title":"Usage","text":"<pre><code>Expr_is_nan\n</code></pre>"},{"location":"reference/Expr_is_nan/#details","title":"Details","text":"<p>Floating point NaN's are a different flag from Null(polars) which is the same as  NA_real_(R).  See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_is_nan/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_is_nan/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(alice=c(0,NaN,NA,Inf,-Inf)))$select(pl$col(\"alice\")$is_nan())\n</code></pre>"},{"location":"reference/Expr_is_not/","title":"<code>Expr_is_not</code>","text":"<p>Not !</p>"},{"location":"reference/Expr_is_not/#description","title":"Description","text":"<p>not method and operator</p>"},{"location":"reference/Expr_is_not/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_is_not/#usage","title":"Usage","text":"<pre><code>Expr_is_not(other)\nlist(list(\"!\"), list(\"Expr\"))(x)\n</code></pre>"},{"location":"reference/Expr_is_not/#arguments","title":"Arguments","text":"Argument Description <code>x</code> Expr <code>other</code> literal or Robj which can become a literal"},{"location":"reference/Expr_is_not/#value","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/Expr_is_not/#examples","title":"Examples","text":"<pre><code>#two syntaxes same result\npl$lit(TRUE)$is_not()\n!pl$lit(TRUE)\n</code></pre>"},{"location":"reference/Expr_is_not_nan/","title":"<code>Expr_is_not_nan</code>","text":"<p>Are elements not NaN's</p>"},{"location":"reference/Expr_is_not_nan/#description","title":"Description","text":"<p>Returns a boolean Series indicating which values are not NaN.</p>"},{"location":"reference/Expr_is_not_nan/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_is_not_nan/#usage","title":"Usage","text":"<pre><code>Expr_is_not_nan\n</code></pre>"},{"location":"reference/Expr_is_not_nan/#details","title":"Details","text":"<p>Floating point NaN's are a different flag from Null(polars) which is the same as  NA_real_(R).</p> <p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_is_not_nan/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_is_not_nan/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(alice=c(0,NaN,NA,Inf,-Inf)))$select(pl$col(\"alice\")$is_not_nan())\n</code></pre>"},{"location":"reference/Expr_is_not_null/","title":"<code>Expr_is_not_null</code>","text":"<p>is_not_null</p>"},{"location":"reference/Expr_is_not_null/#description","title":"Description","text":"<p>Returns a boolean Series indicating which values are not null.  Similar to R syntax !is.na(x)  null polars about the same as R NA</p>"},{"location":"reference/Expr_is_not_null/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_is_not_null/#usage","title":"Usage","text":"<pre><code>Expr_is_not_null\n</code></pre>"},{"location":"reference/Expr_is_not_null/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_is_not_null/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_is_not_null/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NA,3)))$select(pl$col(\"x\")$is_not_null())\n</code></pre>"},{"location":"reference/Expr_is_null/","title":"<code>Expr_is_null</code>","text":"<p>is_null</p>"},{"location":"reference/Expr_is_null/#description","title":"Description","text":"<p>Returns a boolean Series indicating which values are null.  Similar to R syntax is.na(x)  null polars about the same as R NA</p>"},{"location":"reference/Expr_is_null/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_is_null/#usage","title":"Usage","text":"<pre><code>Expr_is_null\n</code></pre>"},{"location":"reference/Expr_is_null/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_is_null/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_is_null/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NA,3)))$select(pl$col(\"x\")$is_null())\n</code></pre>"},{"location":"reference/Expr_is_unique/","title":"<code>Expr_is_unique</code>","text":"<p>Get mask of unique values</p>"},{"location":"reference/Expr_is_unique/#description","title":"Description","text":"<p>Get mask of unique values</p>"},{"location":"reference/Expr_is_unique/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_is_unique/#usage","title":"Usage","text":"<pre><code>Expr_is_unique\n</code></pre>"},{"location":"reference/Expr_is_unique/#value","title":"Value","text":"<p>Expr (boolean)</p>"},{"location":"reference/Expr_is_unique/#examples","title":"Examples","text":"<pre><code>v = c(1,1,2,2,3,NA,NaN,Inf)\nall.equal(\npl$select(\npl$lit(v)$is_unique()$alias(\"is_unique\"),\npl$lit(v)$is_first()$alias(\"is_first\"),\npl$lit(v)$is_duplicated()$alias(\"is_duplicated\"),\npl$lit(v)$is_first()$is_not()$alias(\"R_duplicated\")\n)$to_list(),\nlist(\nis_unique = !v %in% v[duplicated(v)],\nis_first  = !duplicated(v),\nis_duplicated = v %in% v[duplicated(v)],\nR_duplicated = duplicated(v)\n)\n)\n</code></pre>"},{"location":"reference/Expr_keep_name/","title":"<code>Expr_keep_name</code>","text":"<p>Keep the original root name of the expression.</p>"},{"location":"reference/Expr_keep_name/#description","title":"Description","text":"<p>Keep the original root name of the expression.</p>"},{"location":"reference/Expr_keep_name/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_keep_name/#usage","title":"Usage","text":"<pre><code>Expr_keep_name\n</code></pre>"},{"location":"reference/Expr_keep_name/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_keep_name/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(alice=1:3))$select(pl$col(\"alice\")$alias(\"bob\")$keep_name())\n</code></pre>"},{"location":"reference/Expr_kurtosis/","title":"<code>Expr_kurtosis</code>","text":"<p>Kurtosis</p>"},{"location":"reference/Expr_kurtosis/#description","title":"Description","text":"<p>Compute the kurtosis (Fisher or Pearson) of a dataset.</p>"},{"location":"reference/Expr_kurtosis/#usage","title":"Usage","text":"<pre><code>Expr_kurtosis(fisher = TRUE, bias = TRUE)\n</code></pre>"},{"location":"reference/Expr_kurtosis/#arguments","title":"Arguments","text":"Argument Description <code>fisher</code> bool se details <code>bias</code> bool, If FALSE, then the calculations are corrected for statistical bias."},{"location":"reference/Expr_kurtosis/#details","title":"Details","text":"<p>Kurtosis is the fourth central moment divided by the square of the  variance. If Fisher's definition is used, then 3.0 is subtracted from  the result to give 0.0 for a normal distribution.  If bias is False then the kurtosis is calculated using k statistics to  eliminate bias coming from biased moment estimators  See scipy.stats for more information</p> <p>#' See scipy.stats for more information.</p>"},{"location":"reference/Expr_kurtosis/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_kurtosis/#references","title":"References","text":"<p>https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.kurtosis.html?highlight=kurtosis</p>"},{"location":"reference/Expr_kurtosis/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list( a=c(1:3,2:1)))\ndf$select(pl$col(\"a\")$kurtosis())\n</code></pre>"},{"location":"reference/Expr_last/","title":"<code>Expr_last</code>","text":"<p>Last</p>"},{"location":"reference/Expr_last/#description","title":"Description","text":"<p>Get the lastvalue.  Similar to R syntax tail(x,1)</p>"},{"location":"reference/Expr_last/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_last/#usage","title":"Usage","text":"<pre><code>Expr_last\n</code></pre>"},{"location":"reference/Expr_last/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_last/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,2,3)))$select(pl$col(\"x\")$last())\n</code></pre>"},{"location":"reference/Expr_limit/","title":"<code>Expr_limit</code>","text":"<p>Limit</p>"},{"location":"reference/Expr_limit/#description","title":"Description","text":"<p>Alias for Head  Get the head n elements.  Similar to R head(x)</p>"},{"location":"reference/Expr_limit/#usage","title":"Usage","text":"<pre><code>Expr_limit(n = 10)\n</code></pre>"},{"location":"reference/Expr_limit/#arguments","title":"Arguments","text":"Argument Description <code>n</code> numeric number of elements to select from head"},{"location":"reference/Expr_limit/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_limit/#examples","title":"Examples","text":"<pre><code>#get 3 first elements\npl$DataFrame(list(x=1:11))$select(pl$col(\"x\")$limit(3))\n</code></pre>"},{"location":"reference/Expr_list/","title":"<code>Expr_list</code>","text":"<p>Wrap column in list</p>"},{"location":"reference/Expr_list/#description","title":"Description","text":"<p>Aggregate to list.</p>"},{"location":"reference/Expr_list/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_list/#usage","title":"Usage","text":"<pre><code>Expr_list\n</code></pre>"},{"location":"reference/Expr_list/#details","title":"Details","text":"<p>use to_struct to wrap a DataFrame</p>"},{"location":"reference/Expr_list/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_list/#examples","title":"Examples","text":"<pre><code>pl$select(pl$lit(1:4)$list(), pl$lit(c(\"a\")))\n</code></pre>"},{"location":"reference/Expr_lit_to_df/","title":"<code>Expr_lit_to_df</code>","text":"<p>Literal to DataFrame</p>"},{"location":"reference/Expr_lit_to_df/#description","title":"Description","text":"<p>collect an expression based on literals into a DataFrame</p>"},{"location":"reference/Expr_lit_to_df/#usage","title":"Usage","text":"<pre><code>Expr_lit_to_df()\n</code></pre>"},{"location":"reference/Expr_lit_to_df/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Expr_lit_to_df/#examples","title":"Examples","text":"<pre><code>(\npl$Series(list(1:1, 1:2, 1:3, 1:4))\n$print()\n$to_lit()\n$arr$lengths()\n$sum()\n$cast(pl$dtypes$Int8)\n$lit_to_df()\n)\n</code></pre>"},{"location":"reference/Expr_lit_to_s/","title":"<code>Expr_lit_to_s</code>","text":"<p>Literal to Series</p>"},{"location":"reference/Expr_lit_to_s/#description","title":"Description","text":"<p>collect an expression based on literals into a Series</p>"},{"location":"reference/Expr_lit_to_s/#usage","title":"Usage","text":"<pre><code>Expr_lit_to_s()\n</code></pre>"},{"location":"reference/Expr_lit_to_s/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Expr_lit_to_s/#examples","title":"Examples","text":"<pre><code>(\npl$Series(list(1:1, 1:2, 1:3, 1:4))\n$print()\n$to_lit()\n$arr$lengths()\n$sum()\n$cast(pl$dtypes$Int8)\n$lit_to_s()\n)\n</code></pre>"},{"location":"reference/Expr_log/","title":"<code>Expr_log</code>","text":"<p>Natural Log</p>"},{"location":"reference/Expr_log/#description","title":"Description","text":"<p>Compute the base x logarithm of the input array, element-wise.</p>"},{"location":"reference/Expr_log/#usage","title":"Usage","text":"<pre><code>Expr_log(base = base::exp(1))\n</code></pre>"},{"location":"reference/Expr_log/#arguments","title":"Arguments","text":"Argument Description <code>base</code> numeric base value for log, default base::exp(1)"},{"location":"reference/Expr_log/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_log/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a = exp(1)^(-1:3)))$select(pl$col(\"a\")$log())\n</code></pre>"},{"location":"reference/Expr_log10/","title":"<code>Expr_log10</code>","text":"<p>10-base log</p>"},{"location":"reference/Expr_log10/#description","title":"Description","text":"<p>Compute the base 10 logarithm of the input array, element-wise.</p>"},{"location":"reference/Expr_log10/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_log10/#usage","title":"Usage","text":"<pre><code>Expr_log10\n</code></pre>"},{"location":"reference/Expr_log10/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_log10/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a = 10^(-1:3)))$select(pl$col(\"a\")$log10())\n</code></pre>"},{"location":"reference/Expr_lt/","title":"<code>Expr_lt</code>","text":"<p>Less Than &lt;</p>"},{"location":"reference/Expr_lt/#description","title":"Description","text":"<p>lt method and operator</p>"},{"location":"reference/Expr_lt/#usage","title":"Usage","text":"<pre><code>Expr_lt(other)\nlist(list(\"&lt;\"), list(\"Expr\"))(e1, e2)\n</code></pre>"},{"location":"reference/Expr_lt/#arguments","title":"Arguments","text":"Argument Description <code>other</code> literal or Robj which can become a literal <code>e1</code> lhs Expr <code>e2</code> rhs Expr or anything which can become a literal Expression"},{"location":"reference/Expr_lt/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_lt/#value","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/Expr_lt/#examples","title":"Examples","text":"<pre><code>#' #three syntaxes same result\npl$lit(5) &lt; 10\npl$lit(5) &lt; pl$lit(10)\npl$lit(5)$lt(pl$lit(10))\n</code></pre>"},{"location":"reference/Expr_lt_eq/","title":"<code>Expr_lt_eq</code>","text":"<p>Less Than Or Equal &lt;=</p>"},{"location":"reference/Expr_lt_eq/#description","title":"Description","text":"<p>lt_eq method and operator</p>"},{"location":"reference/Expr_lt_eq/#usage","title":"Usage","text":"<pre><code>Expr_lt_eq(other)\nlist(list(\"&lt;=\"), list(\"Expr\"))(e1, e2)\n</code></pre>"},{"location":"reference/Expr_lt_eq/#arguments","title":"Arguments","text":"Argument Description <code>other</code> literal or Robj which can become a literal <code>e1</code> lhs Expr <code>e2</code> rhs Expr or anything which can become a literal Expression"},{"location":"reference/Expr_lt_eq/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_lt_eq/#value","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/Expr_lt_eq/#examples","title":"Examples","text":"<pre><code>#' #three syntaxes same result\npl$lit(2) &lt;= 2\npl$lit(2) &lt;=  pl$lit(2)\npl$lit(2)$lt_eq(pl$lit(2))\n</code></pre>"},{"location":"reference/Expr_map/","title":"<code>Expr_map</code>","text":"<p>Expr_map</p>"},{"location":"reference/Expr_map/#description","title":"Description","text":"<p>Expr_map</p>"},{"location":"reference/Expr_map/#usage","title":"Usage","text":"<pre><code>Expr_map(f, output_type = NULL, agg_list = FALSE)\n</code></pre>"},{"location":"reference/Expr_map/#arguments","title":"Arguments","text":"Argument Description <code>f</code> a function mapping a series <code>output_type</code> NULL or one of pl$dtypes$..., the output datatype, NULL is the same as input. <code>agg_list</code> Aggregate list. Map from vector to group in groupby context. Likely not so useful."},{"location":"reference/Expr_map/#details","title":"Details","text":"<p>user function return should be a series or any Robj convertable into a Series.  In PyPolars likely return must be Series. User functions do fully support <code>browser()</code> , helpful to  investigate.</p>"},{"location":"reference/Expr_map/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_map/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$select(pl$col(\"Sepal.Length\")$map(\\(x) {\npaste(\"cheese\",as.character(x$to_r_vector()))\n}, pl$dtypes$Utf8))\n</code></pre>"},{"location":"reference/Expr_map_alias/","title":"<code>Expr_map_alias</code>","text":"<p>Map alias of expression with an R function</p>"},{"location":"reference/Expr_map_alias/#description","title":"Description","text":"<p>Rename the output of an expression by mapping a function over the root name.</p>"},{"location":"reference/Expr_map_alias/#usage","title":"Usage","text":"<pre><code>Expr_map_alias(fun)\n</code></pre>"},{"location":"reference/Expr_map_alias/#arguments","title":"Arguments","text":"Argument Description <code>fun</code> an R function which takes a string as input and return a string"},{"location":"reference/Expr_map_alias/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_map_alias/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(alice=1:3))$select(\npl$col(\"alice\")$alias(\"joe_is_not_root\")$map_alias(\\(x) paste0(x,\"_and_bob\"))\n)\n</code></pre>"},{"location":"reference/Expr_max/","title":"<code>Expr_max</code>","text":"<p>max</p>"},{"location":"reference/Expr_max/#description","title":"Description","text":"<p>Get maximum value.</p>"},{"location":"reference/Expr_max/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_max/#usage","title":"Usage","text":"<pre><code>Expr_max\n</code></pre>"},{"location":"reference/Expr_max/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_max/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_max/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NA,3)))$select(pl$col(\"x\")$max() == 3) #is true\n</code></pre>"},{"location":"reference/Expr_mean/","title":"<code>Expr_mean</code>","text":"<p>mean</p>"},{"location":"reference/Expr_mean/#description","title":"Description","text":"<p>Get mean value.</p>"},{"location":"reference/Expr_mean/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_mean/#usage","title":"Usage","text":"<pre><code>Expr_mean\n</code></pre>"},{"location":"reference/Expr_mean/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_mean/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NA,3)))$select(pl$col(\"x\")$mean()==2) #is true\n</code></pre>"},{"location":"reference/Expr_median/","title":"<code>Expr_median</code>","text":"<p>median</p>"},{"location":"reference/Expr_median/#description","title":"Description","text":"<p>Get median value.</p>"},{"location":"reference/Expr_median/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_median/#usage","title":"Usage","text":"<pre><code>Expr_median\n</code></pre>"},{"location":"reference/Expr_median/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_median/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NA,2)))$select(pl$col(\"x\")$median()==1.5) #is true\n</code></pre>"},{"location":"reference/Expr_meta/","title":"<code>Expr_meta</code>","text":"<p>meta: related methods</p>"},{"location":"reference/Expr_meta/#description","title":"Description","text":"<p>Create an object namespace of all meta related methods.  See the individual method pages for full details</p>"},{"location":"reference/Expr_meta/#usage","title":"Usage","text":"<pre><code>Expr_meta()\n</code></pre>"},{"location":"reference/Expr_meta/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_meta/#examples","title":"Examples","text":"<pre><code>#missing\n</code></pre>"},{"location":"reference/Expr_min/","title":"<code>Expr_min</code>","text":"<p>min</p>"},{"location":"reference/Expr_min/#description","title":"Description","text":"<p>Get minimum value.</p>"},{"location":"reference/Expr_min/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_min/#usage","title":"Usage","text":"<pre><code>Expr_min\n</code></pre>"},{"location":"reference/Expr_min/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_min/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_min/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NA,3)))$select(pl$col(\"x\")$min()== 1 ) #is true\n</code></pre>"},{"location":"reference/Expr_mode/","title":"<code>Expr_mode</code>","text":"<p>Mode</p>"},{"location":"reference/Expr_mode/#description","title":"Description","text":"<p>Compute the most occurring value(s). Can return multiple Values.</p>"},{"location":"reference/Expr_mode/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_mode/#usage","title":"Usage","text":"<pre><code>Expr_mode\n</code></pre>"},{"location":"reference/Expr_mode/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_mode/#examples","title":"Examples","text":"<pre><code>df =pl$DataFrame(list(a=1:6,b = c(1L,1L,3L,3L,5L,6L), c = c(1L,1L,2L,2L,3L,3L)))\ndf$select(pl$col(\"a\")$mode())\ndf$select(pl$col(\"b\")$mode())\ndf$select(pl$col(\"c\")$mode())\n</code></pre>"},{"location":"reference/Expr_mul/","title":"<code>Expr_mul</code>","text":"<p>Mul *</p>"},{"location":"reference/Expr_mul/#description","title":"Description","text":"<p>Multiplication</p>"},{"location":"reference/Expr_mul/#usage","title":"Usage","text":"<pre><code>Expr_mul(other)\nlist(list(\"*\"), list(\"Expr\"))(e1, e2)\n</code></pre>"},{"location":"reference/Expr_mul/#arguments","title":"Arguments","text":"Argument Description <code>other</code> literal or Robj which can become a literal <code>e1</code> lhs Expr <code>e2</code> rhs Expr or anything which can become a literal Expression"},{"location":"reference/Expr_mul/#value","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/Expr_mul/#examples","title":"Examples","text":"<pre><code>#three syntaxes same result\npl$lit(5) * 10\npl$lit(5) * pl$lit(10)\npl$lit(5)$mul(pl$lit(10))\n</code></pre>"},{"location":"reference/Expr_n_unique/","title":"<code>Expr_n_unique</code>","text":"<p>Count number of unique values</p>"},{"location":"reference/Expr_n_unique/#description","title":"Description","text":"<p>Count number of unique values.  Similar to R length(unique(x))</p>"},{"location":"reference/Expr_n_unique/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_n_unique/#usage","title":"Usage","text":"<pre><code>Expr_n_unique\n</code></pre>"},{"location":"reference/Expr_n_unique/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_n_unique/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$select(pl$col(\"Species\")$n_unique())\n</code></pre>"},{"location":"reference/Expr_nan_max/","title":"<code>Expr_nan_max</code>","text":"<p>max</p>"},{"location":"reference/Expr_nan_max/#description","title":"Description","text":"<p>Get maximum value, but propagate/poison encountered <code>NaN</code> values.  Get maximum value.</p>"},{"location":"reference/Expr_nan_max/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_nan_max/#usage","title":"Usage","text":"<pre><code>Expr_nan_max\n</code></pre>"},{"location":"reference/Expr_nan_max/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_nan_max/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_nan_max/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NaN,Inf,3)))$select(pl$col(\"x\")$nan_max()$is_nan()) #is true\n</code></pre>"},{"location":"reference/Expr_nan_min/","title":"<code>Expr_nan_min</code>","text":"<p>min propagate NaN</p>"},{"location":"reference/Expr_nan_min/#description","title":"Description","text":"<p>Get minimum value, but propagate/poison encountered <code>NaN</code> values.</p>"},{"location":"reference/Expr_nan_min/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_nan_min/#usage","title":"Usage","text":"<pre><code>Expr_nan_min\n</code></pre>"},{"location":"reference/Expr_nan_min/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_nan_min/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_nan_min/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,NaN,-Inf,3)))$select(pl$col(\"x\")$nan_min()$is_nan()) #is true\n</code></pre>"},{"location":"reference/Expr_neq/","title":"<code>Expr_neq</code>","text":"<p>Not Equal !=</p>"},{"location":"reference/Expr_neq/#description","title":"Description","text":"<p>neq method and operator</p>"},{"location":"reference/Expr_neq/#usage","title":"Usage","text":"<pre><code>Expr_neq(other)\nlist(list(\"!=\"), list(\"Expr\"))(e1, e2)\n</code></pre>"},{"location":"reference/Expr_neq/#arguments","title":"Arguments","text":"Argument Description <code>other</code> literal or Robj which can become a literal <code>e1</code> lhs Expr <code>e2</code> rhs Expr or anything which can become a literal Expression"},{"location":"reference/Expr_neq/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_neq/#value","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/Expr_neq/#examples","title":"Examples","text":"<pre><code>#' #three syntaxes same result\npl$lit(1) != 2\npl$lit(1) !=  pl$lit(2)\npl$lit(1)$neq(pl$lit(2))\n</code></pre>"},{"location":"reference/Expr_null_count/","title":"<code>Expr_null_count</code>","text":"<p>Count <code>Nulls</code></p>"},{"location":"reference/Expr_null_count/#description","title":"Description","text":"<p>Count <code>Nulls</code></p>"},{"location":"reference/Expr_null_count/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_null_count/#usage","title":"Usage","text":"<pre><code>Expr_null_count\n</code></pre>"},{"location":"reference/Expr_null_count/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_null_count/#examples","title":"Examples","text":"<pre><code>pl$select(pl$lit(c(NA,\"a\",NA,\"b\"))$null_count())\n</code></pre>"},{"location":"reference/Expr_or/","title":"<code>Expr_or</code>","text":"<p>Or</p>"},{"location":"reference/Expr_or/#description","title":"Description","text":"<p>combine to boolean expresions with OR</p>"},{"location":"reference/Expr_or/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_or/#usage","title":"Usage","text":"<pre><code>Expr_or(other)\n</code></pre>"},{"location":"reference/Expr_or/#arguments","title":"Arguments","text":"Argument Description <code>other</code> Expr or into Expr"},{"location":"reference/Expr_or/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_or/#examples","title":"Examples","text":"<pre><code>pl$lit(TRUE) | FALSE\npl$lit(TRUE)$or(pl$lit(TRUE))\n</code></pre>"},{"location":"reference/Expr_over/","title":"<code>Expr_over</code>","text":"<p>over</p>"},{"location":"reference/Expr_over/#description","title":"Description","text":"<p>Apply window function over a subgroup.  This is similar to a groupby + aggregation + self join.  Or similar to window functions in Postgres https://www.postgresql.org/docs/current/tutorial-window.html _.</p>"},{"location":"reference/Expr_over/#usage","title":"Usage","text":"<pre><code>Expr_over(...)\n</code></pre>"},{"location":"reference/Expr_over/#arguments","title":"Arguments","text":"Argument Description <code>...</code> of strings or columns to group by"},{"location":"reference/Expr_over/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_over/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(\nval = 1:5,\na = c(\"+\",\"+\",\"-\",\"-\",\"+\"),\nb = c(\"+\",\"-\",\"+\",\"-\",\"+\")\n)$select(\npl$col(\"val\")$count()$over(\"a\",\"b\")\n)\n</code></pre>"},{"location":"reference/Expr_pct_change/","title":"<code>Expr_pct_change</code>","text":"<p>Pct change</p>"},{"location":"reference/Expr_pct_change/#description","title":"Description","text":"<p>Computes percentage change between values.  Percentage change (as fraction) between current element and most-recent  non-null element at least <code>n</code> period(s) before the current element.  Computes the change from the previous row by default.</p>"},{"location":"reference/Expr_pct_change/#usage","title":"Usage","text":"<pre><code>Expr_pct_change(n = 1)\n</code></pre>"},{"location":"reference/Expr_pct_change/#arguments","title":"Arguments","text":"Argument Description <code>n</code> periods to shift for forming percent change."},{"location":"reference/Expr_pct_change/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_pct_change/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list( a=c(10L, 11L, 12L, NA_integer_, 12L)))\ndf$with_column(pl$col(\"a\")$pct_change()$alias(\"pct_change\"))\n</code></pre>"},{"location":"reference/Expr_pow/","title":"<code>Expr_pow</code>","text":"<p>Exponentiation <code>^</code> or **</p>"},{"location":"reference/Expr_pow/#description","title":"Description","text":"<p>Raise expression to the power of exponent.</p>"},{"location":"reference/Expr_pow/#usage","title":"Usage","text":"<pre><code>Expr_pow(exponent)\n</code></pre>"},{"location":"reference/Expr_pow/#arguments","title":"Arguments","text":"Argument Description <code>exponent</code> exponent"},{"location":"reference/Expr_pow/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_pow/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a= -1:3)$select(\npl$lit(2)$pow(pl$col(\"a\"))\n)$get_column(\"literal\")$to_r()== 2^(-1:3)\npl$DataFrame(a = -1:3)$select(\npl$lit(2) ^ (pl$col(\"a\"))\n)$get_column(\"literal\")$to_r()== 2^(-1:3)\n</code></pre>"},{"location":"reference/Expr_product/","title":"<code>Expr_product</code>","text":"<p>Product</p>"},{"location":"reference/Expr_product/#description","title":"Description","text":"<p>Compute the product of an expression.</p>"},{"location":"reference/Expr_product/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_product/#usage","title":"Usage","text":"<pre><code>Expr_product\n</code></pre>"},{"location":"reference/Expr_product/#details","title":"Details","text":"<p>does not support integer32 currently, .cast() to f64 or i64 first.</p>"},{"location":"reference/Expr_product/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_product/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1,2,3)))$select(pl$col(\"x\")$product()==6) #is true\n</code></pre>"},{"location":"reference/Expr_quantile/","title":"<code>Expr_quantile</code>","text":"<p>Get quantile value.</p>"},{"location":"reference/Expr_quantile/#description","title":"Description","text":"<p>Get quantile value.</p>"},{"location":"reference/Expr_quantile/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_quantile/#usage","title":"Usage","text":"<pre><code>Expr_quantile(quantile, interpolation = \"nearest\")\n</code></pre>"},{"location":"reference/Expr_quantile/#arguments","title":"Arguments","text":"Argument Description <code>quantile</code> numeric/Expression 0.0 to 1.0 <code>interpolation</code> string value from choices \"nearest\", \"higher\", \"lower\", \"midpoint\", \"linear\""},{"location":"reference/Expr_quantile/#details","title":"Details","text":"<p><code>Nulls</code> are ignored and <code>NaNs</code> are ranked as the largest value.  For linear interpolation <code>NaN</code> poisons <code>Inf</code> , that poisons any other value.</p>"},{"location":"reference/Expr_quantile/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_quantile/#examples","title":"Examples","text":"<pre><code>pl$select(pl$lit(-5:5)$quantile(.5))\n</code></pre>"},{"location":"reference/Expr_rank/","title":"<code>Expr_rank</code>","text":"<p>Rank</p>"},{"location":"reference/Expr_rank/#description","title":"Description","text":"<p>Assign ranks to data, dealing with ties appropriately.</p>"},{"location":"reference/Expr_rank/#usage","title":"Usage","text":"<pre><code>Expr_rank(method = \"average\", reverse = FALSE)\n</code></pre>"},{"location":"reference/Expr_rank/#arguments","title":"Arguments","text":"Argument Description <code>method</code> string option 'average', 'min', 'max', 'dense', 'ordinal', 'random'  #' The method used to assign ranks to tied elements. The following methods are available (default is 'average'): <ul> <li> <p>'average' : The average of the ranks that would have been assigned to all the tied values is assigned to each value. </p> </li> <li> <p>'min' : The minimum of the ranks that would have been assigned to all the tied values is assigned to each value. (This is also referred to as \"competition\" ranking.) </p> </li> <li> <p>'max' : The maximum of the ranks that would have been assigned to all the tied values is assigned to each value. </p> </li> <li> <p>'dense' : Like 'min', but the rank of the next highest element is assigned the rank immediately after those assigned to the tied elements. </p> </li> <li> <p>'ordinal' : All values are given a distinct rank, corresponding to the order that the values occur in the Series. </p> </li> <li> <p>'random' : Like 'ordinal', but the rank for ties is not dependent on the order that the values occur in the Series. <code>reverse</code>     |     bool, reverse the operation</p> </li> </ul>"},{"location":"reference/Expr_rank/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_rank/#examples","title":"Examples","text":"<pre><code>#  The 'average' method:\ndf = pl$DataFrame(list(a = c(3, 6, 1, 1, 6)))\ndf$select(pl$col(\"a\")$rank())\n#  The 'ordinal' method:\ndf = pl$DataFrame(list(a = c(3, 6, 1, 1, 6)))\ndf$select(pl$col(\"a\")$rank(\"ordinal\"))\n</code></pre>"},{"location":"reference/Expr_rechunk/","title":"<code>Expr_rechunk</code>","text":"<p>Rechunk memory layout</p>"},{"location":"reference/Expr_rechunk/#description","title":"Description","text":"<p>Create a single chunk of memory for this Series.</p>"},{"location":"reference/Expr_rechunk/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_rechunk/#usage","title":"Usage","text":"<pre><code>Expr_rechunk\n</code></pre>"},{"location":"reference/Expr_rechunk/#details","title":"Details","text":"<p>See rechunk() explained here <code>docs_translations</code></p>"},{"location":"reference/Expr_rechunk/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_rechunk/#examples","title":"Examples","text":"<pre><code>#get chunked lengths with/without rechunk\nseries_list = pl$DataFrame(list(a=1:3,b=4:6))$select(\npl$col(\"a\")$append(pl$col(\"b\"))$alias(\"a_chunked\"),\npl$col(\"a\")$append(pl$col(\"b\"))$rechunk()$alias(\"a_rechunked\")\n)$get_columns()\nlapply(series_list, \\(x) x$chunk_lengths())\n</code></pre>"},{"location":"reference/Expr_reinterpret/","title":"<code>Expr_reinterpret</code>","text":"<p>reinterpret bits</p>"},{"location":"reference/Expr_reinterpret/#description","title":"Description","text":"<p>Reinterpret the underlying bits as a signed/unsigned integer.  This operation is only allowed for 64bit integers. For lower bits integers,  you can safely use that cast operation.</p>"},{"location":"reference/Expr_reinterpret/#usage","title":"Usage","text":"<pre><code>Expr_reinterpret(signed = TRUE)\n</code></pre>"},{"location":"reference/Expr_reinterpret/#arguments","title":"Arguments","text":"Argument Description <code>signed</code> bool reinterpret into Int64 else UInt64"},{"location":"reference/Expr_reinterpret/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_reinterpret/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris)\ndf$select(pl$all()$head(2)$hash(1,2,3,4)$reinterpret())$as_data_frame()\n</code></pre>"},{"location":"reference/Expr_rep/","title":"<code>Expr_rep</code>","text":"<p>expression: repeat series</p>"},{"location":"reference/Expr_rep/#description","title":"Description","text":"<p>This expression takes input and repeats it n times and append chunk</p>"},{"location":"reference/Expr_rep/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_rep/#usage","title":"Usage","text":"<pre><code>Expr_rep(n, rechunk = TRUE)\n</code></pre>"},{"location":"reference/Expr_rep/#arguments","title":"Arguments","text":"Argument Description <code>n</code> Numeric the number of times to repeat, must be non-negative and finite <code>rechunk</code> bool default = TRUE, if true memory layout will be rewritten"},{"location":"reference/Expr_rep/#details","title":"Details","text":"<p>if self$len() == 1 , has a special faster implementation,  Here rechunk is not  necessary, and takes no effect.</p> <p>if self$len() &gt; 1 , then the expression instructs the series to append onto  itself n time and rewrite memory</p>"},{"location":"reference/Expr_rep/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_rep/#examples","title":"Examples","text":"<pre><code>pl$select(\npl$lit(\"alice\")$rep(n = 3)\n)\npl$select(\npl$lit(1:3)$rep(n = 2)\n)\n</code></pre>"},{"location":"reference/Expr_rep_extend/","title":"<code>Expr_rep_extend</code>","text":"<p>extend series with repeated series</p>"},{"location":"reference/Expr_rep_extend/#description","title":"Description","text":"<p>Extend a series with a repeated series or value.</p>"},{"location":"reference/Expr_rep_extend/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_rep_extend/#usage","title":"Usage","text":"<pre><code>Expr_rep_extend(expr, n, rechunk = TRUE, upcast = TRUE)\n</code></pre>"},{"location":"reference/Expr_rep_extend/#arguments","title":"Arguments","text":"Argument Description <code>expr</code> Expr or into Expr <code>n</code> Numeric the number of times to repeat, must be non-negative and finite <code>rechunk</code> bool default = TRUE, if true memory layout will be rewritten <code>upcast</code> bool default = TRUE, passed to self$append(), if TRUE non identical types will be casted to common super type if any. If FALSE or no common super type throw error."},{"location":"reference/Expr_rep_extend/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_rep_extend/#examples","title":"Examples","text":"<pre><code>pl$select(pl$lit(c(1,2,3))$rep_extend(1:3, n = 5))\n</code></pre>"},{"location":"reference/Expr_repeat_by/","title":"<code>Expr_repeat_by</code>","text":"<p>Repeat by</p>"},{"location":"reference/Expr_repeat_by/#description","title":"Description","text":"<p>Repeat the elements in this Series as specified in the given expression.  The repeated elements are expanded into a <code>List</code> .</p>"},{"location":"reference/Expr_repeat_by/#usage","title":"Usage","text":"<pre><code>Expr_repeat_by(by)\n</code></pre>"},{"location":"reference/Expr_repeat_by/#arguments","title":"Arguments","text":"Argument Description <code>by</code> Expr Numeric column that determines how often the values will be repeated. The column will be coerced to UInt32. Give this dtype to make the coercion a no-op."},{"location":"reference/Expr_repeat_by/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_repeat_by/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = c(\"x\",\"y\",\"z\"), n = c(0:2)))\ndf$select(pl$col(\"a\")$repeat_by(\"n\"))\n</code></pre>"},{"location":"reference/Expr_reshape/","title":"<code>Expr_reshape</code>","text":"<p>Reshape</p>"},{"location":"reference/Expr_reshape/#description","title":"Description","text":"<p>Reshape this Expr to a flat Series or a Series of Lists.</p>"},{"location":"reference/Expr_reshape/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_reshape/#usage","title":"Usage","text":"<pre><code>Expr_reshape(dims)\n</code></pre>"},{"location":"reference/Expr_reshape/#arguments","title":"Arguments","text":"Argument Description <code>dims</code> numeric vec of the dimension sizes. If a -1 is used in any of the dimensions, that dimension is inferred."},{"location":"reference/Expr_reshape/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_reshape/#examples","title":"Examples","text":"<pre><code>pl$select(pl$lit(1:12)$reshape(c(3,4)))\npl$select(pl$lit(1:12)$reshape(c(3,-1)))\n</code></pre>"},{"location":"reference/Expr_rolling_max/","title":"<code>Expr_rolling_max</code>","text":"<p>Rolling max</p>"},{"location":"reference/Expr_rolling_max/#description","title":"Description","text":"<p>Apply a rolling max (moving max) over the values in this array.  A window of length <code>window_size</code> will traverse the array. The values that fill  this window will (optionally) be multiplied with the weights given by the  <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/Expr_rolling_max/#usage","title":"Usage","text":"<pre><code>Expr_rolling_max(\nwindow_size,\nweights = NULL,\nmin_periods = NULL,\ncenter = FALSE,\nby = NULL,\nclosed = \"left\"\n)\n</code></pre>"},{"location":"reference/Expr_rolling_max/#arguments","title":"Arguments","text":"Argument Description <code>window_size</code> The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: <ul> <li> <p>1ns   (1 nanosecond) </p> </li> <li> <p>1us   (1 microsecond) </p> </li> <li> <p>1ms   (1 millisecond) </p> </li> <li> <p>1s    (1 second) </p> </li> <li> <p>1m    (1 minute) </p> </li> <li> <p>1h    (1 hour) </p> </li> <li> <p>1d    (1 day) </p> </li> <li> <p>1w    (1 week) </p> </li> <li> <p>1mo   (1 calendar month) </p> </li> <li> <p>1y    (1 calendar year) </p> </li> <li> <p>1i    (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set. <code>weights</code>     |     An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. <code>min_periods</code>     |     The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. <code>center</code>     |     Set the labels at the center of the window <code>by</code>     |     If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} <code>closed</code>     |     : 'left', 'right', 'both', 'none'  Define whether the temporal window interval is closed or not.</p> </li> </ul>"},{"location":"reference/Expr_rolling_max/#details","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a  breaking change.  Notes:  If you want to compute multiple aggregation statistics over the same dynamic  window, consider using <code>groupby_rolling</code> this method can cache the window size  computation.</p>"},{"location":"reference/Expr_rolling_max/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_rolling_max/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(pl$col(\"a\")$rolling_max(window_size = 2))\n</code></pre>"},{"location":"reference/Expr_rolling_mean/","title":"<code>Expr_rolling_mean</code>","text":"<p>Rolling mean</p>"},{"location":"reference/Expr_rolling_mean/#description","title":"Description","text":"<p>Apply a rolling mean (moving mean) over the values in this array.  A window of length <code>window_size</code> will traverse the array. The values that fill  this window will (optionally) be multiplied with the weights given by the  <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/Expr_rolling_mean/#usage","title":"Usage","text":"<pre><code>Expr_rolling_mean(\nwindow_size,\nweights = NULL,\nmin_periods = NULL,\ncenter = FALSE,\nby = NULL,\nclosed = \"left\"\n)\n</code></pre>"},{"location":"reference/Expr_rolling_mean/#arguments","title":"Arguments","text":"Argument Description <code>window_size</code> The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: <ul> <li> <p>1ns   (1 nanosecond) </p> </li> <li> <p>1us   (1 microsecond) </p> </li> <li> <p>1ms   (1 millisecond) </p> </li> <li> <p>1s    (1 second) </p> </li> <li> <p>1m    (1 minute) </p> </li> <li> <p>1h    (1 hour) </p> </li> <li> <p>1d    (1 day) </p> </li> <li> <p>1w    (1 week) </p> </li> <li> <p>1mo   (1 calendar month) </p> </li> <li> <p>1y    (1 calendar year) </p> </li> <li> <p>1i    (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set. <code>weights</code>     |     An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. <code>min_periods</code>     |     The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. <code>center</code>     |     Set the labels at the center of the window <code>by</code>     |     If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} <code>closed</code>     |     : 'left', 'right', 'both', 'none'  Define whether the temporal window interval is closed or not.</p> </li> </ul>"},{"location":"reference/Expr_rolling_mean/#details","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a  breaking change.  Notes:  If you want to compute multiple aggregation statistics over the same dynamic  window, consider using <code>groupby_rolling</code> this method can cache the window size  computation.</p>"},{"location":"reference/Expr_rolling_mean/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_rolling_mean/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(pl$col(\"a\")$rolling_mean(window_size = 2))\n</code></pre>"},{"location":"reference/Expr_rolling_median/","title":"<code>Expr_rolling_median</code>","text":"<p>Rolling median</p>"},{"location":"reference/Expr_rolling_median/#description","title":"Description","text":"<p>Apply a rolling median (moving median) over the values in this array.  A window of length <code>window_size</code> will traverse the array. The values that fill  this window will (optionally) be multiplied with the weights given by the  <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/Expr_rolling_median/#usage","title":"Usage","text":"<pre><code>Expr_rolling_median(\nwindow_size,\nweights = NULL,\nmin_periods = NULL,\ncenter = FALSE,\nby = NULL,\nclosed = \"left\"\n)\n</code></pre>"},{"location":"reference/Expr_rolling_median/#arguments","title":"Arguments","text":"Argument Description <code>window_size</code> The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: <ul> <li> <p>1ns   (1 nanosecond) </p> </li> <li> <p>1us   (1 microsecond) </p> </li> <li> <p>1ms   (1 millisecond) </p> </li> <li> <p>1s    (1 second) </p> </li> <li> <p>1m    (1 minute) </p> </li> <li> <p>1h    (1 hour) </p> </li> <li> <p>1d    (1 day) </p> </li> <li> <p>1w    (1 week) </p> </li> <li> <p>1mo   (1 calendar month) </p> </li> <li> <p>1y    (1 calendar year) </p> </li> <li> <p>1i    (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set. <code>weights</code>     |     An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. <code>min_periods</code>     |     The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. <code>center</code>     |     Set the labels at the center of the window <code>by</code>     |     If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} <code>closed</code>     |     : 'left', 'right', 'both', 'none'  Define whether the temporal window interval is closed or not.</p> </li> </ul>"},{"location":"reference/Expr_rolling_median/#details","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a  breaking change.  Notes:  If you want to compute multiple aggregation statistics over the same dynamic  window, consider using <code>groupby_rolling</code> this method can cache the window size  computation.</p>"},{"location":"reference/Expr_rolling_median/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_rolling_median/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(pl$col(\"a\")$rolling_median(window_size = 2))\n</code></pre>"},{"location":"reference/Expr_rolling_min/","title":"<code>Expr_rolling_min</code>","text":"<p>Rolling Min</p>"},{"location":"reference/Expr_rolling_min/#description","title":"Description","text":"<p>Apply a rolling min (moving min) over the values in this array.  A window of length <code>window_size</code> will traverse the array. The values that fill  this window will (optionally) be multiplied with the weights given by the  <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/Expr_rolling_min/#usage","title":"Usage","text":"<pre><code>Expr_rolling_min(\nwindow_size,\nweights = NULL,\nmin_periods = NULL,\ncenter = FALSE,\nby = NULL,\nclosed = \"left\"\n)\n</code></pre>"},{"location":"reference/Expr_rolling_min/#arguments","title":"Arguments","text":"Argument Description <code>window_size</code> The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: <ul> <li> <p>1ns   (1 nanosecond) </p> </li> <li> <p>1us   (1 microsecond) </p> </li> <li> <p>1ms   (1 millisecond) </p> </li> <li> <p>1s    (1 second) </p> </li> <li> <p>1m    (1 minute) </p> </li> <li> <p>1h    (1 hour) </p> </li> <li> <p>1d    (1 day) </p> </li> <li> <p>1w    (1 week) </p> </li> <li> <p>1mo   (1 calendar month) </p> </li> <li> <p>1y    (1 calendar year) </p> </li> <li> <p>1i    (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set. <code>weights</code>     |     An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. <code>min_periods</code>     |     The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. <code>center</code>     |     Set the labels at the center of the window <code>by</code>     |     If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} <code>closed</code>     |     : 'left', 'right', 'both', 'none'  Define whether the temporal window interval is closed or not.</p> </li> </ul>"},{"location":"reference/Expr_rolling_min/#details","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a  breaking change.  Notes:  If you want to compute multiple aggregation statistics over the same dynamic  window, consider using <code>groupby_rolling</code> this method can cache the window size  computation.</p>"},{"location":"reference/Expr_rolling_min/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_rolling_min/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(pl$col(\"a\")$rolling_min(window_size = 2))\n</code></pre>"},{"location":"reference/Expr_rolling_quantile/","title":"<code>Expr_rolling_quantile</code>","text":"<p>Rolling quantile</p>"},{"location":"reference/Expr_rolling_quantile/#description","title":"Description","text":"<p>Apply a rolling quantile (moving quantile) over the values in this array.  A window of length <code>window_size</code> will traverse the array. The values that fill  this window will (optionally) be multiplied with the weights given by the  <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/Expr_rolling_quantile/#usage","title":"Usage","text":"<pre><code>Expr_rolling_quantile(\nquantile,\ninterpolation = \"nearest\",\nwindow_size,\nweights = NULL,\nmin_periods = NULL,\ncenter = FALSE,\nby = NULL,\nclosed = \"left\"\n)\n</code></pre>"},{"location":"reference/Expr_rolling_quantile/#arguments","title":"Arguments","text":"Argument Description <code>quantile</code> Quantile between 0.0 and 1.0. <code>interpolation</code> choice c('nearest', 'higher', 'lower', 'midpoint', 'linear') <code>window_size</code> The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: <ul> <li> <p>1ns   (1 nanosecond) </p> </li> <li> <p>1us   (1 microsecond) </p> </li> <li> <p>1ms   (1 millisecond) </p> </li> <li> <p>1s    (1 second) </p> </li> <li> <p>1m    (1 minute) </p> </li> <li> <p>1h    (1 hour) </p> </li> <li> <p>1d    (1 day) </p> </li> <li> <p>1w    (1 week) </p> </li> <li> <p>1mo   (1 calendar month) </p> </li> <li> <p>1y    (1 calendar year) </p> </li> <li> <p>1i    (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set. <code>weights</code>     |     An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. <code>min_periods</code>     |     The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. <code>center</code>     |     Set the labels at the center of the window <code>by</code>     |     If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} <code>closed</code>     |     : 'left', 'right', 'both', 'none'  Define whether the temporal window interval is closed or not.</p> </li> </ul>"},{"location":"reference/Expr_rolling_quantile/#details","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a  breaking change.  Notes:  If you want to compute multiple aggregation statistics over the same dynamic  window, consider using <code>groupby_rolling</code> this method can cache the window size  computation.</p>"},{"location":"reference/Expr_rolling_quantile/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_rolling_quantile/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(\npl$col(\"a\")$rolling_quantile(window_size = 2, quantile = .5)\n)\n</code></pre>"},{"location":"reference/Expr_rolling_skew/","title":"<code>Expr_rolling_skew</code>","text":"<p>Rolling skew</p>"},{"location":"reference/Expr_rolling_skew/#description","title":"Description","text":"<p>Compute a rolling skew.</p>"},{"location":"reference/Expr_rolling_skew/#usage","title":"Usage","text":"<pre><code>Expr_rolling_skew(window_size, bias = TRUE)\n</code></pre>"},{"location":"reference/Expr_rolling_skew/#arguments","title":"Arguments","text":"Argument Description <code>window_size</code> integerish, Size of the rolling window <code>bias</code> bool default = TRUE,  If False, then the calculations are corrected for statistical bias."},{"location":"reference/Expr_rolling_skew/#details","title":"Details","text":"<p>Extra comments copied from rust-polars_0.25.1  Compute the sample skewness of a data set.</p> <p>For normally distributed data, the skewness should be about zero. For  uni-modal continuous distributions, a skewness value greater than zero means  that there is more weight in the right tail of the distribution. The  function <code>skewtest</code> can be used to determine if the skewness value  is close enough to zero, statistically speaking.  see: https://github.com/scipy/scipy/blob/47bb6febaa10658c72962b9615d5d5aa2513fa3a/scipy/stats/stats.py#L1024</p>"},{"location":"reference/Expr_rolling_skew/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_rolling_skew/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=iris$Sepal.Length))$select(pl$col(\"a\")$rolling_skew(window_size = 4 )$head(10))\n</code></pre>"},{"location":"reference/Expr_rolling_std/","title":"<code>Expr_rolling_std</code>","text":"<p>Rolling std</p>"},{"location":"reference/Expr_rolling_std/#description","title":"Description","text":"<p>Apply a rolling std (moving std) over the values in this array.  A window of length <code>window_size</code> will traverse the array. The values that fill  this window will (optionally) be multiplied with the weights given by the  <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/Expr_rolling_std/#usage","title":"Usage","text":"<pre><code>Expr_rolling_std(\nwindow_size,\nweights = NULL,\nmin_periods = NULL,\ncenter = FALSE,\nby = NULL,\nclosed = \"left\"\n)\n</code></pre>"},{"location":"reference/Expr_rolling_std/#arguments","title":"Arguments","text":"Argument Description <code>window_size</code> The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: <ul> <li> <p>1ns   (1 nanosecond) </p> </li> <li> <p>1us   (1 microsecond) </p> </li> <li> <p>1ms   (1 millisecond) </p> </li> <li> <p>1s    (1 second) </p> </li> <li> <p>1m    (1 minute) </p> </li> <li> <p>1h    (1 hour) </p> </li> <li> <p>1d    (1 day) </p> </li> <li> <p>1w    (1 week) </p> </li> <li> <p>1mo   (1 calendar month) </p> </li> <li> <p>1y    (1 calendar year) </p> </li> <li> <p>1i    (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set. <code>weights</code>     |     An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. <code>min_periods</code>     |     The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. <code>center</code>     |     Set the labels at the center of the window <code>by</code>     |     If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} <code>closed</code>     |     : 'left', 'right', 'both', 'none'  Define whether the temporal window interval is closed or not.</p> </li> </ul>"},{"location":"reference/Expr_rolling_std/#details","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a  breaking change.  Notes:  If you want to compute multiple aggregation statistics over the same dynamic  window, consider using <code>groupby_rolling</code> this method can cache the window size  computation.</p>"},{"location":"reference/Expr_rolling_std/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_rolling_std/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(pl$col(\"a\")$rolling_std(window_size = 2))\n</code></pre>"},{"location":"reference/Expr_rolling_sum/","title":"<code>Expr_rolling_sum</code>","text":"<p>Rolling sum</p>"},{"location":"reference/Expr_rolling_sum/#description","title":"Description","text":"<p>Apply a rolling sum (moving sum) over the values in this array.  A window of length <code>window_size</code> will traverse the array. The values that fill  this window will (optionally) be multiplied with the weights given by the  <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/Expr_rolling_sum/#usage","title":"Usage","text":"<pre><code>Expr_rolling_sum(\nwindow_size,\nweights = NULL,\nmin_periods = NULL,\ncenter = FALSE,\nby = NULL,\nclosed = \"left\"\n)\n</code></pre>"},{"location":"reference/Expr_rolling_sum/#arguments","title":"Arguments","text":"Argument Description <code>window_size</code> The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: <ul> <li> <p>1ns   (1 nanosecond) </p> </li> <li> <p>1us   (1 microsecond) </p> </li> <li> <p>1ms   (1 millisecond) </p> </li> <li> <p>1s    (1 second) </p> </li> <li> <p>1m    (1 minute) </p> </li> <li> <p>1h    (1 hour) </p> </li> <li> <p>1d    (1 day) </p> </li> <li> <p>1w    (1 week) </p> </li> <li> <p>1mo   (1 calendar month) </p> </li> <li> <p>1y    (1 calendar year) </p> </li> <li> <p>1i    (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set. <code>weights</code>     |     An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. <code>min_periods</code>     |     The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. <code>center</code>     |     Set the labels at the center of the window <code>by</code>     |     If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} <code>closed</code>     |     : 'left', 'right', 'both', 'none'  Define whether the temporal window interval is closed or not.</p> </li> </ul>"},{"location":"reference/Expr_rolling_sum/#details","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a  breaking change.  Notes:  If you want to compute multiple aggregation statistics over the same dynamic  window, consider using <code>groupby_rolling</code> this method can cache the window size  computation.</p>"},{"location":"reference/Expr_rolling_sum/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_rolling_sum/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(pl$col(\"a\")$rolling_sum(window_size = 2))\n</code></pre>"},{"location":"reference/Expr_rolling_var/","title":"<code>Expr_rolling_var</code>","text":"<p>Rolling var</p>"},{"location":"reference/Expr_rolling_var/#description","title":"Description","text":"<p>Apply a rolling var (moving var) over the values in this array.  A window of length <code>window_size</code> will traverse the array. The values that fill  this window will (optionally) be multiplied with the weights given by the  <code>weight</code> vector. The resulting values will be aggregated to their sum.</p>"},{"location":"reference/Expr_rolling_var/#usage","title":"Usage","text":"<pre><code>Expr_rolling_var(\nwindow_size,\nweights = NULL,\nmin_periods = NULL,\ncenter = FALSE,\nby = NULL,\nclosed = \"left\"\n)\n</code></pre>"},{"location":"reference/Expr_rolling_var/#arguments","title":"Arguments","text":"Argument Description <code>window_size</code> The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: <ul> <li> <p>1ns   (1 nanosecond) </p> </li> <li> <p>1us   (1 microsecond) </p> </li> <li> <p>1ms   (1 millisecond) </p> </li> <li> <p>1s    (1 second) </p> </li> <li> <p>1m    (1 minute) </p> </li> <li> <p>1h    (1 hour) </p> </li> <li> <p>1d    (1 day) </p> </li> <li> <p>1w    (1 week) </p> </li> <li> <p>1mo   (1 calendar month) </p> </li> <li> <p>1y    (1 calendar year) </p> </li> <li> <p>1i    (1 index count) If the dynamic string language is used, the <code>by</code> and <code>closed</code> arguments must also be set. <code>weights</code>     |     An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. <code>min_periods</code>     |     The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. <code>center</code>     |     Set the labels at the center of the window <code>by</code>     |     If the <code>window_size</code> is temporal for instance <code>\"5h\"</code> or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} <code>closed</code>     |     : 'left', 'right', 'both', 'none'  Define whether the temporal window interval is closed or not.</p> </li> </ul>"},{"location":"reference/Expr_rolling_var/#details","title":"Details","text":"<p>This functionality is experimental and may change without it being considered a  breaking change.  Notes:  If you want to compute multiple aggregation statistics over the same dynamic  window, consider using <code>groupby_rolling</code> this method can cache the window size  computation.</p>"},{"location":"reference/Expr_rolling_var/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_rolling_var/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=1:6))$select(pl$col(\"a\")$rolling_var(window_size = 2))\n</code></pre>"},{"location":"reference/Expr_round/","title":"<code>Expr_round</code>","text":"<p>round</p>"},{"location":"reference/Expr_round/#description","title":"Description","text":"<p>Round underlying floating point data by <code>decimals</code> digits.</p>"},{"location":"reference/Expr_round/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_round/#usage","title":"Usage","text":"<pre><code>Expr_round(decimals)\n</code></pre>"},{"location":"reference/Expr_round/#arguments","title":"Arguments","text":"Argument Description <code>decimals</code> integer Number of decimals to round by."},{"location":"reference/Expr_round/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_round/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(0.33, 0.5, 1.02, 1.5, NaN , NA, Inf, -Inf)\n))$select(\npl$col(\"a\")$round(0)\n)\n</code></pre>"},{"location":"reference/Expr_rpow/","title":"<code>Expr_rpow</code>","text":"<p>Reverse exponentiation %% (in R  == ^ )</p>"},{"location":"reference/Expr_rpow/#description","title":"Description","text":"<p>Raise a base to the power of the expression as exponent.</p>"},{"location":"reference/Expr_rpow/#usage","title":"Usage","text":"<pre><code>Expr_rpow(base)\ne1 %**% e2\n`%**%.Expr`(e1, e2)\n</code></pre>"},{"location":"reference/Expr_rpow/#arguments","title":"Arguments","text":"Argument Description <code>base</code> real or Expr, the value of the base, self is the exponent <code>e1</code> value where ** operator is defined <code>e2</code> value where ** operator is defined"},{"location":"reference/Expr_rpow/#details","title":"Details","text":"<p>do not use ** , R secretly parses that just as if it was a <code>^</code></p>"},{"location":"reference/Expr_rpow/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_rpow/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a = -1:3))$select(\npl$lit(2)$rpow(pl$col(\"a\"))\n)$get_column(\"a\")$to_r() ==  (-1:3)^2\npl$DataFrame(list(a = -1:3))$select(\npl$lit(2) %**% (pl$col(\"a\"))\n)$get_column(\"a\")$to_r() ==  (-1:3)^2\n</code></pre>"},{"location":"reference/Expr_sample/","title":"<code>Expr_sample</code>","text":"<p>Sample</p>"},{"location":"reference/Expr_sample/#description","title":"Description","text":""},{"location":"reference/Expr_sample/#sample-from-this-expression","title":"' Sample from this expression.","text":""},{"location":"reference/Expr_sample/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_sample/#usage","title":"Usage","text":"<pre><code>Expr_sample(\nfrac = NULL,\nwith_replacement = TRUE,\nshuffle = FALSE,\nseed = NULL,\nn = NULL\n)\n</code></pre>"},{"location":"reference/Expr_sample/#arguments","title":"Arguments","text":"Argument Description <code>frac</code> Fraction of items to return. Cannot be used with <code>n</code> . <code>with_replacement</code> Allow values to be sampled more than once. <code>shuffle</code> Shuffle the order of sampled data points. (implicitly TRUE if, with_replacement = TRUE) <code>seed</code> Seed for the random number generator. If set to None (default), a random seed is used. <code>n</code> Number of items to return. Cannot be used with <code>frac</code> ."},{"location":"reference/Expr_sample/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_sample/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(a=1:3)\ndf$select(pl$col(\"a\")$sample(frac=1,with_replacement=TRUE,seed=1L))\ndf$select(pl$col(\"a\")$sample(frac=2,with_replacement=TRUE,seed=1L))\ndf$select(pl$col(\"a\")$sample(n=2,with_replacement=FALSE,seed=1L))\n</code></pre>"},{"location":"reference/Expr_search_sorted/","title":"<code>Expr_search_sorted</code>","text":"<p>Where to inject element(s) to maintain sorting</p>"},{"location":"reference/Expr_search_sorted/#description","title":"Description","text":"<p>Find indices in self where elements should be inserted into to maintain order.</p>"},{"location":"reference/Expr_search_sorted/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_search_sorted/#usage","title":"Usage","text":"<pre><code>Expr_search_sorted(element)\n</code></pre>"},{"location":"reference/Expr_search_sorted/#arguments","title":"Arguments","text":"Argument Description <code>element</code> a R value into literal or an expression of an element"},{"location":"reference/Expr_search_sorted/#details","title":"Details","text":"<p>This function look up where to insert element if to keep self column sorted.  It is assumed the self column is already sorted ascending, otherwise wrongs answers.  This function is a bit under documented in py-polars.</p>"},{"location":"reference/Expr_search_sorted/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_search_sorted/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=0:100))$select(pl$col(\"a\")$search_sorted(pl$lit(42L)))\n</code></pre>"},{"location":"reference/Expr_set_sorted/","title":"<code>Expr_set_sorted</code>","text":"<p>Set_sorted</p>"},{"location":"reference/Expr_set_sorted/#description","title":"Description","text":"<p>Flags the expression as 'sorted'.</p>"},{"location":"reference/Expr_set_sorted/#usage","title":"Usage","text":"<pre><code>Expr_set_sorted(reverse = FALSE)\n</code></pre>"},{"location":"reference/Expr_set_sorted/#arguments","title":"Arguments","text":"Argument Description <code>reverse</code> bool if TRUE Descending else Ascending"},{"location":"reference/Expr_set_sorted/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_set_sorted/#examples","title":"Examples","text":"<pre><code>#correct use flag something correctly as ascendingly sorted\ns = pl$select(pl$lit(1:4)$set_sorted()$alias(\"a\"))$get_column(\"a\")\ns$flags # see flags\n#incorrect use, flag somthing as not sorted ascendingly\ns2 = pl$select(pl$lit(c(1,3,2,4))$set_sorted()$alias(\"a\"))$get_column(\"a\")\ns2$sort() #sorting skipped, although not actually sorted\n</code></pre>"},{"location":"reference/Expr_shift/","title":"<code>Expr_shift</code>","text":"<p>Shift values</p>"},{"location":"reference/Expr_shift/#description","title":"Description","text":"<p>Shift values</p>"},{"location":"reference/Expr_shift/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_shift/#usage","title":"Usage","text":"<pre><code>Expr_shift(periods)\n</code></pre>"},{"location":"reference/Expr_shift/#arguments","title":"Arguments","text":"Argument Description <code>periods</code> numeric number of periods to shift, may be negative."},{"location":"reference/Expr_shift/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_shift/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_shift/#examples","title":"Examples","text":"<pre><code>pl$select(\npl$lit(0:3)$shift(-2)$alias(\"shift-2\"),\npl$lit(0:3)$shift(2)$alias(\"shift+2\")\n)\n</code></pre>"},{"location":"reference/Expr_shift_and_fill/","title":"<code>Expr_shift_and_fill</code>","text":"<p>Shift and fill values</p>"},{"location":"reference/Expr_shift_and_fill/#description","title":"Description","text":"<p>Shift the values by a given period and fill the resulting null values.</p>"},{"location":"reference/Expr_shift_and_fill/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_shift_and_fill/#usage","title":"Usage","text":"<pre><code>Expr_shift_and_fill(periods, fill_value)\n</code></pre>"},{"location":"reference/Expr_shift_and_fill/#arguments","title":"Arguments","text":"Argument Description <code>periods</code> numeric number of periods to shift, may be negative. <code>fill_value</code> Fill None values with the result of this expression."},{"location":"reference/Expr_shift_and_fill/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_shift_and_fill/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_shift_and_fill/#examples","title":"Examples","text":"<pre><code>pl$select(\npl$lit(0:3),\npl$lit(0:3)$shift_and_fill(-2, fill_value = 42)$alias(\"shift-2\"),\npl$lit(0:3)$shift_and_fill(2, fill_value = pl$lit(42)/2)$alias(\"shift+2\")\n)\n</code></pre>"},{"location":"reference/Expr_shrink_dtype/","title":"<code>Expr_shrink_dtype</code>","text":"<p>Wrap column in list</p>"},{"location":"reference/Expr_shrink_dtype/#description","title":"Description","text":"<p>Shrink numeric columns to the minimal required datatype.  Shrink to the dtype needed to fit the extrema of this [Series] .  This can be used to reduce memory pressure.</p>"},{"location":"reference/Expr_shrink_dtype/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_shrink_dtype/#usage","title":"Usage","text":"<pre><code>Expr_shrink_dtype\n</code></pre>"},{"location":"reference/Expr_shrink_dtype/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_shrink_dtype/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(\na= c(1L, 2L, 3L),\nb= c(1L, 2L, bitwShiftL(2L,29)),\nc= c(-1L, 2L, bitwShiftL(1L,15)),\nd= c(-112L, 2L, 112L),\ne= c(-112L, 2L, 129L),\nf= c(\"a\", \"b\", \"c\"),\ng= c(0.1, 1.32, 0.12),\nh= c(TRUE, NA, FALSE)\n)$with_column( pl$col(\"b\")$cast(pl$Int64) *32L\n)$select(pl$all()$shrink_dtype())\n</code></pre>"},{"location":"reference/Expr_shuffle/","title":"<code>Expr_shuffle</code>","text":"<p>Shuffle</p>"},{"location":"reference/Expr_shuffle/#description","title":"Description","text":"<p>Shuffle the contents of this expr.</p>"},{"location":"reference/Expr_shuffle/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_shuffle/#usage","title":"Usage","text":"<pre><code>Expr_shuffle(seed = NULL)\n</code></pre>"},{"location":"reference/Expr_shuffle/#arguments","title":"Arguments","text":"Argument Description <code>seed</code> numeric value of 0 to 2^52 Seed for the random number generator. If set to Null (default), a random seed value intergish value between 0 and 10000 is picked"},{"location":"reference/Expr_shuffle/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_shuffle/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a = 1:3)$select(pl$col(\"a\")$shuffle(seed=1))\n</code></pre>"},{"location":"reference/Expr_sign/","title":"<code>Expr_sign</code>","text":"<p>Sign</p>"},{"location":"reference/Expr_sign/#description","title":"Description","text":"<p>Compute the element-wise indication of the sign.</p>"},{"location":"reference/Expr_sign/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_sign/#usage","title":"Usage","text":"<pre><code>Expr_sign\n</code></pre>"},{"location":"reference/Expr_sign/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_sign/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(.9,-0,0,4,NA_real_))$select(pl$col(\"a\")$sign())\n</code></pre>"},{"location":"reference/Expr_sin/","title":"<code>Expr_sin</code>","text":"<p>Sin</p>"},{"location":"reference/Expr_sin/#description","title":"Description","text":"<p>Compute the element-wise value for the sine.</p>"},{"location":"reference/Expr_sin/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_sin/#usage","title":"Usage","text":"<pre><code>Expr_sin\n</code></pre>"},{"location":"reference/Expr_sin/#details","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/Expr_sin/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_sin/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(0,pi/2,pi,NA_real_))$select(pl$col(\"a\")$sin())\n</code></pre>"},{"location":"reference/Expr_sinh/","title":"<code>Expr_sinh</code>","text":"<p>Sinh</p>"},{"location":"reference/Expr_sinh/#description","title":"Description","text":"<p>Compute the element-wise value for the hyperbolic sine.</p>"},{"location":"reference/Expr_sinh/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_sinh/#usage","title":"Usage","text":"<pre><code>Expr_sinh\n</code></pre>"},{"location":"reference/Expr_sinh/#details","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/Expr_sinh/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_sinh/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,asinh(0.5),0,1,NA_real_))$select(pl$col(\"a\")$sinh())\n</code></pre>"},{"location":"reference/Expr_skew/","title":"<code>Expr_skew</code>","text":"<p>Skewness</p>"},{"location":"reference/Expr_skew/#description","title":"Description","text":"<p>Compute the sample skewness of a data set.</p>"},{"location":"reference/Expr_skew/#usage","title":"Usage","text":"<pre><code>Expr_skew(bias = TRUE)\n</code></pre>"},{"location":"reference/Expr_skew/#arguments","title":"Arguments","text":"Argument Description <code>bias</code> If False, then the calculations are corrected for statistical bias."},{"location":"reference/Expr_skew/#details","title":"Details","text":"<p>For normally distributed data, the skewness should be about zero. For  unimodal continuous distributions, a skewness value greater than zero means  that there is more weight in the right tail of the distribution. The  function <code>skewtest</code> can be used to determine if the skewness value  is close enough to zero, statistically speaking.</p> <p>See scipy.stats for more information.  list(list(\"Notes\"), list(\"\\n\", \"\\n\", \"The sample skewness is computed as the Fisher-Pearson coefficient\\n\", \"of skewness, i.e.\\n\", \"\\n\", list(list(\" g_1=\\frac{m_3}{m_2^{3/2}}\")), \"\\n\", \"\\n\", \"where\\n\", \"\\n\", list(list(\" m_i=\\frac{1}{N}\\sum_{n=1}^N(x[n]-\\bar{x})^i\")), \"\\n\", \"\\n\", \"is the biased sample :math:\", list(\"i\\texttt{th}\"), \" central moment, and \", list(list(\"\\bar{x}\")), \" is\\n\", \"the sample mean.  If \", list(\"bias\"), \" is False, the calculations are\\n\", \"corrected for bias and the value computed is the adjusted\\n\",      \"Fisher-Pearson standardized moment coefficient, i.e.\\n\", \"\\n\", list(list(\" G_1 = \\frac{k_3}{k_2^{3/2}} = \\frac{\\sqrt{N(N-1)}}{N-2}\\frac{m_3}{m_2^{3/2}}\")), \"\\n\"))</p>"},{"location":"reference/Expr_skew/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_skew/#references","title":"References","text":"<p>https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.skew.html?highlight=skew#scipy.stats.skew</p>"},{"location":"reference/Expr_skew/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list( a=c(1:3,2:1)))\ndf$select(pl$col(\"a\")$skew())\n</code></pre>"},{"location":"reference/Expr_slice/","title":"<code>Expr_slice</code>","text":"<p>Get a slice of this expression.</p>"},{"location":"reference/Expr_slice/#description","title":"Description","text":"<p>Get a slice of this expression.</p>"},{"location":"reference/Expr_slice/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_slice/#usage","title":"Usage","text":"<pre><code>Expr_slice(offset, length = NULL)\n</code></pre>"},{"location":"reference/Expr_slice/#arguments","title":"Arguments","text":"Argument Description <code>offset</code> numeric or expression, zero-indexed where to start slice negative value indicate starting (one-indexed) from back <code>length</code> how many elements should slice contain, default NULL is max length"},{"location":"reference/Expr_slice/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_slice/#examples","title":"Examples","text":"<pre><code>#as head\npl$DataFrame(list(a=0:100))$select(\npl$all()$slice(0,6)\n)\n#as tail\npl$DataFrame(list(a=0:100))$select(\npl$all()$slice(-6,6)\n)\npl$DataFrame(list(a=0:100))$select(\npl$all()$slice(80)\n)\n</code></pre>"},{"location":"reference/Expr_sort/","title":"<code>Expr_sort</code>","text":"<p>Expr_sort</p>"},{"location":"reference/Expr_sort/#description","title":"Description","text":"<p>Sort this column. In projection/ selection context the whole column is sorted.  If used in a groupby context, the groups are sorted.</p>"},{"location":"reference/Expr_sort/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_sort/#usage","title":"Usage","text":"<pre><code>Expr_sort(reverse = FALSE, nulls_last = FALSE)\n</code></pre>"},{"location":"reference/Expr_sort/#arguments","title":"Arguments","text":"Argument Description <code>reverse</code> bool default FALSE, reverses sort <code>nulls_last</code> bool, default FALSE, place Nulls last"},{"location":"reference/Expr_sort/#details","title":"Details","text":"<p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_sort/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_sort/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(6, 1, 0, NA, Inf, NaN)\n))$select(pl$col(\"a\")$sort())\n</code></pre>"},{"location":"reference/Expr_sort_by/","title":"<code>Expr_sort_by</code>","text":"<p>sort column by order of others</p>"},{"location":"reference/Expr_sort_by/#description","title":"Description","text":"<p>Sort this column by the ordering of another column, or multiple other columns.</p>"},{"location":"reference/Expr_sort_by/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_sort_by/#usage","title":"Usage","text":"<pre><code>Expr_sort_by(by, reverse = FALSE)\n</code></pre>"},{"location":"reference/Expr_sort_by/#arguments","title":"Arguments","text":"Argument Description <code>by</code> one expression or list expressions and/or strings(interpreted as column names) <code>reverse</code> single bool to boolean vector, any is_TRUE will give reverse sorting of that column"},{"location":"reference/Expr_sort_by/#details","title":"Details","text":"<p>In projection/ selection context the whole column is sorted.  If used in a groupby context, the groups are sorted.</p> <p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_sort_by/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_sort_by/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(\ngroup = c(\"a\",\"a\",\"a\",\"b\",\"b\",\"b\"),\nvalue1 = c(98,1,3,2,99,100),\nvalue2 = c(\"d\",\"f\",\"b\",\"e\",\"c\",\"a\")\n))\n# by one column/expression\ndf$select(\npl$col(\"group\")$sort_by(\"value1\")\n)\n# by two columns/expressions\ndf$select(\npl$col(\"group\")$sort_by(list(\"value2\",pl$col(\"value1\")), reverse =c(TRUE,FALSE))\n)\n# by some expression\ndf$select(\npl$col(\"group\")$sort_by(pl$col(\"value1\")$sort(reverse=TRUE))\n)\n#quite similar usecase as R function `order()`\nl = list(\nab = c(rep(\"a\",6),rep(\"b\",6)),\nv4 = rep(1:4, 3),\nv3 = rep(1:3, 4),\nv2 = rep(1:2,6),\nv1 = 1:12\n)\ndf = pl$DataFrame(l)\n#examples of order versus sort_by\nall.equal(\ndf$select(\npl$col(\"ab\")$sort_by(\"v4\")$alias(\"ab4\"),\npl$col(\"ab\")$sort_by(\"v3\")$alias(\"ab3\"),\npl$col(\"ab\")$sort_by(\"v2\")$alias(\"ab2\"),\npl$col(\"ab\")$sort_by(\"v1\")$alias(\"ab1\"),\npl$col(\"ab\")$sort_by(list(\"v3\",pl$col(\"v1\")),reverse=c(FALSE,TRUE))$alias(\"ab13FT\"),\npl$col(\"ab\")$sort_by(list(\"v3\",pl$col(\"v1\")),reverse=TRUE)$alias(\"ab13T\")\n)$to_list(),\nlist(\nab4 = l$ab[order(l$v4)],\nab3 = l$ab[order(l$v3)],\nab2 = l$ab[order(l$v2)],\nab1 = l$ab[order(l$v1)],\nab13FT= l$ab[order(l$v3,rev(l$v1))],\nab13T = l$ab[order(l$v3,l$v1,decreasing= TRUE)]\n)\n)\n</code></pre>"},{"location":"reference/Expr_sqrt/","title":"<code>Expr_sqrt</code>","text":"<p>Square root</p>"},{"location":"reference/Expr_sqrt/#description","title":"Description","text":"<p>Compute the square root of the elements.</p>"},{"location":"reference/Expr_sqrt/#usage","title":"Usage","text":"<pre><code>Expr_sqrt()\n</code></pre>"},{"location":"reference/Expr_sqrt/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_sqrt/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a = -1:3))$select(pl$col(\"a\")$sqrt())\n</code></pre>"},{"location":"reference/Expr_std/","title":"<code>Expr_std</code>","text":"<p>Get Standard Deviation</p>"},{"location":"reference/Expr_std/#description","title":"Description","text":"<p>Get Standard Deviation</p>"},{"location":"reference/Expr_std/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_std/#usage","title":"Usage","text":"<pre><code>Expr_std(ddof = 1)\n</code></pre>"},{"location":"reference/Expr_std/#arguments","title":"Arguments","text":"Argument Description <code>ddof</code> integer in range [0;255] degrees of freedom"},{"location":"reference/Expr_std/#value","title":"Value","text":"<p>Expr (f64 scalar)</p>"},{"location":"reference/Expr_std/#examples","title":"Examples","text":"<pre><code>pl$select(pl$lit(1:5)$std())\n</code></pre>"},{"location":"reference/Expr_str/","title":"<code>Expr_str</code>","text":"<p>str: string related methods</p>"},{"location":"reference/Expr_str/#description","title":"Description","text":"<p>Create an object namespace of all string related methods.  See the individual method pages for full details</p>"},{"location":"reference/Expr_str/#usage","title":"Usage","text":"<pre><code>Expr_str()\n</code></pre>"},{"location":"reference/Expr_str/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_str/#examples","title":"Examples","text":"<pre><code>#missing\n</code></pre>"},{"location":"reference/Expr_struct/","title":"<code>Expr_struct</code>","text":"<p>struct: related methods</p>"},{"location":"reference/Expr_struct/#description","title":"Description","text":"<p>Create an object namespace of all struct related methods.  See the individual method pages for full details</p>"},{"location":"reference/Expr_struct/#usage","title":"Usage","text":"<pre><code>Expr_struct()\n</code></pre>"},{"location":"reference/Expr_struct/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_struct/#examples","title":"Examples","text":"<pre><code>#missing\n</code></pre>"},{"location":"reference/Expr_sub/","title":"<code>Expr_sub</code>","text":"<p>Sub</p>"},{"location":"reference/Expr_sub/#description","title":"Description","text":"<p>Substract</p>"},{"location":"reference/Expr_sub/#usage","title":"Usage","text":"<pre><code>Expr_sub(other)\nlist(list(\"-\"), list(\"Expr\"))(e1, e2)\n</code></pre>"},{"location":"reference/Expr_sub/#arguments","title":"Arguments","text":"Argument Description <code>other</code> literal or Robj which can become a literal <code>e1</code> lhs Expr <code>e2</code> rhs Expr or anything which can become a literal Expression"},{"location":"reference/Expr_sub/#value","title":"Value","text":"<p>Exprs</p>"},{"location":"reference/Expr_sub/#examples","title":"Examples","text":"<pre><code>#three syntaxes same result\npl$lit(5) - 10\npl$lit(5) - pl$lit(10)\npl$lit(5)$sub(pl$lit(10))\n-pl$lit(5)\n</code></pre>"},{"location":"reference/Expr_sum/","title":"<code>Expr_sum</code>","text":"<p>sum</p>"},{"location":"reference/Expr_sum/#description","title":"Description","text":"<p>Get sum value</p>"},{"location":"reference/Expr_sum/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_sum/#usage","title":"Usage","text":"<pre><code>Expr_sum\n</code></pre>"},{"location":"reference/Expr_sum/#details","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to  Int64 before summing to prevent overflow issues.</p>"},{"location":"reference/Expr_sum/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_sum/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(x=c(1L,NA,2L)))$select(pl$col(\"x\")$sum())#is i32 3 (Int32 not casted)\n</code></pre>"},{"location":"reference/Expr_tail/","title":"<code>Expr_tail</code>","text":"<p>Tail</p>"},{"location":"reference/Expr_tail/#description","title":"Description","text":"<p>Get the tail n elements.  Similar to R tail(x)</p>"},{"location":"reference/Expr_tail/#usage","title":"Usage","text":"<pre><code>Expr_tail(n = 10)\n</code></pre>"},{"location":"reference/Expr_tail/#arguments","title":"Arguments","text":"Argument Description <code>n</code> numeric number of elements to select from tail"},{"location":"reference/Expr_tail/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_tail/#examples","title":"Examples","text":"<pre><code>#get 3 last elements\npl$DataFrame(list(x=1:11))$select(pl$col(\"x\")$tail(3))\n</code></pre>"},{"location":"reference/Expr_take/","title":"<code>Expr_take</code>","text":"<p>Take values by index.</p>"},{"location":"reference/Expr_take/#description","title":"Description","text":"<p>Take values by index.</p>"},{"location":"reference/Expr_take/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_take/#usage","title":"Usage","text":"<pre><code>Expr_take(indices)\n</code></pre>"},{"location":"reference/Expr_take/#arguments","title":"Arguments","text":"Argument Description <code>indices</code> R scalar/vector or Series, or Expr that leads to a UInt32 dtyped Series."},{"location":"reference/Expr_take/#details","title":"Details","text":"<p>similar to R indexing syntax e.g. <code>letters[c(1,3,5)]</code> , however as an expression, not as eager computation  exceeding</p>"},{"location":"reference/Expr_take/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_take/#examples","title":"Examples","text":"<pre><code>pl$select( pl$lit(0:10)$take(c(1,8,0,7)))\n</code></pre>"},{"location":"reference/Expr_take_every/","title":"<code>Expr_take_every</code>","text":"<p>Take every n'th element</p>"},{"location":"reference/Expr_take_every/#description","title":"Description","text":"<p>Take every nth value in the Series and return as a new Series.</p>"},{"location":"reference/Expr_take_every/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_take_every/#usage","title":"Usage","text":"<pre><code>Expr_take_every(n)\n</code></pre>"},{"location":"reference/Expr_take_every/#arguments","title":"Arguments","text":"Argument Description <code>n</code> positive integerish value"},{"location":"reference/Expr_take_every/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_take_every/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(a=0:24))$select(pl$col(\"a\")$take_every(6))\n</code></pre>"},{"location":"reference/Expr_tan/","title":"<code>Expr_tan</code>","text":"<p>Tan</p>"},{"location":"reference/Expr_tan/#description","title":"Description","text":"<p>Compute the element-wise value for the tangent.</p>"},{"location":"reference/Expr_tan/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_tan/#usage","title":"Usage","text":"<pre><code>Expr_tan\n</code></pre>"},{"location":"reference/Expr_tan/#details","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/Expr_tan/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_tan/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(0,pi/2,pi,NA_real_))$select(pl$col(\"a\")$tan())\n</code></pre>"},{"location":"reference/Expr_tanh/","title":"<code>Expr_tanh</code>","text":"<p>Tanh</p>"},{"location":"reference/Expr_tanh/#description","title":"Description","text":"<p>Compute the element-wise value for the hyperbolic tangent.</p>"},{"location":"reference/Expr_tanh/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_tanh/#usage","title":"Usage","text":"<pre><code>Expr_tanh\n</code></pre>"},{"location":"reference/Expr_tanh/#details","title":"Details","text":"<p>Evaluated Series has dtype Float64</p>"},{"location":"reference/Expr_tanh/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_tanh/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(a=c(-1,atanh(0.5),0,1,NA_real_))$select(pl$col(\"a\")$tanh())\n</code></pre>"},{"location":"reference/Expr_to_physical/","title":"<code>Expr_to_physical</code>","text":"<p>To physical representation</p>"},{"location":"reference/Expr_to_physical/#description","title":"Description","text":"<p>expression request underlying physical base representation</p>"},{"location":"reference/Expr_to_physical/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_to_physical/#usage","title":"Usage","text":"<pre><code>Expr_to_physical\n</code></pre>"},{"location":"reference/Expr_to_physical/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_to_physical/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(\nlist(vals = c(\"a\", \"x\", NA, \"a\"))\n)$with_columns(\npl$col(\"vals\")$cast(pl$Categorical),\npl$col(\"vals\")\n$cast(pl$Categorical)\n$to_physical()\n$alias(\"vals_physical\")\n)\n</code></pre>"},{"location":"reference/Expr_to_r/","title":"<code>Expr_to_r</code>","text":"<p>to_r: for debuging an expression</p>"},{"location":"reference/Expr_to_r/#description","title":"Description","text":"<p>debug an expression by evaluating in empty DataFrame and return first series to R</p>"},{"location":"reference/Expr_to_r/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_to_r/#usage","title":"Usage","text":"<pre><code>Expr_to_r(df = NULL, i = 0)\n</code></pre>"},{"location":"reference/Expr_to_r/#arguments","title":"Arguments","text":"Argument Description <code>df</code> otherwise a DataFrame to evaluate in, default NULL is an empty DataFrame <code>i</code> numeric column to extract zero index default first, expression could generate multiple columns"},{"location":"reference/Expr_to_r/#value","title":"Value","text":"<p>R object</p>"},{"location":"reference/Expr_to_r/#examples","title":"Examples","text":"<pre><code>pl$lit(1:3)$to_r()\npl$expr_to_r(pl$lit(1:3))\npl$expr_to_r(1:3)\n</code></pre>"},{"location":"reference/Expr_to_struct/","title":"<code>Expr_to_struct</code>","text":"<p>to_struct</p>"},{"location":"reference/Expr_to_struct/#description","title":"Description","text":"<p>pass expr to pl$struct</p>"},{"location":"reference/Expr_to_struct/#usage","title":"Usage","text":"<pre><code>Expr_to_struct()\n</code></pre>"},{"location":"reference/Expr_to_struct/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_to_struct/#examples","title":"Examples","text":"<pre><code>e = pl$all()$to_struct()$alias(\"my_struct\")\nprint(e)\npl$DataFrame(iris)$select(e)\n</code></pre>"},{"location":"reference/Expr_top_k/","title":"<code>Expr_top_k</code>","text":"<p>Top k values</p>"},{"location":"reference/Expr_top_k/#description","title":"Description","text":"<p>Return the <code>k</code> largest elements.  If 'reverse=True` the smallest elements will be given.</p>"},{"location":"reference/Expr_top_k/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_top_k/#usage","title":"Usage","text":"<pre><code>Expr_top_k(k, reverse = FALSE)\n</code></pre>"},{"location":"reference/Expr_top_k/#arguments","title":"Arguments","text":"Argument Description <code>k</code> numeric k top values to get <code>reverse</code> bool if true then k smallest values"},{"location":"reference/Expr_top_k/#details","title":"Details","text":"<p>This has time complexity: $ O(n + k \\log{}n - \\frac{k}{2}) $ </p> <p>See Inf,NaN,NULL,Null/NA translations here <code>docs_translations</code></p>"},{"location":"reference/Expr_top_k/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_top_k/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(\na = c(6, 1, 0, NA, Inf, NaN)\n))$select(pl$col(\"a\")$top_k(5))\n</code></pre>"},{"location":"reference/Expr_unique/","title":"<code>Expr_unique</code>","text":"<p>get unqie values</p>"},{"location":"reference/Expr_unique/#description","title":"Description","text":"<p>Get unique values of this expression.  Similar to R unique()</p>"},{"location":"reference/Expr_unique/#usage","title":"Usage","text":"<pre><code>Expr_unique(maintain_order = FALSE)\n</code></pre>"},{"location":"reference/Expr_unique/#arguments","title":"Arguments","text":"Argument Description <code>maintain_order</code> bool, if TRUE guranteed same order, if FALSE maybe"},{"location":"reference/Expr_unique/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_unique/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$select(pl$col(\"Species\")$unique())\n</code></pre>"},{"location":"reference/Expr_unique_counts/","title":"<code>Expr_unique_counts</code>","text":"<p>Value counts</p>"},{"location":"reference/Expr_unique_counts/#description","title":"Description","text":"<p>Return a count of the unique values in the order of appearance.  This method differs from <code>value_counts</code> in that it does not return the  values, only the counts and might be faster</p>"},{"location":"reference/Expr_unique_counts/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_unique_counts/#usage","title":"Usage","text":"<pre><code>Expr_unique_counts\n</code></pre>"},{"location":"reference/Expr_unique_counts/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_unique_counts/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$select(pl$col(\"Species\")$unique_counts())\n</code></pre>"},{"location":"reference/Expr_upper_lower_bound/","title":"<code>Expr_upper_lower_bound</code>","text":"<p>Upper bound</p>"},{"location":"reference/Expr_upper_lower_bound/#description","title":"Description","text":"<p>Calculate the upper/lower bound.  Returns a unit Series with the highest value possible for the dtype of this  expression.</p>"},{"location":"reference/Expr_upper_lower_bound/#format","title":"Format","text":"<p>Method</p> <p>Method</p>"},{"location":"reference/Expr_upper_lower_bound/#usage","title":"Usage","text":"<pre><code>Expr_upper_bound\nExpr_lower_bound\n</code></pre>"},{"location":"reference/Expr_upper_lower_bound/#details","title":"Details","text":"<p>Notice lower bound i32 exported to R is NA_integer_ for now</p>"},{"location":"reference/Expr_upper_lower_bound/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_upper_lower_bound/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(i32=1L,f64=1)$select(pl$all()$upper_bound())\npl$DataFrame(i32=1L,f64=1)$select(pl$all()$lower_bound())\n</code></pre>"},{"location":"reference/Expr_value_counts/","title":"<code>Expr_value_counts</code>","text":"<p>Value counts</p>"},{"location":"reference/Expr_value_counts/#description","title":"Description","text":"<p>Count all unique values and create a struct mapping value to count.</p>"},{"location":"reference/Expr_value_counts/#format","title":"Format","text":"<p>Method</p>"},{"location":"reference/Expr_value_counts/#usage","title":"Usage","text":"<pre><code>Expr_value_counts(multithreaded = FALSE, sort = FALSE)\n</code></pre>"},{"location":"reference/Expr_value_counts/#arguments","title":"Arguments","text":"Argument Description <code>multithreaded</code> Better to turn this off in the aggregation context, as it can lead to contention. <code>sort</code> Ensure the output is sorted from most values to least."},{"location":"reference/Expr_value_counts/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_value_counts/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(iris)$select(pl$col(\"Species\")$value_counts())\ndf\ndf$unnest()$as_data_frame() #recommended to unnest structs before converting to R\n</code></pre>"},{"location":"reference/Expr_var/","title":"<code>Expr_var</code>","text":"<p>Get Variance</p>"},{"location":"reference/Expr_var/#description","title":"Description","text":"<p>Get Variance</p>"},{"location":"reference/Expr_var/#format","title":"Format","text":"<p>a method</p>"},{"location":"reference/Expr_var/#usage","title":"Usage","text":"<pre><code>Expr_var(ddof = 1)\n</code></pre>"},{"location":"reference/Expr_var/#arguments","title":"Arguments","text":"Argument Description <code>ddof</code> integer in range [0;255] degrees of freedom"},{"location":"reference/Expr_var/#value","title":"Value","text":"<p>Expr (f64 scalar)</p>"},{"location":"reference/Expr_var/#examples","title":"Examples","text":"<pre><code>pl$select(pl$lit(1:5)$var())\n</code></pre>"},{"location":"reference/Expr_xor/","title":"<code>Expr_xor</code>","text":"<p>Xor</p>"},{"location":"reference/Expr_xor/#description","title":"Description","text":"<p>combine to boolean expresions with XOR</p>"},{"location":"reference/Expr_xor/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Expr_xor/#usage","title":"Usage","text":"<pre><code>Expr_xor(other)\n</code></pre>"},{"location":"reference/Expr_xor/#arguments","title":"Arguments","text":"Argument Description <code>other</code> literal or Robj which can become a literal"},{"location":"reference/Expr_xor/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Expr_xor/#examples","title":"Examples","text":"<pre><code>pl$lit(TRUE)$xor(pl$lit(FALSE))\n</code></pre>"},{"location":"reference/GroupBy_agg/","title":"<code>agg</code>","text":"<p>GroupBy Aggregate</p>"},{"location":"reference/GroupBy_agg/#description","title":"Description","text":"<p>Aggregatete a DataFrame over a groupby</p>"},{"location":"reference/GroupBy_agg/#usage","title":"Usage","text":"<pre><code>GroupBy_agg(...)\n</code></pre>"},{"location":"reference/GroupBy_agg/#arguments","title":"Arguments","text":"Argument Description <code>...</code> exprs to aggregate"},{"location":"reference/GroupBy_agg/#value","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/GroupBy_agg/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(\nlist(\nfoo = c(\"one\", \"two\", \"two\", \"one\", \"two\"),\nbar = c(5, 3, 2, 4, 1)\n)\n)$groupby(\n\"foo\"\n)$agg(\npl$col(\"bar\")$sum()$alias(\"bar_sum\"),\npl$col(\"bar\")$mean()$alias(\"bar_tail_sum\")\n)\n</code></pre>"},{"location":"reference/GroupBy_as_data_frame/","title":"<code>as_data_frame</code>","text":"<p>convert to data.frame</p>"},{"location":"reference/GroupBy_as_data_frame/#description","title":"Description","text":"<p>convert to data.frame</p>"},{"location":"reference/GroupBy_as_data_frame/#usage","title":"Usage","text":"<pre><code>GroupBy_as_data_frame(...)\n</code></pre>"},{"location":"reference/GroupBy_as_data_frame/#arguments","title":"Arguments","text":"Argument Description <code>...</code> any opt param passed to R as.data.frame"},{"location":"reference/GroupBy_as_data_frame/#value","title":"Value","text":"<p>R data.frame</p>"},{"location":"reference/GroupBy_as_data_frame/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$as_data_frame() #R-polars back and forth\n</code></pre>"},{"location":"reference/GroupBy_class/","title":"<code>class</code>","text":"<p>Use groups on a Polars DataFrame</p>"},{"location":"reference/GroupBy_class/#description","title":"Description","text":"<p>Use groups on a Polars DataFrame</p>"},{"location":"reference/GroupBy_class/#value","title":"Value","text":"<p>A grouped DataFrame</p>"},{"location":"reference/GroupBy_first/","title":"<code>first</code>","text":"<p>GroupBy First</p>"},{"location":"reference/GroupBy_first/#description","title":"Description","text":"<p>Reduce the groups to the first value.</p>"},{"location":"reference/GroupBy_first/#usage","title":"Usage","text":"<pre><code>GroupBy_first()\n</code></pre>"},{"location":"reference/GroupBy_first/#value","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/GroupBy_first/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$first()\n</code></pre>"},{"location":"reference/GroupBy_last/","title":"<code>last</code>","text":"<p>GroupBy Last</p>"},{"location":"reference/GroupBy_last/#description","title":"Description","text":"<p>Reduce the groups to the last value.</p>"},{"location":"reference/GroupBy_last/#usage","title":"Usage","text":"<pre><code>GroupBy_last()\n</code></pre>"},{"location":"reference/GroupBy_last/#value","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/GroupBy_last/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$last()\n</code></pre>"},{"location":"reference/GroupBy_max/","title":"<code>max</code>","text":"<p>GroupBy Max</p>"},{"location":"reference/GroupBy_max/#description","title":"Description","text":"<p>Reduce the groups to the maximum value.</p>"},{"location":"reference/GroupBy_max/#usage","title":"Usage","text":"<pre><code>GroupBy_max()\n</code></pre>"},{"location":"reference/GroupBy_max/#value","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/GroupBy_max/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$max()\n</code></pre>"},{"location":"reference/GroupBy_mean/","title":"<code>mean</code>","text":"<p>GroupBy Mean</p>"},{"location":"reference/GroupBy_mean/#description","title":"Description","text":"<p>Reduce the groups to the mean value.</p>"},{"location":"reference/GroupBy_mean/#usage","title":"Usage","text":"<pre><code>GroupBy_mean()\n</code></pre>"},{"location":"reference/GroupBy_mean/#value","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/GroupBy_mean/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$mean()\n</code></pre>"},{"location":"reference/GroupBy_median/","title":"<code>median</code>","text":"<p>GroupBy Median</p>"},{"location":"reference/GroupBy_median/#description","title":"Description","text":"<p>Reduce the groups to the median value.</p>"},{"location":"reference/GroupBy_median/#usage","title":"Usage","text":"<pre><code>GroupBy_median()\n</code></pre>"},{"location":"reference/GroupBy_median/#value","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/GroupBy_median/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$median()\n</code></pre>"},{"location":"reference/GroupBy_min/","title":"<code>min</code>","text":"<p>GroupBy Min</p>"},{"location":"reference/GroupBy_min/#description","title":"Description","text":"<p>Reduce the groups to the minimum value.</p>"},{"location":"reference/GroupBy_min/#usage","title":"Usage","text":"<pre><code>GroupBy_min()\n</code></pre>"},{"location":"reference/GroupBy_min/#value","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/GroupBy_min/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$min()\n</code></pre>"},{"location":"reference/GroupBy_null_count/","title":"<code>null_count</code>","text":"<p>GroupBy null count</p>"},{"location":"reference/GroupBy_null_count/#description","title":"Description","text":"<p>Create a new DataFrame that shows the null counts per column.</p>"},{"location":"reference/GroupBy_null_count/#usage","title":"Usage","text":"<pre><code>GroupBy_null_count()\n</code></pre>"},{"location":"reference/GroupBy_null_count/#value","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/GroupBy_null_count/#examples","title":"Examples","text":"<pre><code>x = mtcars\nx[1:10, 3:5] = NA\npl$DataFrame(x)$groupby(\"cyl\")$null_count()\n</code></pre>"},{"location":"reference/GroupBy_std/","title":"<code>std</code>","text":"<p>GroupBy Std</p>"},{"location":"reference/GroupBy_std/#description","title":"Description","text":"<p>Reduce the groups to the standard deviation value.</p>"},{"location":"reference/GroupBy_std/#usage","title":"Usage","text":"<pre><code>GroupBy_std()\n</code></pre>"},{"location":"reference/GroupBy_std/#value","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/GroupBy_std/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$std()\n</code></pre>"},{"location":"reference/GroupBy_sum/","title":"<code>sum</code>","text":"<p>GroupBy Sum</p>"},{"location":"reference/GroupBy_sum/#description","title":"Description","text":"<p>Reduce the groups to the sum value.</p>"},{"location":"reference/GroupBy_sum/#usage","title":"Usage","text":"<pre><code>GroupBy_sum()\n</code></pre>"},{"location":"reference/GroupBy_sum/#value","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/GroupBy_sum/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$sum()\n</code></pre>"},{"location":"reference/GroupBy_var/","title":"<code>var</code>","text":"<p>GroupBy Var</p>"},{"location":"reference/GroupBy_var/#description","title":"Description","text":"<p>Reduce the groups to the variance value.</p>"},{"location":"reference/GroupBy_var/#usage","title":"Usage","text":"<pre><code>GroupBy_var()\n</code></pre>"},{"location":"reference/GroupBy_var/#value","title":"Value","text":"<p>aggregated DataFrame</p>"},{"location":"reference/GroupBy_var/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = c(1, 2, 2, 3, 4, 5),\nb = c(0.5, 0.5, 4, 10, 13, 14),\nc = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),\nd = c(\"Apple\", \"Orange\", \"Apple\", \"Apple\", \"Banana\", \"Banana\")\n)\ndf$groupby(\"d\", maintain_order=TRUE)$var()\n</code></pre>"},{"location":"reference/LazyFrame_class/","title":"<code>class</code>","text":"<p>Inner workings of the LazyFrame-class</p>"},{"location":"reference/LazyFrame_class/#description","title":"Description","text":"<p>The <code>LazyFrame</code> -class is simply two environments of respectively the public and private methods/function calls to the polars rust side. The instanciated <code>LazyFrame</code> -object is an <code>externalptr</code> to a lowlevel rust polars LazyFrame  object. The pointer address is the only statefullness of the LazyFrame object on the R side. Any other state resides on the rust side. The S3 method <code>.DollarNames.LazyFrame</code> exposes all public $foobar() -methods which are callable onto the object. Most methods return another <code>LazyFrame</code> -class instance or similar which allows for method chaining. This class system in lack of a better name could be called \"environment classes\" and is the same class system extendr provides, except here there is both a public and private set of methods. For implementation reasons, the private methods are external and must be called from polars:::.pr.$LazyFrame$methodname(), also all private methods must take any self as an argument, thus they are pure functions. Having the private methods as pure functions solved/simplified self-referential complications.</p> <p><code>DataFrame</code> and <code>LazyFrame</code> can both be said to be a <code>Frame</code> . To convert use <code>DataFrame_object$lazy() -&gt; LazyFrame_object</code> and <code>LazyFrame_object$collect() -&gt; DataFrame_object</code> . This is quite similar to the lazy-collect syntax of the dplyrpackage to interact with database connections such as SQL variants. Most SQL databases would be able to perform the same otimizations as polars such Predicate Pushdown and Projection. However polars can intertact and optimize queries with both SQL DBs and other data sources such parquet files simultanously. (#TODO implement r-polars SQL ;)</p>"},{"location":"reference/LazyFrame_class/#details","title":"Details","text":"<p>Check out the source code in R/LazyFrame__lazy.R how public methods are derived from private methods. Check out  extendr-wrappers.R to see the extendr-auto-generated methods. These are moved to .pr and converted into pure external functions in after-wrappers.R. In zzz.R (named zzz to be last file sourced) the extendr-methods are removed and replaced by any function prefixed <code>LazyFrame_</code> .</p>"},{"location":"reference/LazyFrame_class/#examples","title":"Examples","text":"<pre><code>#see all exported methods\nls(polars:::LazyFrame)\n#see all private methods (not intended for regular use)\nls(polars:::.pr$LazyFrame)\n## Practical example ##\n# First writing R iris dataset to disk, to illustrte a difference\ntemp_filepath = tempfile()\nwrite.csv(iris, temp_filepath,row.names = FALSE)\n# Following example illustrates 2 ways to obtain a LazyFrame\n# The-Okay-way: convert an in-memory DataFrame to LazyFrame\n#eager in-mem R data.frame\nRdf = read.csv(temp_filepath)\n#eager in-mem polars DataFrame\nPdf = pl$DataFrame(Rdf)\n#lazy frame starting from in-mem DataFrame\nLdf_okay = Pdf$lazy()\n#The-Best-Way:  LazyFrame created directly from a data source is best...\nLdf_best = pl$lazy_csv_reader(temp_filepath)\n# ... as if to e.g. filter the LazyFrame, that filtering also caleld predicate will be\n# pushed down in the executation stack to the csv_reader, and thereby only bringing into\n# memory the rows matching to filter.\n# apply filter:\nfilter_expr = pl$col(\"Species\") == \"setosa\" #get only rows where Species is setosa\nLdf_okay = Ldf_okay$filter(filter_expr) #overwrite LazyFrame with new\nLdf_best = Ldf_best$filter(filter_expr)\n# the non optimized plans are similar, on entire in-mem csv, apply filter\nLdf_okay$describe_plan()\nLdf_best$describe_plan()\n# NOTE For Ldf_okay, the full time to load csv alrady paid when creating Rdf and Pdf\n#The optimized plan are quite different, Ldf_best will read csv and perform filter simultanously\nLdf_okay$describe_optimized_plan()\nLdf_best$describe_optimized_plan()\n#To acquire result in-mem use $colelct()\nPdf_okay = Ldf_okay$collect()\nPdf_best = Ldf_best$collect()\n#verify tables would be the same\nall.equal(\nPdf_okay$as_data_frame(),\nPdf_best$as_data_frame()\n)\n#a user might write it as a one-liner like so:\nPdf_best2 = pl$lazy_csv_reader(temp_filepath)$filter(pl$col(\"Species\") == \"setosa\")\n</code></pre>"},{"location":"reference/LazyFrame_collect/","title":"<code>collect</code>","text":"<p>New DataFrame from LazyFrame_object$collect()</p>"},{"location":"reference/LazyFrame_collect/#description","title":"Description","text":"<p>collect DataFrame by lazy query</p>"},{"location":"reference/LazyFrame_collect/#usage","title":"Usage","text":"<pre><code>LazyFrame_collect()\n</code></pre>"},{"location":"reference/LazyFrame_collect/#value","title":"Value","text":"<p>collected <code>DataFrame</code></p>"},{"location":"reference/LazyFrame_collect/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$lazy()$filter(pl$col(\"Species\")==\"setosa\")$collect()\n</code></pre>"},{"location":"reference/LazyFrame_collect_background/","title":"<code>collect_background</code>","text":"<p>New DataFrame from LazyFrame_object$collect()</p>"},{"location":"reference/LazyFrame_collect_background/#description","title":"Description","text":"<p>collect DataFrame by lazy query</p>"},{"location":"reference/LazyFrame_collect_background/#usage","title":"Usage","text":"<pre><code>LazyFrame_collect_background()\n</code></pre>"},{"location":"reference/LazyFrame_collect_background/#value","title":"Value","text":"<p>collected <code>DataFrame</code></p>"},{"location":"reference/LazyFrame_collect_background/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$lazy()$filter(pl$col(\"Species\")==\"setosa\")$collect()\n</code></pre>"},{"location":"reference/LazyFrame_describe_optimized_plan/","title":"<code>describe_optimized_plan</code>","text":"<p>Print the optmized plan of LazyFrame</p>"},{"location":"reference/LazyFrame_describe_optimized_plan/#description","title":"Description","text":"<p>select on a LazyFrame</p>"},{"location":"reference/LazyFrame_describe_optimized_plan/#usage","title":"Usage","text":"<pre><code>LazyFrame_describe_optimized_plan()\n</code></pre>"},{"location":"reference/LazyFrame_describe_plan/","title":"<code>describe_plan</code>","text":"<p>Print the non-optimized plan plan of LazyFrame</p>"},{"location":"reference/LazyFrame_describe_plan/#description","title":"Description","text":"<p>select on a LazyFrame</p>"},{"location":"reference/LazyFrame_describe_plan/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/LazyFrame_describe_plan/#usage","title":"Usage","text":"<pre><code>LazyFrame_describe_plan\n</code></pre>"},{"location":"reference/LazyFrame_filter/","title":"<code>filter</code>","text":"<p>Apply filter to LazyFrame</p>"},{"location":"reference/LazyFrame_filter/#description","title":"Description","text":"<p>Filter rows with an Expression definining a boolean column</p>"},{"location":"reference/LazyFrame_filter/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/LazyFrame_filter/#usage","title":"Usage","text":"<pre><code>LazyFrame_filter(expr)\n</code></pre>"},{"location":"reference/LazyFrame_filter/#arguments","title":"Arguments","text":"Argument Description <code>expr</code> one Expr or string naming a column"},{"location":"reference/LazyFrame_filter/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object with add/modified column.</p>"},{"location":"reference/LazyFrame_filter/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$lazy()$filter(pl$col(\"Species\")==\"setosa\")$collect()\n</code></pre>"},{"location":"reference/LazyFrame_first/","title":"<code>first</code>","text":"<p>First</p>"},{"location":"reference/LazyFrame_first/#description","title":"Description","text":"<p>Get the first row of the DataFrame.</p>"},{"location":"reference/LazyFrame_first/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/LazyFrame_first/#usage","title":"Usage","text":"<pre><code>LazyFrame_first\n</code></pre>"},{"location":"reference/LazyFrame_first/#value","title":"Value","text":"<p>A new <code>DataFrame</code> object with applied filter.</p>"},{"location":"reference/LazyFrame_first/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$first()$collect()\n</code></pre>"},{"location":"reference/LazyFrame_groupby/","title":"<code>groupby</code>","text":"<p>Lazy_groupby</p>"},{"location":"reference/LazyFrame_groupby/#description","title":"Description","text":"<p>apply groupby on LazyFrame, return LazyGroupBy</p>"},{"location":"reference/LazyFrame_groupby/#usage","title":"Usage","text":"<pre><code>LazyFrame_groupby(..., maintain_order = FALSE)\n</code></pre>"},{"location":"reference/LazyFrame_groupby/#arguments","title":"Arguments","text":"Argument Description <code>...</code> any single Expr or string naming a column <code>maintain_order</code> bool should an aggregate of groupby retain order of groups or FALSE = random, slightly faster?"},{"location":"reference/LazyFrame_groupby/#value","title":"Value","text":"<p>A new <code>LazyGroupBy</code> object with applied groups.</p>"},{"location":"reference/LazyFrame_join/","title":"<code>join</code>","text":"<p>LazyFrame join</p>"},{"location":"reference/LazyFrame_join/#description","title":"Description","text":"<p>join a LazyFrame</p>"},{"location":"reference/LazyFrame_join/#usage","title":"Usage","text":"<pre><code>LazyFrame_join(\nother,\nleft_on = NULL,\nright_on = NULL,\non = NULL,\nhow = c(\"inner\", \"left\", \"outer\", \"semi\", \"anti\", \"cross\"),\nsuffix = \"_right\",\nallow_parallel = TRUE,\nforce_parallel = FALSE\n)\n</code></pre>"},{"location":"reference/LazyFrame_join/#arguments","title":"Arguments","text":"Argument Description <code>other</code> LazyFrame <code>left_on</code> names of columns in self LazyFrame, order should match. Type, see on param. <code>right_on</code> names of columns in other LazyFrame, order should match. Type, see on param. <code>on</code> named columns as char vector of named columns, or list of expressions and/or strings. <code>how</code> a string selecting one of the following methods: inner, left, outer, semi, anti, cross <code>suffix</code> name to added right table <code>allow_parallel</code> bool <code>force_parallel</code> bool"},{"location":"reference/LazyFrame_join/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied join.</p>"},{"location":"reference/LazyFrame_last/","title":"<code>last</code>","text":"<p>Last</p>"},{"location":"reference/LazyFrame_last/#description","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their maximum value.</p>"},{"location":"reference/LazyFrame_last/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/LazyFrame_last/#usage","title":"Usage","text":"<pre><code>LazyFrame_last\n</code></pre>"},{"location":"reference/LazyFrame_last/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied aggregation.</p>"},{"location":"reference/LazyFrame_last/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$last()$collect()\n</code></pre>"},{"location":"reference/LazyFrame_limit/","title":"<code>limit</code>","text":"<p>Limits</p>"},{"location":"reference/LazyFrame_limit/#description","title":"Description","text":"<p>take limit of n rows of query</p>"},{"location":"reference/LazyFrame_limit/#usage","title":"Usage","text":"<pre><code>LazyFrame_limit(n)\n</code></pre>"},{"location":"reference/LazyFrame_limit/#arguments","title":"Arguments","text":"Argument Description <code>n</code> positive numeric or integer number not larger than 2^32"},{"location":"reference/LazyFrame_limit/#details","title":"Details","text":"<p>any number will converted to u32. Negative raises error</p>"},{"location":"reference/LazyFrame_limit/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied filter.</p>"},{"location":"reference/LazyFrame_limit/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$limit(4)$collect()\n</code></pre>"},{"location":"reference/LazyFrame_max/","title":"<code>max</code>","text":"<p>Max</p>"},{"location":"reference/LazyFrame_max/#description","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their maximum value.</p>"},{"location":"reference/LazyFrame_max/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/LazyFrame_max/#usage","title":"Usage","text":"<pre><code>LazyFrame_max\n</code></pre>"},{"location":"reference/LazyFrame_max/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied aggregation.</p>"},{"location":"reference/LazyFrame_max/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$max()$collect()\n</code></pre>"},{"location":"reference/LazyFrame_mean/","title":"<code>mean</code>","text":"<p>Mean</p>"},{"location":"reference/LazyFrame_mean/#description","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their mean value.</p>"},{"location":"reference/LazyFrame_mean/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/LazyFrame_mean/#usage","title":"Usage","text":"<pre><code>LazyFrame_mean\n</code></pre>"},{"location":"reference/LazyFrame_mean/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied aggregation.</p>"},{"location":"reference/LazyFrame_mean/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$mean()$collect()\n</code></pre>"},{"location":"reference/LazyFrame_median/","title":"<code>median</code>","text":"<p>Median</p>"},{"location":"reference/LazyFrame_median/#description","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their median value.</p>"},{"location":"reference/LazyFrame_median/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/LazyFrame_median/#usage","title":"Usage","text":"<pre><code>LazyFrame_median\n</code></pre>"},{"location":"reference/LazyFrame_median/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied aggregation.</p>"},{"location":"reference/LazyFrame_median/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$median()$collect()\n</code></pre>"},{"location":"reference/LazyFrame_min/","title":"<code>min</code>","text":"<p>Min</p>"},{"location":"reference/LazyFrame_min/#description","title":"Description","text":"<p>Aggregate the columns in the DataFrame to their minimum value.</p>"},{"location":"reference/LazyFrame_min/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/LazyFrame_min/#usage","title":"Usage","text":"<pre><code>LazyFrame_min\n</code></pre>"},{"location":"reference/LazyFrame_min/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied aggregation.</p>"},{"location":"reference/LazyFrame_min/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$min()$collect()\n</code></pre>"},{"location":"reference/LazyFrame_print/","title":"<code>print</code>","text":"<p>print LazyFrame internal method</p>"},{"location":"reference/LazyFrame_print/#description","title":"Description","text":"<p>can be used i the middle of a method chain</p>"},{"location":"reference/LazyFrame_print/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/LazyFrame_print/#usage","title":"Usage","text":"<pre><code>LazyFrame_print(x)\n</code></pre>"},{"location":"reference/LazyFrame_print/#arguments","title":"Arguments","text":"Argument Description <code>x</code> LazyFrame"},{"location":"reference/LazyFrame_print/#value","title":"Value","text":"<p>self</p>"},{"location":"reference/LazyFrame_print/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$lazy()$print()\n</code></pre>"},{"location":"reference/LazyFrame_reverse/","title":"<code>reverse</code>","text":"<p>Reverse</p>"},{"location":"reference/LazyFrame_reverse/#description","title":"Description","text":"<p>Reverse the DataFrame.</p>"},{"location":"reference/LazyFrame_reverse/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/LazyFrame_reverse/#usage","title":"Usage","text":"<pre><code>LazyFrame_reverse\n</code></pre>"},{"location":"reference/LazyFrame_reverse/#value","title":"Value","text":"<p>LazyFrame</p>"},{"location":"reference/LazyFrame_reverse/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$reverse()$collect()\n</code></pre>"},{"location":"reference/LazyFrame_select/","title":"<code>select</code>","text":"<p>Lazy_select</p>"},{"location":"reference/LazyFrame_select/#description","title":"Description","text":"<p>select on a LazyFrame</p>"},{"location":"reference/LazyFrame_select/#usage","title":"Usage","text":"<pre><code>LazyFrame_select(...)\n</code></pre>"},{"location":"reference/LazyFrame_select/#arguments","title":"Arguments","text":"Argument Description <code>...</code> any single Expr or string naming a column"},{"location":"reference/LazyFrame_select/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied filter.</p>"},{"location":"reference/LazyFrame_slice/","title":"<code>slice</code>","text":"<p>Slice</p>"},{"location":"reference/LazyFrame_slice/#description","title":"Description","text":"<p>Get a slice of this DataFrame.</p>"},{"location":"reference/LazyFrame_slice/#usage","title":"Usage","text":"<pre><code>LazyFrame_slice(offset, length = NULL)\n</code></pre>"},{"location":"reference/LazyFrame_slice/#arguments","title":"Arguments","text":"Argument Description <code>offset</code> integer <code>length</code> integer or NULL"},{"location":"reference/LazyFrame_slice/#value","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/LazyFrame_slice/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$slice(2, 4)$collect()\npl$DataFrame(mtcars)$lazy()$slice(30)$collect()\nmtcars[2:6,]\n</code></pre>"},{"location":"reference/LazyFrame_std/","title":"<code>std</code>","text":"<p>Std</p>"},{"location":"reference/LazyFrame_std/#description","title":"Description","text":"<p>Aggregate the columns of this LazyFrame to their standard deviation values.</p>"},{"location":"reference/LazyFrame_std/#usage","title":"Usage","text":"<pre><code>LazyFrame_std(ddof = 1)\n</code></pre>"},{"location":"reference/LazyFrame_std/#arguments","title":"Arguments","text":"Argument Description <code>ddof</code> integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1."},{"location":"reference/LazyFrame_std/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied aggregation.</p>"},{"location":"reference/LazyFrame_std/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$std()$collect()\n</code></pre>"},{"location":"reference/LazyFrame_sum/","title":"<code>sum</code>","text":"<p>Sum</p>"},{"location":"reference/LazyFrame_sum/#description","title":"Description","text":"<p>Aggregate the columns of this DataFrame to their sum values.</p>"},{"location":"reference/LazyFrame_sum/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/LazyFrame_sum/#usage","title":"Usage","text":"<pre><code>LazyFrame_sum\n</code></pre>"},{"location":"reference/LazyFrame_sum/#value","title":"Value","text":"<p>LazyFrame</p>"},{"location":"reference/LazyFrame_sum/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$sum()$collect()\n</code></pre>"},{"location":"reference/LazyFrame_tail/","title":"<code>tail</code>","text":"<p>Tail</p>"},{"location":"reference/LazyFrame_tail/#description","title":"Description","text":"<p>take last n rows of query</p>"},{"location":"reference/LazyFrame_tail/#usage","title":"Usage","text":"<pre><code>LazyFrame_tail(n)\n</code></pre>"},{"location":"reference/LazyFrame_tail/#arguments","title":"Arguments","text":"Argument Description <code>n</code> positive numeric or integer number not larger than 2^32"},{"location":"reference/LazyFrame_tail/#details","title":"Details","text":"<p>any number will converted to u32. Negative raises error</p>"},{"location":"reference/LazyFrame_tail/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied filter.</p>"},{"location":"reference/LazyFrame_tail/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$tail(2)$collect()\n</code></pre>"},{"location":"reference/LazyFrame_var/","title":"<code>var</code>","text":"<p>Var</p>"},{"location":"reference/LazyFrame_var/#description","title":"Description","text":"<p>Aggregate the columns of this LazyFrame to their variance values.</p>"},{"location":"reference/LazyFrame_var/#usage","title":"Usage","text":"<pre><code>LazyFrame_var(ddof = 1)\n</code></pre>"},{"location":"reference/LazyFrame_var/#arguments","title":"Arguments","text":"Argument Description <code>ddof</code> integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1."},{"location":"reference/LazyFrame_var/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object with applied aggregation.</p>"},{"location":"reference/LazyFrame_var/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(mtcars)$lazy()$var()$collect()\n</code></pre>"},{"location":"reference/LazyFrame_with_column/","title":"<code>with_column</code>","text":"<p>Lazy with column</p>"},{"location":"reference/LazyFrame_with_column/#description","title":"Description","text":"<p>add or replace columns of LazyFrame</p>"},{"location":"reference/LazyFrame_with_column/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/LazyFrame_with_column/#usage","title":"Usage","text":"<pre><code>LazyFrame_with_column(expr)\n</code></pre>"},{"location":"reference/LazyFrame_with_column/#arguments","title":"Arguments","text":"Argument Description <code>expr</code> one Expr or string naming a column"},{"location":"reference/LazyFrame_with_column/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object with add/modified column.</p>"},{"location":"reference/LazyFrame_with_columns/","title":"<code>with_columns</code>","text":"<p>Lazy with columns</p>"},{"location":"reference/LazyFrame_with_columns/#description","title":"Description","text":"<p>add or replace columns of LazyFrame</p>"},{"location":"reference/LazyFrame_with_columns/#usage","title":"Usage","text":"<pre><code>LazyFrame_with_columns(...)\n</code></pre>"},{"location":"reference/LazyFrame_with_columns/#arguments","title":"Arguments","text":"Argument Description <code>...</code> any single Expr or string naming a column"},{"location":"reference/LazyFrame_with_columns/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object with added/modified columns.</p>"},{"location":"reference/LazyGroupBy_agg/","title":"<code>agg</code>","text":"<p>LazyGroupBy_agg</p>"},{"location":"reference/LazyGroupBy_agg/#description","title":"Description","text":"<p>aggregate a polar_lazy_groupby</p>"},{"location":"reference/LazyGroupBy_agg/#usage","title":"Usage","text":"<pre><code>LazyGroupBy_agg(...)\n</code></pre>"},{"location":"reference/LazyGroupBy_agg/#arguments","title":"Arguments","text":"Argument Description <code>...</code> any Expr or string"},{"location":"reference/LazyGroupBy_agg/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object.</p>"},{"location":"reference/LazyGroupBy_apply/","title":"<code>apply</code>","text":"<p>LazyGroupBy_apply</p>"},{"location":"reference/LazyGroupBy_apply/#description","title":"Description","text":"<p>one day this will apply</p>"},{"location":"reference/LazyGroupBy_apply/#usage","title":"Usage","text":"<pre><code>LazyGroupBy_apply(f)\n</code></pre>"},{"location":"reference/LazyGroupBy_apply/#arguments","title":"Arguments","text":"Argument Description <code>f</code> R function to apply"},{"location":"reference/LazyGroupBy_apply/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object.</p>"},{"location":"reference/LazyGroupBy_class/","title":"<code>class</code>","text":"<p>Use groups on a Polars lazy DataFrame</p>"},{"location":"reference/LazyGroupBy_class/#description","title":"Description","text":"<p>Use groups on a Polars lazy DataFrame</p>"},{"location":"reference/LazyGroupBy_class/#value","title":"Value","text":"<p>A lazy grouped DataFrame</p>"},{"location":"reference/LazyGroupBy_head/","title":"<code>head</code>","text":"<p>LazyGroupBy_head</p>"},{"location":"reference/LazyGroupBy_head/#description","title":"Description","text":"<p>get n rows of head of group</p>"},{"location":"reference/LazyGroupBy_head/#usage","title":"Usage","text":"<pre><code>LazyGroupBy_head(n = 1L)\n</code></pre>"},{"location":"reference/LazyGroupBy_head/#arguments","title":"Arguments","text":"Argument Description <code>n</code> integer number of rows to get"},{"location":"reference/LazyGroupBy_head/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object.</p>"},{"location":"reference/LazyGroupBy_print/","title":"<code>print</code>","text":"<p>LazyGroupBy_print</p>"},{"location":"reference/LazyGroupBy_print/#description","title":"Description","text":"<p>prints opague groupby, not much to show</p>"},{"location":"reference/LazyGroupBy_print/#usage","title":"Usage","text":"<pre><code>LazyGroupBy_print()\n</code></pre>"},{"location":"reference/LazyGroupBy_tail/","title":"<code>tail</code>","text":"<p>LazyGroupBy_tail</p>"},{"location":"reference/LazyGroupBy_tail/#description","title":"Description","text":"<p>get n tail rows of group</p>"},{"location":"reference/LazyGroupBy_tail/#usage","title":"Usage","text":"<pre><code>LazyGroupBy_tail(n = 1L)\n</code></pre>"},{"location":"reference/LazyGroupBy_tail/#arguments","title":"Arguments","text":"Argument Description <code>n</code> integer number of rows to get"},{"location":"reference/LazyGroupBy_tail/#value","title":"Value","text":"<p>A new <code>LazyFrame</code> object.</p>"},{"location":"reference/Ok/","title":"<code>Ok</code>","text":"<p>Wrap in Ok</p>"},{"location":"reference/Ok/#description","title":"Description","text":"<p>Wrap in Ok</p>"},{"location":"reference/Ok/#usage","title":"Usage","text":"<pre><code>Ok(x)\n</code></pre>"},{"location":"reference/Ok/#arguments","title":"Arguments","text":"Argument Description <code>x</code> any R object"},{"location":"reference/Ok/#value","title":"Value","text":"<p>same R object wrapped in a Ok-result</p>"},{"location":"reference/PolarsBackgroundHandle_is_exhausted/","title":"<code>PolarsBackgroundHandle_is_exhausted</code>","text":"<p>PolarsBackgroundHandle</p>"},{"location":"reference/PolarsBackgroundHandle_is_exhausted/#description","title":"Description","text":"<p>PolarsBackgroundHandle</p>"},{"location":"reference/PolarsBackgroundHandle_is_exhausted/#usage","title":"Usage","text":"<pre><code>PolarsBackgroundHandle_is_exhausted()\n</code></pre>"},{"location":"reference/PolarsBackgroundHandle_is_exhausted/#value","title":"Value","text":"<p>Bool</p>"},{"location":"reference/PolarsBackgroundHandle_is_exhausted/#examples","title":"Examples","text":"<pre><code>lazy_df = pl$DataFrame(iris[,1:3])$lazy()$select(pl$all()$first())\nhandle = lazy_df$collect_background()\nhandle$is_exhausted()\ndf = handle$join()\nhandle$is_exhausted()\n</code></pre>"},{"location":"reference/PolarsBackgroundHandle_join/","title":"<code>PolarsBackgroundHandle_join</code>","text":"<p>PolarsBackgroundHandle</p>"},{"location":"reference/PolarsBackgroundHandle_join/#description","title":"Description","text":"<p>PolarsBackgroundHandle</p>"},{"location":"reference/PolarsBackgroundHandle_join/#usage","title":"Usage","text":"<pre><code>PolarsBackgroundHandle_join()\n</code></pre>"},{"location":"reference/PolarsBackgroundHandle_join/#value","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/PolarsBackgroundHandle_join/#examples","title":"Examples","text":"<pre><code>lazy_df = pl$DataFrame(iris[,1:3])$lazy()$select(pl$all()$first())\nhandle = lazy_df$collect_background()\ndf = handle$join()\n</code></pre>"},{"location":"reference/RField_name/","title":"<code>RField_name</code>","text":"<p>get/set Field name</p>"},{"location":"reference/RField_name/#description","title":"Description","text":"<p>get/set Field name</p>"},{"location":"reference/RField_name/#usage","title":"Usage","text":"<pre><code>RField_name()\n</code></pre>"},{"location":"reference/RField_name/#value","title":"Value","text":"<p>name</p>"},{"location":"reference/RField_name/#examples","title":"Examples","text":"<pre><code>field = pl$Field(\"Cities\",pl$Utf8)\n#get name / datatype\nfield$name\nfield$datatype\n#set + get values\nfield$name = \"CityPoPulations\" #&lt;- is fine too\nfield$datatype = pl$UInt32\nprint(field)\n</code></pre>"},{"location":"reference/RField_print/","title":"<code>RField_print</code>","text":"<p>Print a polars Field</p>"},{"location":"reference/RField_print/#description","title":"Description","text":"<p>Print a polars Field</p>"},{"location":"reference/RField_print/#usage","title":"Usage","text":"<pre><code>RField_print()\n</code></pre>"},{"location":"reference/RField_print/#value","title":"Value","text":"<p>self</p>"},{"location":"reference/RField_print/#examples","title":"Examples","text":"<pre><code>print(pl$Field(\"foo\",pl$List(pl$UInt64)))\n</code></pre>"},{"location":"reference/Series/","title":"<code>Series</code>","text":"<p>Create new Series</p>"},{"location":"reference/Series/#description","title":"Description","text":"<p>found in api as pl$Series named Series_constructor internally</p>"},{"location":"reference/Series/#arguments","title":"Arguments","text":"Argument Description <code>x</code> any vector <code>name</code> string"},{"location":"reference/Series/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series/#examples","title":"Examples","text":"<pre><code>{\npl$Series(1:4)\n}\n</code></pre>"},{"location":"reference/Series_abs/","title":"<code>abs</code>","text":"<p>Take absolute value of Series</p>"},{"location":"reference/Series_abs/#description","title":"Description","text":"<p>Take absolute value of Series</p>"},{"location":"reference/Series_abs/#usage","title":"Usage","text":"<pre><code>Series_abs()\n</code></pre>"},{"location":"reference/Series_abs/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_abs/#examples","title":"Examples","text":"<pre><code>pl$Series(-2:2)$abs()\n</code></pre>"},{"location":"reference/Series_add/","title":"<code>add</code>","text":"<p>add Series</p>"},{"location":"reference/Series_add/#description","title":"Description","text":"<p>Series arithmetics</p>"},{"location":"reference/Series_add/#usage","title":"Usage","text":"<pre><code>Series_add(other)\nlist(list(\"+\"), list(\"Series\"))(s1, s2)\n</code></pre>"},{"location":"reference/Series_add/#arguments","title":"Arguments","text":"Argument Description <code>other</code> Series or into Series <code>s1</code> lhs Series <code>s2</code> rhs Series or any into Series"},{"location":"reference/Series_add/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_add/#examples","title":"Examples","text":"<pre><code>pl$Series(1:3)$add(11:13)\npl$Series(1:3)$add(pl$Series(11:13))\npl$Series(1:3)$add(1L)\n1L + pl$Series(1:3)\npl$Series(1:3) + 1L\n</code></pre>"},{"location":"reference/Series_alias/","title":"<code>alias</code>","text":"<p>Alias</p>"},{"location":"reference/Series_alias/#description","title":"Description","text":"<p>Change name of Series</p>"},{"location":"reference/Series_alias/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Series_alias/#usage","title":"Usage","text":"<pre><code>Series_alias(name)\n</code></pre>"},{"location":"reference/Series_alias/#arguments","title":"Arguments","text":"Argument Description <code>name</code> a String as the new name"},{"location":"reference/Series_alias/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_alias/#examples","title":"Examples","text":"<pre><code>pl$Series(1:3,name = \"alice\")$alias(\"bob\")\n</code></pre>"},{"location":"reference/Series_all/","title":"<code>all</code>","text":"<p>Reduce Boolean Series with ALL</p>"},{"location":"reference/Series_all/#description","title":"Description","text":"<p>Reduce Boolean Series with ALL</p>"},{"location":"reference/Series_all/#usage","title":"Usage","text":"<pre><code>Series_all()\n</code></pre>"},{"location":"reference/Series_all/#value","title":"Value","text":"<p>bool</p>"},{"location":"reference/Series_all/#examples","title":"Examples","text":"<pre><code>pl$Series(c(TRUE,TRUE,NA))$all()\n</code></pre>"},{"location":"reference/Series_any/","title":"<code>any</code>","text":"<p>Reduce Boolean Series with ANY</p>"},{"location":"reference/Series_any/#description","title":"Description","text":"<p>Reduce Boolean Series with ANY</p>"},{"location":"reference/Series_any/#usage","title":"Usage","text":"<pre><code>Series_any()\n</code></pre>"},{"location":"reference/Series_any/#value","title":"Value","text":"<p>bool</p>"},{"location":"reference/Series_any/#examples","title":"Examples","text":"<pre><code>pl$Series(c(TRUE,FALSE,NA))$any()\n</code></pre>"},{"location":"reference/Series_append/","title":"<code>append</code>","text":"<p>append (default immutable)</p>"},{"location":"reference/Series_append/#description","title":"Description","text":"<p>append two Series, see details for mutability</p>"},{"location":"reference/Series_append/#usage","title":"Usage","text":"<pre><code>Series_append(other, immutable = TRUE)\n</code></pre>"},{"location":"reference/Series_append/#arguments","title":"Arguments","text":"Argument Description <code>other</code> Series to append <code>immutable</code> bool should append be immutable, default TRUE as mutable operations should be avoided in plain R API's."},{"location":"reference/Series_append/#details","title":"Details","text":"<p>if immutable = FLASE, the Series object will not behave as immutable. This mean appending to this Series will affect any variable pointing to this memory location. This will break normal scoping rules of R. Polars-clones are cheap. Mutable operations are likely never needed in any sense.</p>"},{"location":"reference/Series_append/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_append/#examples","title":"Examples","text":"<pre><code>#default immutable behaviour, s_imut and s_imut_copy stay the same\ns_imut = pl$Series(1:3)\ns_imut_copy = s_imut\ns_new = s_imut$append(pl$Series(1:3))\nidentical(s_imut$to_r_vector(),s_imut_copy$to_r_vector())\n#pypolars-like mutable behaviour,s_mut_copy become the same as s_new\ns_mut = pl$Series(1:3)\ns_mut_copy = s_mut\n#must deactivate this to allow to use immutable=FALSE\npl$set_polars_options(strictly_immutable = FALSE)\ns_new = s_mut$append(pl$Series(1:3),immutable= FALSE)\nidentical(s_new$to_r_vector(),s_mut_copy$to_r_vector())\n</code></pre>"},{"location":"reference/Series_apply/","title":"<code>apply</code>","text":"<p>Apply every value with an R fun</p>"},{"location":"reference/Series_apply/#description","title":"Description","text":"<p>About as slow as regular non-vectorized R. Similar to using R sapply on a vector.</p>"},{"location":"reference/Series_apply/#usage","title":"Usage","text":"<pre><code>Series_apply(\nfun,\ndatatype = NULL,\nstrict_return_type = TRUE,\nallow_fail_eval = FALSE\n)\n</code></pre>"},{"location":"reference/Series_apply/#arguments","title":"Arguments","text":"Argument Description <code>fun</code> r function, should take a scalar value as input and return one. <code>datatype</code> DataType of return value. Default NULL means same as input. <code>strict_return_type</code> bool, default TRUE: fail on wrong return type, FALSE: convert to polars Null <code>allow_fail_eval</code> bool, default FALSE: raise R fun error, TRUE: convert to polars Null"},{"location":"reference/Series_apply/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_apply/#examples","title":"Examples","text":"<pre><code>s = pl$Series(letters[1:5],\"ltrs\")\nf = \\(x) paste(x,\":\",as.integer(charToRaw(x)))\ns$apply(f,pl$Utf8)\n#same as\npl$Series(sapply(s$to_r(),f),s$name)\n</code></pre>"},{"location":"reference/Series_arg_max/","title":"<code>arg_max</code>","text":"<p>idx to max value</p>"},{"location":"reference/Series_arg_max/#description","title":"Description","text":"<p>idx to max value</p>"},{"location":"reference/Series_arg_max/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Series_arg_max/#usage","title":"Usage","text":"<pre><code>Series_arg_max\n</code></pre>"},{"location":"reference/Series_arg_max/#value","title":"Value","text":"<p>bool</p>"},{"location":"reference/Series_arg_max/#examples","title":"Examples","text":"<pre><code>pl$Series(c(5,1))$arg_max()\n</code></pre>"},{"location":"reference/Series_arg_min/","title":"<code>arg_min</code>","text":"<p>idx to min value</p>"},{"location":"reference/Series_arg_min/#description","title":"Description","text":"<p>idx to min value</p>"},{"location":"reference/Series_arg_min/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Series_arg_min/#usage","title":"Usage","text":"<pre><code>Series_arg_min\n</code></pre>"},{"location":"reference/Series_arg_min/#value","title":"Value","text":"<p>bool</p>"},{"location":"reference/Series_arg_min/#examples","title":"Examples","text":"<pre><code>pl$Series(c(5,1))$arg_min()\n</code></pre>"},{"location":"reference/Series_arr/","title":"<code>arr</code>","text":"<p>arr: list related methods on Series of dtype List</p>"},{"location":"reference/Series_arr/#description","title":"Description","text":"<p>Create an object namespace of all list related methods. See the individual method pages for full details</p>"},{"location":"reference/Series_arr/#usage","title":"Usage","text":"<pre><code>Series_arr()\n</code></pre>"},{"location":"reference/Series_arr/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Series_arr/#examples","title":"Examples","text":"<pre><code>s = pl$Series(list(1:3,1:2,NULL))\ns\ns$arr$first()\n</code></pre>"},{"location":"reference/Series_ceil/","title":"<code>ceil</code>","text":"<p>Series_ceil</p>"},{"location":"reference/Series_ceil/#description","title":"Description","text":"<p>Ceil of this Series</p>"},{"location":"reference/Series_ceil/#usage","title":"Usage","text":"<pre><code>Series_ceil()\n</code></pre>"},{"location":"reference/Series_ceil/#value","title":"Value","text":"<p>bool</p>"},{"location":"reference/Series_ceil/#examples","title":"Examples","text":"<pre><code>pl$Series(c(.5,1.999))$ceil()\n</code></pre>"},{"location":"reference/Series_chunk_lengths/","title":"<code>chunk_lengths</code>","text":"<p>Lengths of Series memory chunks</p>"},{"location":"reference/Series_chunk_lengths/#description","title":"Description","text":"<p>Get the Lengths of Series memory chunks as vector.</p>"},{"location":"reference/Series_chunk_lengths/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Series_chunk_lengths/#usage","title":"Usage","text":"<pre><code>Series_chunk_lengths\n</code></pre>"},{"location":"reference/Series_chunk_lengths/#value","title":"Value","text":"<p>numeric vector. Length is number of chunks. Sum of lengths is equal to size of Series.</p>"},{"location":"reference/Series_chunk_lengths/#examples","title":"Examples","text":"<pre><code>chunked_series = c(pl$Series(1:3),pl$Series(1:10))\nchunked_series$chunk_lengths()\n</code></pre>"},{"location":"reference/Series_class/","title":"<code>class</code>","text":"<p>Inner workings of the Series-class</p>"},{"location":"reference/Series_class/#description","title":"Description","text":"<p>The <code>Series</code> -class is simply two environments of respectively the public and private methods/function calls to the polars rust side. The instanciated <code>Series</code> -object is an <code>externalptr</code> to a lowlevel rust polars Series  object. The pointer address is the only statefullness of the Series object on the R side. Any other state resides on the rust side. The S3 method <code>.DollarNames.Series</code> exposes all public $foobar() -methods which are callable onto the object. Most methods return another <code>Series</code> -class instance or similar which allows for method chaining. This class system in lack of a better name could be called \"environment classes\" and is the same class system extendr provides, except here there is both a public and private set of methods. For implementation reasons, the private methods are external and must be called from polars:::.pr.$Series$methodname(), also all private methods must take any self as an argument, thus they are pure functions. Having the private methods as pure functions solved/simplified self-referential complications.</p>"},{"location":"reference/Series_class/#details","title":"Details","text":"<p>Check out the source code in R/Series_frame.R how public methods are derived from private methods. Check out  extendr-wrappers.R to see the extendr-auto-generated methods. These are moved to .pr and converted into pure external functions in after-wrappers.R. In zzz.R (named zzz to be last file sourced) the extendr-methods are removed and replaced by any function prefixed <code>Series_</code> .</p>"},{"location":"reference/Series_class/#examples","title":"Examples","text":"<pre><code>#see all exported methods\nls(polars:::Series)\n#see all private methods (not intended for regular use)\nls(polars:::.pr$Series)\n#make an object\ns = pl$Series(1:3)\n#use a public method/property\ns$shape\n#use a private method (mutable append not allowed in public api)\ns_copy = s\n.pr$Series$append_mut(s, pl$Series(5:1))\nidentical(s_copy$to_r(), s$to_r()) # s_copy was modified when s was modified\n</code></pre>"},{"location":"reference/Series_clone/","title":"<code>clone</code>","text":"<p>Clone a Series</p>"},{"location":"reference/Series_clone/#description","title":"Description","text":"<p>Rarely useful as Series are nearly 100% immutable Any modification of a Series should lead to a clone anyways.</p>"},{"location":"reference/Series_clone/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Series_clone/#usage","title":"Usage","text":"<pre><code>Series_clone\n</code></pre>"},{"location":"reference/Series_clone/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_clone/#examples","title":"Examples","text":"<pre><code>s1 = pl$Series(1:3);\ns2 =  s1$clone();\ns3 = s1\npl$mem_address(s1) != pl$mem_address(s2)\npl$mem_address(s1) == pl$mem_address(s3)\n</code></pre>"},{"location":"reference/Series_compare/","title":"<code>compare</code>","text":"<p>Compare Series</p>"},{"location":"reference/Series_compare/#description","title":"Description","text":"<p>compare two Series</p>"},{"location":"reference/Series_compare/#usage","title":"Usage","text":"<pre><code>Series_compare(other, op)\nlist(list(\"==\"), list(\"Series\"))(s1, s2)\nlist(list(\"!=\"), list(\"Series\"))(s1, s2)\nlist(list(\"&lt;\"), list(\"Series\"))(s1, s2)\nlist(list(\"&gt;\"), list(\"Series\"))(s1, s2)\nlist(list(\"&lt;=\"), list(\"Series\"))(s1, s2)\nlist(list(\"&gt;=\"), list(\"Series\"))(s1, s2)\n</code></pre>"},{"location":"reference/Series_compare/#arguments","title":"Arguments","text":"Argument Description <code>other</code> A Series or something a Series can be created from <code>op</code> the chosen operator a String either: 'equal', 'not_equal', 'lt', 'gt', 'lt_eq' or 'gt_eq' <code>s1</code> lhs Series <code>s2</code> rhs Series or any into Series"},{"location":"reference/Series_compare/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_compare/#examples","title":"Examples","text":"<pre><code>pl$Series(1:5) == pl$Series(c(1:3,NA_integer_,10L))\n</code></pre>"},{"location":"reference/Series_cumsum/","title":"<code>cumsum</code>","text":"<p>Cumulative sum</p>"},{"location":"reference/Series_cumsum/#description","title":"Description","text":"<p>Get an array with the cumulative sum computed at every element.</p>"},{"location":"reference/Series_cumsum/#usage","title":"Usage","text":"<pre><code>Series_cumsum(reverse = FALSE)\n</code></pre>"},{"location":"reference/Series_cumsum/#arguments","title":"Arguments","text":"Argument Description <code>reverse</code> bool, default FALSE, if true roll over vector from back to forth"},{"location":"reference/Series_cumsum/#details","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues.</p>"},{"location":"reference/Series_cumsum/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_cumsum/#examples","title":"Examples","text":"<pre><code>pl$Series(c(1:2,NA,3,NaN,4,Inf))$cumsum()\npl$Series(c(1:2,NA,3,Inf,4,-Inf,5))$cumsum()\n</code></pre>"},{"location":"reference/Series_div/","title":"<code>div</code>","text":"<p>div Series</p>"},{"location":"reference/Series_div/#description","title":"Description","text":"<p>Series arithmetics</p>"},{"location":"reference/Series_div/#usage","title":"Usage","text":"<pre><code>Series_div(other)\nlist(list(\"/\"), list(\"Series\"))(s1, s2)\n</code></pre>"},{"location":"reference/Series_div/#arguments","title":"Arguments","text":"Argument Description <code>other</code> Series or into Series <code>s1</code> lhs Series <code>s2</code> rhs Series or any into Series"},{"location":"reference/Series_div/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_div/#examples","title":"Examples","text":"<pre><code>pl$Series(1:3)$div(11:13)\npl$Series(1:3)$div(pl$Series(11:13))\npl$Series(1:3)$div(1L)\n2L / pl$Series(1:3)\npl$Series(1:3) / 2L\n</code></pre>"},{"location":"reference/Series_dtype/","title":"<code>dtype</code>","text":"<p>Get data type of Series</p>"},{"location":"reference/Series_dtype/#description","title":"Description","text":"<p>Get data type of Series</p> <p>Get data type of Series</p>"},{"location":"reference/Series_dtype/#usage","title":"Usage","text":"<pre><code>Series_dtype()\nSeries_flags()\n</code></pre>"},{"location":"reference/Series_dtype/#details","title":"Details","text":"<p>property sorted flags are not settable, use set_sorted</p>"},{"location":"reference/Series_dtype/#value","title":"Value","text":"<p>DataType</p> <p>DataType</p>"},{"location":"reference/Series_dtype/#examples","title":"Examples","text":"<pre><code>pl$Series(1:4)$dtype\npl$Series(c(1,2))$dtype\npl$Series(letters)$dtype\npl$Series(1:4)$sort()$flags\n</code></pre>"},{"location":"reference/Series_expr/","title":"<code>expr</code>","text":"<p>Any expr method on a Series</p>"},{"location":"reference/Series_expr/#description","title":"Description","text":"<p>Call an expression on a Series See the individual Expr method pages for full details</p>"},{"location":"reference/Series_expr/#usage","title":"Usage","text":"<pre><code>Series_expr()\n</code></pre>"},{"location":"reference/Series_expr/#details","title":"Details","text":"<p>This is a shorthand of writing  something like <code>pl$DataFrame(s)$select(pl$col(\"sname\")$expr)$to_series(0)</code></p> <p>This subnamespace is experimental. Submit an issue if anything unexpected happend.</p>"},{"location":"reference/Series_expr/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Series_expr/#examples","title":"Examples","text":"<pre><code>s = pl$Series(list(1:3,1:2,NULL))\ns$expr$first()\ns$expr$alias(\"alice\")\n</code></pre>"},{"location":"reference/Series_floor/","title":"<code>floor</code>","text":"<p>Series_floor</p>"},{"location":"reference/Series_floor/#description","title":"Description","text":"<p>Floor of this Series</p>"},{"location":"reference/Series_floor/#usage","title":"Usage","text":"<pre><code>Series_floor()\n</code></pre>"},{"location":"reference/Series_floor/#value","title":"Value","text":"<p>numeric</p>"},{"location":"reference/Series_floor/#examples","title":"Examples","text":"<pre><code>pl$Series(c(.5,1.999))$floor()\n</code></pre>"},{"location":"reference/Series_is_numeric/","title":"<code>is_numeric</code>","text":"<p>is_numeric</p>"},{"location":"reference/Series_is_numeric/#description","title":"Description","text":"<p>return bool whether series is numeric</p>"},{"location":"reference/Series_is_numeric/#format","title":"Format","text":"<p>method</p>"},{"location":"reference/Series_is_numeric/#usage","title":"Usage","text":"<pre><code>Series_is_numeric()\n</code></pre>"},{"location":"reference/Series_is_numeric/#details","title":"Details","text":"<p>true of series dtype is member of pl$numeric_dtypes</p>"},{"location":"reference/Series_is_numeric/#value","title":"Value","text":"<p>bool</p>"},{"location":"reference/Series_is_numeric/#examples","title":"Examples","text":"<pre><code>pl$Series(1:4)$is_numeric()\npl$Series(c(\"a\",\"b\",\"c\"))$is_numeric()\npl$numeric_dtypes\n</code></pre>"},{"location":"reference/Series_is_sorted/","title":"<code>is_sorted</code>","text":"<p>is_sorted</p>"},{"location":"reference/Series_is_sorted/#description","title":"Description","text":"<p>is_sorted</p>"},{"location":"reference/Series_is_sorted/#usage","title":"Usage","text":"<pre><code>Series_is_sorted(reverse = FALSE, nulls_last = NULL)\n</code></pre>"},{"location":"reference/Series_is_sorted/#arguments","title":"Arguments","text":"Argument Description <code>reverse</code> order sorted <code>nulls_last</code> bool where to keep nulls, default same as reverse"},{"location":"reference/Series_is_sorted/#details","title":"Details","text":"<p>property sorted flags are not settable, use set_sorted</p>"},{"location":"reference/Series_is_sorted/#value","title":"Value","text":"<p>DataType</p>"},{"location":"reference/Series_is_sorted/#examples","title":"Examples","text":"<pre><code>pl$Series(1:4)$sort()$is_sorted()\n</code></pre>"},{"location":"reference/Series_len/","title":"<code>len</code>","text":"<p>Series_len</p>"},{"location":"reference/Series_len/#description","title":"Description","text":"<p>Length of this Series.</p>"},{"location":"reference/Series_len/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Series_len/#usage","title":"Usage","text":"<pre><code>Series_len\n</code></pre>"},{"location":"reference/Series_len/#value","title":"Value","text":"<p>numeric</p>"},{"location":"reference/Series_len/#examples","title":"Examples","text":"<pre><code>pl$Series(1:10)$len()\n</code></pre>"},{"location":"reference/Series_max/","title":"<code>max</code>","text":"<p>max</p>"},{"location":"reference/Series_max/#description","title":"Description","text":"<p>Reduce Series with max</p>"},{"location":"reference/Series_max/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Series_max/#usage","title":"Usage","text":"<pre><code>Series_max\n</code></pre>"},{"location":"reference/Series_max/#details","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before maxming to prevent overflow issues.</p>"},{"location":"reference/Series_max/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_max/#examples","title":"Examples","text":"<pre><code>pl$Series(c(1:2,NA,3,5))$max() # a NA is dropped always\npl$Series(c(1:2,NA,3,NaN,4,Inf))$max() # NaN carries / poisons\npl$Series(c(1:2,3,Inf,4,-Inf,5))$max() # Inf-Inf is NaN\n</code></pre>"},{"location":"reference/Series_min/","title":"<code>min</code>","text":"<p>min</p>"},{"location":"reference/Series_min/#description","title":"Description","text":"<p>Reduce Series with min</p>"},{"location":"reference/Series_min/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Series_min/#usage","title":"Usage","text":"<pre><code>Series_min\n</code></pre>"},{"location":"reference/Series_min/#details","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before minming to prevent overflow issues.</p>"},{"location":"reference/Series_min/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_min/#examples","title":"Examples","text":"<pre><code>pl$Series(c(1:2,NA,3,5))$min() # a NA is dropped always\npl$Series(c(1:2,NA,3,NaN,4,Inf))$min() # NaN carries / poisons\npl$Series(c(1:2,3,Inf,4,-Inf,5))$min() # Inf-Inf is NaN\n</code></pre>"},{"location":"reference/Series_mul/","title":"<code>mul</code>","text":"<p>mul Series</p>"},{"location":"reference/Series_mul/#description","title":"Description","text":"<p>Series arithmetics</p>"},{"location":"reference/Series_mul/#usage","title":"Usage","text":"<pre><code>Series_mul(other)\nlist(list(\"*\"), list(\"Series\"))(s1, s2)\n</code></pre>"},{"location":"reference/Series_mul/#arguments","title":"Arguments","text":"Argument Description <code>other</code> Series or into Series <code>s1</code> lhs Series <code>s2</code> rhs Series or any into Series"},{"location":"reference/Series_mul/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_mul/#examples","title":"Examples","text":"<pre><code>pl$Series(1:3)$mul(11:13)\npl$Series(1:3)$mul(pl$Series(11:13))\npl$Series(1:3)$mul(1L)\n2L * pl$Series(1:3)\npl$Series(1:3) * 2L\n</code></pre>"},{"location":"reference/Series_name/","title":"<code>name</code>","text":"<p>Property: Name</p>"},{"location":"reference/Series_name/#description","title":"Description","text":"<p>Get name of Series</p>"},{"location":"reference/Series_name/#usage","title":"Usage","text":"<pre><code>Series_name()\n</code></pre>"},{"location":"reference/Series_name/#value","title":"Value","text":"<p>String the name</p>"},{"location":"reference/Series_name/#examples","title":"Examples","text":"<pre><code>pl$Series(1:3,name = \"alice\")$name\n</code></pre>"},{"location":"reference/Series_print/","title":"<code>print</code>","text":"<p>Print Series</p>"},{"location":"reference/Series_print/#description","title":"Description","text":"<p>Print Series</p> <p>Print Series</p>"},{"location":"reference/Series_print/#usage","title":"Usage","text":"<pre><code>list(list(\"print\"), list(\"Series\"))(x, ...)\nSeries_print()\n</code></pre>"},{"location":"reference/Series_print/#arguments","title":"Arguments","text":"Argument Description <code>x</code> Series <code>...</code> not used"},{"location":"reference/Series_print/#value","title":"Value","text":"<p>invisible(self)</p> <p>self</p>"},{"location":"reference/Series_print/#examples","title":"Examples","text":"<pre><code>print(pl$Series(1:3))\npl$Series(1:3)\n</code></pre>"},{"location":"reference/Series_rem/","title":"<code>rem</code>","text":"<p>rem Series</p>"},{"location":"reference/Series_rem/#description","title":"Description","text":"<p>Series arithmetics, remainder</p>"},{"location":"reference/Series_rem/#usage","title":"Usage","text":"<pre><code>Series_rem(other)\n</code></pre>"},{"location":"reference/Series_rem/#arguments","title":"Arguments","text":"Argument Description <code>other</code> Series or into Series"},{"location":"reference/Series_rem/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_rem/#examples","title":"Examples","text":"<pre><code>pl$Series(1:4)$rem(2L)\npl$Series(1:3)$rem(pl$Series(11:13))\npl$Series(1:3)$rem(1L)\n</code></pre>"},{"location":"reference/Series_rename/","title":"<code>rename</code>","text":"<p>Rename a series</p>"},{"location":"reference/Series_rename/#description","title":"Description","text":"<p>Rename a series</p>"},{"location":"reference/Series_rename/#format","title":"Format","text":"<p>method</p>"},{"location":"reference/Series_rename/#usage","title":"Usage","text":"<pre><code>Series_rename(name, in_place = FALSE)\n</code></pre>"},{"location":"reference/Series_rename/#arguments","title":"Arguments","text":"Argument Description <code>name</code> string the new name <code>in_place</code> bool rename in-place, breaks immutability If true will throw an error unless this option has been set: <code>pl$set_polars_options(strictly_immutable = FALSE)</code>"},{"location":"reference/Series_rename/#value","title":"Value","text":"<p>bool</p>"},{"location":"reference/Series_rename/#examples","title":"Examples","text":"<pre><code>pl$Series(1:4,\"bob\")$rename(\"alice\")\n</code></pre>"},{"location":"reference/Series_rep/","title":"<code>rep</code>","text":"<p>duplicate and concatenate a series</p>"},{"location":"reference/Series_rep/#description","title":"Description","text":"<p>duplicate and concatenate a series</p>"},{"location":"reference/Series_rep/#format","title":"Format","text":"<p>method</p>"},{"location":"reference/Series_rep/#usage","title":"Usage","text":"<pre><code>Series_rep(n, rechunk = TRUE)\n</code></pre>"},{"location":"reference/Series_rep/#arguments","title":"Arguments","text":"Argument Description <code>n</code> number of times to repeat <code>rechunk</code> bool default true, reallocate object in memory. If FALSE the Series will take up less space, If TRUE calculations might be faster."},{"location":"reference/Series_rep/#details","title":"Details","text":"<p>This function in not implemented in pypolars</p>"},{"location":"reference/Series_rep/#value","title":"Value","text":"<p>bool</p>"},{"location":"reference/Series_rep/#examples","title":"Examples","text":"<pre><code>pl$Series(1:2,\"bob\")$rep(3)\n</code></pre>"},{"location":"reference/Series_series_equal/","title":"<code>series_equal</code>","text":"<p>Are Series's equal?</p>"},{"location":"reference/Series_series_equal/#description","title":"Description","text":"<p>Check if series is equal with another Series.</p>"},{"location":"reference/Series_series_equal/#format","title":"Format","text":"<p>method</p>"},{"location":"reference/Series_series_equal/#usage","title":"Usage","text":"<pre><code>Series_series_equal(other, null_equal = FALSE, strict = FALSE)\n</code></pre>"},{"location":"reference/Series_series_equal/#arguments","title":"Arguments","text":"Argument Description <code>other</code> Series to compare with <code>null_equal</code> bool if TRUE, (Null==Null) is true and not Null/NA. Overridden by strict. <code>strict</code> bool if TRUE, do not allow similar DataType comparison. Overrides null_equal."},{"location":"reference/Series_series_equal/#value","title":"Value","text":"<p>bool</p>"},{"location":"reference/Series_series_equal/#examples","title":"Examples","text":"<pre><code>pl$Series(1:4,\"bob\")$series_equal(pl$Series(1:4))\n</code></pre>"},{"location":"reference/Series_set_sorted/","title":"<code>set_sorted</code>","text":"<p>Set sorted</p>"},{"location":"reference/Series_set_sorted/#description","title":"Description","text":"<p>Set sorted</p>"},{"location":"reference/Series_set_sorted/#usage","title":"Usage","text":"<pre><code>Series_set_sorted(reverse = FALSE, in_place = FALSE)\n</code></pre>"},{"location":"reference/Series_set_sorted/#arguments","title":"Arguments","text":"Argument Description <code>reverse</code> bool if TRUE, signals series is Descendingly sorted, otherwise Ascendingly. <code>in_place</code> if TRUE, will set flag mutably and return NULL. Remember to use pl$set_polars_options(strictly_immutable = FALSE) otherwise an error will be thrown. If FALSE will return a cloned Series with set_flag which in the very most cases should be just fine."},{"location":"reference/Series_set_sorted/#value","title":"Value","text":"<p>Series invisible</p>"},{"location":"reference/Series_set_sorted/#examples","title":"Examples","text":"<pre><code>s = pl$Series(1:4)$set_sorted()\ns$flags\n</code></pre>"},{"location":"reference/Series_shape/","title":"<code>shape</code>","text":"<p>Shape of series</p>"},{"location":"reference/Series_shape/#description","title":"Description","text":"<p>Shape of series</p>"},{"location":"reference/Series_shape/#usage","title":"Usage","text":"<pre><code>Series_shape()\n</code></pre>"},{"location":"reference/Series_shape/#value","title":"Value","text":"<p>dimension vector of Series</p>"},{"location":"reference/Series_shape/#examples","title":"Examples","text":"<pre><code>identical(pl$Series(1:2)$shape, 2:1)\n</code></pre>"},{"location":"reference/Series_sort/","title":"<code>sort</code>","text":"<p>Sort this Series</p>"},{"location":"reference/Series_sort/#description","title":"Description","text":"<p>Sort this Series</p>"},{"location":"reference/Series_sort/#usage","title":"Usage","text":"<pre><code>Series_sort(reverse = FALSE, in_place = FALSE)\n</code></pre>"},{"location":"reference/Series_sort/#arguments","title":"Arguments","text":"Argument Description <code>reverse</code> bool reverse(descending) sort <code>in_place</code> bool sort mutable in-place, breaks immutability If true will throw an error unless this option has been set: <code>pl$set_polars_options(strictly_immutable = FALSE)</code>"},{"location":"reference/Series_sort/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_sort/#examples","title":"Examples","text":"<pre><code>pl$Series(c(1,NA,NaN,Inf,-Inf))$sort()\n</code></pre>"},{"location":"reference/Series_std/","title":"<code>std</code>","text":"<p>Get the standard deviation of this Series.</p>"},{"location":"reference/Series_std/#description","title":"Description","text":"<p>Get the standard deviation of this Series.</p>"},{"location":"reference/Series_std/#format","title":"Format","text":"<p>method</p>"},{"location":"reference/Series_std/#usage","title":"Usage","text":"<pre><code>Series_std(ddof = 1)\n</code></pre>"},{"location":"reference/Series_std/#arguments","title":"Arguments","text":"Argument Description <code>ddof</code> \"Delta Degrees of Freedom\": the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1."},{"location":"reference/Series_std/#value","title":"Value","text":"<p>bool</p>"},{"location":"reference/Series_std/#examples","title":"Examples","text":"<pre><code>pl$Series(1:4,\"bob\")$std()\n</code></pre>"},{"location":"reference/Series_sub/","title":"<code>sub</code>","text":"<p>sub Series</p>"},{"location":"reference/Series_sub/#description","title":"Description","text":"<p>Series arithmetics</p>"},{"location":"reference/Series_sub/#usage","title":"Usage","text":"<pre><code>Series_sub(other)\nlist(list(\"-\"), list(\"Series\"))(s1, s2)\n</code></pre>"},{"location":"reference/Series_sub/#arguments","title":"Arguments","text":"Argument Description <code>other</code> Series or into Series <code>s1</code> lhs Series <code>s2</code> rhs Series or any into Series"},{"location":"reference/Series_sub/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_sub/#examples","title":"Examples","text":"<pre><code>pl$Series(1:3)$sub(11:13)\npl$Series(1:3)$sub(pl$Series(11:13))\npl$Series(1:3)$sub(1L)\n1L - pl$Series(1:3)\npl$Series(1:3) - 1L\n</code></pre>"},{"location":"reference/Series_sum/","title":"<code>sum</code>","text":"<p>Sum</p>"},{"location":"reference/Series_sum/#description","title":"Description","text":"<p>Reduce Series with sum</p>"},{"location":"reference/Series_sum/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/Series_sum/#usage","title":"Usage","text":"<pre><code>Series_sum\n</code></pre>"},{"location":"reference/Series_sum/#details","title":"Details","text":"<p>Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues.</p>"},{"location":"reference/Series_sum/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_sum/#examples","title":"Examples","text":"<pre><code>pl$Series(c(1:2,NA,3,5))$sum() # a NA is dropped always\npl$Series(c(1:2,NA,3,NaN,4,Inf))$sum() # NaN carries / poisons\npl$Series(c(1:2,3,Inf,4,-Inf,5))$sum() # Inf-Inf is NaN\n</code></pre>"},{"location":"reference/Series_to_frames/","title":"<code>to_frames</code>","text":"<p>Series to DataFrame</p>"},{"location":"reference/Series_to_frames/#description","title":"Description","text":"<p>Series to DataFrame</p>"},{"location":"reference/Series_to_frames/#format","title":"Format","text":"<p>method</p>"},{"location":"reference/Series_to_frames/#usage","title":"Usage","text":"<pre><code>Series_to_frame()\n</code></pre>"},{"location":"reference/Series_to_frames/#value","title":"Value","text":"<p>Series</p>"},{"location":"reference/Series_to_frames/#examples","title":"Examples","text":"<pre><code>pl$Series(1:4,\"bob\")$to_frame()\n</code></pre>"},{"location":"reference/Series_to_lit/","title":"<code>to_lit</code>","text":"<p>Series to Literal</p>"},{"location":"reference/Series_to_lit/#description","title":"Description","text":"<p>convert Series to literal to perform modification and return</p>"},{"location":"reference/Series_to_lit/#usage","title":"Usage","text":"<pre><code>Series_to_lit()\n</code></pre>"},{"location":"reference/Series_to_lit/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/Series_to_lit/#examples","title":"Examples","text":"<pre><code>(\npl$Series(list(1:1, 1:2, 1:3, 1:4))\n$print()\n$to_lit()\n$arr$lengths()\n$sum()\n$cast(pl$dtypes$Int8)\n$lit_to_s()\n)\n</code></pre>"},{"location":"reference/Series_to_r/","title":"<code>to_r</code>","text":"<p>Get r vector/list</p>"},{"location":"reference/Series_to_r/#description","title":"Description","text":"<p>return R list (if polars Series is list)  or vector (any other polars Series type)</p> <p>return R vector (implicit unlist)</p> <p>return R list (implicit as.list)</p>"},{"location":"reference/Series_to_r/#usage","title":"Usage","text":"<pre><code>Series_to_r()\nSeries_to_r_vector()\nSeries_to_r_list()\n</code></pre>"},{"location":"reference/Series_to_r/#details","title":"Details","text":"<p>Fun fact: Nested polars Series list must have same inner type, e.g. List(List(Int32)) Thus every leaf(non list type) will be placed on the same depth of the tree, and be the same type.</p>"},{"location":"reference/Series_to_r/#value","title":"Value","text":"<p>R list or vector</p> <p>R vector</p> <p>R list</p>"},{"location":"reference/Series_to_r/#examples","title":"Examples","text":"<pre><code>#make polars Series_Utf8\nseries_vec = pl$Series(letters[1:3])\n#Series_non_list\nseries_vec$to_r() #as vector because Series DataType is not list (is Utf8)\nseries_vec$to_r_list() #implicit call as.list(), convert to list\nseries_vec$to_r_vector() #implicit call unlist(), same as to_r() as already vector\n#make nested Series_list of Series_list of Series_Int32\n#using Expr syntax because currently more complete translated\nseries_list = pl$DataFrame(list(a=c(1:5,NA_integer_)))$select(\npl$col(\"a\")$list()$list()$append(\n(\npl$col(\"a\")$head(2)$list()$append(\npl$col(\"a\")$tail(1)$list()\n)\n)$list()\n)\n)$get_column(\"a\") # get series from DataFrame\n#Series_list\nseries_list$to_r() #as list because Series DataType is list\nseries_list$to_r_list() #implicit call as.list(), same as to_r() as already list\nseries_list$to_r_vector() #implicit call unlist(), append into a vector\n#\n#\n</code></pre>"},{"location":"reference/Series_value_count/","title":"<code>value_count</code>","text":"<p>Value Counts as DataFrame</p>"},{"location":"reference/Series_value_count/#description","title":"Description","text":"<p>Value Counts as DataFrame</p>"},{"location":"reference/Series_value_count/#usage","title":"Usage","text":"<pre><code>Series_value_counts(sorted = TRUE, multithreaded = FALSE)\n</code></pre>"},{"location":"reference/Series_value_count/#arguments","title":"Arguments","text":"Argument Description <code>sorted</code> bool, default TRUE: sort table by value; FALSE: random <code>multithreaded</code> bool, default FALSE, process multithreaded. Likely faster to have TRUE for a big Series. If called within an already multithreaded context such calling apply on a GroupBy with many groups, then likely slightly faster to leave FALSE."},{"location":"reference/Series_value_count/#value","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/Series_value_count/#examples","title":"Examples","text":"<pre><code>pl$Series(iris$Species,\"flower species\")$value_counts()\n</code></pre>"},{"location":"reference/Series_var/","title":"<code>var</code>","text":"<p>Get the standard deviation of this Series.</p>"},{"location":"reference/Series_var/#description","title":"Description","text":"<p>Get the standard deviation of this Series.</p>"},{"location":"reference/Series_var/#format","title":"Format","text":"<p>method</p>"},{"location":"reference/Series_var/#usage","title":"Usage","text":"<pre><code>Series_var(ddof = 1)\n</code></pre>"},{"location":"reference/Series_var/#arguments","title":"Arguments","text":"Argument Description <code>ddof</code> \"Delta Degrees of Freedom\": the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1."},{"location":"reference/Series_var/#value","title":"Value","text":"<p>bool</p>"},{"location":"reference/Series_var/#examples","title":"Examples","text":"<pre><code>pl$Series(1:4,\"bob\")$var()\n</code></pre>"},{"location":"reference/all/","title":"<code>all</code>","text":"<p>New Expr referring to all columns</p>"},{"location":"reference/all/#description","title":"Description","text":"<p>Not to mix up with <code>Expr_object$all()</code> which is a 'reduce Boolean columns by AND' method.</p>"},{"location":"reference/all/#details","title":"Details","text":"<p>last <code>all()</code> in example is this Expr method, the first <code>pl$all()</code> refers  to \"all-columns\" and is an expression constructor</p>"},{"location":"reference/all/#value","title":"Value","text":"<p>Boolean literal</p>"},{"location":"reference/all/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(list(all=c(TRUE,TRUE),some=c(TRUE,FALSE)))$select(pl$all()$all())\n</code></pre>"},{"location":"reference/and_then/","title":"<code>and_then</code>","text":"<p>map an ok-value or pass on an err-value</p>"},{"location":"reference/and_then/#description","title":"Description","text":"<p>map an ok-value or pass on an err-value</p>"},{"location":"reference/and_then/#usage","title":"Usage","text":"<pre><code>and_then(x, f)\n</code></pre>"},{"location":"reference/and_then/#arguments","title":"Arguments","text":"Argument Description <code>x</code> any R object <code>f</code> a closure that takes the ok part as input"},{"location":"reference/and_then/#value","title":"Value","text":"<p>same R object wrapped in a Err-result</p>"},{"location":"reference/arr_arg_max/","title":"<code>arr_arg_max</code>","text":"<p>Arg max sublists</p>"},{"location":"reference/arr_arg_max/#description","title":"Description","text":"<p>Retrieve the index of the maximum value in every sublist.</p>"},{"location":"reference/arr_arg_max/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_arg_max/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_arg_max/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(s = list(1:2,2:1)))\ndf$select(pl$col(\"s\")$arr$arg_max())\n</code></pre>"},{"location":"reference/arr_arg_min/","title":"<code>arr_arg_min</code>","text":"<p>Arg min sublists</p>"},{"location":"reference/arr_arg_min/#description","title":"Description","text":"<p>Retrieve the index of the minimal value in every sublist.</p>"},{"location":"reference/arr_arg_min/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_arg_min/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_arg_min/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(s = list(1:2,2:1)))\ndf$select(pl$col(\"s\")$arr$arg_min())\n</code></pre>"},{"location":"reference/arr_concat/","title":"<code>arr_concat</code>","text":"<p>concat another list</p>"},{"location":"reference/arr_concat/#description","title":"Description","text":"<p>Concat the arrays in a Series dtype List in linear time.</p>"},{"location":"reference/arr_concat/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_concat/#arguments","title":"Arguments","text":"Argument Description <code>other</code> Rlist, Expr or column of same tyoe as self."},{"location":"reference/arr_concat/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_concat/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = list(\"a\",\"x\"),\nb = list(c(\"b\",\"c\"),c(\"y\",\"z\"))\n)\ndf$select(pl$col(\"a\")$arr$concat(pl$col(\"b\")))\ndf$select(pl$col(\"a\")$arr$concat(\"hello from R\"))\ndf$select(pl$col(\"a\")$arr$concat(list(\"hello\",c(\"hello\",\"world\"))))\n</code></pre>"},{"location":"reference/arr_contains/","title":"<code>arr_contains</code>","text":"<p>Sublists contains</p>"},{"location":"reference/arr_contains/#description","title":"Description","text":"<p>Check if sublists contain the given item.</p>"},{"location":"reference/arr_contains/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_contains/#arguments","title":"Arguments","text":"Argument Description <code>item</code> any into Expr/literal"},{"location":"reference/arr_contains/#value","title":"Value","text":"<p>Expr of a boolean mask</p>"},{"location":"reference/arr_contains/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(3:1, NULL, 1:2))) #NULL or integer() or list()\ndf$select(pl$col(\"a\")$arr$contains(1L))\n</code></pre>"},{"location":"reference/arr_diff/","title":"<code>arr_diff</code>","text":"<p>Diff sublists</p>"},{"location":"reference/arr_diff/#description","title":"Description","text":"<p>Calculate the n-th discrete difference of every sublist.</p>"},{"location":"reference/arr_diff/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_diff/#arguments","title":"Arguments","text":"Argument Description <code>n</code> Number of slots to shift <code>null_behavior</code> choice \"ignore\"(default) \"drop\""},{"location":"reference/arr_diff/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_diff/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(s = list(1:4,c(10L,2L,1L))))\ndf$select(pl$col(\"s\")$arr$diff())\n</code></pre>"},{"location":"reference/arr_eval/","title":"<code>arr_eval</code>","text":"<p>eval sublists (kinda like lapply)</p>"},{"location":"reference/arr_eval/#description","title":"Description","text":"<p>Run any polars expression against the lists' elements.</p>"},{"location":"reference/arr_eval/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_eval/#arguments","title":"Arguments","text":"Argument Description <code>Expr</code> Expression to run. Note that you can select an element with <code>pl$first()</code> , or <code>pl$col()</code> <code>parallel</code> bool Run all expression parallel. Don't activate this blindly. Parallelism is worth it if there is enough work to do per thread. This likely should not be use in the groupby context, because we already parallel execution per group"},{"location":"reference/arr_eval/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_eval/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(a = list(c(1,8,3), b = c(4,5,2)))\ndf$select(pl$all()$cast(pl$dtypes$Int64))$with_column(\npl$concat_list(c(\"a\",\"b\"))$arr$eval(pl$element()$rank())$alias(\"rank\")\n)\n</code></pre>"},{"location":"reference/arr_first/","title":"<code>arr_first</code>","text":"<p>First in sublists</p>"},{"location":"reference/arr_first/#description","title":"Description","text":"<p>Get the first value of the sublists.</p>"},{"location":"reference/arr_first/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_first/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_first/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(3:1, NULL, 1:2))) #NULL or integer() or list()\ndf$select(pl$col(\"a\")$arr$first())\n</code></pre>"},{"location":"reference/arr_get/","title":"<code>arr_get</code>","text":"<p>Get list</p>"},{"location":"reference/arr_get/#description","title":"Description","text":"<p>Get the value by index in the sublists.</p>"},{"location":"reference/arr_get/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_get/#usage","title":"Usage","text":"<pre><code>list(list(\"[\"), list(\"ExprArrNameSpace\"))(x, index)\n</code></pre>"},{"location":"reference/arr_get/#arguments","title":"Arguments","text":"Argument Description <code>x</code> ExprArrNameSpace <code>index</code> value to get"},{"location":"reference/arr_get/#details","title":"Details","text":"<p>[.ExprArrNameSpace used as e.g. <code>pl$col(\"a\")$arr[0]</code> same as <code>pl$col(\"a\")$get(0)</code></p>"},{"location":"reference/arr_get/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_get/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(3:1, NULL, 1:2))) #NULL or integer() or list()\ndf$select(pl$col(\"a\")$arr$get(0))\ndf$select(pl$col(\"a\")$arr$get(c(2,0,-1)))\ndf = pl$DataFrame(list(a = list(3:1, NULL, 1:2))) #NULL or integer() or list()\ndf$select(pl$col(\"a\")$arr[0])\ndf$select(pl$col(\"a\")$arr[c(2,0,-1)])\n</code></pre>"},{"location":"reference/arr_head/","title":"<code>arr_head</code>","text":"<p>Heads of sublists</p>"},{"location":"reference/arr_head/#description","title":"Description","text":"<p>head the first <code>n</code> values of every sublist.</p>"},{"location":"reference/arr_head/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_head/#arguments","title":"Arguments","text":"Argument Description <code>n</code> Numeric or Expr, number of values to return for each sublist."},{"location":"reference/arr_head/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_head/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(1:4, c(10L, 2L, 1L))))\ndf$select(pl$col(\"a\")$arr$head(2))\n</code></pre>"},{"location":"reference/arr_join/","title":"<code>arr_join</code>","text":"<p>Join sublists</p>"},{"location":"reference/arr_join/#description","title":"Description","text":"<p>Join all string items in a sublist and place a separator between them.  This errors if inner type of list != Utf8 .</p>"},{"location":"reference/arr_join/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_join/#arguments","title":"Arguments","text":"Argument Description <code>separator</code> string to separate the items with"},{"location":"reference/arr_join/#value","title":"Value","text":"<p>Series of dtype Utf8</p>"},{"location":"reference/arr_join/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(s = list(c(\"a\",\"b\",\"c\"), c(\"x\",\"y\"))))\ndf$select(pl$col(\"s\")$arr$join(\" \"))\n</code></pre>"},{"location":"reference/arr_last/","title":"<code>arr_last</code>","text":"<p>Last in sublists</p>"},{"location":"reference/arr_last/#description","title":"Description","text":"<p>Get the last value of the sublists.</p>"},{"location":"reference/arr_last/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_last/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_last/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(3:1, NULL, 1:2))) #NULL or integer() or list()\ndf$select(pl$col(\"a\")$arr$last())\n</code></pre>"},{"location":"reference/arr_lengths/","title":"<code>arr_lengths</code>","text":"<p>Lengths arrays in list</p>"},{"location":"reference/arr_lengths/#description","title":"Description","text":"<p>Get the length of the arrays as UInt32</p>"},{"location":"reference/arr_lengths/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_lengths/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_lengths/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list_of_strs = pl$Series(list(c(\"a\",\"b\"),\"c\")))\ndf$with_column(pl$col(\"list_of_strs\")$arr$lengths()$alias(\"list_of_strs_lengths\"))\n</code></pre>"},{"location":"reference/arr_max/","title":"<code>arr_max</code>","text":"<p>Max lists</p>"},{"location":"reference/arr_max/#description","title":"Description","text":"<p>Compute the max value of the lists in the array.</p>"},{"location":"reference/arr_max/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_max/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_max/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(values = pl$Series(list(1L,2:3)))\ndf$select(pl$col(\"values\")$arr$max())\n</code></pre>"},{"location":"reference/arr_mean/","title":"<code>arr_mean</code>","text":"<p>Mean of lists</p>"},{"location":"reference/arr_mean/#description","title":"Description","text":"<p>Compute the mean value of the lists in the array.</p>"},{"location":"reference/arr_mean/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_mean/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_mean/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(values = pl$Series(list(1L,2:3)))\ndf$select(pl$col(\"values\")$arr$mean())\n</code></pre>"},{"location":"reference/arr_min/","title":"<code>arr_min</code>","text":""},{"location":"reference/arr_min/#min-lists","title":"' Min lists","text":""},{"location":"reference/arr_min/#description","title":"Description","text":"<p>Compute the min value of the lists in the array.</p>"},{"location":"reference/arr_min/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_min/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_min/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(values = pl$Series(list(1L,2:3)))\ndf$select(pl$col(\"values\")$arr$min())\n</code></pre>"},{"location":"reference/arr_reverse/","title":"<code>arr_reverse</code>","text":"<p>Reverse list</p>"},{"location":"reference/arr_reverse/#description","title":"Description","text":"<p>Reverse the arrays in the list.</p>"},{"location":"reference/arr_reverse/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_reverse/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_reverse/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(\nvalues = list(3:1, c(9L, 1:2))\n))\ndf$select(pl$col(\"values\")$arr$reverse())\n</code></pre>"},{"location":"reference/arr_shift/","title":"<code>arr_shift</code>","text":"<p>Shift sublists</p>"},{"location":"reference/arr_shift/#description","title":"Description","text":"<p>Shift values by the given period.</p>"},{"location":"reference/arr_shift/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_shift/#arguments","title":"Arguments","text":"Argument Description <code>periods</code> Value. Number of places to shift (may be negative)."},{"location":"reference/arr_shift/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_shift/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(s = list(1:4,c(10L,2L,1L))))\ndf$select(pl$col(\"s\")$arr$shift())\n</code></pre>"},{"location":"reference/arr_slice/","title":"<code>arr_slice</code>","text":"<p>Slice sublists</p>"},{"location":"reference/arr_slice/#description","title":"Description","text":"<p>Slice every sublist.</p>"},{"location":"reference/arr_slice/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_slice/#arguments","title":"Arguments","text":"Argument Description <code>offset</code> value or Expr.  Start index. Negative indexing is supported. <code>length</code> value or Expr. Length of the slice. If set to <code>None</code> (default), the slice is taken to the end of the list."},{"location":"reference/arr_slice/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_slice/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(s = list(1:4,c(10L,2L,1L))))\ndf$select(pl$col(\"s\")$arr$slice(2))\n</code></pre>"},{"location":"reference/arr_sort/","title":"<code>arr_sort</code>","text":"<p>Get list</p>"},{"location":"reference/arr_sort/#description","title":"Description","text":"<p>Get the value by index in the sublists.</p>"},{"location":"reference/arr_sort/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_sort/#arguments","title":"Arguments","text":"Argument Description <code>index</code> numeric vector or Expr of length 1 or same length of Series. if length 1 pick same value from each sublist, if length as Series/column, pick by individual index across sublists.  So index <code>0</code> would return the first item of every sublist and index <code>-1</code> would return the last item of every sublist if an index is out of bounds, it will return a <code>None</code> ."},{"location":"reference/arr_sort/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_sort/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(3:1, NULL, 1:2))) #NULL or integer() or list()\ndf$select(pl$col(\"a\")$arr$get(0))\ndf$select(pl$col(\"a\")$arr$get(c(2,0,-1)))\n</code></pre>"},{"location":"reference/arr_sum/","title":"<code>arr_sum</code>","text":"<p>Sum lists</p>"},{"location":"reference/arr_sum/#description","title":"Description","text":"<p>Sum all the lists in the array.</p>"},{"location":"reference/arr_sum/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_sum/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_sum/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(values = pl$Series(list(1L,2:3)))\ndf$select(pl$col(\"values\")$arr$sum())\n</code></pre>"},{"location":"reference/arr_tail/","title":"<code>arr_tail</code>","text":"<p>Tails of sublists</p>"},{"location":"reference/arr_tail/#description","title":"Description","text":"<p>tail the first <code>n</code> values of every sublist.</p>"},{"location":"reference/arr_tail/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_tail/#arguments","title":"Arguments","text":"Argument Description <code>n</code> Numeric or Expr, number of values to return for each sublist."},{"location":"reference/arr_tail/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_tail/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(1:4, c(10L, 2L, 1L))))\ndf$select(pl$col(\"a\")$arr$tail(2))\n</code></pre>"},{"location":"reference/arr_take/","title":"<code>arr_take</code>","text":"<p>take in sublists</p>"},{"location":"reference/arr_take/#description","title":"Description","text":"<p>Get the take value of the sublists.</p>"},{"location":"reference/arr_take/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_take/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_take/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(3:1, NULL, 1:2))) #NULL or integer() or list()\nidx = pl$Series(list(0:1,1L,1L))\ndf$select(pl$col(\"a\")$arr$take(99))\n</code></pre>"},{"location":"reference/arr_to_struct/","title":"<code>arr_to_struct</code>","text":"<p>List to Struct</p>"},{"location":"reference/arr_to_struct/#description","title":"Description","text":"<p>List to Struct</p>"},{"location":"reference/arr_to_struct/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_to_struct/#arguments","title":"Arguments","text":"Argument Description <code>n_field_strategy</code> Strategy to determine the number of fields of the struct. default = 'first_non_null' else 'max_width' <code>name_generator</code> an R function that takes a scalar column number and outputs a string value. The default NULL is equivalent to the R function (idx) paste0(\"field_\",idx) <code>upper_bound</code> upper_bound numeric A polars <code>LazyFrame</code> needs to know the schema at all time. The caller therefore must provide an <code>upper_bound</code> of struct fields that will be set. If this is incorrectly downstream operation may fail. For instance an all().sum() expression will look in the current schema to determine which columns to select. It is adviced to set this value in a lazy query."},{"location":"reference/arr_to_struct/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_to_struct/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(1:3, 1:2)))\ndf2 = df$select(pl$col(\"a\")$arr$to_struct(\nname_generator =  \\(idx) paste0(\"hello_you_\",idx))\n)\ndf2$unnest()\ndf2$to_list()\n</code></pre>"},{"location":"reference/arr_unique/","title":"<code>arr_unique</code>","text":"<p>Unique list</p>"},{"location":"reference/arr_unique/#description","title":"Description","text":"<p>Get the unique/distinct values in the list.</p>"},{"location":"reference/arr_unique/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/arr_unique/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/arr_unique/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(a = list(1, 1, 2)))\ndf$select(pl$col(\"a\")$arr$unique())\n</code></pre>"},{"location":"reference/c.Series/","title":"<code>c.Series</code>","text":"<p>Immutable combine series</p>"},{"location":"reference/c.Series/#description","title":"Description","text":"<p>Immutable combine series</p>"},{"location":"reference/c.Series/#usage","title":"Usage","text":"<pre><code>list(list(\"c\"), list(\"Series\"))(x, ...)\n</code></pre>"},{"location":"reference/c.Series/#arguments","title":"Arguments","text":"Argument Description <code>x</code> a Series <code>...</code> Series(s) or any object into Series meaning <code>pl$Series(object)</code> returns a series"},{"location":"reference/c.Series/#details","title":"Details","text":"<p>append datatypes has to match. Combine does not rechunk.  Read more about R vectors, Series and chunks in <code>docs_translations</code> :</p>"},{"location":"reference/c.Series/#value","title":"Value","text":"<p>a combined Series</p>"},{"location":"reference/c.Series/#examples","title":"Examples","text":"<pre><code>s = c(pl$Series(1:5),3:1,NA_integer_)\ns$chunk_lengths() #the series contain three unmerged chunks\n</code></pre>"},{"location":"reference/check_no_missing_args/","title":"<code>check_no_missing_args</code>","text":"<p>check_no_missing_args</p>"},{"location":"reference/check_no_missing_args/#description","title":"Description","text":"<p>lifecycle: DEPRECATE</p>"},{"location":"reference/check_no_missing_args/#usage","title":"Usage","text":"<pre><code>check_no_missing_args(fun, args, warn = TRUE)\n</code></pre>"},{"location":"reference/check_no_missing_args/#arguments","title":"Arguments","text":"Argument Description <code>fun</code> target function to check incomming arguments for <code>args</code> list of args to check <code>warn</code> bool if TRUE throw warning when check fails"},{"location":"reference/check_no_missing_args/#value","title":"Value","text":"<p>true if args are correct</p>"},{"location":"reference/check_tz_to_result/","title":"<code>check_tz_to_result</code>","text":"<p>Verify correct time zone</p>"},{"location":"reference/check_tz_to_result/#description","title":"Description","text":"<p>Verify correct time zone</p>"},{"location":"reference/check_tz_to_result/#usage","title":"Usage","text":"<pre><code>check_tz_to_result(tz, allow_null = TRUE)\n</code></pre>"},{"location":"reference/check_tz_to_result/#arguments","title":"Arguments","text":"Argument Description <code>tz</code> time zone string or NULL <code>allow_null</code> bool, if TRUE accept NULL"},{"location":"reference/check_tz_to_result/#value","title":"Value","text":"<p>a result object, with either a valid string or an Err</p>"},{"location":"reference/check_tz_to_result/#examples","title":"Examples","text":"<pre><code>check_tz_to_result = polars:::check_tz_to_result # expose internal\n#return Ok\ncheck_tz_to_result(\"GMT\")\ncheck_tz_to_result(NULL)\n#return Err\ncheck_tz_to_result(\"Alice\")\ncheck_tz_to_result(42)\ncheck_tz_to_result(NULL, allow_null = FALSE)\n</code></pre>"},{"location":"reference/clone_env_one_level_deep/","title":"<code>clone_env_one_level_deep</code>","text":"<p>Clone env on level deep.</p>"},{"location":"reference/clone_env_one_level_deep/#description","title":"Description","text":"<p>Clone env on level deep.</p>"},{"location":"reference/clone_env_one_level_deep/#usage","title":"Usage","text":"<pre><code>clone_env_one_level_deep(env)\n</code></pre>"},{"location":"reference/clone_env_one_level_deep/#arguments","title":"Arguments","text":"Argument Description <code>env</code> an R environment."},{"location":"reference/clone_env_one_level_deep/#details","title":"Details","text":"<p>Sometimes used in polars to produce different hashmaps(environments) containing  some of the same, but not all elements.</p> <p>environments are used for collections of methods and types. This function can be used to make  a parallel collection pointing to some of the same types. Simply copying an environment, does  apparently not spawn a new hashmap, and therefore the collections stay identical.</p>"},{"location":"reference/clone_env_one_level_deep/#value","title":"Value","text":"<p>shallow clone of R environment</p>"},{"location":"reference/clone_env_one_level_deep/#examples","title":"Examples","text":"<pre><code>fruit_env = new.env(parent = emptyenv())\nfruit_env$banana = TRUE\nfruit_env$apple = FALSE\nenv_1 = new.env(parent = emptyenv())\nenv_1$fruit_env = fruit_env\nenv_naive_copy = env_1\nenv_shallow_clone = polars:::clone_env_one_level_deep(env_1)\n#modifying env_!\nenv_1$minerals = new.env(parent = emptyenv())\nenv_1$fruit_env$apple = 42L\n#naive copy is fully identical to env_1, so copying it not much useful\nls(env_naive_copy)\n#shallow copy env does not have minerals\nls(env_shallow_clone)\n#however shallow clone does subscribe to changes to fruits as they were there\n# at time of cloning\nenv_shallow_clone$fruit_env$apple\n</code></pre>"},{"location":"reference/coalesce/","title":"<code>coalesce</code>","text":"<p>Coalesce</p>"},{"location":"reference/coalesce/#description","title":"Description","text":"<p>Folds the expressions from left to right, keeping the first non-null value.</p> <p>Folds the expressions from left to right, keeping the first non-null value.</p>"},{"location":"reference/coalesce/#arguments","title":"Arguments","text":"Argument Description <code>...</code> is a: If one arg: <ul> <li> <p>Series or Expr, same as <code>column$sum()</code> </p> </li> <li> <p>string, same as <code>pl$col(column)$sum()</code> </p> </li> <li> <p>numeric, same as <code>pl$lit(column)$sum()</code> </p> </li> <li> <p>list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ...   If several args, then wrapped in a list and handled as above. <code>exprs</code>     |     list of Expr or Series or strings or a mix, or a char vector</p> </li> </ul>"},{"location":"reference/coalesce/#value","title":"Value","text":"<p>Expr</p> <p>Expr</p>"},{"location":"reference/coalesce/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = NA_real_,\nb = c(1:2,NA_real_,NA_real_),\nc = c(1:3,NA_real_)\n)\n#use coalesce to get first non Null value for each row, otherwise insert 99.9\ndf$with_column(\npl$coalesce(\"a\", \"b\", \"c\", 99.9)$alias(\"d\")\n)\n#Create lagged columns and collect them into a list. This mimics a rolling window.\ndf = pl$DataFrame(A = c(1,2,9,2,13))\ndf$with_columns(lapply(\n0:2,\n\\(i) pl$col(\"A\")$shift(i)$alias(paste0(\"A_lag_\",i))\n))$select(\npl$concat_list(lapply(2:0,\\(i) pl$col(paste0(\"A_lag_\",i))))$alias(\n\"A_rolling\"\n)\n)\n#concat Expr a Series and an R obejct\npl$concat_list(list(\npl$lit(1:5),\npl$Series(5:1),\nrep(0L,5)\n))$alias(\"alice\")$lit_to_s()\n</code></pre>"},{"location":"reference/col/","title":"<code>col</code>","text":"<p>Start Expression with a column</p>"},{"location":"reference/col/#description","title":"Description","text":"<p>Return an expression representing a column in a DataFrame.</p>"},{"location":"reference/col/#arguments","title":"Arguments","text":"Argument Description <code>name</code> <ul> <li> <p>a single column by a string </p> </li> <li> <p>all columns by using a wildcard <code>\"*\"</code> </p> </li> <li> <p>multiple columns as vector of strings </p> </li> <li> <p>column by regular expression if the regex starts with <code>^</code> and ends with <code>$</code>  e.g. pl$DataFrame(iris)$select(pl$col(c(\"^Sepal.*$\"))) </p> </li> <li> <p>a single DataType or an R list of DataTypes, select any column of any such DataType </p> </li> <li> <p>Series of utf8 strings abiding to above options</p> </li> </ul>"},{"location":"reference/col/#value","title":"Value","text":"<p>Column Exprression</p>"},{"location":"reference/col/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(list(foo=1, bar=2L,foobar=\"3\"))\n#a single column by a string\ndf$select(pl$col(\"foo\"))\n#all columns by wildcard\ndf$select(pl$col(\"*\"))\ndf$select(pl$all())\n#multiple columns as vector of strings\ndf$select(pl$col(c(\"foo\",\"bar\")))\n#column by regular expression if the regex starts with `^` and ends with `$`\ndf$select(pl$col(\"^foo.*$\"))\n#a single DataType\ndf$select(pl$col(pl$dtypes$Float64))\n# ... or an R list of DataTypes, select any column of any such DataType\ndf$select(pl$col(list(pl$dtypes$Float64, pl$dtypes$Utf8)))\n# from Series of names\ndf$select(pl$col(pl$Series(c(\"bar\",\"foobar\"))))\n</code></pre>"},{"location":"reference/construct_DataTypeVector/","title":"<code>construct_DataTypeVector</code>","text":"<p>construct data type vector</p>"},{"location":"reference/construct_DataTypeVector/#description","title":"Description","text":"<p>lifecycle: Deprecate, move to rust side</p>"},{"location":"reference/construct_DataTypeVector/#usage","title":"Usage","text":"<pre><code>construct_DataTypeVector(l)\n</code></pre>"},{"location":"reference/construct_DataTypeVector/#arguments","title":"Arguments","text":"Argument Description <code>l</code> list of Expr or string"},{"location":"reference/construct_DataTypeVector/#value","title":"Value","text":"<p>extptr to rust vector of RPolarsDataType's</p>"},{"location":"reference/construct_ProtoExprArray/","title":"<code>construct_ProtoExprArray</code>","text":"<p>construct proto Expr array from args</p>"},{"location":"reference/construct_ProtoExprArray/#description","title":"Description","text":"<p>construct proto Expr array from args</p>"},{"location":"reference/construct_ProtoExprArray/#usage","title":"Usage","text":"<pre><code>construct_ProtoExprArray(...)\n</code></pre>"},{"location":"reference/construct_ProtoExprArray/#arguments","title":"Arguments","text":"Argument Description <code>...</code> any Expr or string"},{"location":"reference/construct_ProtoExprArray/#value","title":"Value","text":"<p>ProtoExprArray object</p>"},{"location":"reference/construct_ProtoExprArray/#examples","title":"Examples","text":"<pre><code>polars:::construct_ProtoExprArray(pl$col(\"Species\"),\"Sepal.Width\")\n</code></pre>"},{"location":"reference/docs_translations/","title":"<code>docs_translations</code>","text":"<p>Translation definitions across python, R and polars.</p>"},{"location":"reference/docs_translations/#description","title":"Description","text":""},{"location":"reference/docs_translations/#comments-for-how-the-r-and-python-world-translates-into-polars","title":"Comments for how the R and python world translates into polars:","text":"<p>R and python are both high-level glue languages great for Data Science.  Rust is a pedantic low-level language with similar use cases as C and C++.  Polars is written in ~100k lines of rust and has a rust API. Py-polars the python API for polars,  is implemented as an interface with the rust API.  r-polars is very parallel to py-polars except it interfaces with R. The performance and behavior  are unexpectedly quite similar as the 'engine' is the exact same rust code and data structures.</p>"},{"location":"reference/docs_translations/#format","title":"Format","text":"<p>info</p>"},{"location":"reference/dot-DollarNames.DataFrame/","title":"<code>.DollarNames.DataFrame</code>","text":"<p>auto complete $-access into a polars object</p>"},{"location":"reference/dot-DollarNames.DataFrame/#description","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/dot-DollarNames.DataFrame/#usage","title":"Usage","text":"<pre><code>list(list(\".DollarNames\"), list(\"DataFrame\"))(x, pattern = \"\")\n</code></pre>"},{"location":"reference/dot-DollarNames.DataFrame/#arguments","title":"Arguments","text":"Argument Description <code>x</code> DataFrame <code>pattern</code> code-stump as string to auto-complete"},{"location":"reference/dot-DollarNames.Expr/","title":"<code>.DollarNames.Expr</code>","text":"<p>auto complete $-access into a polars object</p>"},{"location":"reference/dot-DollarNames.Expr/#description","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/dot-DollarNames.Expr/#usage","title":"Usage","text":"<pre><code>list(list(\".DollarNames\"), list(\"Expr\"))(x, pattern = \"\")\n</code></pre>"},{"location":"reference/dot-DollarNames.Expr/#arguments","title":"Arguments","text":"Argument Description <code>x</code> Expr <code>pattern</code> code-stump as string to auto-complete"},{"location":"reference/dot-DollarNames.GroupBy/","title":"<code>.DollarNames.GroupBy</code>","text":"<p>auto complete $-access into a polars object</p>"},{"location":"reference/dot-DollarNames.GroupBy/#description","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/dot-DollarNames.GroupBy/#usage","title":"Usage","text":"<pre><code>list(list(\".DollarNames\"), list(\"GroupBy\"))(x, pattern = \"\")\n</code></pre>"},{"location":"reference/dot-DollarNames.GroupBy/#arguments","title":"Arguments","text":"Argument Description <code>x</code> GroupBy <code>pattern</code> code-stump as string to auto-complete"},{"location":"reference/dot-DollarNames.LazyFrame/","title":"<code>.DollarNames.LazyFrame</code>","text":"<p>auto complete $-access into a polars object</p>"},{"location":"reference/dot-DollarNames.LazyFrame/#description","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/dot-DollarNames.LazyFrame/#usage","title":"Usage","text":"<pre><code>list(list(\".DollarNames\"), list(\"LazyFrame\"))(x, pattern = \"\")\n</code></pre>"},{"location":"reference/dot-DollarNames.LazyFrame/#arguments","title":"Arguments","text":"Argument Description <code>x</code> LazyFrame <code>pattern</code> code-stump as string to auto-complete"},{"location":"reference/dot-DollarNames.PolarsBackgroundHandle/","title":"<code>.DollarNames.PolarsBackgroundHandle</code>","text":"<p>auto complete $-access into a polars object</p>"},{"location":"reference/dot-DollarNames.PolarsBackgroundHandle/#description","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/dot-DollarNames.PolarsBackgroundHandle/#usage","title":"Usage","text":"<pre><code>list(list(\".DollarNames\"), list(\"PolarsBackgroundHandle\"))(x, pattern = \"\")\n</code></pre>"},{"location":"reference/dot-DollarNames.PolarsBackgroundHandle/#arguments","title":"Arguments","text":"Argument Description <code>x</code> LazyFrame <code>pattern</code> code-stump as string to auto-complete"},{"location":"reference/dot-DollarNames.Series/","title":"<code>.DollarNames.Series</code>","text":"<p>auto complete $-access into a polars object</p>"},{"location":"reference/dot-DollarNames.Series/#description","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/dot-DollarNames.Series/#usage","title":"Usage","text":"<pre><code>list(list(\".DollarNames\"), list(\"Series\"))(x, pattern = \"\")\n</code></pre>"},{"location":"reference/dot-DollarNames.Series/#arguments","title":"Arguments","text":"Argument Description <code>x</code> Series <code>pattern</code> code-stump as string to auto-complete"},{"location":"reference/dot-DollarNames.VecDataFrame/","title":"<code>.DollarNames.VecDataFrame</code>","text":"<p>auto complete $-access into a polars object</p>"},{"location":"reference/dot-DollarNames.VecDataFrame/#description","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/dot-DollarNames.VecDataFrame/#usage","title":"Usage","text":"<pre><code>list(list(\".DollarNames\"), list(\"VecDataFrame\"))(x, pattern = \"\")\n</code></pre>"},{"location":"reference/dot-DollarNames.VecDataFrame/#arguments","title":"Arguments","text":"Argument Description <code>x</code> VecDataFrame <code>pattern</code> code-stump as string to auto-complete"},{"location":"reference/dot-DollarNames.When/","title":"<code>.DollarNames.When</code>","text":"<p>auto complete $-access into a polars object</p>"},{"location":"reference/dot-DollarNames.When/#description","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/dot-DollarNames.When/#usage","title":"Usage","text":"<pre><code>list(list(\".DollarNames\"), list(\"When\"))(x, pattern = \"\")\n</code></pre>"},{"location":"reference/dot-DollarNames.When/#arguments","title":"Arguments","text":"Argument Description <code>x</code> When <code>pattern</code> code-stump as string to auto-complete"},{"location":"reference/dot-DollarNames.WhenThen/","title":"<code>.DollarNames.WhenThen</code>","text":"<p>auto complete $-access into a polars object</p>"},{"location":"reference/dot-DollarNames.WhenThen/#description","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/dot-DollarNames.WhenThen/#usage","title":"Usage","text":"<pre><code>list(list(\".DollarNames\"), list(\"WhenThen\"))(x, pattern = \"\")\n</code></pre>"},{"location":"reference/dot-DollarNames.WhenThen/#arguments","title":"Arguments","text":"Argument Description <code>x</code> WhenThen <code>pattern</code> code-stump as string to auto-complete"},{"location":"reference/dot-DollarNames.WhenThenThen/","title":"<code>.DollarNames.WhenThenThen</code>","text":"<p>auto complete $-access into a polars object</p>"},{"location":"reference/dot-DollarNames.WhenThenThen/#description","title":"Description","text":"<p>called by the interactive R session internally</p>"},{"location":"reference/dot-DollarNames.WhenThenThen/#usage","title":"Usage","text":"<pre><code>list(list(\".DollarNames\"), list(\"WhenThenThen\"))(x, pattern = \"\")\n</code></pre>"},{"location":"reference/dot-DollarNames.WhenThenThen/#arguments","title":"Arguments","text":"Argument Description <code>x</code> WhenThenThen <code>pattern</code> code-stump as string to auto-complete"},{"location":"reference/dot-pr/","title":"<code>.pr</code>","text":"<p>polars-API: private calls to rust-polars</p>"},{"location":"reference/dot-pr/#description","title":"Description","text":"<p><code>.pr</code>   Original extendr bindings converted into pure functions</p>"},{"location":"reference/dot-pr/#format","title":"Format","text":"<p>An object of class <code>environment</code> of length 16.</p>"},{"location":"reference/dot-pr/#usage","title":"Usage","text":"<pre><code>.pr\n</code></pre>"},{"location":"reference/dot-pr/#examples","title":"Examples","text":"<pre><code>#.pr$DataFrame$print() is an external function where self is passed as arg\npolars:::.pr$DataFrame$print(self = pl$DataFrame(iris))\npolars:::print_env(.pr,\".pr the collection of private method calls to rust-polars\")\n</code></pre>"},{"location":"reference/element/","title":"<code>element</code>","text":"<p>an element in 'eval'-expr</p>"},{"location":"reference/element/#description","title":"Description","text":"<p>Alias for an element in evaluated in an <code>eval</code> expression.</p>"},{"location":"reference/element/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/element/#examples","title":"Examples","text":"<pre><code>pl$lit(1:5)$cumulative_eval(pl$element()$first()-pl$element()$last() ** 2)$to_r()\n</code></pre>"},{"location":"reference/extendr_method_to_pure_functions/","title":"<code>extendr_method_to_pure_functions</code>","text":"<p>extendr methods into pure functions</p>"},{"location":"reference/extendr_method_to_pure_functions/#description","title":"Description","text":"<p>self is a global of extendr wrapper methods  this function copies the function into a new environment and  modify formals to have a self argument</p>"},{"location":"reference/extendr_method_to_pure_functions/#usage","title":"Usage","text":"<pre><code>extendr_method_to_pure_functions(env)\n</code></pre>"},{"location":"reference/extendr_method_to_pure_functions/#arguments","title":"Arguments","text":"Argument Description <code>env</code> environment object output from extendr-wrappers.R classes"},{"location":"reference/extendr_method_to_pure_functions/#value","title":"Value","text":"<p>env of pure function calls to rust</p>"},{"location":"reference/extra_auto_completion/","title":"<code>extra_auto_completion</code>","text":"<p>Extra polars auto completion</p>"},{"location":"reference/extra_auto_completion/#description","title":"Description","text":"<p>Extra polars auto completion</p>"},{"location":"reference/extra_auto_completion/#arguments","title":"Arguments","text":"Argument Description <code>activate</code> bool default TRUE, enable chained auto-completion"},{"location":"reference/extra_auto_completion/#details","title":"Details","text":"<p>polars always supports auto completetion via .DollarNames.  However chained methods like x$a()$b()$? are not supported vi .DollarNames.</p> <p>This feature experimental and not perfect. Any feedback is appreciated.  Currently does not play that nice with Rstudio, as Rstudio backtick quotes any custom  suggestions.</p>"},{"location":"reference/extra_auto_completion/#examples","title":"Examples","text":"<pre><code>#auto completion via .DollarNames method\ne = pl$lit(42) # to autocomplete pl$lit(42) save to variable\n# then write `e$`  and press tab to see available methods\n# polars has experimental auto completetion for chain of methods if all on the same line\npl$extra_auto_completion() #first activate feature (this will 'annoy' the Rstudio auto-completer)\npl$lit(42)$lit_to_s() # add a $ and press tab 1-3 times\npl$extra_auto_completion(activate = FALSE) #deactivate\n</code></pre>"},{"location":"reference/filter-open-paren-close-paren/","title":"<code>filter()</code>","text":"<p>filter DataFrame</p>"},{"location":"reference/filter-open-paren-close-paren/#description","title":"Description","text":"<p>DataFrame$filter(bool_expr)</p>"},{"location":"reference/filter-open-paren-close-paren/#usage","title":"Usage","text":"<pre><code>DataFrame_filter(bool_expr)\n</code></pre>"},{"location":"reference/filter-open-paren-close-paren/#arguments","title":"Arguments","text":"Argument Description <code>bool_expr</code> Polars expression which will evaluate to a bool pl$Series"},{"location":"reference/filter-open-paren-close-paren/#value","title":"Value","text":"<p>filtered DataFrame</p>"},{"location":"reference/filter-open-paren-close-paren/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$lazy()$filter(pl$col(\"Sepal.Length\") &gt; 5)$collect()\n</code></pre>"},{"location":"reference/get_method_usages/","title":"<code>get_method_usages</code>","text":"<p>Generate autocompletion suggestions for object</p>"},{"location":"reference/get_method_usages/#description","title":"Description","text":"<p>Generate autocompletion suggestions for object</p>"},{"location":"reference/get_method_usages/#usage","title":"Usage","text":"<pre><code>get_method_usages(env, pattern = \"\")\n</code></pre>"},{"location":"reference/get_method_usages/#arguments","title":"Arguments","text":"Argument Description <code>env</code> environment to extract usages from <code>pattern</code> string passed to ls(pattern) to subset methods by pattern"},{"location":"reference/get_method_usages/#details","title":"Details","text":"<p>used internally for auto completion in .DollarNames methods</p>"},{"location":"reference/get_method_usages/#value","title":"Value","text":"<p>method usages</p>"},{"location":"reference/get_method_usages/#examples","title":"Examples","text":"<pre><code>polars:::get_method_usages(polars:::DataFrame, pattern=\"col\")\n</code></pre>"},{"location":"reference/is_DataFrame_data_input/","title":"<code>is_DataFrame_data_input</code>","text":"<p>Validate data input for create Dataframe with pl$DataFrame</p>"},{"location":"reference/is_DataFrame_data_input/#description","title":"Description","text":"<p>The Dataframe constructors accepts data.frame inheritors or list of vectors and/or Series.</p>"},{"location":"reference/is_DataFrame_data_input/#usage","title":"Usage","text":"<pre><code>is_DataFrame_data_input(x)\n</code></pre>"},{"location":"reference/is_DataFrame_data_input/#arguments","title":"Arguments","text":"Argument Description <code>x</code> any R object to test if suitable as input to DataFrame"},{"location":"reference/is_DataFrame_data_input/#value","title":"Value","text":"<p>bool</p>"},{"location":"reference/is_DataFrame_data_input/#examples","title":"Examples","text":"<pre><code>polars:::is_DataFrame_data_input(iris)\npolars:::is_DataFrame_data_input(list(1:5,pl$Series(1:5),letters[1:5]))\n</code></pre>"},{"location":"reference/is_err/","title":"<code>is_err</code>","text":"<p>check if x ss a result and an err</p>"},{"location":"reference/is_err/#description","title":"Description","text":"<p>check if x ss a result and an err</p>"},{"location":"reference/is_err/#usage","title":"Usage","text":"<pre><code>is_err(x)\n</code></pre>"},{"location":"reference/is_err/#arguments","title":"Arguments","text":"Argument Description <code>x</code> R object which could be a rust-like result of a list with two elements, ok and err"},{"location":"reference/is_err/#value","title":"Value","text":"<p>bool if is a result object which is an err</p>"},{"location":"reference/is_ok/","title":"<code>is_ok</code>","text":"<p>check if x ss a result and an ok</p>"},{"location":"reference/is_ok/#description","title":"Description","text":"<p>check if x ss a result and an ok</p>"},{"location":"reference/is_ok/#usage","title":"Usage","text":"<pre><code>is_ok(x)\n</code></pre>"},{"location":"reference/is_ok/#arguments","title":"Arguments","text":"Argument Description <code>x</code> R object which could be a rust-like result of a list with two elements, ok and err"},{"location":"reference/is_ok/#value","title":"Value","text":"<p>bool if is a result object which is an ok</p>"},{"location":"reference/is_polars_dtype/","title":"<code>is_polars_dtype</code>","text":"<p>chek if x is a valid RPolarsDataType</p>"},{"location":"reference/is_polars_dtype/#description","title":"Description","text":"<p>chek if x is a valid RPolarsDataType</p>"},{"location":"reference/is_polars_dtype/#usage","title":"Usage","text":"<pre><code>is_polars_dtype(x, include_unknown = FALSE)\n</code></pre>"},{"location":"reference/is_polars_dtype/#arguments","title":"Arguments","text":"Argument Description <code>x</code> a candidate"},{"location":"reference/is_polars_dtype/#value","title":"Value","text":"<p>a list DataType with an inner DataType</p>"},{"location":"reference/is_polars_dtype/#examples","title":"Examples","text":"<pre><code>polars:::is_polars_dtype(pl$Int64)\n</code></pre>"},{"location":"reference/is_result/","title":"<code>is_result</code>","text":"<p>check if z is a result</p>"},{"location":"reference/is_result/#description","title":"Description","text":"<p>check if z is a result</p>"},{"location":"reference/is_result/#usage","title":"Usage","text":"<pre><code>is_result(x)\n</code></pre>"},{"location":"reference/is_result/#arguments","title":"Arguments","text":"Argument Description <code>x</code> R object which could be a rust-like result of a list with two elements, ok and err"},{"location":"reference/is_result/#details","title":"Details","text":"<p>both ok and err being NULL encodes ok-value NULL. No way to encode an err-value NULL  If both ok and err has value then this is an invalid result</p>"},{"location":"reference/is_result/#value","title":"Value","text":"<p>bool if is a result object</p>"},{"location":"reference/is_schema/","title":"<code>is_schema</code>","text":"<p>check if schema</p>"},{"location":"reference/is_schema/#description","title":"Description","text":"<p>check if schema</p>"},{"location":"reference/is_schema/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/is_schema/#usage","title":"Usage","text":"<pre><code>is_schema(x)\n</code></pre>"},{"location":"reference/is_schema/#arguments","title":"Arguments","text":"Argument Description <code>x</code> objet to test if schema"},{"location":"reference/is_schema/#value","title":"Value","text":"<p>bool</p>"},{"location":"reference/is_schema/#examples","title":"Examples","text":"<pre><code>polars:::is_schema(pl$DataFrame(iris)$schema)\npl$is_schema(pl$DataFrame(iris)$schema)\npolars:::is_schema(list(\"alice\",\"bob\"))\n</code></pre>"},{"location":"reference/l_to_vdf/","title":"<code>l_to_vdf</code>","text":"<p>DataFrame-list to rust vector of DataFrame</p>"},{"location":"reference/l_to_vdf/#description","title":"Description","text":"<p>lifecycle: DEPRECATE, imple on rust side as a function</p>"},{"location":"reference/l_to_vdf/#usage","title":"Usage","text":"<pre><code>l_to_vdf(l)\n</code></pre>"},{"location":"reference/l_to_vdf/#arguments","title":"Arguments","text":"Argument Description <code>l</code> list of DataFrame"},{"location":"reference/l_to_vdf/#value","title":"Value","text":"<p>VecDataFrame</p>"},{"location":"reference/lazy_csv_reader/","title":"<code>lazy_csv_reader</code>","text":"<p>new LazyFrame from csv</p>"},{"location":"reference/lazy_csv_reader/#description","title":"Description","text":"<p>will scan the csv when collect(), not now</p>"},{"location":"reference/lazy_csv_reader/#usage","title":"Usage","text":"<pre><code>lazy_csv_reader(\npath,\nsep = \",\",\nhas_header = TRUE,\nignore_errors = FALSE,\nskip_rows = 0,\nn_rows = NULL,\ncache = FALSE,\noverwrite_dtype = NULL,\nlow_memory = FALSE,\ncomment_char = NULL,\nquote_char = \"\\\"\",\nnull_values = NULL,\ninfer_schema_length = 100,\nskip_rows_after_header = 0,\nencoding = \"utf8\",\nrow_count_name = NULL,\nrow_count_offset = 0,\nparse_dates = FALSE\n)\ncsv_reader(...)\n</code></pre>"},{"location":"reference/lazy_csv_reader/#arguments","title":"Arguments","text":"Argument Description <code>path</code> string, Path to a file <code>sep</code> Single char to use as delimiter in the file. <code>has_header</code> bool, indicate if the first row of dataset is a header or not. If set to False, column names will be autogenerated in the following format: column_x, with x being an enumeration over every column in the dataset starting at 1. <code>ignore_errors</code> bool, try to keep reading lines if some lines yield errors. First try infer_schema_length=0 to read all columns as pl.Utf8 to check which values might cause an issue. <code>skip_rows</code> integer, Start reading after skip_rows lines. The header will be parsed at this offset. <code>n_rows</code> int (NULL is disable),Stop reading from CSV file after reading n_rows. <code>cache</code> bool, cache the result after reading. <code>overwrite_dtype</code> (NULL is disable) named list of dtypes OR dtype-names, where name points to a column. Can overwrite dtypes during inference. Supported types so far are: name <code>low_memory</code> bool, reduce memory usage in expense of performance <code>comment_char</code> (NULL is disable) Single byte character that indicates the start of a comment line, for instance #. <code>quote_char</code> (NULL is disable) Single byte character used for csv quoting, default = \". Set to None to turn off special handling and escaping of quotes. <code>null_values</code> (NULL is disable) Values to interpret as null values. You can provide a String : All values equal to this string will be null. Unnamed char vector: A null value per column. Named char vector.  A mapping from (names)column to a null value string(values). <code>infer_schema_length</code> Maximum number of rows to read to infer the column types. If set to 0, all columns will be read as UTF-8. If <code>NULL</code> , a full table scan will be done (slow). <code>skip_rows_after_header</code> bool Skip this number of rows when the header is parsed. <code>encoding</code> either \"utf8\" or \"utf8-lossy\". Lossy means that invalid utf8 values are replaced with \"?\" characters. <code>row_count_name</code> String(NULL is disable), name of a added row count column <code>row_count_offset</code> integer, Offset to start the row_count column (only used if the name is set). <code>parse_dates</code> bool Try to automatically parse dates. If this does not succeed, the column remains of data type pl.Utf8. <code>...</code> any argument passed to lazy_csv_reader"},{"location":"reference/lazy_csv_reader/#details","title":"Details","text":"<p>Read a file from path into a polars lazy frame. Not yet supporting eol_char and with_column_names</p>"},{"location":"reference/lazy_csv_reader/#value","title":"Value","text":"<p>lazyframe</p> <p>DataFrame</p>"},{"location":"reference/lazy_csv_reader/#examples","title":"Examples","text":"<pre><code>my_file = tempfile()\nwrite.csv(iris,my_file)\nlazy_frame = polars:::lazy_csv_reader(path=my_file)\nlazy_frame$collect()\nunlink(my_file)\n</code></pre>"},{"location":"reference/length.Series/","title":"<code>length.Series</code>","text":"<p>Length of series</p>"},{"location":"reference/length.Series/#description","title":"Description","text":"<p>Length of series</p>"},{"location":"reference/length.Series/#usage","title":"Usage","text":"<pre><code>list(list(\"length\"), list(\"Series\"))(x)\n</code></pre>"},{"location":"reference/length.Series/#arguments","title":"Arguments","text":"Argument Description <code>x</code> a Series"},{"location":"reference/length.Series/#value","title":"Value","text":"<p>the length as a double</p>"},{"location":"reference/macro_add_syntax_check_to/","title":"<code>macro_add_syntax_check_to</code>","text":"<p>add syntax verification to class</p>"},{"location":"reference/macro_add_syntax_check_to/#description","title":"Description","text":"<p>add syntax verification to class</p>"},{"location":"reference/macro_add_syntax_check_to/#usage","title":"Usage","text":"<pre><code>macro_add_syntax_check_to_class(Class_name)\n</code></pre>"},{"location":"reference/macro_add_syntax_check_to/#arguments","title":"Arguments","text":"Argument Description <code>Class_name</code> string name of env class"},{"location":"reference/macro_add_syntax_check_to/#details","title":"Details","text":"<p>this function overrides dollarclass method of a extendr env_class  to run first verify_method_call() to check for syntax error and return  more user friendly error if issues</p> <p>All R functions coined 'macro'-functions use eval(parse()) but only at package build time  to solve some tricky self-referential problem. If possible to deprecate a macro in a clean way  , go ahead.</p> <p>see zzz.R for usage examples</p>"},{"location":"reference/macro_add_syntax_check_to/#value","title":"Value","text":"<p>dollarsign method with syntax verification</p>"},{"location":"reference/macro_add_syntax_check_to/#seealso","title":"Seealso","text":"<p>verify_method_call</p>"},{"location":"reference/macro_new_subnamespace/","title":"<code>macro_new_subnamespace</code>","text":"<p>Macro - New subnamespace</p>"},{"location":"reference/macro_new_subnamespace/#description","title":"Description","text":"<p>Bundle class methods into an environment (subname space)</p>"},{"location":"reference/macro_new_subnamespace/#usage","title":"Usage","text":"<pre><code>macro_new_subnamespace(class_pattern, subclass_env = NULL, remove_f = TRUE)\n</code></pre>"},{"location":"reference/macro_new_subnamespace/#arguments","title":"Arguments","text":"Argument Description <code>class_pattern</code> regex to select functions <code>subclass_env</code> optional subclass of <code>remove_f</code> drop sourced functions from package ns after bundling into sub ns"},{"location":"reference/macro_new_subnamespace/#details","title":"Details","text":"<p>This function is used to emulate py-polars subnamespace-methods  All R functions coined 'macro_'-functions use eval(parse()) but only at package build time  to solve some tricky self-referential problem. If possible to deprecate a macro in a clean way  , go ahead.</p>"},{"location":"reference/macro_new_subnamespace/#value","title":"Value","text":"<p>A function which returns a subclass environment of bundled class functions.</p>"},{"location":"reference/macro_new_subnamespace/#examples","title":"Examples","text":"<pre><code>#macro_new_subnamespace() is not exported, export for this toy example\n#macro_new_subnamespace = polars:::macro_new_subnamespace\n##define some new methods prefixed 'MyClass_'\n#MyClass_add2 = function() self + 2\n#MyClass_mul2 = function() self * 2\n##grab any sourced function prefixed 'MyClass_'\n#my_class_sub_ns = macro_new_subnamespace(\"^MyClass_\", \"myclass_sub_ns\")\n#here adding sub-namespace as a expr-class property/method during session-time,\n#which only is for this demo.\n#instead sourced method like Expr_arr() at package build time instead\n#env = polars:::Expr #get env of the Expr Class\n#env$my_sub_ns = method_as_property(function() { #add a property/method\n# my_class_sub_ns(self)\n#})\n#rm(env) #optional clean up\n#add user defined S3 method the subclass 'myclass_sub_ns'\n#print.myclass_sub_ns = function(x, ...) { #add ... even if not used\n#   print(\"hello world, I'm myclass_sub_ns\")\n#   print(\"methods in sub namespace are:\")\n#  print(ls(x))\n#  }\n#test\n# e = pl$lit(1:5)  #make an Expr\n#print(e$my_sub_ns) #inspect\n#e$my_sub_ns$add2() #use the sub namespace\n#e$my_sub_ns$mul2()\n</code></pre>"},{"location":"reference/map/","title":"<code>map</code>","text":"<p>map an Err part of Result</p>"},{"location":"reference/map/#description","title":"Description","text":"<p>map an Err part of Result</p>"},{"location":"reference/map/#usage","title":"Usage","text":"<pre><code>map(x, f)\n</code></pre>"},{"location":"reference/map/#arguments","title":"Arguments","text":"Argument Description <code>x</code> any R object <code>f</code> a closure that takes the ok part as input"},{"location":"reference/map/#value","title":"Value","text":"<p>same R object wrapped in a Err-result</p>"},{"location":"reference/map_err/","title":"<code>map_err</code>","text":"<p>map an Err part of Result</p>"},{"location":"reference/map_err/#description","title":"Description","text":"<p>map an Err part of Result</p>"},{"location":"reference/map_err/#usage","title":"Usage","text":"<pre><code>map_err(x, f)\n</code></pre>"},{"location":"reference/map_err/#arguments","title":"Arguments","text":"Argument Description <code>x</code> any R object <code>f</code> a closure that takes the err part as input"},{"location":"reference/map_err/#value","title":"Value","text":"<p>same R object wrapped in a Err-result</p>"},{"location":"reference/max/","title":"<code>max</code>","text":"<p>max across expressions / literals / Series</p>"},{"location":"reference/max/#description","title":"Description","text":"<p>Folds the expressions from left to right, keeping the first non-null value.</p>"},{"location":"reference/max/#arguments","title":"Arguments","text":"Argument Description <code>...</code> is a: If one arg: <ul> <li> <p>Series or Expr, same as <code>column$sum()</code> </p> </li> <li> <p>string, same as <code>pl$col(column)$sum()</code> </p> </li> <li> <p>numeric, same as <code>pl$lit(column)$sum()</code> </p> </li> <li> <p>list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ...   If several args, then wrapped in a list and handled as above.</p> </li> </ul>"},{"location":"reference/max/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/max/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = NA_real_,\nb = c(1:2,NA_real_,NA_real_),\nc = c(1:3,NA_real_)\n)\n#use coalesce to get first non Null value for each row, otherwise insert 99.9\ndf$with_column(\npl$coalesce(\"a\", \"b\", \"c\", 99.9)$alias(\"d\")\n)\n</code></pre>"},{"location":"reference/mem_address/","title":"<code>mem_address</code>","text":"<p>Get Memory Address</p>"},{"location":"reference/mem_address/#description","title":"Description","text":"<p>mimics pl$mem_address</p>"},{"location":"reference/mem_address/#arguments","title":"Arguments","text":"Argument Description <code>robj</code> an R object"},{"location":"reference/mem_address/#value","title":"Value","text":"<p>String of mem address</p>"},{"location":"reference/mem_address/#examples","title":"Examples","text":"<pre><code>pl$mem_address(pl$Series(1:3))\n</code></pre>"},{"location":"reference/method_as_property/","title":"<code>method_as_property</code>","text":"<p>Give a class method property behavior</p>"},{"location":"reference/method_as_property/#description","title":"Description","text":"<p>Internal function, see use in source</p>"},{"location":"reference/method_as_property/#usage","title":"Usage","text":"<pre><code>method_as_property(f, setter = FALSE)\n</code></pre>"},{"location":"reference/method_as_property/#arguments","title":"Arguments","text":"Argument Description <code>f</code> a function <code>setter</code> bool, if true a property method can be modified by user"},{"location":"reference/method_as_property/#value","title":"Value","text":"<p>function subclassed into c(\"property\",\"function\") or c(\"setter\",\"property\",\"function\")</p>"},{"location":"reference/min/","title":"<code>min</code>","text":"<p>min across expressions / literals / Series</p>"},{"location":"reference/min/#description","title":"Description","text":"<p>Folds the expressions from left to right, keeping the first non-null value.</p>"},{"location":"reference/min/#arguments","title":"Arguments","text":"Argument Description <code>...</code> is a: If one arg: <ul> <li> <p>Series or Expr, same as <code>column$sum()</code> </p> </li> <li> <p>string, same as <code>pl$col(column)$sum()</code> </p> </li> <li> <p>numeric, same as <code>pl$lit(column)$sum()</code> </p> </li> <li> <p>list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ...   If several args, then wrapped in a list and handled as above.</p> </li> </ul>"},{"location":"reference/min/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/min/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(\na = NA_real_,\nb = c(2:1,NA_real_,NA_real_),\nc = c(1:3,NA_real_),\nd = c(1:2,NA_real_,-Inf)\n)\n#use min to get first non Null value for each row, otherwise insert 99.9\ndf$with_column(\npl$min(\"a\", \"b\", \"c\", 99.9)$alias(\"d\")\n)\n</code></pre>"},{"location":"reference/move_env_elements/","title":"<code>move_env_elements</code>","text":"<p>Move environment elements from one env to another</p>"},{"location":"reference/move_env_elements/#description","title":"Description","text":"<p>Move environment elements from one env to another</p>"},{"location":"reference/move_env_elements/#usage","title":"Usage","text":"<pre><code>move_env_elements(from_env, to_env, element_names, remove = TRUE)\n</code></pre>"},{"location":"reference/move_env_elements/#arguments","title":"Arguments","text":"Argument Description <code>from_env</code> env from <code>to_env</code> env to <code>element_names</code> names of elements to move, if named names, then name of name is to_env name <code>remove</code> bool, actually remove element in from_env"},{"location":"reference/nanoarrow/","title":"<code>nanoarrow</code>","text":"<p>polars to nanoarrow and arrow</p>"},{"location":"reference/nanoarrow/#description","title":"Description","text":"<p>Conversion via native apache arrow array stream (fast), THIS REQUIRES \u00b4nanoarrow\u00b4</p>"},{"location":"reference/nanoarrow/#usage","title":"Usage","text":"<pre><code>as_nanoarrow_array_stream.DataFrame(x, ..., schema = NULL)\ninfer_nanoarrow_schema.DataFrame(x, ...)\nas_arrow_table.DataFrame(x, ...)\nas_record_batch_reader.DataFrame(x, ..., schema = NULL)\n</code></pre>"},{"location":"reference/nanoarrow/#arguments","title":"Arguments","text":"Argument Description <code>x</code> a polars DataFrame <code>...</code> not used right now <code>schema</code> must stay at default value NULL"},{"location":"reference/nanoarrow/#details","title":"Details","text":"<p>The following functions enable conversion to <code>nanoarrow</code> and <code>arrow</code> .  Conversion kindly provided by \"paleolimbot / Dewey Dunnington\" Author of <code>nanoarrow</code> .  Currently these conversions are the fastest way to convert from polars to R.</p>"},{"location":"reference/nanoarrow/#value","title":"Value","text":"<ul> <li> <p>a nanoarrow array stream </p> </li> <li> <p>a nanoarrow array schema </p> </li> <li> <p>an arrow table </p> </li> <li> <p>an arrow record batch reader</p> </li> </ul>"},{"location":"reference/nanoarrow/#examples","title":"Examples","text":"<pre><code>library(nanoarrow)\ndf = pl$DataFrame(mtcars)\nnanoarrow_array_stream = as_nanoarrow_array_stream(df)\nrdf = as.data.frame(nanoarrow_array_stream)\nprint(head(rdf))\nnanoarrow_array_schema = infer_nanoarrow_schema(df)\nprint(nanoarrow_array_schema)\nlibrary(arrow)\narrow_table = as_arrow_table(df)\nprint(arrow_table)\narrow_record_batch_reader = as_record_batch_reader(df) #requires arrow\nprint(arrow_record_batch_reader)\n</code></pre>"},{"location":"reference/ncol.DataFrame/","title":"<code>ncol.DataFrame</code>","text":"<p>The Number of Columns of a DataFrame</p>"},{"location":"reference/ncol.DataFrame/#description","title":"Description","text":"<p>The Number of Columns of a DataFrame</p>"},{"location":"reference/ncol.DataFrame/#usage","title":"Usage","text":"<pre><code>ncol.DataFrame(x)\n</code></pre>"},{"location":"reference/ncol.DataFrame/#arguments","title":"Arguments","text":"Argument Description <code>x</code> DataFrame"},{"location":"reference/ncol.DataFrame/#value","title":"Value","text":"<p>Integer</p>"},{"location":"reference/ncol.LazyFrame/","title":"<code>ncol.LazyFrame</code>","text":"<p>The Number of Columns of a LazyFrame</p>"},{"location":"reference/ncol.LazyFrame/#description","title":"Description","text":"<p>The Number of Columns of a LazyFrame</p>"},{"location":"reference/ncol.LazyFrame/#usage","title":"Usage","text":"<pre><code>ncol.LazyFrame(x)\n</code></pre>"},{"location":"reference/ncol.LazyFrame/#arguments","title":"Arguments","text":"Argument Description <code>x</code> LazyFrame"},{"location":"reference/ncol.LazyFrame/#value","title":"Value","text":"<p>Integer</p>"},{"location":"reference/nrow.DataFrame/","title":"<code>nrow.DataFrame</code>","text":"<p>The Number of Rows of a DataFrame</p>"},{"location":"reference/nrow.DataFrame/#description","title":"Description","text":"<p>The Number of Rows of a DataFrame</p>"},{"location":"reference/nrow.DataFrame/#usage","title":"Usage","text":"<pre><code>nrow.DataFrame(x)\n</code></pre>"},{"location":"reference/nrow.DataFrame/#arguments","title":"Arguments","text":"Argument Description <code>x</code> DataFrame"},{"location":"reference/nrow.DataFrame/#value","title":"Value","text":"<p>Integer</p>"},{"location":"reference/nrow.LazyFrame/","title":"<code>nrow.LazyFrame</code>","text":"<p>The Number of Rows of a LazyFrame</p>"},{"location":"reference/nrow.LazyFrame/#description","title":"Description","text":"<p>The Number of Rows of a LazyFrame</p>"},{"location":"reference/nrow.LazyFrame/#usage","title":"Usage","text":"<pre><code>nrow.LazyFrame(x)\n</code></pre>"},{"location":"reference/nrow.LazyFrame/#arguments","title":"Arguments","text":"Argument Description <code>x</code> LazyFrame"},{"location":"reference/nrow.LazyFrame/#value","title":"Value","text":"<p>Integer</p>"},{"location":"reference/object/","title":"<code>object</code>","text":"<p>Any polars class object is made of this</p>"},{"location":"reference/object/#description","title":"Description","text":"<p>One SEXP of Rtype: \"externalptr\" + a class attribute</p>"},{"location":"reference/object/#format","title":"Format","text":"<p>An object of class <code>character</code> of length 1.</p>"},{"location":"reference/object/#usage","title":"Usage","text":"<pre><code>object\n</code></pre>"},{"location":"reference/object/#details","title":"Details","text":"<ul> <li> <p><code>object$method()</code> calls are facilitated by a $.ClassName - s3method see 'R/after-wrappers.R' </p> </li> <li> <p>Code completion is facilitted by <code>.DollarNames.ClassName</code> -s3method see e.g. 'R/dataframe__frame.R' </p> </li> <li> <p>Implementation of property-methods as DataFrame_columns() and syntax checking is an extension to $.ClassName  See function macro_add_syntax_check_to_class().</p> </li> </ul>"},{"location":"reference/object/#examples","title":"Examples","text":"<pre><code>#all a polars object is made of:\nsome_polars_object = pl$DataFrame(iris)\nstr(some_polars_object) #External Pointer tagged with a class attribute.\n</code></pre>"},{"location":"reference/or_else/","title":"<code>or_else</code>","text":"<p>map an Err part of Result</p>"},{"location":"reference/or_else/#description","title":"Description","text":"<p>map an Err part of Result</p>"},{"location":"reference/or_else/#usage","title":"Usage","text":"<pre><code>or_else(x, f)\n</code></pre>"},{"location":"reference/or_else/#arguments","title":"Arguments","text":"Argument Description <code>x</code> any R object <code>f</code> a closure that takes the ok part as input, must return a result itself"},{"location":"reference/or_else/#value","title":"Value","text":"<p>same R object wrapped in a Err-result</p>"},{"location":"reference/pcase/","title":"<code>pcase</code>","text":"<p>Simple SQL CASE WHEN implementation for R</p>"},{"location":"reference/pcase/#description","title":"Description","text":"<p>Inspired by data.table::fcase + dplyr::case_when.  Used instead of base::switch internally.</p>"},{"location":"reference/pcase/#usage","title":"Usage","text":"<pre><code>pcase(..., or_else = NULL)\n</code></pre>"},{"location":"reference/pcase/#arguments","title":"Arguments","text":"Argument Description <code>...</code> odd arugments are bool statements, a next even argument is returned if prior bool statement is the first true <code>or_else</code> return this if no bool statements were true"},{"location":"reference/pcase/#details","title":"Details","text":"<p>Lifecycle: perhaps replace with something written in rust to speed up a bit</p>"},{"location":"reference/pcase/#value","title":"Value","text":"<p>any return given first true bool statement otherwise value of or_else</p>"},{"location":"reference/pcase/#examples","title":"Examples","text":"<pre><code>n = 7\npolars:::pcase(\nn&lt;5,\"nope\",\nn&gt;6,\"yeah\",\nor_else = stopf(\"failed to have a case for n=%s\",n)\n)\n</code></pre>"},{"location":"reference/pl-cash-from_arrow/","title":"<code>pl$from_arrow</code>","text":"<p>pl$from_arrow</p>"},{"location":"reference/pl-cash-from_arrow/#description","title":"Description","text":"<p>import Arrow Table or Array</p>"},{"location":"reference/pl-cash-from_arrow/#arguments","title":"Arguments","text":"Argument Description <code>data</code> arrow Table or Array or ChunkedArray <code>rechunk</code> bool rewrite in one array per column, Implemented for ChunkedArray Array is already contiguous. Not implemented for Table. C <code>schema</code> named list of DataTypes or char vec of names. Same length as arrow table. If schema names or types do not match arrow table, the columns will be renamed/recasted. NULL default is to import columns as is. Takes no effect for Array or ChunkedArray <code>schema_overrides</code> named list of DataTypes. Name some columns to recast by the DataType. Takes not effect for Array or ChunkedArray"},{"location":"reference/pl-cash-from_arrow/#value","title":"Value","text":"<p>DataFrame or Series</p>"},{"location":"reference/pl-cash-from_arrow/#examples","title":"Examples","text":"<pre><code>pl$from_arrow(\ndata = arrow::arrow_table(iris),\nschema_overrides = list(Sepal.Length=pl$Float32, Species = pl$Utf8)\n)\nchar_schema = names(iris)\nchar_schema[1] = \"Alice\"\npl$from_arrow(\ndata = arrow::arrow_table(iris),\nschema = char_schema\n)\n</code></pre>"},{"location":"reference/pl_Datetime/","title":"<code>Datetime</code>","text":"<p>Create Datetime DataType</p>"},{"location":"reference/pl_Datetime/#description","title":"Description","text":"<p>Datetime DataType constructor</p>"},{"location":"reference/pl_Datetime/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/pl_Datetime/#arguments","title":"Arguments","text":"Argument Description <code>tu</code> string option either \"ms\", \"us\" or \"ns\" <code>tz</code> string the Time Zone, see details"},{"location":"reference/pl_Datetime/#details","title":"Details","text":"<p>all allowed TimeZone designations can be found in <code>base::OlsonNames()</code></p>"},{"location":"reference/pl_Datetime/#value","title":"Value","text":"<p>Datetime DataType</p>"},{"location":"reference/pl_Datetime/#examples","title":"Examples","text":"<pre><code>pl$Datetime(\"ns\",\"Pacific/Samoa\")\n</code></pre>"},{"location":"reference/pl_Field/","title":"<code>Field</code>","text":"<p>Create Field</p>"},{"location":"reference/pl_Field/#description","title":"Description","text":"<p>Create Field</p>"},{"location":"reference/pl_Field/#arguments","title":"Arguments","text":"Argument Description <code>name</code> string name <code>datatype</code> DataType"},{"location":"reference/pl_Field/#details","title":"Details","text":"<p>A Field is not a DataType but a name + DataType Fields are used in Structs-datatypes and Schemas to represent everything of the Series/Column except the raw values.</p>"},{"location":"reference/pl_Field/#value","title":"Value","text":"<p>a list DataType with an inner DataType</p>"},{"location":"reference/pl_Field/#examples","title":"Examples","text":"<pre><code>#make a struct\npl$Field(\"city_names\",pl$Utf8)\n# find any DataType bundled pl$dtypes\nprint(pl$dtypes)\n</code></pre>"},{"location":"reference/pl_List/","title":"<code>List</code>","text":"<p>Create List DataType</p>"},{"location":"reference/pl_List/#description","title":"Description","text":"<p>Create List DataType</p>"},{"location":"reference/pl_List/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/pl_List/#arguments","title":"Arguments","text":"Argument Description <code>datatype</code> an inner DataType"},{"location":"reference/pl_List/#value","title":"Value","text":"<p>a list DataType with an inner DataType</p>"},{"location":"reference/pl_List/#examples","title":"Examples","text":"<pre><code>pl$List(pl$List(pl$Boolean))\n</code></pre>"},{"location":"reference/pl_PTime/","title":"<code>PTime</code>","text":"<p>Store Time in R</p>"},{"location":"reference/pl_PTime/#description","title":"Description","text":"<p>Store Time in R</p>"},{"location":"reference/pl_PTime/#arguments","title":"Arguments","text":"Argument Description <code>x</code> an integer or double vector of n epochs since midnight OR a char vector of char times passed to as.POSIXct converted to seconds. <code>tu</code> timeunit either \"s\",\"ms\",\"us\",\"ns\" <code>fmt</code> a format string passed to as.POSIXct format via ..."},{"location":"reference/pl_PTime/#details","title":"Details","text":"<p>PTime should probably be replaced with package nanotime or similar.</p> <p>base R is missing encoding of Time since midnight \"s\" \"ms\", \"us\" and \"ns\". The latter \"ns\" is the standard for the polars Time type.</p> <p>Use PTime to convert R doubles and integers and use as input to polars functions which needs a time.</p> <p>Loosely inspired by data.table::ITime which is i32 only. PTime must support polars native timeunit is nanoseconds. The R double(float64) can imitate a i64 ns with full precision within the full range of 24 hours.</p> <p>PTime does not have a time zone and always prints the time as is no matter local machine time zone.</p> <p>An essential difference between R and polars is R prints POSIXct/lt without a timezone in local time. Polars prints Datetime without a timezone label as is (GMT). For POSIXct/lt taged with a timexone(tzone) and Datetime with a timezone(tz) the behavior is the same conversion is intuitive.</p> <p>It appears behavior of R timezones is subject to change a bit in R 4.3.0, see polars unit test test-expr_datetime.R/\"pl$date_range Date lazy/eager\".</p>"},{"location":"reference/pl_PTime/#value","title":"Value","text":"<p>a PTime vector either double or integer, with class \"PTime\" and attribute \"tu\" being either \"s\",\"ms\",\"us\" or \"ns\"</p>"},{"location":"reference/pl_PTime/#examples","title":"Examples","text":"<pre><code>#make PTime in all time units\npl$PTime(runif(5)*3600*24*1E0, tu = \"s\")\npl$PTime(runif(5)*3600*24*1E3, tu = \"ms\")\npl$PTime(runif(5)*3600*24*1E6, tu = \"us\")\npl$PTime(runif(5)*3600*24*1E9, tu = \"ns\")\npl$PTime(\"23:59:59\")\npl$Series(pl$PTime(runif(5)*3600*24*1E0, tu = \"s\"))\npl$lit(pl$PTime(\"23:59:59\"))$lit_to_s()\npl$lit(pl$PTime(\"23:59:59\"))$to_r()\n</code></pre>"},{"location":"reference/pl_Struct/","title":"<code>Struct</code>","text":"<p>Create Struct DataType</p>"},{"location":"reference/pl_Struct/#description","title":"Description","text":"<p>Struct DataType Constructor</p>"},{"location":"reference/pl_Struct/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/pl_Struct/#arguments","title":"Arguments","text":"Argument Description <code>datatype</code> an inner DataType"},{"location":"reference/pl_Struct/#value","title":"Value","text":"<p>a list DataType with an inner DataType</p>"},{"location":"reference/pl_Struct/#examples","title":"Examples","text":"<pre><code># create a Struct-DataType\npl$List(pl$List(pl$Boolean))\n# Find any DataType via pl$dtypes\nprint(pl$dtypes)\n</code></pre>"},{"location":"reference/pl_class/","title":"<code>class</code>","text":"<p>The complete polars public API.</p>"},{"location":"reference/pl_class/#description","title":"Description","text":"<p><code>pl</code> -object is a environment of all public functions and class constructors. Public functions are not exported as a normal package as it would be huge namespace collision with base:: and other functions. All object-methods are accessed with object$method() via the new class functions.</p> <p>Having all functions in an namespace is similar to the rust- and python- polars api.</p>"},{"location":"reference/pl_class/#format","title":"Format","text":"<p>An object of class <code>environment</code> of length 57.</p>"},{"location":"reference/pl_class/#usage","title":"Usage","text":"<pre><code>pl\n</code></pre>"},{"location":"reference/pl_class/#details","title":"Details","text":"<p>If someone do not particularly like the letter combination <code>pl</code> , they are free to bind the environment to another variable name as <code>simon_says = pl</code> or even do <code>attach(pl)</code></p>"},{"location":"reference/pl_class/#examples","title":"Examples","text":"<pre><code>#how to use polars via `pl`\npl$col(\"colname\")$sum() / pl$lit(42L)  #expression ~ chain-method / literal-expression\n#pl inventory\npolars:::print_env(pl,\"polars public functions\")\n#all accessible classes and their public methods\npolars:::print_env(\npolars:::pl_pub_class_env,\n\"polars public class methods, access via object$method()\"\n)\n</code></pre>"},{"location":"reference/pl_concat/","title":"<code>concat</code>","text":"<p>Concat polars objects</p>"},{"location":"reference/pl_concat/#description","title":"Description","text":"<p>Concat polars objects</p>"},{"location":"reference/pl_concat/#arguments","title":"Arguments","text":"Argument Description <code>l</code> list of DataFrame, or Series, LazyFrame or Expr <code>rechunk</code> perform a rechunk at last <code>how</code> choice of bind direction \"vertical\"(rbind) \"horizontal\"(cbind) \"diagnoal\" diagonally <code>parallel</code> BOOL default TRUE, only used for LazyFrames"},{"location":"reference/pl_concat/#value","title":"Value","text":"<p>DataFrame, or Series, LazyFrame or Expr</p>"},{"location":"reference/pl_concat/#examples","title":"Examples","text":"<pre><code>#vertical\nl_ver = lapply(1:10, function(i) {\nl_internal = list(\na = 1:5,\nb = letters[1:5]\n)\npl$DataFrame(l_internal)\n})\npl$concat(l_ver, how=\"vertical\")\n#horizontal\nl_hor = lapply(1:10, function(i) {\nl_internal = list(\n1:5,\nletters[1:5]\n)\nnames(l_internal) = paste0(c(\"a\",\"b\"),i)\npl$DataFrame(l_internal)\n})\npl$concat(l_hor, how = \"horizontal\")\n#diagonal\npl$concat(l_hor, how = \"diagonal\")\n</code></pre>"},{"location":"reference/pl_date_range/","title":"<code>date_range</code>","text":"<p>new date_range</p>"},{"location":"reference/pl_date_range/#description","title":"Description","text":"<p>new date_range</p>"},{"location":"reference/pl_date_range/#arguments","title":"Arguments","text":"Argument Description <code>low</code> POSIXt or Date preferably with time_zone or double or integer <code>high</code> POSIXt or Date preferably with time_zone or double or integer. If high is and interval are missing, then single datetime is constructed. <code>interval</code> string pl_duration or R difftime. Can be missing if high is missing also. <code>lazy</code> bool, if TRUE return expression <code>closed</code> option one of 'both'(default), 'left', 'none' or 'right' <code>name</code> name of series <code>time_unit</code> option string (\"ns\" \"us\" \"ms\") duration of one int64 value on polars side <code>time_zone</code> optional string describing a timezone."},{"location":"reference/pl_date_range/#details","title":"Details","text":"<p>If param time_zone is not defined the Series will have no time zone.</p> <p>NOTICE: R POSIXt without defined timezones(tzone/tz), so called naive datetimes, are counter intuitive in R. It is recommended to always set the timezone of low and high. If not output will vary between local machine timezone, R and polars.</p> <p>In R/r-polars it is perfectly fine to mix timezones of params time_zone, low and high.</p>"},{"location":"reference/pl_date_range/#value","title":"Value","text":"<p>a datetime</p>"},{"location":"reference/pl_date_range/#examples","title":"Examples","text":"<pre><code># All in GMT, straight forward, no mental confusion\ns_gmt = pl$date_range(\nas.POSIXct(\"2022-01-01\",tz = \"GMT\"),\nas.POSIXct(\"2022-01-02\",tz = \"GMT\"),\ninterval = \"6h\", time_unit = \"ms\", time_zone = \"GMT\"\n)\ns_gmt\ns_gmt$to_r() #printed same way in R and polars becuase tagged with a time_zone/tzone\n# polars assumes any input in GMT if time_zone = NULL, set GMT on low high to see same print\ns_null = pl$date_range(\nas.POSIXct(\"2022-01-01\",tz = \"GMT\"),\nas.POSIXct(\"2022-01-02\",tz = \"GMT\"),\ninterval = \"6h\", time_unit = \"ms\", time_zone = NULL\n)\ns_null$to_r() #back to R POSIXct. R prints non tzone tagged POSIXct in local timezone.\n#Any mixing of timezones is fine, just set them all, and it works as expected.\nt1 = as.POSIXct(\"2022-01-01\", tz = \"Etc/GMT+2\")\nt2 = as.POSIXct(\"2022-01-01 08:00:00\", tz = \"Etc/GMT-2\")\ns_mix = pl$date_range(low = t1, high = t2, interval = \"1h\", time_unit = \"ms\", time_zone = \"CET\")\ns_mix\ns_mix$to_r()\n#use of ISOdate\nt1 = ISOdate(2022,1,1,0) #preset GMT\nt2 = ISOdate(2022,1,2,0) #preset GMT\npl$date_range(t1,t2,interval = \"4h\", time_unit = \"ms\", time_zone = \"GMT\")\n</code></pre>"},{"location":"reference/pl_select/","title":"<code>select</code>","text":"<p>Select from an empty DataFrame</p>"},{"location":"reference/pl_select/#description","title":"Description","text":"<p>Select from an empty DataFrame</p>"},{"location":"reference/pl_select/#format","title":"Format","text":"<p>method</p>"},{"location":"reference/pl_select/#details","title":"Details","text":"<p>param ... expressions passed to select <code>pl$select</code> is a shorthand for <code>pl$DataFrame(list())$select</code></p> <p>NB param of this function</p>"},{"location":"reference/pl_select/#value","title":"Value","text":"<p>DataFrame</p>"},{"location":"reference/pl_select/#examples","title":"Examples","text":"<pre><code>pl$select(\npl$lit(1:4)$alias(\"ints\"),\npl$lit(letters[1:4])$alias(\"letters\")\n)\n</code></pre>"},{"location":"reference/polars_options/","title":"<code>strictly_immutable</code>","text":"<p>polars options</p>"},{"location":"reference/polars_options/#description","title":"Description","text":"<p>get, set, reset polars options</p>"},{"location":"reference/polars_options/#arguments","title":"Arguments","text":"Argument Description <code>strictly_immutable</code> bool, default = TRUE, keep polars strictly immutable. Polars/arrow is in general pro \"immutable objects\". However pypolars API has some minor exceptions. All settable property elements of classes are mutable. Why?, I guess python just do not have strong stance on immutability. R strongly suggests immutable objects, so why not make polars strictly immutable where little performance costs? However, if to mimic pypolars as much as possible, set this to FALSE. <code>named_exprs</code> bool, default = FALSE, allow named exprs in e.g. select, with_columns, groupby, join. a named expresion will be extended with $alias(name) wildcards or expression producing multiple are problematic due to name collision the related option in py-polars is currently called 'pl.Config.with_columns_kwargs' and only allow named exprs in with_columns (or potentially any method derived there of) <code>no_messages</code> bool, default = FALSE, turn of messages <code>do_not_repeat_call</code> bool, default = FALSE, turn of messages <code>...</code> any options to modify <code>return_replaced_options</code> return previous state of modified options Convenient for temporarily swapping of options during testing."},{"location":"reference/polars_options/#details","title":"Details","text":"<p>who likes polars package messages? use this option to turn them off.</p> <p>do not print the call causing the error in error messages</p> <p>modifing list takes no effect, pass it to pl$set_polars_options  get/set/resest interact with internal env <code>polars:::polars_optenv</code> </p> <p>setting an options may be rejected if not passing opt_requirements</p>"},{"location":"reference/polars_options/#value","title":"Value","text":"<p>current settings as list</p> <p>current settings as list</p> <p>list named by options of requirement function input must satisfy</p>"},{"location":"reference/polars_options/#examples","title":"Examples","text":"<pre><code>#rename columns by naming expression, experimental requires option named_exprs = TRUE\npl$set_polars_options(named_exprs = TRUE)\npl$DataFrame(iris)$with_columns(\npl$col(\"Sepal.Length\")$abs(), #not named expr will keep name \"Sepal.Length\"\nSW_add_2 = (pl$col(\"Sepal.Width\")+2)\n)\npl$get_polars_options()\npl$set_polars_options(strictly_immutable = FALSE)\npl$get_polars_options()\n#setting strictly_immutable = 42 will be rejected as\ntryCatch(\npl$set_polars_options(strictly_immutable = 42),\nerror= function(e) print(e)\n)\n#reset options like this\npl$reset_polars_options()\n#use get_polars_opt_requirements() to requirements\npl$get_polars_opt_requirements()\n</code></pre>"},{"location":"reference/polars_runtime_flags/","title":"<code>polars_runtime_flags</code>","text":"<p>internal keeping of state at runtime</p>"},{"location":"reference/polars_runtime_flags/#description","title":"Description","text":"<p>This environment is used internally for the package to remember  what has been going on. Currently only used to throw one-time warnings()</p>"},{"location":"reference/polars_runtime_flags/#format","title":"Format","text":"<p>An object of class <code>environment</code> of length 0.</p>"},{"location":"reference/polars_runtime_flags/#usage","title":"Usage","text":"<pre><code>runtime_state\n</code></pre>"},{"location":"reference/prepare_alpha/","title":"<code>prepare_alpha</code>","text":"<p>preapare alpha</p>"},{"location":"reference/prepare_alpha/#description","title":"Description","text":"<p>internal function for emw_x expressions</p>"},{"location":"reference/prepare_alpha/#usage","title":"Usage","text":"<pre><code>prepare_alpha(com = NULL, span = NULL, half_life = NULL, alpha = NULL)\n</code></pre>"},{"location":"reference/prepare_alpha/#arguments","title":"Arguments","text":"Argument Description <code>com</code> numeric or NULL <code>span</code> numeric or NULL <code>half_life</code> numeric or NULL <code>alpha</code> numeric or NULL"},{"location":"reference/prepare_alpha/#value","title":"Value","text":"<p>numeric</p>"},{"location":"reference/print-open-paren-close-paren/","title":"<code>print()</code>","text":"<p>s3 method print DataFrame</p>"},{"location":"reference/print-open-paren-close-paren/#description","title":"Description","text":"<p>s3 method print DataFrame</p>"},{"location":"reference/print-open-paren-close-paren/#usage","title":"Usage","text":"<pre><code>list(list(\"print\"), list(\"DataFrame\"))(x, ...)\n</code></pre>"},{"location":"reference/print-open-paren-close-paren/#arguments","title":"Arguments","text":"Argument Description <code>x</code> DataFrame <code>...</code> not used"},{"location":"reference/print-open-paren-close-paren/#value","title":"Value","text":"<p>self</p>"},{"location":"reference/print-open-paren-close-paren/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)\n</code></pre>"},{"location":"reference/print.Expr/","title":"<code>print.Expr</code>","text":"<p>Print expr</p>"},{"location":"reference/print.Expr/#description","title":"Description","text":"<p>Print expr</p>"},{"location":"reference/print.Expr/#usage","title":"Usage","text":"<pre><code>list(list(\"print\"), list(\"Expr\"))(x, ...)\n</code></pre>"},{"location":"reference/print.Expr/#arguments","title":"Arguments","text":"Argument Description <code>x</code> Expr <code>...</code> not used"},{"location":"reference/print.Expr/#value","title":"Value","text":"<p>self</p>"},{"location":"reference/print.Expr/#examples","title":"Examples","text":"<pre><code>pl$col(\"some_column\")$sum()$over(\"some_other_column\")\n</code></pre>"},{"location":"reference/print.GroupBy/","title":"<code>print.GroupBy</code>","text":"<p>print GroupBy</p>"},{"location":"reference/print.GroupBy/#description","title":"Description","text":"<p>print GroupBy</p>"},{"location":"reference/print.GroupBy/#usage","title":"Usage","text":"<pre><code>list(list(\"print\"), list(\"GroupBy\"))(x, ...)\n</code></pre>"},{"location":"reference/print.GroupBy/#arguments","title":"Arguments","text":"Argument Description <code>x</code> DataFrame <code>...</code> not used"},{"location":"reference/print.GroupBy/#value","title":"Value","text":"<p>self</p>"},{"location":"reference/print.GroupBy/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$groupby(\"Species\")\n</code></pre>"},{"location":"reference/print.LazyFrame/","title":"<code>print.LazyFrame</code>","text":"<p>print LazyFrame s3 method</p>"},{"location":"reference/print.LazyFrame/#description","title":"Description","text":"<p>print LazyFrame s3 method</p>"},{"location":"reference/print.LazyFrame/#usage","title":"Usage","text":"<pre><code>list(list(\"print\"), list(\"LazyFrame\"))(x, ...)\n</code></pre>"},{"location":"reference/print.LazyFrame/#arguments","title":"Arguments","text":"Argument Description <code>x</code> DataFrame <code>...</code> not used"},{"location":"reference/print.LazyFrame/#value","title":"Value","text":"<p>self</p>"},{"location":"reference/print.LazyFrame/#examples","title":"Examples","text":"<pre><code>print(pl$DataFrame(iris)$lazy())\n</code></pre>"},{"location":"reference/print.LazyGroupBy/","title":"<code>print.LazyGroupBy</code>","text":"<p>print LazyGroupBy</p>"},{"location":"reference/print.LazyGroupBy/#description","title":"Description","text":"<p>print LazyGroupBy</p>"},{"location":"reference/print.LazyGroupBy/#usage","title":"Usage","text":"<pre><code>list(list(\"print\"), list(\"LazyGroupBy\"))(x, ...)\n</code></pre>"},{"location":"reference/print.LazyGroupBy/#arguments","title":"Arguments","text":"Argument Description <code>x</code> LazyGroupBy <code>...</code> not used"},{"location":"reference/print.LazyGroupBy/#value","title":"Value","text":"<p>self</p>"},{"location":"reference/print.PTime/","title":"<code>print.PTime</code>","text":"<p>print PTime</p>"},{"location":"reference/print.PTime/#description","title":"Description","text":"<p>print PTime</p>"},{"location":"reference/print.PTime/#usage","title":"Usage","text":"<pre><code>list(list(\"print\"), list(\"PTime\"))(x, ...)\n</code></pre>"},{"location":"reference/print.PTime/#arguments","title":"Arguments","text":"Argument Description <code>x</code> a PTime vector <code>...</code> not used"},{"location":"reference/print.PTime/#value","title":"Value","text":"<p>invisible x</p>"},{"location":"reference/print.PolarsBackgroundHandle/","title":"<code>print.PolarsBackgroundHandle</code>","text":"<p>print LazyFrame s3 method</p>"},{"location":"reference/print.PolarsBackgroundHandle/#description","title":"Description","text":"<p>print LazyFrame s3 method</p>"},{"location":"reference/print.PolarsBackgroundHandle/#usage","title":"Usage","text":"<pre><code>list(list(\"print\"), list(\"PolarsBackgroundHandle\"))(x, ...)\n</code></pre>"},{"location":"reference/print.PolarsBackgroundHandle/#arguments","title":"Arguments","text":"Argument Description <code>x</code> DataFrame <code>...</code> not used"},{"location":"reference/print.PolarsBackgroundHandle/#value","title":"Value","text":"<p>self</p>"},{"location":"reference/print.PolarsBackgroundHandle/#examples","title":"Examples","text":"<pre><code>lazy_df = pl$DataFrame(iris[,1:3])$lazy()$select(pl$all()$first())\nhandle = lazy_df$collect_background()\nhandle$is_exhausted()\ndf = handle$join()\nhandle$is_exhausted()\n</code></pre>"},{"location":"reference/print.RField/","title":"<code>print.RField</code>","text":"<p>Print a polars Field</p>"},{"location":"reference/print.RField/#description","title":"Description","text":"<p>Print a polars Field</p>"},{"location":"reference/print.RField/#usage","title":"Usage","text":"<pre><code>list(list(\"print\"), list(\"RField\"))(x, ...)\n</code></pre>"},{"location":"reference/print.RField/#arguments","title":"Arguments","text":"Argument Description <code>x</code> DataType <code>...</code> not used"},{"location":"reference/print.RField/#value","title":"Value","text":"<p>self</p>"},{"location":"reference/print.RField/#examples","title":"Examples","text":"<pre><code>print(pl$Field(\"foo\",pl$List(pl$UInt64)))\n</code></pre>"},{"location":"reference/print.RPolarsDataType/","title":"<code>print.RPolarsDataType</code>","text":"<p>print a polars datatype</p>"},{"location":"reference/print.RPolarsDataType/#description","title":"Description","text":"<p>print a polars datatype</p>"},{"location":"reference/print.RPolarsDataType/#usage","title":"Usage","text":"<pre><code>list(list(\"print\"), list(\"RPolarsDataType\"))(x, ...)\n</code></pre>"},{"location":"reference/print.RPolarsDataType/#arguments","title":"Arguments","text":"Argument Description <code>x</code> DataType <code>...</code> not used"},{"location":"reference/print.RPolarsDataType/#value","title":"Value","text":"<p>self</p>"},{"location":"reference/print.RPolarsDataType/#examples","title":"Examples","text":"<pre><code>pl$dtypes$Boolean #implicit print\n</code></pre>"},{"location":"reference/print.When/","title":"<code>print.When</code>","text":"<p>print When</p>"},{"location":"reference/print.When/#description","title":"Description","text":"<p>print When</p>"},{"location":"reference/print.When/#usage","title":"Usage","text":"<pre><code>list(list(\"print\"), list(\"When\"))(x, ...)\n</code></pre>"},{"location":"reference/print.When/#arguments","title":"Arguments","text":"Argument Description <code>x</code> When object <code>...</code> not used"},{"location":"reference/print.When/#value","title":"Value","text":"<p>self</p>"},{"location":"reference/print.When/#examples","title":"Examples","text":"<pre><code>print(pl$when(pl$col(\"a\")&gt;2))\n</code></pre>"},{"location":"reference/print.WhenThen/","title":"<code>print.WhenThen</code>","text":"<p>print When</p>"},{"location":"reference/print.WhenThen/#description","title":"Description","text":"<p>print When</p>"},{"location":"reference/print.WhenThen/#usage","title":"Usage","text":"<pre><code>list(list(\"print\"), list(\"WhenThen\"))(x, ...)\n</code></pre>"},{"location":"reference/print.WhenThen/#arguments","title":"Arguments","text":"Argument Description <code>x</code> When object <code>...</code> not used"},{"location":"reference/print.WhenThen/#value","title":"Value","text":"<p>self</p>"},{"location":"reference/print.WhenThen/#examples","title":"Examples","text":"<pre><code>print(pl$when(pl$col(\"a\")&gt;2)$then(pl$lit(\"more than two\")))\n</code></pre>"},{"location":"reference/print.WhenThenThen/","title":"<code>print.WhenThenThen</code>","text":"<p>print When</p>"},{"location":"reference/print.WhenThenThen/#description","title":"Description","text":"<p>print When</p>"},{"location":"reference/print.WhenThenThen/#usage","title":"Usage","text":"<pre><code>list(list(\"print\"), list(\"WhenThenThen\"))(x, ...)\n</code></pre>"},{"location":"reference/print.WhenThenThen/#arguments","title":"Arguments","text":"Argument Description <code>x</code> When object <code>...</code> not used"},{"location":"reference/print.WhenThenThen/#value","title":"Value","text":"<p>self</p>"},{"location":"reference/print.WhenThenThen/#examples","title":"Examples","text":"<pre><code>#\nprint(pl$when(pl$col(\"a\")&gt;2)$then(pl$lit(\"more than two\"))$when(pl$col(\"b\")&lt;5))\n</code></pre>"},{"location":"reference/print_env/","title":"<code>print_env</code>","text":"<p>print recursively an environment, used in some documentation</p>"},{"location":"reference/print_env/#description","title":"Description","text":"<p>print recursively an environment, used in some documentation</p>"},{"location":"reference/print_env/#usage","title":"Usage","text":"<pre><code>print_env(api, name, max_depth = 10)\n</code></pre>"},{"location":"reference/print_env/#arguments","title":"Arguments","text":"Argument Description <code>api</code> env <code>name</code> name of env <code>max_depth</code> numeric/int max levels to recursive iterate through"},{"location":"reference/pstop/","title":"<code>pstop</code>","text":"<p>Internal preferred function to throw errors</p>"},{"location":"reference/pstop/#description","title":"Description","text":"<p>DEPRECATED USE stopf instead</p>"},{"location":"reference/pstop/#usage","title":"Usage","text":"<pre><code>pstop(err, call = sys.call(1L))\n</code></pre>"},{"location":"reference/pstop/#arguments","title":"Arguments","text":"Argument Description <code>err</code> error msg string <code>call</code> calling context"},{"location":"reference/pstop/#value","title":"Value","text":"<p>throws an error</p>"},{"location":"reference/pstop/#examples","title":"Examples","text":"<pre><code>f = function() polars:::pstop(\"this aint right!!\")\ntryCatch(f(), error = \\(e) as.character(e))\n</code></pre>"},{"location":"reference/read_csv_/","title":"<code>read_csv_</code>","text":"<p>high level csv_reader, will download if path is url</p>"},{"location":"reference/read_csv_/#description","title":"Description","text":"<p>high level csv_reader, will download if path is url</p>"},{"location":"reference/read_csv_/#usage","title":"Usage","text":"<pre><code>read_csv_(path, lazy = FALSE, reuse_downloaded = TRUE, ...)\n</code></pre>"},{"location":"reference/read_csv_/#arguments","title":"Arguments","text":"Argument Description <code>path</code> file or url <code>lazy</code> bool default FALSE, read csv lazy <code>reuse_downloaded</code> bool default TRUE, cache url downloaded files in session an reuse <code>...</code> arguments forwarded to csv_reader or lazy_csv_reader"},{"location":"reference/read_csv_/#value","title":"Value","text":"<p>polars_DataFrame or polars_lazy_DataFrame</p>"},{"location":"reference/read_csv_/#examples","title":"Examples","text":"<pre><code>df = pl$read_csv(\"https://j.mp/iriscsv\")\n</code></pre>"},{"location":"reference/replace_private_with_pub_methods/","title":"<code>replace_private_with_pub_methods</code>","text":"<p>replace private class-methods with public</p>"},{"location":"reference/replace_private_with_pub_methods/#description","title":"Description","text":"<p>extendr places the naked internal calls to rust in env-classes. This function  can be used to delete them and replaces them with the public methods. Which are any function  matching pattern typically '^CLASSNAME' e.g. '^DataFrame_' or '^Series_'. Likely only used in  zzz.R</p>"},{"location":"reference/replace_private_with_pub_methods/#usage","title":"Usage","text":"<pre><code>replace_private_with_pub_methods(\nenv,\nclass_pattern,\nkeep = c(),\nremove_f = FALSE\n)\n</code></pre>"},{"location":"reference/replace_private_with_pub_methods/#arguments","title":"Arguments","text":"Argument Description <code>env</code> class envrionment to modify. Envs are mutable so no return needed <code>class_pattern</code> a regex string matching declared public functions of that class <code>keep</code> list of unmentioned methods to keep in public api <code>remove_f</code> bool if true, will move methods, not copy"},{"location":"reference/replace_private_with_pub_methods/#value","title":"Value","text":"<p>side effects only</p>"},{"location":"reference/restruct_list/","title":"<code>restruct_list</code>","text":"<p>restruct list</p>"},{"location":"reference/restruct_list/#description","title":"Description","text":"<p>lifecycle:: Deprecate  Restruct an object where structs where previously unnested</p>"},{"location":"reference/restruct_list/#usage","title":"Usage","text":"<pre><code>restruct_list(l)\n</code></pre>"},{"location":"reference/restruct_list/#arguments","title":"Arguments","text":"Argument Description <code>l</code> list"},{"location":"reference/restruct_list/#details","title":"Details","text":"<p>It was much easier impl export unnested struct from polars. This function  restructs exported unnested structs.  This function should be repalced with rust code writing this output  directly before nesting.  This hack relies on rust uses the tag \"is_struct\" to mark what should be re-structed.</p>"},{"location":"reference/restruct_list/#value","title":"Value","text":"<p>restructed list</p>"},{"location":"reference/same_outer_datatype/","title":"<code>same_outer_datatype</code>","text":"<p>check if x is a valid RPolarsDataType</p>"},{"location":"reference/same_outer_datatype/#description","title":"Description","text":"<p>check if x is a valid RPolarsDataType</p>"},{"location":"reference/same_outer_datatype/#arguments","title":"Arguments","text":"Argument Description <code>lhs</code> an RPolarsDataType <code>rhs</code> an RPolarsDataType"},{"location":"reference/same_outer_datatype/#value","title":"Value","text":"<p>bool TRUE if outer datatype is the same.</p>"},{"location":"reference/same_outer_datatype/#examples","title":"Examples","text":"<pre><code># TRUE\npl$same_outer_dt(pl$Datetime(\"us\"),pl$Datetime(\"ms\"))\npl$same_outer_dt(pl$List(pl$Int64),pl$List(pl$Float32))\n#FALSE\npl$same_outer_dt(pl$Int64,pl$Float64)\n</code></pre>"},{"location":"reference/scan_arrow_ipc/","title":"<code>scan_arrow_ipc</code>","text":"<p>Import data in Apache Arrow IPC format</p>"},{"location":"reference/scan_arrow_ipc/#description","title":"Description","text":"<p>Import data in Apache Arrow IPC format</p>"},{"location":"reference/scan_arrow_ipc/#usage","title":"Usage","text":"<pre><code>scan_arrow_ipc(\npath,\nn_rows = NULL,\ncache = TRUE,\nrechunk = TRUE,\nrow_count_name = NULL,\nrow_count_offset = 0L,\nmemmap = TRUE\n)\n</code></pre>"},{"location":"reference/scan_arrow_ipc/#arguments","title":"Arguments","text":"Argument Description <code>path</code> string, path <code>n_rows</code> integer, limit rows to scan <code>cache</code> bool, use cache <code>rechunk</code> bool, rechunk reorganize memory layout, potentially make future operations faster, however perform reallocation now. <code>row_count_name</code> NULL or string, if a string add a rowcount column named by this string <code>row_count_offset</code> integer, the rowcount column can be offst by this value <code>memmap</code> bool, mapped memory"},{"location":"reference/scan_arrow_ipc/#details","title":"Details","text":"<p>Create new LazyFrame from Apache Arrow IPC file or stream</p>"},{"location":"reference/scan_arrow_ipc/#value","title":"Value","text":"<p>LazyFrame</p>"},{"location":"reference/scan_parquet/","title":"<code>scan_parquet</code>","text":"<p>new LazyFrame from parquet file</p>"},{"location":"reference/scan_parquet/#description","title":"Description","text":"<p>new LazyFrame from parquet file</p>"},{"location":"reference/scan_parquet/#usage","title":"Usage","text":"<pre><code>scan_parquet(\nfile,\nn_rows = NULL,\ncache = TRUE,\nparallel = c(\"Auto\", \"None\", \"Columns\", \"RowGroups\"),\nrechunk = TRUE,\nrow_count_name = NULL,\nrow_count_offset = 0L,\nlow_memory = FALSE\n)\n</code></pre>"},{"location":"reference/scan_parquet/#arguments","title":"Arguments","text":"Argument Description <code>file</code> string filepath <code>n_rows</code> limit rows to scan <code>cache</code> bool use cache <code>parallel</code> String either Auto, None, Columns or RowGroups. The way to parralize the scan. <code>rechunk</code> bool rechunk reorganize memory layout, potentially make future operations faster , however perform reallocation now. <code>row_count_name</code> NULL or string, if a string add a rowcount column named by this string <code>row_count_offset</code> integer, the rowcount column can be offst by this value <code>low_memory</code> bool, try reduce memory footprint"},{"location":"reference/scan_parquet/#value","title":"Value","text":"<p>LazyFrame</p>"},{"location":"reference/scan_parquet/#examples","title":"Examples","text":"<pre><code>#TODO write parquet example\n</code></pre>"},{"location":"reference/str_string/","title":"<code>str_string</code>","text":"<p>Simple viewer of an R object based on str()</p>"},{"location":"reference/str_string/#description","title":"Description","text":"<p>Simple viewer of an R object based on str()</p>"},{"location":"reference/str_string/#usage","title":"Usage","text":"<pre><code>str_string(x, collapse = \" \")\n</code></pre>"},{"location":"reference/str_string/#arguments","title":"Arguments","text":"Argument Description <code>x</code> object to view. <code>collapse</code> word to glue possible multilines with"},{"location":"reference/str_string/#value","title":"Value","text":"<p>string</p>"},{"location":"reference/str_string/#examples","title":"Examples","text":"<pre><code>polars:::str_string(list(a=42,c(1,2,3,NA)))\n</code></pre>"},{"location":"reference/struct/","title":"<code>struct</code>","text":"<p>struct</p>"},{"location":"reference/struct/#description","title":"Description","text":"<p>Collect several columns into a Series of dtype Struct.</p>"},{"location":"reference/struct/#arguments","title":"Arguments","text":"Argument Description <code>exprs</code> Columns/Expressions to collect into a Struct. <code>eager</code> Evaluate immediately. <code>schema</code> Optional schema named list that explicitly defines the struct field dtypes. Each name must match a column name wrapped in the struct. Can only be used to cast some or all dtypes, not to change the names. NULL means to include keep columns into the struct by their current DataType. If a column is not included in the schema it is removed from the final struct."},{"location":"reference/struct/#details","title":"Details","text":"<p>pl$struct creates Expr or Series of DataType Struct()  pl$Struct creates the DataType Struct()  In polars a schema is a named list of DataTypes. #' A schema describes e.g. a DataFrame.  More formally schemas consist of Fields.  A Field is an object describing the name and DataType of a column/Series, but same same.  A struct is a DataFrame wrapped into a Series, the DataType is Struct, and each  sub-datatype within are Fields.  In a dynamic language schema and a Struct (the DataType) are quite the same, except  schemas describe DataFrame and Struct's describe some Series.</p>"},{"location":"reference/struct/#value","title":"Value","text":"<p>Eager=FALSE: Expr of Series with dtype Struct | Eager=TRUE: Series with dtype Struct</p>"},{"location":"reference/struct/#examples","title":"Examples","text":"<pre><code>#isolated expression to wrap all columns in a struct aliased 'my_struct'\npl$struct(pl$all())$alias(\"my_struct\")\n#wrap all column into on column/Series\ndf = pl$DataFrame(\nint = 1:2,\nstr = c(\"a\", \"b\"),\nbool = c(TRUE, NA),\nlist = list(1:2, 3L)\n)$select(\npl$struct(pl$all())$alias(\"my_struct\")\n)\nprint(df)\nprint(df$schema) #returns a schema, a named list containing one element a Struct named my_struct\n# wrap two columns in a struct and provide a schema to set all or some DataTypes by name\ne1 = pl$struct(\npl$col(c(\"int\",\"str\")),\nschema = list(int=pl$Int64, str=pl$Utf8)\n)$alias(\"my_struct\")\n# same result as e.g. wrapping the columns in a struct and casting afterwards\ne2 = pl$struct(\nlist(pl$col(\"int\"),pl$col(\"str\"))\n)$cast(\npl$Struct(int=pl$Int64,str=pl$Utf8)\n)$alias(\"my_struct\")\ndf = pl$DataFrame(\nint = 1:2,\nstr = c(\"a\", \"b\"),\nbool = c(TRUE, NA),\nlist = list(1:2, 3L)\n)\n#verify equality in R\nidentical(df$select(e1)$to_list(),df$select(e2)$to_list())\ndf$select(e2)\ndf$select(e2)$as_data_frame()\n</code></pre>"},{"location":"reference/sum/","title":"<code>sum</code>","text":"<p>sum across expressions / literals / Series</p>"},{"location":"reference/sum/#description","title":"Description","text":"<p>syntactic sugar for starting a expression with sum</p>"},{"location":"reference/sum/#arguments","title":"Arguments","text":"Argument Description <code>...</code> is a: If one arg: <ul> <li> <p>Series or Expr, same as <code>column$sum()</code> </p> </li> <li> <p>string, same as <code>pl$col(column)$sum()</code> </p> </li> <li> <p>numeric, same as <code>pl$lit(column)$sum()</code> </p> </li> <li> <p>list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ...   If several args, then wrapped in a list and handled as above.</p> </li> </ul>"},{"location":"reference/sum/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/sum/#examples","title":"Examples","text":"<pre><code>#column as string\npl$DataFrame(iris)$select(pl$sum(\"Petal.Width\"))\n#column as Expr (prefer pl$col(\"Petal.Width\")$sum())\npl$DataFrame(iris)$select(pl$sum(pl$col(\"Petal.Width\")))\n#column as numeric\npl$DataFrame()$select(pl$sum(1:5))\n#column as list\npl$DataFrame(a=1:2,b=3:4,c=5:6)$with_column(pl$sum(list(\"a\",\"c\")))\npl$DataFrame(a=1:2,b=3:4,c=5:6)$with_column(pl$sum(list(\"a\",\"c\", 42L)))\n#three eqivalent lines\npl$DataFrame(a=1:2,b=3:4,c=5:6)$with_column(pl$sum(list(\"a\",\"c\", pl$sum(list(\"a\",\"b\",\"c\")))))\npl$DataFrame(a=1:2,b=3:4,c=5:6)$with_column(pl$sum(list(pl$col(\"a\")+pl$col(\"b\"),\"c\")))\npl$DataFrame(a=1:2,b=3:4,c=5:6)$with_column(pl$sum(list(\"*\")))\n</code></pre>"},{"location":"reference/tick-set-_DataFrame-tick/","title":"<code>&lt;-_DataFrame</code>","text":"<p>generic setter method</p>"},{"location":"reference/tick-set-_DataFrame-tick/#description","title":"Description","text":"<p>set value of properties of DataFrames</p>"},{"location":"reference/tick-set-_DataFrame-tick/#usage","title":"Usage","text":"<pre><code>list(list(\"$\"), list(\"DataFrame\"))(self, name) &lt;- value\n</code></pre>"},{"location":"reference/tick-set-_DataFrame-tick/#arguments","title":"Arguments","text":"Argument Description <code>self</code> DataFrame <code>name</code> name method/property to set <code>value</code> value to insert"},{"location":"reference/tick-set-_DataFrame-tick/#details","title":"Details","text":"<p>settable polars object properties may appear to be R objects, but they are not.  See [[method_name]] example</p>"},{"location":"reference/tick-set-_DataFrame-tick/#value","title":"Value","text":"<p>value</p>"},{"location":"reference/tick-set-_DataFrame-tick/#examples","title":"Examples","text":"<pre><code>#For internal use\n#is only activated for following methods of DataFrame\nls(polars:::DataFrame.property_setters)\n#specific use case for one object property 'columns' (names)\ndf = pl$DataFrame(iris)\n#get values\ndf$columns\n#set + get values\ndf$columns = letters[1:5] #&lt;- is fine too\ndf$columns\n# Rstudio is not using the standard R code completion tool\n# and it will backtick any special characters. It is possible\n# to completely customize the R / Rstudio code completion except\n# it will trigger Rstudio to backtick any completion! Also R does\n# not support package isolated customization.\n#Concrete example if tabbing on 'df$' the raw R suggestion is df$columns&lt;-\n#however Rstudio backticks it into df$`columns&lt;-`\n#to make life simple, this is valid polars syntax also, and can be used in fast scripting\ndf$`columns&lt;-` = letters[5:1]\n#for stable code prefer e.g.  df$columns = letters[5:1]\n#to see inside code of a property use the [[]] syntax instead\ndf[[\"columns\"]] # to see property code, .pr is the internal polars api into rust polars\npolars:::DataFrame.property_setters$columns #and even more obscure to see setter code\n</code></pre>"},{"location":"reference/to_list/","title":"<code>to_list</code>","text":"<p>return polars DataFrame as R lit of vectors</p>"},{"location":"reference/to_list/#description","title":"Description","text":"<p>return polars DataFrame as R lit of vectors</p>"},{"location":"reference/to_list/#usage","title":"Usage","text":"<pre><code>DataFrame_to_list(unnest_structs = TRUE)\n</code></pre>"},{"location":"reference/to_list/#arguments","title":"Arguments","text":"Argument Description <code>unnest_structs</code> bool default true, as calling $unnest() on any struct column"},{"location":"reference/to_list/#details","title":"Details","text":"<p>This implementation for simplicity reasons relies on unnesting all structs before  exporting to R. unnest_structs = FALSE, the previous struct columns will be re-  nested. A struct in a R is a lists of lists, where each row is a list of values.  Such a structure is not very typical or efficient in R.</p>"},{"location":"reference/to_list/#value","title":"Value","text":"<p>R list of vectors</p>"},{"location":"reference/to_list/#examples","title":"Examples","text":"<pre><code>pl$DataFrame(iris)$to_list()\n</code></pre>"},{"location":"reference/unAsIs/","title":"<code>unAsIs</code>","text":"<p>Reverts wrapping in I</p>"},{"location":"reference/unAsIs/#description","title":"Description","text":"<p>Reverts wrapping in I</p>"},{"location":"reference/unAsIs/#usage","title":"Usage","text":"<pre><code>unAsIs(X)\n</code></pre>"},{"location":"reference/unAsIs/#arguments","title":"Arguments","text":"Argument Description <code>X</code> any Robj wrapped in `I()``"},{"location":"reference/unAsIs/#details","title":"Details","text":"<p>https://stackoverflow.com/questions/12865218/getting-rid-of-asis-class-attribute</p>"},{"location":"reference/unAsIs/#value","title":"Value","text":"<p>X without any AsIs subclass</p>"},{"location":"reference/unwrap/","title":"<code>unwrap</code>","text":"<p>rust-like unwrapping of result. Useful to keep error handling on the R side.</p>"},{"location":"reference/unwrap/#description","title":"Description","text":"<p>rust-like unwrapping of result. Useful to keep error handling on the R side.</p>"},{"location":"reference/unwrap/#usage","title":"Usage","text":"<pre><code>unwrap(result, context = NULL, call = sys.call(1L))\n</code></pre>"},{"location":"reference/unwrap/#arguments","title":"Arguments","text":"Argument Description <code>result</code> a list here either element ok or err is NULL, or both if ok is litteral NULL <code>context</code> a msg to prefix a raised error with <code>call</code> context of error or string"},{"location":"reference/unwrap/#value","title":"Value","text":"<p>the ok-element of list , or a error will be thrown</p>"},{"location":"reference/unwrap/#examples","title":"Examples","text":"<pre><code>structure(list(ok = \"foo\", err = NULL), class = \"extendr_result\")\ntryCatch(\nunwrap(\nstructure(\nlist(ok = NULL, err = \"something happen on the rust side\"),\nclass = \"extendr_result\"\n)\n),\nerror = function(err) as.character(err)\n)\n</code></pre>"},{"location":"reference/verify_method_call/","title":"<code>verify_method_call</code>","text":"<p>Verify user selected method/attribute exists</p>"},{"location":"reference/verify_method_call/#description","title":"Description","text":"<p>internal function to check method call of env_classes</p>"},{"location":"reference/verify_method_call/#usage","title":"Usage","text":"<pre><code>verify_method_call(\nClass_env,\nMethod_name,\ncall = sys.call(1L),\nclass_name = NULL\n)\n</code></pre>"},{"location":"reference/verify_method_call/#arguments","title":"Arguments","text":"Argument Description <code>Class_env</code> env_class object (the classes created by extendr-wrappers.R) <code>Method_name</code> name of method requested by user <code>call</code> context to throw user error, just use default <code>class_name</code> NULLs"},{"location":"reference/verify_method_call/#value","title":"Value","text":"<p>invisible(NULL)</p>"},{"location":"reference/when_then_otherwise/","title":"<code>when_then_otherwise</code>","text":"<p>when-then-otherwise Expr</p>"},{"location":"reference/when_then_otherwise/#description","title":"Description","text":"<p>Start a \u201cwhen, then, otherwise\u201d expression.</p>"},{"location":"reference/when_then_otherwise/#arguments","title":"Arguments","text":"Argument Description <code>predicate</code> Into Expr into a boolean mask to branch by <code>expr</code> Into Expr value to insert in when() or otherwise()"},{"location":"reference/when_then_otherwise/#details","title":"Details","text":"<p>For the impl nerds: pl$when returns a whenthen object and whenthen returns whenthenthen, except  for otherwise(), which will terminate and return an Expr.  Otherwise may fail to return an Expr if e.g. two consecutive <code>when(x)$when(y)</code></p>"},{"location":"reference/when_then_otherwise/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/when_then_otherwise/#examples","title":"Examples","text":"<pre><code>df = pl$DataFrame(mtcars)\nwtt =\npl$when(pl$col(\"cyl\")&lt;=4)$then(\"&lt;=4cyl\")$\nwhen(pl$col(\"cyl\")&lt;=6)$then(\"&lt;=6cyl\")$\notherwise(\"&gt;6cyl\")$alias(\"cyl_groups\")\nprint(wtt)\ndf$with_columns(wtt)\n</code></pre>"},{"location":"reference/wrap_e/","title":"<code>wrap_e</code>","text":"<p>wrap as literal</p>"},{"location":"reference/wrap_e/#description","title":"Description","text":"<p>wrap as literal</p>"},{"location":"reference/wrap_e/#usage","title":"Usage","text":"<pre><code>wrap_e(e, str_to_lit = TRUE)\n</code></pre>"},{"location":"reference/wrap_e/#arguments","title":"Arguments","text":"Argument Description <code>e</code> an Expr(polars) or any R expression"},{"location":"reference/wrap_e/#details","title":"Details","text":"<p>used internally to ensure an object is an expression</p>"},{"location":"reference/wrap_e/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/wrap_e/#examples","title":"Examples","text":"<pre><code>pl$col(\"foo\") &lt; 5\n</code></pre>"},{"location":"reference/wrap_e_result/","title":"<code>wrap_e_result</code>","text":"<p>wrap as Expression capture ok/err as result</p>"},{"location":"reference/wrap_e_result/#description","title":"Description","text":"<p>wrap as Expression capture ok/err as result</p>"},{"location":"reference/wrap_e_result/#usage","title":"Usage","text":"<pre><code>wrap_e_result(e, str_to_lit = TRUE, argname = NULL)\n</code></pre>"},{"location":"reference/wrap_e_result/#arguments","title":"Arguments","text":"Argument Description <code>e</code> an Expr(polars) or any R expression <code>str_to_lit</code> bool should string become a column name or not, then a literal string <code>argname</code> if error, blame argument of this name"},{"location":"reference/wrap_e_result/#details","title":"Details","text":"<p>used internally to ensure an object is an expression and to catch any error</p>"},{"location":"reference/wrap_e_result/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/wrap_e_result/#examples","title":"Examples","text":"<pre><code>pl$col(\"foo\") &lt; 5\n</code></pre>"},{"location":"reference/wrap_elist_result/","title":"<code>wrap_elist_result</code>","text":"<p>wrap_elist_result</p>"},{"location":"reference/wrap_elist_result/#description","title":"Description","text":"<p>make sure all elementsof a list is wrapped as Expr  Capture any conversion error in the result</p>"},{"location":"reference/wrap_elist_result/#usage","title":"Usage","text":"<pre><code>wrap_elist_result(elist, str_to_lit = TRUE)\n</code></pre>"},{"location":"reference/wrap_elist_result/#arguments","title":"Arguments","text":"Argument Description <code>elist</code> a list Expr or any R object Into list(list(\"html\"), list(list(\"\"))) (passable to pl$lit)"},{"location":"reference/wrap_elist_result/#details","title":"Details","text":"<p>Used internally to ensure an object is a list of expression  The output is wrapped in a result, which can contain an ok or  err value.</p>"},{"location":"reference/wrap_elist_result/#value","title":"Value","text":"<p>Expr</p>"},{"location":"reference/wrap_elist_result/#examples","title":"Examples","text":"<pre><code>polars:::wrap_elist_result(list(pl$lit(42),42,1:3))\n</code></pre>"},{"location":"reference/wrap_proto_schema/","title":"<code>wrap_proto_schema</code>","text":"<p>wrap proto schema</p>"},{"location":"reference/wrap_proto_schema/#description","title":"Description","text":"<p>wrap proto schema</p>"},{"location":"reference/wrap_proto_schema/#format","title":"Format","text":"<p>function</p>"},{"location":"reference/wrap_proto_schema/#usage","title":"Usage","text":"<pre><code>wrap_proto_schema(x)\n</code></pre>"},{"location":"reference/wrap_proto_schema/#arguments","title":"Arguments","text":"Argument Description <code>x</code> either schema, or incomplete schema where dataType can be NULL or schema is just char vec, implicitly the same as if all DataType are NULL, mean undefinesd."},{"location":"reference/wrap_proto_schema/#value","title":"Value","text":"<p>bool</p>"},{"location":"reference/wrap_proto_schema/#examples","title":"Examples","text":"<pre><code>polars:::wrap_proto_schema(c(\"alice\",\"bob\"))\npolars:::wrap_proto_schema(list(\"alice\"=pl$Int64,\"bob\"=NULL))\n</code></pre>"},{"location":"reference/wrap_s/","title":"<code>wrap_s</code>","text":"<p>Wrap as Series</p>"},{"location":"reference/wrap_s/#description","title":"Description","text":"<p>input is either already a Series of will be passed to the Series constructor</p>"},{"location":"reference/wrap_s/#usage","title":"Usage","text":"<pre><code>wrap_s(x)\n</code></pre>"},{"location":"reference/wrap_s/#arguments","title":"Arguments","text":"Argument Description <code>x</code> a Series or something-turned-into-Series"},{"location":"reference/wrap_s/#value","title":"Value","text":"<p>Series</p>"}]}