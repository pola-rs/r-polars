{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"polars The goal of this project is to bring the blazingly fast Polars data manipulation library to R. The underlying computation engine is written in Rust and this R implementation has no other dependencies than R itself (\u2265 4.1.0). Documentation can be found on the r-polars homepage . The primary developer of the upstream Polars project is Ritchie Vink ( @ritchie46 ). This R port is maintained by S\u00f8ren Welling ( @sorhawell ), together with other contributors . Consider joining our Discord (subchannel) for additional help and discussion. Update: As of March 2023, polars has now reached nearly 100% coverage of the underlying \u201clazy\u201d Expr syntax. While translation of the \u201ceager\u201d syntax is still a little further behind, you should be able to do just about everything using $select() + $with_columns() . Install The package is not yet available on CRAN. But we provide convenient installation options for a variety of operating systems: R-universe R-universe provides pre-compiled polars binaries for Windows and MacOS (x86_64), with source builds for other platforms. Please see the GitHub release option below for binary install options on Linux. install.packages ( \"polars\" , repos = \"https://rpolars.r-universe.dev\" ) Special thanks to Jeroen Ooms ( @jeroen ) for the excellent R-universe support. GitHub releases We also provide pre-compiled binaries for various operating systems, as well as source installs, on our GitHub releases page. You can download and install these files manually, or install directly from R. Simply match the URL for your operating system and the desired release. For example, to install the latest release of polars on Linux (x86_64) one would use: install.packages ( \"https://github.com/pola-rs/r-polars/releases/latest/download/polars__x86_64-pc-linux-gnu.gz\" , repos = NULL ) Similarly for Windows ( URL and MacOS (x86_64, URL ). Just remember to invoke the repos = NULL argument if you are installing these binary builds directly from within R. One exception worth noting is MacOS (arm64), i.e. systems based on the new M1/M2 \u201cSilicon\u201d chips. To install polars on one of these machines, we need to build the package from source and this requires Xcode ( xcode-select --install ). Once Xcode is installed, you can run the below code chunk to build polars . The corresponding Makevars script will download a \\~200MB cross-compiled object file, while your machine links and builds the final R package. # install.packages(\"remotes\") remotes :: install_github ( \"https://github.com/pola-rs/r-polars\" , ref = \"long_arms64\" , force = TRUE ) Please file an issue if you require a different target or operating system build. Finally, see the bottom of this README for details on how to install rust to build from source (only relevant for developers, or users of unsupported operating systems). Quickstart example The introductory vignette ( vignette(\"polars\") ) contains a series of detailed examples. But here is a quick illustration of polars in action. Start by loading the package and creating a Polars DataFrame object. Similar to the Python implementation, note that we use the pl$ prefix to specify a Polars constructor. library ( polars ) dat = pl $ DataFrame ( mtcars ) dat #> polars DataFrame: shape: (32, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 4.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 6.0 \u2502 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Once our Polars DataFrame has been created, we can chain together a series of data manipulations as part of the same query. For example: dat $ filter ( pl $ col ( \"cyl\" ) >= 6 ) $ groupby ( \"cyl\" , \"am\" ) $ agg ( pl $ col ( \"mpg\" ) $ mean () $ alias ( \"mean_mpg\" ), pl $ col ( \"hp\" ) $ median () $ alias ( \"med_hp\" ) ) #> polars DataFrame: shape: (4, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cyl \u2506 am \u2506 mean_mpg \u2506 med_hp \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6.0 \u2506 1.0 \u2506 20.566667 \u2506 110.0 \u2502 #> \u2502 6.0 \u2506 0.0 \u2506 19.125 \u2506 116.5 \u2502 #> \u2502 8.0 \u2506 0.0 \u2506 15.05 \u2506 180.0 \u2502 #> \u2502 8.0 \u2506 1.0 \u2506 15.4 \u2506 299.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The above is an example of Polars\u2019 eager execution engine. But for maximum performance, it is preferable to use Polars\u2019 lazy execution mode, which allows the package to apply additional query optimizations. ldat = dat $ lazy () ldat $ filter ( pl $ col ( \"cyl\" ) >= 6 ) $ groupby ( \"cyl\" , \"am\" ) $ agg ( pl $ col ( \"mpg\" ) $ mean () $ alias ( \"mean_mpg\" ), pl $ col ( \"hp\" ) $ median () $ alias ( \"med_hp\" ) ) $ collect () #> polars DataFrame: shape: (4, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cyl \u2506 am \u2506 mean_mpg \u2506 med_hp \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6.0 \u2506 1.0 \u2506 20.566667 \u2506 110.0 \u2502 #> \u2502 6.0 \u2506 0.0 \u2506 19.125 \u2506 116.5 \u2502 #> \u2502 8.0 \u2506 0.0 \u2506 15.05 \u2506 180.0 \u2502 #> \u2502 8.0 \u2506 1.0 \u2506 15.4 \u2506 299.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Contribute Contributions are very welcome! Here are the steps required for an example contribution, where we are implementing the cosine expression : Look up the polars.Expr.cos method in py-polars documentation . Press the [source] button to see the Python impl Find the cos py-polars rust implementation (likely just a simple call to the Rust-Polars API) Adapt the Rust part and place it here . Adapt the Python frontend syntax to R and place it here . Add the roxygen docs + examples above. Notice we use Expr_cos = \"use_extendr_wrapper\" , it means we\u2019re just using unmodified the extendr auto-generated wrapper Write a test here . Run renv::restore() and resolve all R packages Run rextendr::document() to recompile and confirm the added method functions as intended, e.g. pl$DataFrame(a=c(0,pi/2,pi,NA_real_))$select(pl$col(\"a\")$cos()) Run devtools::test() . See below for how to set up your development environment correctly. Note that PRs to polars will be automatically be built and tested on all platforms as part of our GitHub Actions workflow. A more detailed description of the development environment and workflow for local builds is provided below. Development environment and workflow System dependencies Rust toolchain Install rustup , the cross-platform Rust installer. Then: rustup toolchain install nightly rustup default nightly Windows: Make sure the latest version of Rtools is installed and on your PATH. MacOS: Make sure Xcode is installed. Install CMake and added it to your PATH. Development workflow Assuming the system dependencies have been met (above), the typical polars development workflow is as follows: Step 1: Fork the polars repo on GitHub and then clone it locally. git clone git@github.com:<YOUR-GITHUB-ACCOUNT>/r-polars.git cd r-polars Step 2: Build the package and install the suggested package dependencies. Option A: Using devtools . Rscript - e 'devtools::install(pkg = \".\", dependencies = TRUE)' Option B: Using renv . # Rscript -e 'install.packages(\"renv\")' Rscript - e 'renv::activate(); renv::restore()' Step 3: Make your proposed changes to the R and/or Rust code. Don\u2019t forget to run: rextendr :: document () # compile Rust code + update wrappers & docs devtools :: test () # run all unit tests Step 4 (optional): Build the package locally. R CMD INSTALL -- no - multiarch -- with - keep.source polars Step 5: Commit your changes and submit a PR to the main polars repo. As aside, notice that ./renv.lock sets all R packages during the server build. Tip: To speed up the local R CMD check, run the following: devtools :: check ( env_vars = list ( RPOLARS_RUST_SOURCE = \"/YOUR/OWN/ABSOLUTE/PATH/r-polars/src/rust\" ), check_dir = \"./check/\" ) source ( \"./inst/misc/filter_rcmdcheck.R\" ) Sys.sleep ( 5 ) unlink ( \"check\" , recursive = TRUE , force = TRUE ) The RPOLARS_RUST_SOURCE environment variable allows polars to recover the Cargo cache even if source files have been moved. Replace with your own absolute path to your local clone! filter_rcmdcheck.R removes known warnings from final check report. unlink(\"check\") cleans up.","title":"Home"},{"location":"#polars","text":"The goal of this project is to bring the blazingly fast Polars data manipulation library to R. The underlying computation engine is written in Rust and this R implementation has no other dependencies than R itself (\u2265 4.1.0). Documentation can be found on the r-polars homepage . The primary developer of the upstream Polars project is Ritchie Vink ( @ritchie46 ). This R port is maintained by S\u00f8ren Welling ( @sorhawell ), together with other contributors . Consider joining our Discord (subchannel) for additional help and discussion. Update: As of March 2023, polars has now reached nearly 100% coverage of the underlying \u201clazy\u201d Expr syntax. While translation of the \u201ceager\u201d syntax is still a little further behind, you should be able to do just about everything using $select() + $with_columns() .","title":"polars"},{"location":"#install","text":"The package is not yet available on CRAN. But we provide convenient installation options for a variety of operating systems:","title":"Install"},{"location":"#quickstart-example","text":"The introductory vignette ( vignette(\"polars\") ) contains a series of detailed examples. But here is a quick illustration of polars in action. Start by loading the package and creating a Polars DataFrame object. Similar to the Python implementation, note that we use the pl$ prefix to specify a Polars constructor. library ( polars ) dat = pl $ DataFrame ( mtcars ) dat #> polars DataFrame: shape: (32, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 4.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 6.0 \u2502 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Once our Polars DataFrame has been created, we can chain together a series of data manipulations as part of the same query. For example: dat $ filter ( pl $ col ( \"cyl\" ) >= 6 ) $ groupby ( \"cyl\" , \"am\" ) $ agg ( pl $ col ( \"mpg\" ) $ mean () $ alias ( \"mean_mpg\" ), pl $ col ( \"hp\" ) $ median () $ alias ( \"med_hp\" ) ) #> polars DataFrame: shape: (4, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cyl \u2506 am \u2506 mean_mpg \u2506 med_hp \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6.0 \u2506 1.0 \u2506 20.566667 \u2506 110.0 \u2502 #> \u2502 6.0 \u2506 0.0 \u2506 19.125 \u2506 116.5 \u2502 #> \u2502 8.0 \u2506 0.0 \u2506 15.05 \u2506 180.0 \u2502 #> \u2502 8.0 \u2506 1.0 \u2506 15.4 \u2506 299.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The above is an example of Polars\u2019 eager execution engine. But for maximum performance, it is preferable to use Polars\u2019 lazy execution mode, which allows the package to apply additional query optimizations. ldat = dat $ lazy () ldat $ filter ( pl $ col ( \"cyl\" ) >= 6 ) $ groupby ( \"cyl\" , \"am\" ) $ agg ( pl $ col ( \"mpg\" ) $ mean () $ alias ( \"mean_mpg\" ), pl $ col ( \"hp\" ) $ median () $ alias ( \"med_hp\" ) ) $ collect () #> polars DataFrame: shape: (4, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cyl \u2506 am \u2506 mean_mpg \u2506 med_hp \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6.0 \u2506 1.0 \u2506 20.566667 \u2506 110.0 \u2502 #> \u2502 6.0 \u2506 0.0 \u2506 19.125 \u2506 116.5 \u2502 #> \u2502 8.0 \u2506 0.0 \u2506 15.05 \u2506 180.0 \u2502 #> \u2502 8.0 \u2506 1.0 \u2506 15.4 \u2506 299.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Quickstart example"},{"location":"#contribute","text":"Contributions are very welcome! Here are the steps required for an example contribution, where we are implementing the cosine expression : Look up the polars.Expr.cos method in py-polars documentation . Press the [source] button to see the Python impl Find the cos py-polars rust implementation (likely just a simple call to the Rust-Polars API) Adapt the Rust part and place it here . Adapt the Python frontend syntax to R and place it here . Add the roxygen docs + examples above. Notice we use Expr_cos = \"use_extendr_wrapper\" , it means we\u2019re just using unmodified the extendr auto-generated wrapper Write a test here . Run renv::restore() and resolve all R packages Run rextendr::document() to recompile and confirm the added method functions as intended, e.g. pl$DataFrame(a=c(0,pi/2,pi,NA_real_))$select(pl$col(\"a\")$cos()) Run devtools::test() . See below for how to set up your development environment correctly. Note that PRs to polars will be automatically be built and tested on all platforms as part of our GitHub Actions workflow. A more detailed description of the development environment and workflow for local builds is provided below.","title":"Contribute"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2023 rpolars authors Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"LICENSE/#mit-license","text":"Copyright (c) 2023 rpolars authors Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"NEWS/","text":"polars (development version) polars v0.5.0 BREAKING CHANGE The package name was changed from rpolars to polars . (#84) What's changed Several new methods for DataFrame, LazyFrame \\& GroupBy translated (#103, #105 @vincentarelbundock) Doc fixes (#102, #109 @etiennebacher) Experimental opt-in auto completion (#96 @sorhawell) New Contributors @etiennebacher made their first contribution in #102 @vincentarelbundock made their first contribution in #103 Release date: 2023-04-16. Full changelog: v0.4.6...v0.5.0 rpolars v0.4.7 What's changed Revamped docs that includes a new introductory vignette (#81 @grantmcdermott) Misc documentation improvements rpolars v0.4.6 Release date: 2023-03-13. Full changelog: v0.4.5...v0.4.6 What's new Almost all Expr translated, only missing 'binary'-expr now. #52 #53 Run polars queries in detached background threads, no need for any parallel libraries or cluster config #56 #59 Full support for when-then-otherwise-syntax #65 rpolars now uses bit64 integer64 vectors as input/output for i64 vectors: #68 #69 use pl$from_arrow to zero-copy(almost) import Table / Array from r-arrow . #67 Support inter process connections with scan_ipc Implement scan_ipc by @Sicheng-Pan in #63 'Backend' improvements (prepare support for aarch64-linux) Touch libgcc_eh.a by @yutannihilation in #49 Use py-polars rust file structure (to help devs) by @sorhawell in #55 Refactor Makefiles by @eitsupi in #58 Build rpolars from Nix by @Sicheng-Pan in #54 extendr_api 0.4 by @sorhawell in #6 Add r-universe URL by @jeroen in #71 chore: install nanoarrow from cran by @eitsupi in #72 chore: install nanoarrow from cran (#72) by @sorhawell in #73 Fix pdf latex errors by @sorhawell in #74 re-enable devel test, pak R-devel issue went away by @sorhawell in #75 DO NOT MERGE: tracking hello_r_universe branch by @eitsupi in #38 revert to nightly by @sorhawell in #78 New Contributors @Sicheng-Pan made their first contribution in #54 @jeroen made their first contribution in #71 rpolars v0.4.5 Release date: 2023-02-21. Full Changelog: v0.4.3...v0.4.5 What's Changed bump rust polars to latest rust-polars and fix all errors by @sorhawell in #42 Customize extendr to better support cross Rust-R/R-Rust error handling bump extendr_api by @sorhawell in #44 Str even more by @sorhawell in #47 rpolars is now available for install from rpolars.r-universe.dev @eitsupi advertise R-universe by @sorhawell in #39 Includes reasonably easy pre-compiled installation for arm64-MacBooks All string Expressions available Expr str strptime by @sorhawell in #40 rust_result tests + fixes by @sorhawell in #41 Str continued by @sorhawell in #43 Str even more by @sorhawell in #47 Starting to roll out new error-handling and type-conversions between R and rust. Precise source of error should be very clear even in a long method-chain e.g. pl $ lit ( \"hey-you-there\" ) $ str $ splitn ( \"-\" , -3 ) $ alias ( \"struct_of_words\" ) $ to_r () > Error : in str $ splitn the arg [ n ] the value -3 cannot be less than zero when calling : pl $ lit ( \"hey-you-there\" ) $ str $ splitn ( \"-\" , -3 ) Misc Clippy + tiny optimization by @sorhawell in #45 Tidying by @sorhawell in #37 rpolars v0.4.3 Release date: 2023-02-01. Full Changelog: v0.4.2...v0.4.3 What's Changed All DateTime expresssions implemented + update rust-polars to latest commit. Arr str by @sorhawell in #32 Datetime continued by @sorhawell in #33 Datatime remaining tests + tidy util functions by @sorhawell in #36 Developer changes Refactoring GitHub Actions workflows by @eitsupi in #24 Fix cache and check scan by @sorhawell in #30 rpolars v0.4.2 Release date: 2023-01-17. Full Changelog: V0.4.1...v0.4.2 What's Changed fix minor Series syntax issue #8 @sorhawell in #22 nanoarrow followup: docs + adjust test by @sorhawell in #21 Add R CMD check workflow by @eitsupi in #23 usethis::use_mit_license() by @yutannihilation in #27 Fix check errors by @sorhawell in #26 New Contributors @eitsupi made their first contribution in #23 @yutannihilation made their first contribution in #27 rpolars v0.4.1 Release date: 2023-01-12. Full Changelog: v0.4.0...V0.4.1 What's Changed Export ArrowArrayStream from polars data frame by @paleolimbot in #5 Minor arithmetics syntax improvement @sorhawell in #20 Dev env Renv is deactivated as default. Renv.lock still defines package stack on build server @sorhawell in #19 Minor stuff Improve docs by @sorhawell in #16 Update rust polars to +26.1 by @sorhawell in #18 New Contributors @paleolimbot made their first contribution in #5 rpolars v0.4.0 Release date: 2023-01-11. Full Changelog: v0.3.1...v0.4.0 Breaking changes Class label \"DataType\" is now called \"RPolarsDataType\". Syntax wise 'DataType' can still be used, e.g. .pr$DataType$ try fix name space collision with arrow by @sorhawell in #15 New features all list Expr$arr$list functions have been translated: Expr list 2.0 by @sorhawell in #10 Expr list 3.0 by @sorhawell in #12 Dev environment update rextendr by @sorhawell in #13 rpolars v0.3.1 Release date: 2023-01-07. Full Changelog: v0.3.0...v0.3.1 What's Changed drop github action upload pre-release of PR's by @sorhawell in #7 Fix readme typo by @erjanmx in #6 Expr arr list functions + rework r_to_series by @sorhawell in #2 New Contributors @erjanmx made their first contribution in #6 rpolars v0.3.0 Release date: 2022-12-31. Full Changelog: v0.2.1...v0.3.0 What's Changed use jemalloc(linux) else mimallac as py-polars by @sorhawell in #1 Bump rust polars 26.1 by @sorhawell in #3 Expr_interpolate now has two methods, linear, nearest Expr_quantile also takes quantile value as an expression map_alias improved error handling rpolars v0.2.1 Release date: 2022-12-27 rpolars is now hosted at https://github.com/pola-rs/r-polars . Happy to be here.","title":"Changelog"},{"location":"NEWS/#polars-development-version","text":"","title":"polars (development version)"},{"location":"NEWS/#polars-v050","text":"","title":"polars v0.5.0"},{"location":"NEWS/#rpolars-v047","text":"","title":"rpolars v0.4.7"},{"location":"NEWS/#rpolars-v046","text":"Release date: 2023-03-13. Full changelog: v0.4.5...v0.4.6","title":"rpolars v0.4.6"},{"location":"NEWS/#rpolars-v045","text":"Release date: 2023-02-21. Full Changelog: v0.4.3...v0.4.5","title":"rpolars v0.4.5"},{"location":"NEWS/#rpolars-v043","text":"Release date: 2023-02-01. Full Changelog: v0.4.2...v0.4.3","title":"rpolars v0.4.3"},{"location":"NEWS/#rpolars-v042","text":"Release date: 2023-01-17. Full Changelog: V0.4.1...v0.4.2","title":"rpolars v0.4.2"},{"location":"NEWS/#rpolars-v041","text":"Release date: 2023-01-12. Full Changelog: v0.4.0...V0.4.1","title":"rpolars v0.4.1"},{"location":"NEWS/#rpolars-v040","text":"Release date: 2023-01-11. Full Changelog: v0.3.1...v0.4.0","title":"rpolars v0.4.0"},{"location":"NEWS/#rpolars-v031","text":"Release date: 2023-01-07. Full Changelog: v0.3.0...v0.3.1","title":"rpolars v0.3.1"},{"location":"NEWS/#rpolars-v030","text":"Release date: 2022-12-31. Full Changelog: v0.2.1...v0.3.0","title":"rpolars v0.3.0"},{"location":"NEWS/#rpolars-v021","text":"Release date: 2022-12-27 rpolars is now hosted at https://github.com/pola-rs/r-polars . Happy to be here.","title":"rpolars v0.2.1"},{"location":"articles/polars/","text":"An Introduction to Polars from R What is Polars? Polars is a lightning fast Data Frame library. Its embarrassingly parallel execution, cache efficient algorithms and expressive API makes it perfect for efficient data wrangling, data pipelines, snappy APIs and so much more. Polars also supports \u201cstreaming mode\u201d for out-of-memory operations. This allows users to analyze datasets many times larger than RAM. The underlying computation engine is written in Rust and is built on the Apache Arrow columnar memory format. It can be used in Rust or via Python bindings. The polars R-package provides equivalent bindings from R. Within R, python and rust each polars package is just called polars. The implemention polars in the different languages can be called rust-polars, py-polars, r-polars, nodejs-polars\u2026 polars users can expect orders of magnitude(s) improvement compared to dplyr for simple transformations on datasets >500Mb. The automatic Polars optimization framework means that that this speed boost can be even greater for complex queries that chain together many operations. Performance is similar to that of data.table , although polars supports additional functionality via its relationship to the Apache Arrow memory model. For example, it can scan multiple Parquet files and datasets and selectively import random subsets without having to read all of the data. Polars syntax is similar to that of Spark, but the workflow is column-oriented rather than row-oriented. Since R is itself a column-oriented language, this should immediately feel familiar to most R users. Like Spark and modern SQL variants, Polars optimizes queries for memory consumption and speed, so you don\u2019t have to. However, unlike Spark, Polars is natively multithreaded instead of multinoded. This makes (r)polars much simpler to install and can be used as one would any other R package. This R port relies on the excellent extendr package, which is the R equivalent to pyo3+maturin. extendr is very convenient for calling Rust from R, and vice versa, and is what we use to build the polars package. Once built, however, polars has no other dependencies other than R itself. This makes it very fast and lightweight to install, and so polars can immediately be used to tackle your big (or small!) data wrangling tasks. Documentation and tutorials Users can find detailed documentation for all objects, functions, and methods on the Reference page of this website. This documentation can also be accessed from the R console using the typical ? syntax. For example, we will later use the DataFrame() constructor function and apply the groupby() method to a DataFrame object. The documentation for these can be accessed by typing these commands: ? DataFrame ? DataFrame_groupby The Polars book offers a great introduction to the Polars data frame library, with a very large number of examples in Python and Rust. The syntax and expressions in the polars package for R are (deliberately) as close to the Python implementation as possible, so you can always refer to the polars book for more ideas. Just remember to switch out any \u201c.\u201d (Python) for a \u201c\\$\u201d (R) when chaining methods. For example, here are two equivalent lines of code for some hypothetical dataset. # Python df . group_by ( \"id\" ) . mean () # R df $ groupby ( \"id\" ) $ mean () Series and DataFrames In polars objects of class Series are analogous to R vectors. Objects of class DataFrame are analogous to R data frames. To convert R vectors and data frames to Polars Series and DataFrames , we load the library and use constructor functions with the pl$ prefix. This prefix is very important, as most of the polars functions are made available via pl$ : library ( polars ) ser = pl $ Series (( 1 : 5 ) * 5 ) ser #> polars Series: shape: (5,) #> Series: '' [f64] #> [ #> 5.0 #> 10.0 #> 15.0 #> 20.0 #> 25.0 #> ] dat = pl $ DataFrame ( mtcars ) dat #> polars DataFrame: shape: (32, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 4.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 6.0 \u2502 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Both Polars and R are column-orientated. So you can think of DataFrames (data.frames) as being made up of a collection of Series (vectors). In fact, you can create a new Polars DataFrame as a mix of Series and/or regular R vectors. pl $ DataFrame ( a = pl $ Series (( 1 : 5 ) * 5 ), b = pl $ Series ( letters [ 1 : 5 ]), c = pl $ Series ( c ( 1 , 2 , 3 , 4 , 5 )), d = c ( 15 , 14 , 13 , 12 , 11 ), c ( 5 , 4 , 3 , 2 , 1 ), 1 : 5 ) #> polars DataFrame: shape: (5, 6) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 d \u2506 new_column \u2506 new_column_1 \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 str \u2506 f64 \u2506 f64 \u2506 f64 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.0 \u2506 a \u2506 1.0 \u2506 15.0 \u2506 5.0 \u2506 1 \u2502 #> \u2502 10.0 \u2506 b \u2506 2.0 \u2506 14.0 \u2506 4.0 \u2506 2 \u2502 #> \u2502 15.0 \u2506 c \u2506 3.0 \u2506 13.0 \u2506 3.0 \u2506 3 \u2502 #> \u2502 20.0 \u2506 d \u2506 4.0 \u2506 12.0 \u2506 2.0 \u2506 4 \u2502 #> \u2502 25.0 \u2506 e \u2506 5.0 \u2506 11.0 \u2506 1.0 \u2506 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Series and DataFrame can be operated on using many standard R functions. For example: # Series length ( ser ) #> [1] 5 max ( ser ) #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> 25.0 #> ] # DataFrame names ( dat ) #> [1] \"mpg\" \"cyl\" \"disp\" \"hp\" \"drat\" \"wt\" \"qsec\" \"vs\" \"am\" \"gear\" \"carb\" dim ( dat ) #> [1] 32 11 head ( dat , n = 2 ) #> polars DataFrame: shape: (2, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Methods and pipelines Although some simple R functions work out of the box on polars objects, the full power of Polars is realized via methods . Polars methods are accessed using the $ syntax. For example, to convert Polars Series and DataFrames back to standard R objects, we use the $to_r_vector() and $as_data_frame() methods: ser $ to_r_vector () #> [1] 5 10 15 20 25 There are numerous methods designed to accomplish various tasks: ser $ max () #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> 25.0 #> ] dat $ slice ( offset = 2 , length = 3 ) #> polars DataFrame: shape: (3, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 18.7 \u2506 8.0 \u2506 360.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 0.0 \u2506 3.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 One advantage of using methods is that many more operations are possible on Polars objects using methods than through base R functions. A second advantage is Methods Chaining , a core part of the Polars workflow. If you are coming from one of the other popular data wrangling libraries in R, then you probably already have an innate sense of what this means. For instance, In dplyr we use a pipe operator, e.g. dat |> filter(...) |> select(...) In data.table we use its indexing syntax, e.g. DT[i, j, by][...] Etc. In polars our method chaining syntax takes the form object$m1()$m2() , where object is our data object, and m1() and m2() are appropriate methods , like subsetting or aggregation expressions. This might all seem a little abstract, so let\u2019s walk through some quick examples to help make things concrete. We use the mtcars dataset that we coerced to a DataFrame in introduction.[^1] We use the $max method to compute the maximum value in each column: dat $ max () #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 33.9 \u2506 8.0 \u2506 472.0 \u2506 335.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Now, we first use the $tail method to select the last 10 rows of the dataset, and then use the $max method to compute the maximums in those 10 rows: dat $ tail ( 10 ) $ max () #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 30.4 \u2506 8.0 \u2506 400.0 \u2506 335.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Finally, we convert the result to a standard R data frame: dat $ tail ( 10 ) $ max () $ as_data_frame () #> mpg cyl disp hp drat wt qsec vs am gear carb #> 1 30.4 8 400 335 4.43 3.845 18.9 1 1 5 8 Below, we will introduce several other methods, including $select , $filter , and $groupby which allow us to do powerful data manipulations easily. To give you a small taste, we now take group-wise means: dat $ groupby ( \"cyl\" ) $ mean () #> polars DataFrame: shape: (3, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cyl \u2506 mpg \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 4.0 \u2506 26.663636 \u2506 105.136364 \u2506 82.636364 \u2506 ... \u2506 0.909091 \u2506 0.727273 \u2506 4.090909 \u2506 1.545455 \u2502 #> \u2502 6.0 \u2506 19.742857 \u2506 183.314286 \u2506 122.285714 \u2506 ... \u2506 0.571429 \u2506 0.428571 \u2506 3.857143 \u2506 3.428571 \u2502 #> \u2502 8.0 \u2506 15.1 \u2506 353.1 \u2506 209.214286 \u2506 ... \u2506 0.0 \u2506 0.142857 \u2506 3.285714 \u2506 3.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 select columns and filter rows We can now start chaining together various methods (expressions) to manipulate it in different ways. For example, we can subset the data by rows ( filter() ) and also columns ( select() ): dat $ filter ( pl $ col ( \"cyl\" ) == 6 ) #> polars DataFrame: shape: (7, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 18.1 \u2506 6.0 \u2506 225.0 \u2506 105.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 19.2 \u2506 6.0 \u2506 167.6 \u2506 123.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 17.8 \u2506 6.0 \u2506 167.6 \u2506 123.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 6.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 dat $ filter ( pl $ col ( \"cyl\" ) == 6 & pl $ col ( \"am\" ) == 1 ) #> polars DataFrame: shape: (3, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 6.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 dat $ select ( pl $ col ( c ( \"mpg\" , \"hp\" ))) #> polars DataFrame: shape: (32, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 hp \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 110.0 \u2502 #> \u2502 21.0 \u2506 110.0 \u2502 #> \u2502 22.8 \u2506 93.0 \u2502 #> \u2502 21.4 \u2506 110.0 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 15.8 \u2506 264.0 \u2502 #> \u2502 19.7 \u2506 175.0 \u2502 #> \u2502 15.0 \u2506 335.0 \u2502 #> \u2502 21.4 \u2506 109.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Of course, we can chain those methods to create a pipeline: dat $ filter ( pl $ col ( \"cyl\" ) == 6 ) $ select ( pl $ col ( c ( \"mpg\" , \"hp\" , \"cyl\" )) ) #> polars DataFrame: shape: (7, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 hp \u2506 cyl \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 110.0 \u2506 6.0 \u2502 #> \u2502 21.0 \u2506 110.0 \u2506 6.0 \u2502 #> \u2502 21.4 \u2506 110.0 \u2506 6.0 \u2502 #> \u2502 18.1 \u2506 105.0 \u2506 6.0 \u2502 #> \u2502 19.2 \u2506 123.0 \u2506 6.0 \u2502 #> \u2502 17.8 \u2506 123.0 \u2506 6.0 \u2502 #> \u2502 19.7 \u2506 175.0 \u2506 6.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 Aggregations and modifications The select() method that we introduced above also supports data modification, so you can simultaneously transform it while you are subsetting. However, the result will exclude any columns that weren\u2019t specified as part of the expression. To modify or add some columns\u2014whilst preserving all others in the dataset\u2014it is therefore better to use the with_columns() method. This next code chunk is equivalent to mtcars |> dplyr::mutate(sum_mpg=sum(mpg), sum_hp=sum(hp), .by = cyl) . # Add the grouped sums of some selected columns. dat $ with_columns ( pl $ col ( \"mpg\" ) $ sum () $ over ( \"cyl\" ) $ alias ( \"sum_mpg\" ), pl $ col ( \"hp\" ) $ sum () $ over ( \"cyl\" ) $ alias ( \"sum_hp\" ) ) #> polars DataFrame: shape: (32, 13) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 gear \u2506 carb \u2506 sum_mpg \u2506 sum_hp \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 4.0 \u2506 4.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 4.0 \u2506 4.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 4.0 \u2506 1.0 \u2506 293.3 \u2506 909.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 3.0 \u2506 1.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 5.0 \u2506 4.0 \u2506 211.4 \u2506 2929.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 5.0 \u2506 6.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 5.0 \u2506 8.0 \u2506 211.4 \u2506 2929.0 \u2502 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 4.0 \u2506 2.0 \u2506 293.3 \u2506 909.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 For what it\u2019s worth, the previous query could have been written more concisely as: dat $ with_columns ( pl $ col ( c ( \"mpg\" , \"hp\" )) $ sum () $ over ( \"cyl\" ) $ prefix ( \"sum_\" ) ) #> polars DataFrame: shape: (32, 13) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 gear \u2506 carb \u2506 sum_mpg \u2506 sum_hp \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 4.0 \u2506 4.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 4.0 \u2506 4.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 4.0 \u2506 1.0 \u2506 293.3 \u2506 909.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 3.0 \u2506 1.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 5.0 \u2506 4.0 \u2506 211.4 \u2506 2929.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 5.0 \u2506 6.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 5.0 \u2506 8.0 \u2506 211.4 \u2506 2929.0 \u2502 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 4.0 \u2506 2.0 \u2506 293.3 \u2506 909.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Similarly, here\u2019s how we could have aggregated (i.e., collapsed) the dataset by groups instead of modifying them. We need simply invoke the groupby() and agg() methods. dat $ groupby ( \"cyl\" , maintain_order = TRUE ) $ agg ( pl $ col ( c ( \"mpg\" , \"hp\" )) $ sum () ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cyl \u2506 mpg \u2506 hp \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 4.0 \u2506 293.3 \u2506 909.0 \u2502 #> \u2502 8.0 \u2506 211.4 \u2506 2929.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (arg maintain_order = TRUE is optional, since polars doesn\u2019t sort the results of grouped operations by default. This is similar to what data.table does and is also true for newer versions of dplyr .) The same principles of method chaining can be combined very flexibly to group by multiple variables and aggregation types. dat $ groupby ( \"cyl\" , pl $ col ( \"am\" ) $ cast ( pl $ Boolean ) $ alias ( \"manual\" ) ) $ agg ( pl $ col ( \"mpg\" ) $ mean () $ alias ( \"mean_mpg\" ), pl $ col ( \"hp\" ) $ median () $ alias ( \"med_hp\" ) ) #> polars DataFrame: shape: (6, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cyl \u2506 manual \u2506 mean_mpg \u2506 med_hp \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 bool \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6.0 \u2506 false \u2506 19.125 \u2506 116.5 \u2502 #> \u2502 8.0 \u2506 false \u2506 15.05 \u2506 180.0 \u2502 #> \u2502 4.0 \u2506 false \u2506 22.9 \u2506 95.0 \u2502 #> \u2502 6.0 \u2506 true \u2506 20.566667 \u2506 110.0 \u2502 #> \u2502 4.0 \u2506 true \u2506 28.075 \u2506 78.5 \u2502 #> \u2502 8.0 \u2506 true \u2506 15.4 \u2506 299.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Note that we used the cast method to convert the data type of the am column. See the section below for more details on data types. Join As a final example of how polars can be used for standard data wrangling tasks, let\u2019s implement a (left) join. For this example, we\u2019ll borrow some datasets from the nycflights13 package. data ( \"flights\" , \"planes\" , package = \"nycflights13\" ) flights = pl $ DataFrame ( flights ) planes = pl $ DataFrame ( planes ) flights $ join ( planes , on = \"tailnum\" , how = \"left\" ) #> polars DataFrame: shape: (336776, 27) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 year \u2506 month \u2506 day \u2506 dep_time \u2506 ... \u2506 engines \u2506 seats \u2506 speed \u2506 engine \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 i32 \u2506 i32 \u2506 \u2506 i32 \u2506 i32 \u2506 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2013 \u2506 1 \u2506 1 \u2506 517 \u2506 ... \u2506 2 \u2506 149 \u2506 null \u2506 Turbo-fan \u2502 #> \u2502 2013 \u2506 1 \u2506 1 \u2506 533 \u2506 ... \u2506 2 \u2506 149 \u2506 null \u2506 Turbo-fan \u2502 #> \u2502 2013 \u2506 1 \u2506 1 \u2506 542 \u2506 ... \u2506 2 \u2506 178 \u2506 null \u2506 Turbo-fan \u2502 #> \u2502 2013 \u2506 1 \u2506 1 \u2506 544 \u2506 ... \u2506 2 \u2506 200 \u2506 null \u2506 Turbo-fan \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 2013 \u2506 9 \u2506 30 \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2502 2013 \u2506 9 \u2506 30 \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2502 2013 \u2506 9 \u2506 30 \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2502 2013 \u2506 9 \u2506 30 \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 More information on the polars joining method can be found in the reference manual . The package supports many other data manipulation operations, which we won\u2019t cover here. Hopefully, you will already have a sense of the key syntax features. We now turn to another core idea of the Polars ecosystem: lazy execution . Lazy execution While the \u201ceager\u201d execution engine of polars works perfectly well\u2014as evidenced by all of the previous examples\u2014to get the most out of the package you need to go lazy . Lazy execution enables several benefits, but the most important is that it improves performance. Delaying execution until the last possible moment allows Polars to apply automatic optimization to every query. Let\u2019s take a quick look. To create a so-called \u201c LazyFrame \u201d from an existing object in memory, we can invoke the lazy() constructor. ldat = dat $ lazy () ldat #> [1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\" #> DF [\"mpg\", \"cyl\", \"disp\", \"hp\"]; PROJECT */11 COLUMNS; SELECTION: \"None\" Now consider what happens when we run our subsetting query from earlier on this LazyFrame. subset_query = ldat $ filter ( pl $ col ( \"cyl\" ) == 6 ) $ select ( pl $ col ( c ( \"mpg\" , \"hp\" , \"cyl\" )) ) subset_query #> [1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\" #> SELECT [col(\"mpg\"), col(\"hp\"), col(\"cyl\")] FROM #> FILTER [(col(\"cyl\")) == (6f64)] FROM #> DF [\"mpg\", \"cyl\", \"disp\", \"hp\"]; PROJECT */11 COLUMNS; SELECTION: \"None\" Right now we only have a tree of instructions. But underneath the hood, Polars has already worked out a more optimized version of the query. We can view this optimized plan this by requesting it. subset_query $ describe_optimized_plan () #> FAST_PROJECT: [mpg, hp, cyl] #> DF [\"mpg\", \"cyl\", \"disp\", \"hp\"]; PROJECT 3/11 COLUMNS; SELECTION: \"[(col(\\\"cyl\\\")) == (6f64)]\" Here we see a simple, but surprisingly effective component in query optimization: projection . Changing the order in which our subsetting operations occurs\u2014in this case, subsetting on columns first\u2014reduces the memory overhead of the overall query and leads to a downstream speedup. Of course, you would hardly notice a difference for this small dataset. But the same principles carry over to much bigger datasets and more complex queries. To actually execute the plan, we just need to invoke the collect() method. This should feel very familiar if you have previously used other lazy execution engines like those provided by arrow or dbplyr . subset_query $ collect () #> polars DataFrame: shape: (7, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 hp \u2506 cyl \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 110.0 \u2506 6.0 \u2502 #> \u2502 21.0 \u2506 110.0 \u2506 6.0 \u2502 #> \u2502 21.4 \u2506 110.0 \u2506 6.0 \u2502 #> \u2502 18.1 \u2506 105.0 \u2506 6.0 \u2502 #> \u2502 19.2 \u2506 123.0 \u2506 6.0 \u2502 #> \u2502 17.8 \u2506 123.0 \u2506 6.0 \u2502 #> \u2502 19.7 \u2506 175.0 \u2506 6.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 Data import polars supports data import of both CSV and Parquet files formats. Here we demonstrate using the airquality dataset that also comes bundled with base R. write.csv ( airquality , \"airquality.csv\" ) pl $ read_csv ( \"airquality.csv\" ) #> polars DataFrame: shape: (153, 7) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2506 Ozone \u2506 Solar.R \u2506 Wind \u2506 Temp \u2506 Month \u2506 Day \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i64 \u2506 str \u2506 str \u2506 f64 \u2506 i64 \u2506 i64 \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 41 \u2506 190 \u2506 7.4 \u2506 67 \u2506 5 \u2506 1 \u2502 #> \u2502 2 \u2506 36 \u2506 118 \u2506 8.0 \u2506 72 \u2506 5 \u2506 2 \u2502 #> \u2502 3 \u2506 12 \u2506 149 \u2506 12.6 \u2506 74 \u2506 5 \u2506 3 \u2502 #> \u2502 4 \u2506 18 \u2506 313 \u2506 11.5 \u2506 62 \u2506 5 \u2506 4 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 150 \u2506 NA \u2506 145 \u2506 13.2 \u2506 77 \u2506 9 \u2506 27 \u2502 #> \u2502 151 \u2506 14 \u2506 191 \u2506 14.3 \u2506 75 \u2506 9 \u2506 28 \u2502 #> \u2502 152 \u2506 18 \u2506 131 \u2506 8.0 \u2506 76 \u2506 9 \u2506 29 \u2502 #> \u2502 153 \u2506 20 \u2506 223 \u2506 11.5 \u2506 68 \u2506 9 \u2506 30 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 Again, however, the package works best if we take the lazy approach. pl $ lazy_csv_reader ( \"airquality.csv\" ) #> [1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\" #> CSV SCAN airquality.csv #> PROJECT */7 COLUMNS We could obviously append a set of query operators to the above LazyFrame and then collect the results. However, this workflow is even better suited to Parquet files, since we can leverage their efficient storage format on disk. Let\u2019s see an example. library ( arrow ) write_parquet ( airquality , \"airquality.parquet\" ) # aq = read_parquet(\"airquality.parquet) # eager version (okay) aq = scan_parquet ( \"airquality.parquet\" ) # lazy version (better) aq $ filter ( pl $ col ( \"Month\" ) <= 6 ) $ groupby ( \"Month\" ) $ agg ( pl $ col ( c ( \"Ozone\" , \"Temp\" )) $ mean () ) $ collect () #> polars DataFrame: shape: (2, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Month \u2506 Ozone \u2506 Temp \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6 \u2506 29.444444 \u2506 79.1 \u2502 #> \u2502 5 \u2506 23.615385 \u2506 65.548387 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Finally, can read/scan multiple files in the same directory through pattern globbing. However, please note that partition-aware scanning is not yet supported out of the box (e.g., Hive-style partitioned datasets). Follow this issue for more details about when this will be resolved. dir.create ( \"airquality-ds\" ) write_dataset ( airquality , \"airquality-ds\" , partitioning = \"Month\" ) # Use pattern globbing to scan all parquet files in the folder aq2 = scan_parquet ( \"airquality-ds/*/*.parquet\" ) # Just print the first two rows. But note that the Month column # (which we used for partitioning) is missing. aq2 $ limit ( 2 ) $ collect () #> polars DataFrame: shape: (2, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Ozone \u2506 Solar.R \u2506 Wind \u2506 Temp \u2506 Day \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 f64 \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 41 \u2506 190 \u2506 7.4 \u2506 67 \u2506 1 \u2502 #> \u2502 36 \u2506 118 \u2506 8.0 \u2506 72 \u2506 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 Before continuing, don\u2019t forget to clean up by removing the newly created temp files and directory on disk. file.remove ( c ( \"airquality.csv\" , \"airquality.parquet\" )) #> [1] TRUE TRUE unlink ( \"airquality-ds\" , recursive = TRUE ) Execute R functions within a Polars query It is possible to mix R code with Polars by passing R functions to polars . This can unlock a lot of flexibility, but note that it can inhibit performance. R functions are typically slower, so we recommend using native Polars functions and expressions wherever possible. pl $ DataFrame ( iris ) $ select ( pl $ col ( \"Sepal.Length\" ) $ map ( \\ ( s ) { # map with a R function x = s $ to_r_vector () # convert from Polars Series to a native R vector x [ x >= 5 ] = 10 x [ 1 : 10 ] # if return is R vector, it will automatically be converted to Polars Series again }) ) $ as_data_frame () #> Sepal.Length #> 1 10.0 #> 2 4.9 #> 3 4.7 #> 4 4.6 #> 5 10.0 #> 6 10.0 #> 7 4.6 #> 8 10.0 #> 9 4.4 #> 10 4.9 Data types Polars is strongly typed and new types can be created with the dtypes constructor. For example: pl $ dtypes $ Float64 #> DataType: Float64 The full list of valid Polars types can be found by typing pl$dtypes into your R console. These include Boolean , Float32(64) , Int32(64) , Utf8 , Categorical , Date , etc. Note that some type names differ from what they are called in R (e.g., Boolean in Polars is equivalent to logical() in R). This might occasionally require you to look up a specific type. But the good news is that polars generally does a good job of inferring types automatically. [^1]: Similar to how (most) data.table operations are limited to objects of class data.table , we can only perform polars operations on objects that have been converted to an appropriate polars class. Later on, we\u2019ll see how to read data from disk directly in Polars format.","title":"An Introduction to Polars from R"},{"location":"articles/polars/#an-introduction-to-polars-from-r","text":"","title":"An Introduction to Polars from R"},{"location":"articles/polars/#what-is-polars","text":"Polars is a lightning fast Data Frame library. Its embarrassingly parallel execution, cache efficient algorithms and expressive API makes it perfect for efficient data wrangling, data pipelines, snappy APIs and so much more. Polars also supports \u201cstreaming mode\u201d for out-of-memory operations. This allows users to analyze datasets many times larger than RAM. The underlying computation engine is written in Rust and is built on the Apache Arrow columnar memory format. It can be used in Rust or via Python bindings. The polars R-package provides equivalent bindings from R. Within R, python and rust each polars package is just called polars. The implemention polars in the different languages can be called rust-polars, py-polars, r-polars, nodejs-polars\u2026 polars users can expect orders of magnitude(s) improvement compared to dplyr for simple transformations on datasets >500Mb. The automatic Polars optimization framework means that that this speed boost can be even greater for complex queries that chain together many operations. Performance is similar to that of data.table , although polars supports additional functionality via its relationship to the Apache Arrow memory model. For example, it can scan multiple Parquet files and datasets and selectively import random subsets without having to read all of the data. Polars syntax is similar to that of Spark, but the workflow is column-oriented rather than row-oriented. Since R is itself a column-oriented language, this should immediately feel familiar to most R users. Like Spark and modern SQL variants, Polars optimizes queries for memory consumption and speed, so you don\u2019t have to. However, unlike Spark, Polars is natively multithreaded instead of multinoded. This makes (r)polars much simpler to install and can be used as one would any other R package. This R port relies on the excellent extendr package, which is the R equivalent to pyo3+maturin. extendr is very convenient for calling Rust from R, and vice versa, and is what we use to build the polars package. Once built, however, polars has no other dependencies other than R itself. This makes it very fast and lightweight to install, and so polars can immediately be used to tackle your big (or small!) data wrangling tasks.","title":"What is Polars?"},{"location":"articles/polars/#documentation-and-tutorials","text":"Users can find detailed documentation for all objects, functions, and methods on the Reference page of this website. This documentation can also be accessed from the R console using the typical ? syntax. For example, we will later use the DataFrame() constructor function and apply the groupby() method to a DataFrame object. The documentation for these can be accessed by typing these commands: ? DataFrame ? DataFrame_groupby The Polars book offers a great introduction to the Polars data frame library, with a very large number of examples in Python and Rust. The syntax and expressions in the polars package for R are (deliberately) as close to the Python implementation as possible, so you can always refer to the polars book for more ideas. Just remember to switch out any \u201c.\u201d (Python) for a \u201c\\$\u201d (R) when chaining methods. For example, here are two equivalent lines of code for some hypothetical dataset. # Python df . group_by ( \"id\" ) . mean () # R df $ groupby ( \"id\" ) $ mean ()","title":"Documentation and tutorials"},{"location":"articles/polars/#series-and-dataframes","text":"In polars objects of class Series are analogous to R vectors. Objects of class DataFrame are analogous to R data frames. To convert R vectors and data frames to Polars Series and DataFrames , we load the library and use constructor functions with the pl$ prefix. This prefix is very important, as most of the polars functions are made available via pl$ : library ( polars ) ser = pl $ Series (( 1 : 5 ) * 5 ) ser #> polars Series: shape: (5,) #> Series: '' [f64] #> [ #> 5.0 #> 10.0 #> 15.0 #> 20.0 #> 25.0 #> ] dat = pl $ DataFrame ( mtcars ) dat #> polars DataFrame: shape: (32, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 4.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 6.0 \u2502 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Both Polars and R are column-orientated. So you can think of DataFrames (data.frames) as being made up of a collection of Series (vectors). In fact, you can create a new Polars DataFrame as a mix of Series and/or regular R vectors. pl $ DataFrame ( a = pl $ Series (( 1 : 5 ) * 5 ), b = pl $ Series ( letters [ 1 : 5 ]), c = pl $ Series ( c ( 1 , 2 , 3 , 4 , 5 )), d = c ( 15 , 14 , 13 , 12 , 11 ), c ( 5 , 4 , 3 , 2 , 1 ), 1 : 5 ) #> polars DataFrame: shape: (5, 6) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 d \u2506 new_column \u2506 new_column_1 \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 str \u2506 f64 \u2506 f64 \u2506 f64 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.0 \u2506 a \u2506 1.0 \u2506 15.0 \u2506 5.0 \u2506 1 \u2502 #> \u2502 10.0 \u2506 b \u2506 2.0 \u2506 14.0 \u2506 4.0 \u2506 2 \u2502 #> \u2502 15.0 \u2506 c \u2506 3.0 \u2506 13.0 \u2506 3.0 \u2506 3 \u2502 #> \u2502 20.0 \u2506 d \u2506 4.0 \u2506 12.0 \u2506 2.0 \u2506 4 \u2502 #> \u2502 25.0 \u2506 e \u2506 5.0 \u2506 11.0 \u2506 1.0 \u2506 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Series and DataFrame can be operated on using many standard R functions. For example: # Series length ( ser ) #> [1] 5 max ( ser ) #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> 25.0 #> ] # DataFrame names ( dat ) #> [1] \"mpg\" \"cyl\" \"disp\" \"hp\" \"drat\" \"wt\" \"qsec\" \"vs\" \"am\" \"gear\" \"carb\" dim ( dat ) #> [1] 32 11 head ( dat , n = 2 ) #> polars DataFrame: shape: (2, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Series and DataFrames"},{"location":"articles/polars/#methods-and-pipelines","text":"Although some simple R functions work out of the box on polars objects, the full power of Polars is realized via methods . Polars methods are accessed using the $ syntax. For example, to convert Polars Series and DataFrames back to standard R objects, we use the $to_r_vector() and $as_data_frame() methods: ser $ to_r_vector () #> [1] 5 10 15 20 25 There are numerous methods designed to accomplish various tasks: ser $ max () #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> 25.0 #> ] dat $ slice ( offset = 2 , length = 3 ) #> polars DataFrame: shape: (3, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 18.7 \u2506 8.0 \u2506 360.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 0.0 \u2506 3.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 One advantage of using methods is that many more operations are possible on Polars objects using methods than through base R functions. A second advantage is Methods Chaining , a core part of the Polars workflow. If you are coming from one of the other popular data wrangling libraries in R, then you probably already have an innate sense of what this means. For instance, In dplyr we use a pipe operator, e.g. dat |> filter(...) |> select(...) In data.table we use its indexing syntax, e.g. DT[i, j, by][...] Etc. In polars our method chaining syntax takes the form object$m1()$m2() , where object is our data object, and m1() and m2() are appropriate methods , like subsetting or aggregation expressions. This might all seem a little abstract, so let\u2019s walk through some quick examples to help make things concrete. We use the mtcars dataset that we coerced to a DataFrame in introduction.[^1] We use the $max method to compute the maximum value in each column: dat $ max () #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 33.9 \u2506 8.0 \u2506 472.0 \u2506 335.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Now, we first use the $tail method to select the last 10 rows of the dataset, and then use the $max method to compute the maximums in those 10 rows: dat $ tail ( 10 ) $ max () #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 30.4 \u2506 8.0 \u2506 400.0 \u2506 335.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Finally, we convert the result to a standard R data frame: dat $ tail ( 10 ) $ max () $ as_data_frame () #> mpg cyl disp hp drat wt qsec vs am gear carb #> 1 30.4 8 400 335 4.43 3.845 18.9 1 1 5 8 Below, we will introduce several other methods, including $select , $filter , and $groupby which allow us to do powerful data manipulations easily. To give you a small taste, we now take group-wise means: dat $ groupby ( \"cyl\" ) $ mean () #> polars DataFrame: shape: (3, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cyl \u2506 mpg \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 4.0 \u2506 26.663636 \u2506 105.136364 \u2506 82.636364 \u2506 ... \u2506 0.909091 \u2506 0.727273 \u2506 4.090909 \u2506 1.545455 \u2502 #> \u2502 6.0 \u2506 19.742857 \u2506 183.314286 \u2506 122.285714 \u2506 ... \u2506 0.571429 \u2506 0.428571 \u2506 3.857143 \u2506 3.428571 \u2502 #> \u2502 8.0 \u2506 15.1 \u2506 353.1 \u2506 209.214286 \u2506 ... \u2506 0.0 \u2506 0.142857 \u2506 3.285714 \u2506 3.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Methods and pipelines"},{"location":"articles/polars/#select-columns-and-filter-rows","text":"We can now start chaining together various methods (expressions) to manipulate it in different ways. For example, we can subset the data by rows ( filter() ) and also columns ( select() ): dat $ filter ( pl $ col ( \"cyl\" ) == 6 ) #> polars DataFrame: shape: (7, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 18.1 \u2506 6.0 \u2506 225.0 \u2506 105.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 19.2 \u2506 6.0 \u2506 167.6 \u2506 123.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 17.8 \u2506 6.0 \u2506 167.6 \u2506 123.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 6.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 dat $ filter ( pl $ col ( \"cyl\" ) == 6 & pl $ col ( \"am\" ) == 1 ) #> polars DataFrame: shape: (3, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 6.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 dat $ select ( pl $ col ( c ( \"mpg\" , \"hp\" ))) #> polars DataFrame: shape: (32, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 hp \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 110.0 \u2502 #> \u2502 21.0 \u2506 110.0 \u2502 #> \u2502 22.8 \u2506 93.0 \u2502 #> \u2502 21.4 \u2506 110.0 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 15.8 \u2506 264.0 \u2502 #> \u2502 19.7 \u2506 175.0 \u2502 #> \u2502 15.0 \u2506 335.0 \u2502 #> \u2502 21.4 \u2506 109.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Of course, we can chain those methods to create a pipeline: dat $ filter ( pl $ col ( \"cyl\" ) == 6 ) $ select ( pl $ col ( c ( \"mpg\" , \"hp\" , \"cyl\" )) ) #> polars DataFrame: shape: (7, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 hp \u2506 cyl \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 110.0 \u2506 6.0 \u2502 #> \u2502 21.0 \u2506 110.0 \u2506 6.0 \u2502 #> \u2502 21.4 \u2506 110.0 \u2506 6.0 \u2502 #> \u2502 18.1 \u2506 105.0 \u2506 6.0 \u2502 #> \u2502 19.2 \u2506 123.0 \u2506 6.0 \u2502 #> \u2502 17.8 \u2506 123.0 \u2506 6.0 \u2502 #> \u2502 19.7 \u2506 175.0 \u2506 6.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518","title":"select columns and filter rows"},{"location":"articles/polars/#aggregations-and-modifications","text":"The select() method that we introduced above also supports data modification, so you can simultaneously transform it while you are subsetting. However, the result will exclude any columns that weren\u2019t specified as part of the expression. To modify or add some columns\u2014whilst preserving all others in the dataset\u2014it is therefore better to use the with_columns() method. This next code chunk is equivalent to mtcars |> dplyr::mutate(sum_mpg=sum(mpg), sum_hp=sum(hp), .by = cyl) . # Add the grouped sums of some selected columns. dat $ with_columns ( pl $ col ( \"mpg\" ) $ sum () $ over ( \"cyl\" ) $ alias ( \"sum_mpg\" ), pl $ col ( \"hp\" ) $ sum () $ over ( \"cyl\" ) $ alias ( \"sum_hp\" ) ) #> polars DataFrame: shape: (32, 13) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 gear \u2506 carb \u2506 sum_mpg \u2506 sum_hp \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 4.0 \u2506 4.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 4.0 \u2506 4.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 4.0 \u2506 1.0 \u2506 293.3 \u2506 909.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 3.0 \u2506 1.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 5.0 \u2506 4.0 \u2506 211.4 \u2506 2929.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 5.0 \u2506 6.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 5.0 \u2506 8.0 \u2506 211.4 \u2506 2929.0 \u2502 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 4.0 \u2506 2.0 \u2506 293.3 \u2506 909.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 For what it\u2019s worth, the previous query could have been written more concisely as: dat $ with_columns ( pl $ col ( c ( \"mpg\" , \"hp\" )) $ sum () $ over ( \"cyl\" ) $ prefix ( \"sum_\" ) ) #> polars DataFrame: shape: (32, 13) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 gear \u2506 carb \u2506 sum_mpg \u2506 sum_hp \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 4.0 \u2506 4.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 4.0 \u2506 4.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 4.0 \u2506 1.0 \u2506 293.3 \u2506 909.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 3.0 \u2506 1.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 5.0 \u2506 4.0 \u2506 211.4 \u2506 2929.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 5.0 \u2506 6.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 5.0 \u2506 8.0 \u2506 211.4 \u2506 2929.0 \u2502 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 4.0 \u2506 2.0 \u2506 293.3 \u2506 909.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Similarly, here\u2019s how we could have aggregated (i.e., collapsed) the dataset by groups instead of modifying them. We need simply invoke the groupby() and agg() methods. dat $ groupby ( \"cyl\" , maintain_order = TRUE ) $ agg ( pl $ col ( c ( \"mpg\" , \"hp\" )) $ sum () ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cyl \u2506 mpg \u2506 hp \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6.0 \u2506 138.2 \u2506 856.0 \u2502 #> \u2502 4.0 \u2506 293.3 \u2506 909.0 \u2502 #> \u2502 8.0 \u2506 211.4 \u2506 2929.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (arg maintain_order = TRUE is optional, since polars doesn\u2019t sort the results of grouped operations by default. This is similar to what data.table does and is also true for newer versions of dplyr .) The same principles of method chaining can be combined very flexibly to group by multiple variables and aggregation types. dat $ groupby ( \"cyl\" , pl $ col ( \"am\" ) $ cast ( pl $ Boolean ) $ alias ( \"manual\" ) ) $ agg ( pl $ col ( \"mpg\" ) $ mean () $ alias ( \"mean_mpg\" ), pl $ col ( \"hp\" ) $ median () $ alias ( \"med_hp\" ) ) #> polars DataFrame: shape: (6, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cyl \u2506 manual \u2506 mean_mpg \u2506 med_hp \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 bool \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6.0 \u2506 false \u2506 19.125 \u2506 116.5 \u2502 #> \u2502 8.0 \u2506 false \u2506 15.05 \u2506 180.0 \u2502 #> \u2502 4.0 \u2506 false \u2506 22.9 \u2506 95.0 \u2502 #> \u2502 6.0 \u2506 true \u2506 20.566667 \u2506 110.0 \u2502 #> \u2502 4.0 \u2506 true \u2506 28.075 \u2506 78.5 \u2502 #> \u2502 8.0 \u2506 true \u2506 15.4 \u2506 299.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Note that we used the cast method to convert the data type of the am column. See the section below for more details on data types.","title":"Aggregations and modifications"},{"location":"articles/polars/#join","text":"As a final example of how polars can be used for standard data wrangling tasks, let\u2019s implement a (left) join. For this example, we\u2019ll borrow some datasets from the nycflights13 package. data ( \"flights\" , \"planes\" , package = \"nycflights13\" ) flights = pl $ DataFrame ( flights ) planes = pl $ DataFrame ( planes ) flights $ join ( planes , on = \"tailnum\" , how = \"left\" ) #> polars DataFrame: shape: (336776, 27) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 year \u2506 month \u2506 day \u2506 dep_time \u2506 ... \u2506 engines \u2506 seats \u2506 speed \u2506 engine \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 i32 \u2506 i32 \u2506 \u2506 i32 \u2506 i32 \u2506 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2013 \u2506 1 \u2506 1 \u2506 517 \u2506 ... \u2506 2 \u2506 149 \u2506 null \u2506 Turbo-fan \u2502 #> \u2502 2013 \u2506 1 \u2506 1 \u2506 533 \u2506 ... \u2506 2 \u2506 149 \u2506 null \u2506 Turbo-fan \u2502 #> \u2502 2013 \u2506 1 \u2506 1 \u2506 542 \u2506 ... \u2506 2 \u2506 178 \u2506 null \u2506 Turbo-fan \u2502 #> \u2502 2013 \u2506 1 \u2506 1 \u2506 544 \u2506 ... \u2506 2 \u2506 200 \u2506 null \u2506 Turbo-fan \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 2013 \u2506 9 \u2506 30 \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2502 2013 \u2506 9 \u2506 30 \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2502 2013 \u2506 9 \u2506 30 \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2502 2013 \u2506 9 \u2506 30 \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 More information on the polars joining method can be found in the reference manual . The package supports many other data manipulation operations, which we won\u2019t cover here. Hopefully, you will already have a sense of the key syntax features. We now turn to another core idea of the Polars ecosystem: lazy execution .","title":"Join"},{"location":"articles/polars/#lazy-execution","text":"While the \u201ceager\u201d execution engine of polars works perfectly well\u2014as evidenced by all of the previous examples\u2014to get the most out of the package you need to go lazy . Lazy execution enables several benefits, but the most important is that it improves performance. Delaying execution until the last possible moment allows Polars to apply automatic optimization to every query. Let\u2019s take a quick look. To create a so-called \u201c LazyFrame \u201d from an existing object in memory, we can invoke the lazy() constructor. ldat = dat $ lazy () ldat #> [1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\" #> DF [\"mpg\", \"cyl\", \"disp\", \"hp\"]; PROJECT */11 COLUMNS; SELECTION: \"None\" Now consider what happens when we run our subsetting query from earlier on this LazyFrame. subset_query = ldat $ filter ( pl $ col ( \"cyl\" ) == 6 ) $ select ( pl $ col ( c ( \"mpg\" , \"hp\" , \"cyl\" )) ) subset_query #> [1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\" #> SELECT [col(\"mpg\"), col(\"hp\"), col(\"cyl\")] FROM #> FILTER [(col(\"cyl\")) == (6f64)] FROM #> DF [\"mpg\", \"cyl\", \"disp\", \"hp\"]; PROJECT */11 COLUMNS; SELECTION: \"None\" Right now we only have a tree of instructions. But underneath the hood, Polars has already worked out a more optimized version of the query. We can view this optimized plan this by requesting it. subset_query $ describe_optimized_plan () #> FAST_PROJECT: [mpg, hp, cyl] #> DF [\"mpg\", \"cyl\", \"disp\", \"hp\"]; PROJECT 3/11 COLUMNS; SELECTION: \"[(col(\\\"cyl\\\")) == (6f64)]\" Here we see a simple, but surprisingly effective component in query optimization: projection . Changing the order in which our subsetting operations occurs\u2014in this case, subsetting on columns first\u2014reduces the memory overhead of the overall query and leads to a downstream speedup. Of course, you would hardly notice a difference for this small dataset. But the same principles carry over to much bigger datasets and more complex queries. To actually execute the plan, we just need to invoke the collect() method. This should feel very familiar if you have previously used other lazy execution engines like those provided by arrow or dbplyr . subset_query $ collect () #> polars DataFrame: shape: (7, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 hp \u2506 cyl \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 110.0 \u2506 6.0 \u2502 #> \u2502 21.0 \u2506 110.0 \u2506 6.0 \u2502 #> \u2502 21.4 \u2506 110.0 \u2506 6.0 \u2502 #> \u2502 18.1 \u2506 105.0 \u2506 6.0 \u2502 #> \u2502 19.2 \u2506 123.0 \u2506 6.0 \u2502 #> \u2502 17.8 \u2506 123.0 \u2506 6.0 \u2502 #> \u2502 19.7 \u2506 175.0 \u2506 6.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518","title":"Lazy execution"},{"location":"articles/polars/#data-import","text":"polars supports data import of both CSV and Parquet files formats. Here we demonstrate using the airquality dataset that also comes bundled with base R. write.csv ( airquality , \"airquality.csv\" ) pl $ read_csv ( \"airquality.csv\" ) #> polars DataFrame: shape: (153, 7) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2506 Ozone \u2506 Solar.R \u2506 Wind \u2506 Temp \u2506 Month \u2506 Day \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i64 \u2506 str \u2506 str \u2506 f64 \u2506 i64 \u2506 i64 \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 41 \u2506 190 \u2506 7.4 \u2506 67 \u2506 5 \u2506 1 \u2502 #> \u2502 2 \u2506 36 \u2506 118 \u2506 8.0 \u2506 72 \u2506 5 \u2506 2 \u2502 #> \u2502 3 \u2506 12 \u2506 149 \u2506 12.6 \u2506 74 \u2506 5 \u2506 3 \u2502 #> \u2502 4 \u2506 18 \u2506 313 \u2506 11.5 \u2506 62 \u2506 5 \u2506 4 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 150 \u2506 NA \u2506 145 \u2506 13.2 \u2506 77 \u2506 9 \u2506 27 \u2502 #> \u2502 151 \u2506 14 \u2506 191 \u2506 14.3 \u2506 75 \u2506 9 \u2506 28 \u2502 #> \u2502 152 \u2506 18 \u2506 131 \u2506 8.0 \u2506 76 \u2506 9 \u2506 29 \u2502 #> \u2502 153 \u2506 20 \u2506 223 \u2506 11.5 \u2506 68 \u2506 9 \u2506 30 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 Again, however, the package works best if we take the lazy approach. pl $ lazy_csv_reader ( \"airquality.csv\" ) #> [1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\" #> CSV SCAN airquality.csv #> PROJECT */7 COLUMNS We could obviously append a set of query operators to the above LazyFrame and then collect the results. However, this workflow is even better suited to Parquet files, since we can leverage their efficient storage format on disk. Let\u2019s see an example. library ( arrow ) write_parquet ( airquality , \"airquality.parquet\" ) # aq = read_parquet(\"airquality.parquet) # eager version (okay) aq = scan_parquet ( \"airquality.parquet\" ) # lazy version (better) aq $ filter ( pl $ col ( \"Month\" ) <= 6 ) $ groupby ( \"Month\" ) $ agg ( pl $ col ( c ( \"Ozone\" , \"Temp\" )) $ mean () ) $ collect () #> polars DataFrame: shape: (2, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Month \u2506 Ozone \u2506 Temp \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6 \u2506 29.444444 \u2506 79.1 \u2502 #> \u2502 5 \u2506 23.615385 \u2506 65.548387 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Finally, can read/scan multiple files in the same directory through pattern globbing. However, please note that partition-aware scanning is not yet supported out of the box (e.g., Hive-style partitioned datasets). Follow this issue for more details about when this will be resolved. dir.create ( \"airquality-ds\" ) write_dataset ( airquality , \"airquality-ds\" , partitioning = \"Month\" ) # Use pattern globbing to scan all parquet files in the folder aq2 = scan_parquet ( \"airquality-ds/*/*.parquet\" ) # Just print the first two rows. But note that the Month column # (which we used for partitioning) is missing. aq2 $ limit ( 2 ) $ collect () #> polars DataFrame: shape: (2, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Ozone \u2506 Solar.R \u2506 Wind \u2506 Temp \u2506 Day \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 f64 \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 41 \u2506 190 \u2506 7.4 \u2506 67 \u2506 1 \u2502 #> \u2502 36 \u2506 118 \u2506 8.0 \u2506 72 \u2506 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 Before continuing, don\u2019t forget to clean up by removing the newly created temp files and directory on disk. file.remove ( c ( \"airquality.csv\" , \"airquality.parquet\" )) #> [1] TRUE TRUE unlink ( \"airquality-ds\" , recursive = TRUE )","title":"Data import"},{"location":"articles/polars/#execute-r-functions-within-a-polars-query","text":"It is possible to mix R code with Polars by passing R functions to polars . This can unlock a lot of flexibility, but note that it can inhibit performance. R functions are typically slower, so we recommend using native Polars functions and expressions wherever possible. pl $ DataFrame ( iris ) $ select ( pl $ col ( \"Sepal.Length\" ) $ map ( \\ ( s ) { # map with a R function x = s $ to_r_vector () # convert from Polars Series to a native R vector x [ x >= 5 ] = 10 x [ 1 : 10 ] # if return is R vector, it will automatically be converted to Polars Series again }) ) $ as_data_frame () #> Sepal.Length #> 1 10.0 #> 2 4.9 #> 3 4.7 #> 4 4.6 #> 5 10.0 #> 6 10.0 #> 7 4.6 #> 8 10.0 #> 9 4.4 #> 10 4.9","title":"Execute R functions within a Polars query"},{"location":"articles/polars/#data-types","text":"Polars is strongly typed and new types can be created with the dtypes constructor. For example: pl $ dtypes $ Float64 #> DataType: Float64 The full list of valid Polars types can be found by typing pl$dtypes into your R console. These include Boolean , Float32(64) , Int32(64) , Utf8 , Categorical , Date , etc. Note that some type names differ from what they are called in R (e.g., Boolean in Polars is equivalent to logical() in R). This might occasionally require you to look up a specific type. But the good news is that polars generally does a good job of inferring types automatically. [^1]: Similar to how (most) data.table operations are limited to objects of class data.table , we can only perform polars operations on objects that have been converted to an appropriate polars class. Later on, we\u2019ll see how to read data from disk directly in Polars format.","title":"Data types"},{"location":"reference/DataFrame/","text":"Create new DataFrame Arguments ... : * one data.frame or something that inherits data.frame or DataFrame one list of mixed vectors and Series of equal length mixed vectors and/or Series of equal length Columns will be named as of named arguments or alternatively by names of Series or given a placeholder name. - make_names_unique : default TRUE, any duplicated names will be prefixed a running number - parallel : bool default FALSE, experimental multithreaded interpretation of R vectors into a polars DataFrame. This is experimental as multiple threads read from R mem simultaneously. So far no issues parallel read from R has been found. Returns DataFrame Create new DataFrame Examples pl $ DataFrame ( a = list ( c ( 1 , 2 , 3 , 4 , 5 ) ) , #NB if first column should be a list, wrap it in a Series b = 1 : 5 , c = letters [ 1 : 5 ] , d = list ( 1 : 1 , 1 : 2 , 1 : 3 , 1 : 4 , 1 : 5 ) ) #directly from vectors #> polars DataFrame: shape: (5, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 d \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 list[f64] \u2506 i32 \u2506 str \u2506 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [1.0, 2.0, ... 5.0] \u2506 1 \u2506 a \u2506 [1] \u2502 #> \u2502 [1.0, 2.0, ... 5.0] \u2506 2 \u2506 b \u2506 [1, 2] \u2502 #> \u2502 [1.0, 2.0, ... 5.0] \u2506 3 \u2506 c \u2506 [1, 2, 3] \u2502 #> \u2502 [1.0, 2.0, ... 5.0] \u2506 4 \u2506 d \u2506 [1, 2, ... 4] \u2502 #> \u2502 [1.0, 2.0, ... 5.0] \u2506 5 \u2506 e \u2506 [1, 2, ... 5] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #from a list of vectors or data.frame pl $ DataFrame ( list ( a = c ( 1 , 2 , 3 , 4 , 5 ) , b = 1 : 5 , c = letters [ 1 : 5 ] , d = list ( 1L , 1 : 2 , 1 : 3 , 1 : 4 , 1 : 5 ) ) ) #> polars DataFrame: shape: (5, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 d \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 i32 \u2506 str \u2506 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 1 \u2506 a \u2506 [1] \u2502 #> \u2502 2.0 \u2506 2 \u2506 b \u2506 [1, 2] \u2502 #> \u2502 3.0 \u2506 3 \u2506 c \u2506 [1, 2, 3] \u2502 #> \u2502 4.0 \u2506 4 \u2506 d \u2506 [1, 2, ... 4] \u2502 #> \u2502 5.0 \u2506 5 \u2506 e \u2506 [1, 2, ... 5] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"DataFrame"},{"location":"reference/DataFrame/#create-new-dataframe","text":"","title":"Create new DataFrame"},{"location":"reference/DataFrame/#arguments","text":"... : * one data.frame or something that inherits data.frame or DataFrame one list of mixed vectors and Series of equal length mixed vectors and/or Series of equal length Columns will be named as of named arguments or alternatively by names of Series or given a placeholder name. - make_names_unique : default TRUE, any duplicated names will be prefixed a running number - parallel : bool default FALSE, experimental multithreaded interpretation of R vectors into a polars DataFrame. This is experimental as multiple threads read from R mem simultaneously. So far no issues parallel read from R has been found.","title":"Arguments"},{"location":"reference/DataFrame/#returns","text":"DataFrame Create new DataFrame","title":"Returns"},{"location":"reference/DataFrame/#examples","text":"pl $ DataFrame ( a = list ( c ( 1 , 2 , 3 , 4 , 5 ) ) , #NB if first column should be a list, wrap it in a Series b = 1 : 5 , c = letters [ 1 : 5 ] , d = list ( 1 : 1 , 1 : 2 , 1 : 3 , 1 : 4 , 1 : 5 ) ) #directly from vectors #> polars DataFrame: shape: (5, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 d \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 list[f64] \u2506 i32 \u2506 str \u2506 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [1.0, 2.0, ... 5.0] \u2506 1 \u2506 a \u2506 [1] \u2502 #> \u2502 [1.0, 2.0, ... 5.0] \u2506 2 \u2506 b \u2506 [1, 2] \u2502 #> \u2502 [1.0, 2.0, ... 5.0] \u2506 3 \u2506 c \u2506 [1, 2, 3] \u2502 #> \u2502 [1.0, 2.0, ... 5.0] \u2506 4 \u2506 d \u2506 [1, 2, ... 4] \u2502 #> \u2502 [1.0, 2.0, ... 5.0] \u2506 5 \u2506 e \u2506 [1, 2, ... 5] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #from a list of vectors or data.frame pl $ DataFrame ( list ( a = c ( 1 , 2 , 3 , 4 , 5 ) , b = 1 : 5 , c = letters [ 1 : 5 ] , d = list ( 1L , 1 : 2 , 1 : 3 , 1 : 4 , 1 : 5 ) ) ) #> polars DataFrame: shape: (5, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 d \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 i32 \u2506 str \u2506 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 1 \u2506 a \u2506 [1] \u2502 #> \u2502 2.0 \u2506 2 \u2506 b \u2506 [1, 2] \u2502 #> \u2502 3.0 \u2506 3 \u2506 c \u2506 [1, 2, 3] \u2502 #> \u2502 4.0 \u2506 4 \u2506 d \u2506 [1, 2, ... 4] \u2502 #> \u2502 5.0 \u2506 5 \u2506 e \u2506 [1, 2, ... 5] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_as_data_frame/","text":"return polars DataFrame as R data.frame < DataFrame >$ as_data_frame () # S3 method as.data.frame.DataFrame () Arguments ... : any params passed to as.data.frame x : DataFrame Returns data.frame data.frame return polars DataFrame as R data.frame Examples df = pl $ DataFrame ( iris [ 1 : 3 , ] ) df $ as_data_frame ( ) #> Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 1 5.1 3.5 1.4 0.2 setosa #> 2 4.9 3.0 1.4 0.2 setosa #> 3 4.7 3.2 1.3 0.2 setosa","title":"as_data_frame"},{"location":"reference/DataFrame_as_data_frame/#return-polars-dataframe-as-r-dataframe","text":"< DataFrame >$ as_data_frame () # S3 method as.data.frame.DataFrame ()","title":"return polars DataFrame as R data.frame"},{"location":"reference/DataFrame_as_data_frame/#arguments","text":"... : any params passed to as.data.frame x : DataFrame","title":"Arguments"},{"location":"reference/DataFrame_as_data_frame/#returns","text":"data.frame data.frame return polars DataFrame as R data.frame","title":"Returns"},{"location":"reference/DataFrame_as_data_frame/#examples","text":"df = pl $ DataFrame ( iris [ 1 : 3 , ] ) df $ as_data_frame ( ) #> Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 1 5.1 3.5 1.4 0.2 setosa #> 2 4.9 3.0 1.4 0.2 setosa #> 3 4.7 3.2 1.3 0.2 setosa","title":"Examples"},{"location":"reference/DataFrame_class/","text":"Inner workings of the DataFrame-class The DataFrame -class is simply two environments of respectively the public and private methods/function calls to the polars rust side. The instanciated DataFrame -object is an externalptr to a lowlevel rust polars DataFrame object. The pointer address is the only statefullness of the DataFrame object on the R side. Any other state resides on the rust side. The S3 method .DollarNames.DataFrame exposes all public $foobar() -methods which are callable onto the object. Most methods return another DataFrame -class instance or similar which allows for method chaining. This class system in lack of a better name could be called \"environment classes\" and is the same class system extendr provides, except here there is both a public and private set of methods. For implementation reasons, the private methods are external and must be called from polars:::.pr.$DataFrame$methodname(), also all private methods must take any self as an argument, thus they are pure functions. Having the private methods as pure functions solved/simplified self-referential complications. Details Check out the source code in R/dataframe_frame.R how public methods are derived from private methods. Check out extendr-wrappers.R to see the extendr-auto-generated methods. These are moved to .pr and converted into pure external functions in after-wrappers.R. In zzz.R (named zzz to be last file sourced) the extendr-methods are removed and replaced by any function prefixed DataFrame_ . Examples #see all exported methods ls ( polars ::: DataFrame ) #> [1] \"as_data_frame\" \"clone\" \"columns\" \"dtypes\" \"estimated_size\" \"filter\" #> [7] \"first\" \"get_column\" \"get_columns\" \"groupby\" \"height\" \"join\" #> [13] \"last\" \"lazy\" \"limit\" \"max\" \"mean\" \"median\" #> [19] \"min\" \"null_count\" \"print\" \"reverse\" \"schema\" \"select\" #> [25] \"shape\" \"slice\" \"std\" \"sum\" \"tail\" \"to_list\" #> [31] \"to_series\" \"to_struct\" \"unnest\" \"var\" \"width\" \"with_column\" #> [37] \"with_columns\" #see all private methods (not intended for regular use) ls ( polars ::: .pr $ DataFrame ) #> [1] \"by_agg\" \"clone_see_me_macro\" \"columns\" \"dtypes\" #> [5] \"estimated_size\" \"export_stream\" \"from_arrow_record_batches\" \"get_column\" #> [9] \"get_columns\" \"lazy\" \"new\" \"new_par_from_list\" #> [13] \"new_with_capacity\" \"null_count\" \"print\" \"schema\" #> [17] \"select\" \"select_at_idx\" \"set_column_from_robj\" \"set_column_from_series\" #> [21] \"set_column_names_mut\" \"shape\" \"to_list\" \"to_list_tag_structs\" #> [25] \"to_list_unwind\" \"to_struct\" \"unnest\" #make an object df = pl $ DataFrame ( iris ) #use a public method/property df $ shape #> [1] 150 5 df2 = df #use a private method, which has mutability result = polars ::: .pr $ DataFrame $ set_column_from_robj ( df , 150 : 1 , \"some_ints\" ) #column exists in both dataframes-objects now, as they are just pointers to the same object # there are no public methods with mutability df $ columns #> [1] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" \"Species\" \"some_ints\" df2 $ columns #> [1] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" \"Species\" \"some_ints\" # set_column_from_robj-method is fallible and returned a result which could be ok or an err. # No public method or function will ever return a result. # The `result` is very close to the same as output from functions decorated with purrr::safely. # To use results on R side, these must be unwrapped first such that # potentially errors can be thrown. unwrap(result) is a way to # bridge rust not throwing errors with R. Extendr default behaviour is to use panic!(s) which # would case some unneccesary confusing and some very verbose error messages on the inner # workings of rust. unwrap(result) #in this case no error, just a NULL because this mutable # method does not return any ok-value. #try unwrapping an error from polars due to unmatching column lengths err_result = polars ::: .pr $ DataFrame $ set_column_from_robj ( df , 1 : 10000 , \"wrong_length\" ) tryCatch ( unwrap ( err_result ,call = NULL ) ,error = \\ ( e ) cat ( as.character ( e ) ) ) #> Error: in set_column_from_robj: ShapeMisMatch(Owned(\"Could not add column. The Series length 10000 differs from the DataFrame height: 150\")) #> when calling : #> NULL","title":"Inner workings of the DataFrame-class"},{"location":"reference/DataFrame_class/#inner-workings-of-the-dataframe-class","text":"The DataFrame -class is simply two environments of respectively the public and private methods/function calls to the polars rust side. The instanciated DataFrame -object is an externalptr to a lowlevel rust polars DataFrame object. The pointer address is the only statefullness of the DataFrame object on the R side. Any other state resides on the rust side. The S3 method .DollarNames.DataFrame exposes all public $foobar() -methods which are callable onto the object. Most methods return another DataFrame -class instance or similar which allows for method chaining. This class system in lack of a better name could be called \"environment classes\" and is the same class system extendr provides, except here there is both a public and private set of methods. For implementation reasons, the private methods are external and must be called from polars:::.pr.$DataFrame$methodname(), also all private methods must take any self as an argument, thus they are pure functions. Having the private methods as pure functions solved/simplified self-referential complications.","title":"Inner workings of the DataFrame-class"},{"location":"reference/DataFrame_class/#details","text":"Check out the source code in R/dataframe_frame.R how public methods are derived from private methods. Check out extendr-wrappers.R to see the extendr-auto-generated methods. These are moved to .pr and converted into pure external functions in after-wrappers.R. In zzz.R (named zzz to be last file sourced) the extendr-methods are removed and replaced by any function prefixed DataFrame_ .","title":"Details"},{"location":"reference/DataFrame_class/#examples","text":"#see all exported methods ls ( polars ::: DataFrame ) #> [1] \"as_data_frame\" \"clone\" \"columns\" \"dtypes\" \"estimated_size\" \"filter\" #> [7] \"first\" \"get_column\" \"get_columns\" \"groupby\" \"height\" \"join\" #> [13] \"last\" \"lazy\" \"limit\" \"max\" \"mean\" \"median\" #> [19] \"min\" \"null_count\" \"print\" \"reverse\" \"schema\" \"select\" #> [25] \"shape\" \"slice\" \"std\" \"sum\" \"tail\" \"to_list\" #> [31] \"to_series\" \"to_struct\" \"unnest\" \"var\" \"width\" \"with_column\" #> [37] \"with_columns\" #see all private methods (not intended for regular use) ls ( polars ::: .pr $ DataFrame ) #> [1] \"by_agg\" \"clone_see_me_macro\" \"columns\" \"dtypes\" #> [5] \"estimated_size\" \"export_stream\" \"from_arrow_record_batches\" \"get_column\" #> [9] \"get_columns\" \"lazy\" \"new\" \"new_par_from_list\" #> [13] \"new_with_capacity\" \"null_count\" \"print\" \"schema\" #> [17] \"select\" \"select_at_idx\" \"set_column_from_robj\" \"set_column_from_series\" #> [21] \"set_column_names_mut\" \"shape\" \"to_list\" \"to_list_tag_structs\" #> [25] \"to_list_unwind\" \"to_struct\" \"unnest\" #make an object df = pl $ DataFrame ( iris ) #use a public method/property df $ shape #> [1] 150 5 df2 = df #use a private method, which has mutability result = polars ::: .pr $ DataFrame $ set_column_from_robj ( df , 150 : 1 , \"some_ints\" ) #column exists in both dataframes-objects now, as they are just pointers to the same object # there are no public methods with mutability df $ columns #> [1] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" \"Species\" \"some_ints\" df2 $ columns #> [1] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" \"Species\" \"some_ints\" # set_column_from_robj-method is fallible and returned a result which could be ok or an err. # No public method or function will ever return a result. # The `result` is very close to the same as output from functions decorated with purrr::safely. # To use results on R side, these must be unwrapped first such that # potentially errors can be thrown. unwrap(result) is a way to # bridge rust not throwing errors with R. Extendr default behaviour is to use panic!(s) which # would case some unneccesary confusing and some very verbose error messages on the inner # workings of rust. unwrap(result) #in this case no error, just a NULL because this mutable # method does not return any ok-value. #try unwrapping an error from polars due to unmatching column lengths err_result = polars ::: .pr $ DataFrame $ set_column_from_robj ( df , 1 : 10000 , \"wrong_length\" ) tryCatch ( unwrap ( err_result ,call = NULL ) ,error = \\ ( e ) cat ( as.character ( e ) ) ) #> Error: in set_column_from_robj: ShapeMisMatch(Owned(\"Could not add column. The Series length 10000 differs from the DataFrame height: 150\")) #> when calling : #> NULL","title":"Examples"},{"location":"reference/DataFrame_clone/","text":"Clone a DataFrame DataFrame_clone () Returns DataFrame Rarely useful as DataFrame is nearly 100% immutable Any modification of a DataFrame would lead to a clone anyways. Examples df1 = pl $ DataFrame ( iris ) ; df2 = df1 $ clone ( ) ; df3 = df1 pl $ mem_address ( df1 ) != pl $ mem_address ( df2 ) #> [1] TRUE pl $ mem_address ( df1 ) == pl $ mem_address ( df3 ) #> [1] TRUE","title":"clone"},{"location":"reference/DataFrame_clone/#clone-a-dataframe","text":"DataFrame_clone ()","title":"Clone a DataFrame"},{"location":"reference/DataFrame_clone/#returns","text":"DataFrame Rarely useful as DataFrame is nearly 100% immutable Any modification of a DataFrame would lead to a clone anyways.","title":"Returns"},{"location":"reference/DataFrame_clone/#examples","text":"df1 = pl $ DataFrame ( iris ) ; df2 = df1 $ clone ( ) ; df3 = df1 pl $ mem_address ( df1 ) != pl $ mem_address ( df2 ) #> [1] TRUE pl $ mem_address ( df1 ) == pl $ mem_address ( df3 ) #> [1] TRUE","title":"Examples"},{"location":"reference/DataFrame_columns/","text":"get/set columns (the names columns) RField_datatype () DataFrame_columns () Returns char vec of column names char vec of column names get/set column names of DataFrame object get/set column names of DataFrame object Examples df = pl $ DataFrame ( iris ) #get values df $ columns #> [1] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" \"Species\" #set + get values df $ columns = letters [ 1 : 5 ] #<- is fine too df $ columns #> [1] \"a\" \"b\" \"c\" \"d\" \"e\" df = pl $ DataFrame ( iris ) #get values df $ columns #> [1] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" \"Species\" #set + get values df $ columns = letters [ 1 : 5 ] #<- is fine too df $ columns #> [1] \"a\" \"b\" \"c\" \"d\" \"e\"","title":"columns"},{"location":"reference/DataFrame_columns/#getset-columns-the-names-columns","text":"RField_datatype () DataFrame_columns ()","title":"get/set columns (the names columns)"},{"location":"reference/DataFrame_columns/#returns","text":"char vec of column names char vec of column names get/set column names of DataFrame object get/set column names of DataFrame object","title":"Returns"},{"location":"reference/DataFrame_columns/#examples","text":"df = pl $ DataFrame ( iris ) #get values df $ columns #> [1] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" \"Species\" #set + get values df $ columns = letters [ 1 : 5 ] #<- is fine too df $ columns #> [1] \"a\" \"b\" \"c\" \"d\" \"e\" df = pl $ DataFrame ( iris ) #get values df $ columns #> [1] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" \"Species\" #set + get values df $ columns = letters [ 1 : 5 ] #<- is fine too df $ columns #> [1] \"a\" \"b\" \"c\" \"d\" \"e\"","title":"Examples"},{"location":"reference/DataFrame_dtypes/","text":"DataFrame dtypes DataFrame_dtypes () DataFrame_schema () Returns width as numeric scalar width as numeric scalar Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame. Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame. Examples pl $ DataFrame ( iris ) $ dtypes #> [[1]] #> DataType: Float64 #> #> [[2]] #> DataType: Float64 #> #> [[3]] #> DataType: Float64 #> #> [[4]] #> DataType: Float64 #> #> [[5]] #> DataType: Categorical( #> Some( #> Local( #> LargeUtf8Array[setosa, versicolor, virginica], #> ), #> ), #> ) #> pl $ DataFrame ( iris ) $ schema #> $Sepal.Length #> DataType: Float64 #> #> $Sepal.Width #> DataType: Float64 #> #> $Petal.Length #> DataType: Float64 #> #> $Petal.Width #> DataType: Float64 #> #> $Species #> DataType: Categorical( #> Some( #> Local( #> LargeUtf8Array[setosa, versicolor, virginica], #> ), #> ), #> ) #>","title":"dtypes"},{"location":"reference/DataFrame_dtypes/#dataframe-dtypes","text":"DataFrame_dtypes () DataFrame_schema ()","title":"DataFrame dtypes"},{"location":"reference/DataFrame_dtypes/#returns","text":"width as numeric scalar width as numeric scalar Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame. Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame.","title":"Returns"},{"location":"reference/DataFrame_dtypes/#examples","text":"pl $ DataFrame ( iris ) $ dtypes #> [[1]] #> DataType: Float64 #> #> [[2]] #> DataType: Float64 #> #> [[3]] #> DataType: Float64 #> #> [[4]] #> DataType: Float64 #> #> [[5]] #> DataType: Categorical( #> Some( #> Local( #> LargeUtf8Array[setosa, versicolor, virginica], #> ), #> ), #> ) #> pl $ DataFrame ( iris ) $ schema #> $Sepal.Length #> DataType: Float64 #> #> $Sepal.Width #> DataType: Float64 #> #> $Petal.Length #> DataType: Float64 #> #> $Petal.Width #> DataType: Float64 #> #> $Species #> DataType: Categorical( #> Some( #> Local( #> LargeUtf8Array[setosa, versicolor, virginica], #> ), #> ), #> ) #>","title":"Examples"},{"location":"reference/DataFrame_estimated_size/","text":"Estimated size Format function DataFrame_estimated_size Returns Bytes Return an estimation of the total (heap) allocated size of the DataFrame. Examples pl $ DataFrame ( mtcars ) $ estimated_size ( ) #> [1] 2816","title":"estimated_size"},{"location":"reference/DataFrame_estimated_size/#estimated-size","text":"","title":"Estimated size"},{"location":"reference/DataFrame_estimated_size/#format","text":"function DataFrame_estimated_size","title":"Format"},{"location":"reference/DataFrame_estimated_size/#returns","text":"Bytes Return an estimation of the total (heap) allocated size of the DataFrame.","title":"Returns"},{"location":"reference/DataFrame_estimated_size/#examples","text":"pl $ DataFrame ( mtcars ) $ estimated_size ( ) #> [1] 2816","title":"Examples"},{"location":"reference/DataFrame_first/","text":"First DataFrame_first () Returns A new DataFrame object with applied filter. Get the first row of the DataFrame. Examples pl $ DataFrame ( mtcars ) $ first ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"first"},{"location":"reference/DataFrame_first/#first","text":"DataFrame_first ()","title":"First"},{"location":"reference/DataFrame_first/#returns","text":"A new DataFrame object with applied filter. Get the first row of the DataFrame.","title":"Returns"},{"location":"reference/DataFrame_first/#examples","text":"pl $ DataFrame ( mtcars ) $ first ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_get_column/","text":"Get Column (as one Series) DataFrame_get_column ( name ) Arguments name : name of column to extract as Series Returns Series get one column by name as series Examples df = pl $ DataFrame ( iris [ 1 , ] ) df $ get_column ( \"Species\" ) #> polars Series: shape: (1,) #> Series: 'Species' [cat] #> [ #> \"setosa\" #> ]","title":"get_column"},{"location":"reference/DataFrame_get_column/#get-column-as-one-series","text":"DataFrame_get_column ( name )","title":"Get Column (as one Series)"},{"location":"reference/DataFrame_get_column/#arguments","text":"name : name of column to extract as Series","title":"Arguments"},{"location":"reference/DataFrame_get_column/#returns","text":"Series get one column by name as series","title":"Returns"},{"location":"reference/DataFrame_get_column/#examples","text":"df = pl $ DataFrame ( iris [ 1 , ] ) df $ get_column ( \"Species\" ) #> polars Series: shape: (1,) #> Series: 'Species' [cat] #> [ #> \"setosa\" #> ]","title":"Examples"},{"location":"reference/DataFrame_get_columns/","text":"data Get columns (as Series) Format An object of class character of length 1. DataFrame_get_columns Returns list of series get columns as list of series Examples df = pl $ DataFrame ( iris [ 1 , ] ) df $ get_columns ( ) #> $Sepal.Length #> polars Series: shape: (1,) #> Series: 'Sepal.Length' [f64] #> [ #> 5.1 #> ] #> #> $Sepal.Width #> polars Series: shape: (1,) #> Series: 'Sepal.Width' [f64] #> [ #> 3.5 #> ] #> #> $Petal.Length #> polars Series: shape: (1,) #> Series: 'Petal.Length' [f64] #> [ #> 1.4 #> ] #> #> $Petal.Width #> polars Series: shape: (1,) #> Series: 'Petal.Width' [f64] #> [ #> 0.2 #> ] #> #> $Species #> polars Series: shape: (1,) #> Series: 'Species' [cat] #> [ #> \"setosa\" #> ] #>","title":"get_columns"},{"location":"reference/DataFrame_get_columns/#get-columns-as-series","text":"","title":"Get columns (as Series)"},{"location":"reference/DataFrame_get_columns/#format","text":"An object of class character of length 1. DataFrame_get_columns","title":"Format"},{"location":"reference/DataFrame_get_columns/#returns","text":"list of series get columns as list of series","title":"Returns"},{"location":"reference/DataFrame_get_columns/#examples","text":"df = pl $ DataFrame ( iris [ 1 , ] ) df $ get_columns ( ) #> $Sepal.Length #> polars Series: shape: (1,) #> Series: 'Sepal.Length' [f64] #> [ #> 5.1 #> ] #> #> $Sepal.Width #> polars Series: shape: (1,) #> Series: 'Sepal.Width' [f64] #> [ #> 3.5 #> ] #> #> $Petal.Length #> polars Series: shape: (1,) #> Series: 'Petal.Length' [f64] #> [ #> 1.4 #> ] #> #> $Petal.Width #> polars Series: shape: (1,) #> Series: 'Petal.Width' [f64] #> [ #> 0.2 #> ] #> #> $Species #> polars Series: shape: (1,) #> Series: 'Species' [cat] #> [ #> \"setosa\" #> ] #>","title":"Examples"},{"location":"reference/DataFrame_groupby/","text":"groupby DataFrame DataFrame_groupby ( ... , maintain_order = FALSE ) Arguments ... : any expression maintain_order : bool Returns GroupBy (subclass of DataFrame) DataFrame$groupby(..., maintain_order = FALSE)","title":"groupby"},{"location":"reference/DataFrame_groupby/#groupby-dataframe","text":"DataFrame_groupby ( ... , maintain_order = FALSE )","title":"groupby DataFrame"},{"location":"reference/DataFrame_groupby/#arguments","text":"... : any expression maintain_order : bool","title":"Arguments"},{"location":"reference/DataFrame_groupby/#returns","text":"GroupBy (subclass of DataFrame) DataFrame$groupby(..., maintain_order = FALSE)","title":"Returns"},{"location":"reference/DataFrame_height/","text":"Height of DataFrame DataFrame_height () Returns height as numeric Get height(nrow) of DataFrame Examples pl $ DataFrame ( iris ) $ height #> [1] 150","title":"height"},{"location":"reference/DataFrame_height/#height-of-dataframe","text":"DataFrame_height ()","title":"Height of DataFrame"},{"location":"reference/DataFrame_height/#returns","text":"height as numeric Get height(nrow) of DataFrame","title":"Returns"},{"location":"reference/DataFrame_height/#examples","text":"pl $ DataFrame ( iris ) $ height #> [1] 150","title":"Examples"},{"location":"reference/DataFrame_join/","text":"join DataFrame with other DataFrame DataFrame_join ( other , left_on = NULL , right_on = NULL , on = NULL , how = c ( \"inner\" , \"left\" , \"outer\" , \"semi\" , \"anti\" , \"cross\" ), suffix = \"_right\" , allow_parallel = TRUE , force_parallel = FALSE ) Arguments other : DataFrame left_on : names of columns in self LazyFrame, order should match. Type, see on param. right_on : names of columns in other LazyFrame, order should match. Type, see on param. on : named columns as char vector of named columns, or list of expressions and/or strings. how : a string selecting one of the following methods: inner, left, outer, semi, anti, cross suffix : name to added right table allow_parallel : bool force_parallel : bool Returns DataFrame join DataFrame with other DataFrame Examples print ( df1 <- pl $ DataFrame ( list ( key = 1 : 3 ,payload = c ( 'f' , 'i' , NA ) ) ) ) #> polars DataFrame: shape: (3, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 key \u2506 payload \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 f \u2502 #> \u2502 2 \u2506 i \u2502 #> \u2502 3 \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 print ( df2 <- pl $ DataFrame ( list ( key = c ( 3L , 4L , 5L , NA_integer_ ) ) ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 key \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 4 \u2502 #> \u2502 5 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df1 $ join ( other = df2 ,on = 'key' ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 key \u2506 payload \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"join"},{"location":"reference/DataFrame_join/#join-dataframe-with-other-dataframe","text":"DataFrame_join ( other , left_on = NULL , right_on = NULL , on = NULL , how = c ( \"inner\" , \"left\" , \"outer\" , \"semi\" , \"anti\" , \"cross\" ), suffix = \"_right\" , allow_parallel = TRUE , force_parallel = FALSE )","title":"join DataFrame with other DataFrame"},{"location":"reference/DataFrame_join/#arguments","text":"other : DataFrame left_on : names of columns in self LazyFrame, order should match. Type, see on param. right_on : names of columns in other LazyFrame, order should match. Type, see on param. on : named columns as char vector of named columns, or list of expressions and/or strings. how : a string selecting one of the following methods: inner, left, outer, semi, anti, cross suffix : name to added right table allow_parallel : bool force_parallel : bool","title":"Arguments"},{"location":"reference/DataFrame_join/#returns","text":"DataFrame join DataFrame with other DataFrame","title":"Returns"},{"location":"reference/DataFrame_join/#examples","text":"print ( df1 <- pl $ DataFrame ( list ( key = 1 : 3 ,payload = c ( 'f' , 'i' , NA ) ) ) ) #> polars DataFrame: shape: (3, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 key \u2506 payload \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 f \u2502 #> \u2502 2 \u2506 i \u2502 #> \u2502 3 \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 print ( df2 <- pl $ DataFrame ( list ( key = c ( 3L , 4L , 5L , NA_integer_ ) ) ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 key \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 4 \u2502 #> \u2502 5 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df1 $ join ( other = df2 ,on = 'key' ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 key \u2506 payload \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_last/","text":"Last DataFrame_last () Returns A new DataFrame object with applied filter. Get the last row of the DataFrame. Examples pl $ DataFrame ( mtcars ) $ last ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"last"},{"location":"reference/DataFrame_last/#last","text":"DataFrame_last ()","title":"Last"},{"location":"reference/DataFrame_last/#returns","text":"A new DataFrame object with applied filter. Get the last row of the DataFrame.","title":"Returns"},{"location":"reference/DataFrame_last/#examples","text":"pl $ DataFrame ( mtcars ) $ last ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_lazy/","text":"data New LazyFrame from DataFrame_object$lazy() Format An object of class character of length 1. DataFrame_lazy Returns a LazyFrame Start a new lazy query from a DataFrame Examples pl $ DataFrame ( iris ) $ lazy ( ) #> [1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\" #> DF [\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"]; PROJECT */5 COLUMNS; SELECTION: \"None\" #> #use of lazy method pl $ DataFrame ( iris ) $ lazy ( ) $ filter ( pl $ col ( \"Sepal.Length\" ) >= 7.7 ) $ collect ( ) #> polars DataFrame: shape: (5, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 7.7 \u2506 3.8 \u2506 6.7 \u2506 2.2 \u2506 virginica \u2502 #> \u2502 7.7 \u2506 2.6 \u2506 6.9 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 7.7 \u2506 2.8 \u2506 6.7 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 7.9 \u2506 3.8 \u2506 6.4 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 7.7 \u2506 3.0 \u2506 6.1 \u2506 2.3 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"lazy"},{"location":"reference/DataFrame_lazy/#new-lazyframe-from-dataframe_objectlazy","text":"","title":"New LazyFrame from DataFrame_object$lazy()"},{"location":"reference/DataFrame_lazy/#format","text":"An object of class character of length 1. DataFrame_lazy","title":"Format"},{"location":"reference/DataFrame_lazy/#returns","text":"a LazyFrame Start a new lazy query from a DataFrame","title":"Returns"},{"location":"reference/DataFrame_lazy/#examples","text":"pl $ DataFrame ( iris ) $ lazy ( ) #> [1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\" #> DF [\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"]; PROJECT */5 COLUMNS; SELECTION: \"None\" #> #use of lazy method pl $ DataFrame ( iris ) $ lazy ( ) $ filter ( pl $ col ( \"Sepal.Length\" ) >= 7.7 ) $ collect ( ) #> polars DataFrame: shape: (5, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 7.7 \u2506 3.8 \u2506 6.7 \u2506 2.2 \u2506 virginica \u2502 #> \u2502 7.7 \u2506 2.6 \u2506 6.9 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 7.7 \u2506 2.8 \u2506 6.7 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 7.9 \u2506 3.8 \u2506 6.4 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 7.7 \u2506 3.0 \u2506 6.1 \u2506 2.3 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_limit/","text":"Limit a DataFrame DataFrame_limit ( n ) Arguments n : positive numeric or integer number not larger than 2^32 Returns DataFrame take limit of n rows of query Details any number will converted to u32. Negative raises error","title":"limit"},{"location":"reference/DataFrame_limit/#limit-a-dataframe","text":"DataFrame_limit ( n )","title":"Limit a DataFrame"},{"location":"reference/DataFrame_limit/#arguments","text":"n : positive numeric or integer number not larger than 2^32","title":"Arguments"},{"location":"reference/DataFrame_limit/#returns","text":"DataFrame take limit of n rows of query","title":"Returns"},{"location":"reference/DataFrame_limit/#details","text":"any number will converted to u32. Negative raises error","title":"Details"},{"location":"reference/DataFrame_max/","text":"Max DataFrame_max () Returns A new DataFrame object with applied aggregation. Aggregate the columns in the DataFrame to their maximum value. Examples pl $ DataFrame ( mtcars ) $ max ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 33.9 \u2506 8.0 \u2506 472.0 \u2506 335.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"max"},{"location":"reference/DataFrame_max/#max","text":"DataFrame_max ()","title":"Max"},{"location":"reference/DataFrame_max/#returns","text":"A new DataFrame object with applied aggregation. Aggregate the columns in the DataFrame to their maximum value.","title":"Returns"},{"location":"reference/DataFrame_max/#examples","text":"pl $ DataFrame ( mtcars ) $ max ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 33.9 \u2506 8.0 \u2506 472.0 \u2506 335.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_mean/","text":"Mean DataFrame_mean () Returns A new DataFrame object with applied aggregation. Aggregate the columns in the DataFrame to their mean value. Examples pl $ DataFrame ( mtcars ) $ mean ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 20.090625 \u2506 6.1875 \u2506 230.721875 \u2506 146.6875 \u2506 ... \u2506 0.4375 \u2506 0.40625 \u2506 3.6875 \u2506 2.8125 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"mean"},{"location":"reference/DataFrame_mean/#mean","text":"DataFrame_mean ()","title":"Mean"},{"location":"reference/DataFrame_mean/#returns","text":"A new DataFrame object with applied aggregation. Aggregate the columns in the DataFrame to their mean value.","title":"Returns"},{"location":"reference/DataFrame_mean/#examples","text":"pl $ DataFrame ( mtcars ) $ mean ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 20.090625 \u2506 6.1875 \u2506 230.721875 \u2506 146.6875 \u2506 ... \u2506 0.4375 \u2506 0.40625 \u2506 3.6875 \u2506 2.8125 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_median/","text":"Median DataFrame_median () Returns A new DataFrame object with applied aggregation. Aggregate the columns in the DataFrame to their median value. Examples pl $ DataFrame ( mtcars ) $ median ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 19.2 \u2506 6.0 \u2506 196.3 \u2506 123.0 \u2506 ... \u2506 0.0 \u2506 0.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"median"},{"location":"reference/DataFrame_median/#median","text":"DataFrame_median ()","title":"Median"},{"location":"reference/DataFrame_median/#returns","text":"A new DataFrame object with applied aggregation. Aggregate the columns in the DataFrame to their median value.","title":"Returns"},{"location":"reference/DataFrame_median/#examples","text":"pl $ DataFrame ( mtcars ) $ median ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 19.2 \u2506 6.0 \u2506 196.3 \u2506 123.0 \u2506 ... \u2506 0.0 \u2506 0.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_min/","text":"Min DataFrame_min () Returns A new DataFrame object with applied aggregation. Aggregate the columns in the DataFrame to their minimum value. Examples pl $ DataFrame ( mtcars ) $ min ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 10.4 \u2506 4.0 \u2506 71.1 \u2506 52.0 \u2506 ... \u2506 0.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"min"},{"location":"reference/DataFrame_min/#min","text":"DataFrame_min ()","title":"Min"},{"location":"reference/DataFrame_min/#returns","text":"A new DataFrame object with applied aggregation. Aggregate the columns in the DataFrame to their minimum value.","title":"Returns"},{"location":"reference/DataFrame_min/#examples","text":"pl $ DataFrame ( mtcars ) $ min ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 10.4 \u2506 4.0 \u2506 71.1 \u2506 52.0 \u2506 ... \u2506 0.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_null_count/","text":"Null count Format function DataFrame_null_count Returns DataFrame Create a new DataFrame that shows the null counts per column. Examples x = mtcars x [ 1 , 2 : 3 ] = NA pl $ DataFrame ( x ) $ null_count ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 u32 \u2506 u32 \u2506 u32 \u2506 u32 \u2506 \u2506 u32 \u2506 u32 \u2506 u32 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0 \u2506 1 \u2506 1 \u2506 0 \u2506 ... \u2506 0 \u2506 0 \u2506 0 \u2506 0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"null_count"},{"location":"reference/DataFrame_null_count/#null-count","text":"","title":"Null count"},{"location":"reference/DataFrame_null_count/#format","text":"function DataFrame_null_count","title":"Format"},{"location":"reference/DataFrame_null_count/#returns","text":"DataFrame Create a new DataFrame that shows the null counts per column.","title":"Returns"},{"location":"reference/DataFrame_null_count/#examples","text":"x = mtcars x [ 1 , 2 : 3 ] = NA pl $ DataFrame ( x ) $ null_count ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 u32 \u2506 u32 \u2506 u32 \u2506 u32 \u2506 \u2506 u32 \u2506 u32 \u2506 u32 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0 \u2506 1 \u2506 1 \u2506 0 \u2506 ... \u2506 0 \u2506 0 \u2506 0 \u2506 0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_print/","text":"internal method print DataFrame DataFrame_print () Returns self internal method print DataFrame Examples pl $ DataFrame ( iris ) #> polars DataFrame: shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"print"},{"location":"reference/DataFrame_print/#internal-method-print-dataframe","text":"DataFrame_print ()","title":"internal method print DataFrame"},{"location":"reference/DataFrame_print/#returns","text":"self internal method print DataFrame","title":"Returns"},{"location":"reference/DataFrame_print/#examples","text":"pl $ DataFrame ( iris ) #> polars DataFrame: shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_reverse/","text":"Reverse DataFrame_reverse () Returns LazyFrame Reverse the DataFrame. Examples pl $ DataFrame ( mtcars ) $ reverse ( ) #> polars DataFrame: shape: (32, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 6.0 \u2502 #> \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 4.0 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"reverse"},{"location":"reference/DataFrame_reverse/#reverse","text":"DataFrame_reverse ()","title":"Reverse"},{"location":"reference/DataFrame_reverse/#returns","text":"LazyFrame Reverse the DataFrame.","title":"Returns"},{"location":"reference/DataFrame_reverse/#examples","text":"pl $ DataFrame ( mtcars ) $ reverse ( ) #> polars DataFrame: shape: (32, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 6.0 \u2502 #> \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 4.0 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_select/","text":"perform select on DataFrame DataFrame_select ( ... ) Arguments ... : expresssions or strings defining columns to select(keep) in context the DataFrame related to dplyr mutate() However discards unmentioned columns as data.table .() .","title":"select"},{"location":"reference/DataFrame_select/#perform-select-on-dataframe","text":"DataFrame_select ( ... )","title":"perform select on DataFrame"},{"location":"reference/DataFrame_select/#arguments","text":"... : expresssions or strings defining columns to select(keep) in context the DataFrame related to dplyr mutate() However discards unmentioned columns as data.table .() .","title":"Arguments"},{"location":"reference/DataFrame_shape/","text":"Shape of DataFrame DataFrame_shape () Returns two length numeric vector of c(nrows,ncols) Get shape/dimensions of DataFrame Examples df = pl $ DataFrame ( iris ) $ shape","title":"shape"},{"location":"reference/DataFrame_shape/#shape-of-dataframe","text":"DataFrame_shape ()","title":"Shape of DataFrame"},{"location":"reference/DataFrame_shape/#returns","text":"two length numeric vector of c(nrows,ncols) Get shape/dimensions of DataFrame","title":"Returns"},{"location":"reference/DataFrame_shape/#examples","text":"df = pl $ DataFrame ( iris ) $ shape","title":"Examples"},{"location":"reference/DataFrame_slice/","text":"Slice DataFrame_slice ( offset , length = NULL ) Arguments offset : integer length : integer or NULL Returns LazyFrame Get a slice of this DataFrame. Examples pl $ DataFrame ( mtcars ) $ slice ( 2 , 4 ) #> polars DataFrame: shape: (4, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 18.7 \u2506 8.0 \u2506 360.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 0.0 \u2506 3.0 \u2506 2.0 \u2502 #> \u2502 18.1 \u2506 6.0 \u2506 225.0 \u2506 105.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 mtcars [ 2 : 6 , ] #> mpg cyl disp hp drat wt qsec vs am gear carb #> Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 #> Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 #> Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 #> Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 #> Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1","title":"slice"},{"location":"reference/DataFrame_slice/#slice","text":"DataFrame_slice ( offset , length = NULL )","title":"Slice"},{"location":"reference/DataFrame_slice/#arguments","text":"offset : integer length : integer or NULL","title":"Arguments"},{"location":"reference/DataFrame_slice/#returns","text":"LazyFrame Get a slice of this DataFrame.","title":"Returns"},{"location":"reference/DataFrame_slice/#examples","text":"pl $ DataFrame ( mtcars ) $ slice ( 2 , 4 ) #> polars DataFrame: shape: (4, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 18.7 \u2506 8.0 \u2506 360.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 0.0 \u2506 3.0 \u2506 2.0 \u2502 #> \u2502 18.1 \u2506 6.0 \u2506 225.0 \u2506 105.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 mtcars [ 2 : 6 , ] #> mpg cyl disp hp drat wt qsec vs am gear carb #> Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 #> Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 #> Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 #> Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 #> Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1","title":"Examples"},{"location":"reference/DataFrame_std/","text":"Std DataFrame_std ( ddof = 1 ) Arguments ddof : integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1. Returns A new DataFrame object with applied aggregation. Aggregate the columns of this DataFrame to their standard deviation values. Examples pl $ DataFrame ( mtcars ) $ std ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6.026948 \u2506 1.785922 \u2506 123.938694 \u2506 68.562868 \u2506 ... \u2506 0.504016 \u2506 0.498991 \u2506 0.737804 \u2506 1.6152 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"std"},{"location":"reference/DataFrame_std/#std","text":"DataFrame_std ( ddof = 1 )","title":"Std"},{"location":"reference/DataFrame_std/#arguments","text":"ddof : integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1.","title":"Arguments"},{"location":"reference/DataFrame_std/#returns","text":"A new DataFrame object with applied aggregation. Aggregate the columns of this DataFrame to their standard deviation values.","title":"Returns"},{"location":"reference/DataFrame_std/#examples","text":"pl $ DataFrame ( mtcars ) $ std ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6.026948 \u2506 1.785922 \u2506 123.938694 \u2506 68.562868 \u2506 ... \u2506 0.504016 \u2506 0.498991 \u2506 0.737804 \u2506 1.6152 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_sum/","text":"Sum DataFrame_sum () Returns A new DataFrame object with applied aggregation. Aggregate the columns of this DataFrame to their sum values. Examples pl $ DataFrame ( mtcars ) $ sum ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 642.9 \u2506 198.0 \u2506 7383.1 \u2506 4694.0 \u2506 ... \u2506 14.0 \u2506 13.0 \u2506 118.0 \u2506 90.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"sum"},{"location":"reference/DataFrame_sum/#sum","text":"DataFrame_sum ()","title":"Sum"},{"location":"reference/DataFrame_sum/#returns","text":"A new DataFrame object with applied aggregation. Aggregate the columns of this DataFrame to their sum values.","title":"Returns"},{"location":"reference/DataFrame_sum/#examples","text":"pl $ DataFrame ( mtcars ) $ sum ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 642.9 \u2506 198.0 \u2506 7383.1 \u2506 4694.0 \u2506 ... \u2506 14.0 \u2506 13.0 \u2506 118.0 \u2506 90.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_tail/","text":"Tail a DataFrame DataFrame_tail ( n ) Arguments n : positive numeric of integer number not larger than 2^32 Returns DataFrame Get the last n rows. Details any number will converted to u32. Negative raises error","title":"tail"},{"location":"reference/DataFrame_tail/#tail-a-dataframe","text":"DataFrame_tail ( n )","title":"Tail a DataFrame"},{"location":"reference/DataFrame_tail/#arguments","text":"n : positive numeric of integer number not larger than 2^32","title":"Arguments"},{"location":"reference/DataFrame_tail/#returns","text":"DataFrame Get the last n rows.","title":"Returns"},{"location":"reference/DataFrame_tail/#details","text":"any number will converted to u32. Negative raises error","title":"Details"},{"location":"reference/DataFrame_to_Struct_unnest/","text":"to_struct and unnest again DataFrame_to_struct ( name = \"\" ) DataFrame_unnest ( names = NULL ) Arguments name : name of new Series names : names of struct columns to unnest, default NULL unnest any struct column Returns @to_struct() returns a Series $unnest() returns a DataFrame with all column including any that has been unnested to_struct and unnest again Unnest a DataFrame struct columns. Examples #round-trip conversion from DataFrame with two columns df = pl $ DataFrame ( a = 1 : 5 ,b = c ( \"one\" , \"two\" , \"three\" , \"four\" , \"five\" ) ) s = df $ to_struct ( ) s #> polars Series: shape: (5,) #> Series: '' [struct[2]] #> [ #> {1,\"one\"} #> {2,\"two\"} #> {3,\"three\"} #> {4,\"four\"} #> {5,\"five\"} #> ] s $ to_r ( ) # to r list #> $a #> [1] 1 2 3 4 5 #> #> $b #> [1] \"one\" \"two\" \"three\" \"four\" \"five\" #> #> attr(,\"is_struct\") #> [1] TRUE df_s = s $ to_frame ( ) #place series in a new DataFrame df_s $ unnest ( ) # back to starting df #> polars DataFrame: shape: (5, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 one \u2502 #> \u2502 2 \u2506 two \u2502 #> \u2502 3 \u2506 three \u2502 #> \u2502 4 \u2506 four \u2502 #> \u2502 5 \u2506 five \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"to_Struct_unnest"},{"location":"reference/DataFrame_to_Struct_unnest/#to_struct-and-unnest-again","text":"DataFrame_to_struct ( name = \"\" ) DataFrame_unnest ( names = NULL )","title":"to_struct and unnest again"},{"location":"reference/DataFrame_to_Struct_unnest/#arguments","text":"name : name of new Series names : names of struct columns to unnest, default NULL unnest any struct column","title":"Arguments"},{"location":"reference/DataFrame_to_Struct_unnest/#returns","text":"@to_struct() returns a Series $unnest() returns a DataFrame with all column including any that has been unnested to_struct and unnest again Unnest a DataFrame struct columns.","title":"Returns"},{"location":"reference/DataFrame_to_Struct_unnest/#examples","text":"#round-trip conversion from DataFrame with two columns df = pl $ DataFrame ( a = 1 : 5 ,b = c ( \"one\" , \"two\" , \"three\" , \"four\" , \"five\" ) ) s = df $ to_struct ( ) s #> polars Series: shape: (5,) #> Series: '' [struct[2]] #> [ #> {1,\"one\"} #> {2,\"two\"} #> {3,\"three\"} #> {4,\"four\"} #> {5,\"five\"} #> ] s $ to_r ( ) # to r list #> $a #> [1] 1 2 3 4 5 #> #> $b #> [1] \"one\" \"two\" \"three\" \"four\" \"five\" #> #> attr(,\"is_struct\") #> [1] TRUE df_s = s $ to_frame ( ) #place series in a new DataFrame df_s $ unnest ( ) # back to starting df #> polars DataFrame: shape: (5, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 one \u2502 #> \u2502 2 \u2506 two \u2502 #> \u2502 3 \u2506 three \u2502 #> \u2502 4 \u2506 four \u2502 #> \u2502 5 \u2506 five \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_to_series/","text":"Get Series by idx, if there DataFrame_to_series ( idx = 0 ) Arguments idx : numeric default 0, zero-index of what column to return as Series Returns Series or NULL get one column by idx as series from DataFrame. Unlike get_column this method will not fail if no series found at idx but return a NULL, idx is zero idx. Examples pl $ DataFrame ( a = 1 : 4 ) $ to_series ( ) #> polars Series: shape: (4,) #> Series: 'a' [i32] #> [ #> 1 #> 2 #> 3 #> 4 #> ]","title":"to_series"},{"location":"reference/DataFrame_to_series/#get-series-by-idx-if-there","text":"DataFrame_to_series ( idx = 0 )","title":"Get Series by idx, if there"},{"location":"reference/DataFrame_to_series/#arguments","text":"idx : numeric default 0, zero-index of what column to return as Series","title":"Arguments"},{"location":"reference/DataFrame_to_series/#returns","text":"Series or NULL get one column by idx as series from DataFrame. Unlike get_column this method will not fail if no series found at idx but return a NULL, idx is zero idx.","title":"Returns"},{"location":"reference/DataFrame_to_series/#examples","text":"pl $ DataFrame ( a = 1 : 4 ) $ to_series ( ) #> polars Series: shape: (4,) #> Series: 'a' [i32] #> [ #> 1 #> 2 #> 3 #> 4 #> ]","title":"Examples"},{"location":"reference/DataFrame_var/","text":"Var DataFrame_var ( ddof = 1 ) Arguments ddof : integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1. Returns A new DataFrame object with applied aggregation. Aggregate the columns of this DataFrame to their variance values. Examples pl $ DataFrame ( mtcars ) $ var ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 36.324103 \u2506 3.189516 \u2506 15360.7998 \u2506 4700.86693 \u2506 ... \u2506 0.254032 \u2506 0.248992 \u2506 0.544355 \u2506 2.608871 \u2502 #> \u2502 \u2506 \u2506 29 \u2506 5 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"var"},{"location":"reference/DataFrame_var/#var","text":"DataFrame_var ( ddof = 1 )","title":"Var"},{"location":"reference/DataFrame_var/#arguments","text":"ddof : integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1.","title":"Arguments"},{"location":"reference/DataFrame_var/#returns","text":"A new DataFrame object with applied aggregation. Aggregate the columns of this DataFrame to their variance values.","title":"Returns"},{"location":"reference/DataFrame_var/#examples","text":"pl $ DataFrame ( mtcars ) $ var ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 36.324103 \u2506 3.189516 \u2506 15360.7998 \u2506 4700.86693 \u2506 ... \u2506 0.254032 \u2506 0.248992 \u2506 0.544355 \u2506 2.608871 \u2502 #> \u2502 \u2506 \u2506 29 \u2506 5 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataFrame_width/","text":"Width of DataFrame DataFrame_width () Returns width as numeric scalar Get width(ncol) of DataFrame Examples pl $ DataFrame ( iris ) $ width #> [1] 5","title":"width"},{"location":"reference/DataFrame_width/#width-of-dataframe","text":"DataFrame_width ()","title":"Width of DataFrame"},{"location":"reference/DataFrame_width/#returns","text":"width as numeric scalar Get width(ncol) of DataFrame","title":"Returns"},{"location":"reference/DataFrame_width/#examples","text":"pl $ DataFrame ( iris ) $ width #> [1] 5","title":"Examples"},{"location":"reference/DataFrame_with_columns/","text":"modify/append column(s) DataFrame_with_columns ( ... ) DataFrame_with_column ( expr ) Arguments ... : any expressions or string column name, or same wrapped in a list expr : a single expression or string Returns DataFrame DataFrame add or modify columns with expressions Details Like dplyr mutate() as it keeps unmentioned columns unlike $select(). with_column is derived from with_columns but takes only one expression argument Examples pl $ DataFrame ( iris ) $ with_columns ( pl $ col ( \"Sepal.Length\" ) $ abs ( ) $ alias ( \"abs_SL\" ) , ( pl $ col ( \"Sepal.Length\" ) + 2 ) $ alias ( \"add_2_SL\" ) ) #> polars DataFrame: shape: (150, 7) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2506 abs_SL \u2506 add_2_SL \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2506 5.1 \u2506 7.1 \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2506 4.9 \u2506 6.9 \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2506 4.7 \u2506 6.7 \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2506 4.6 \u2506 6.6 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2506 6.3 \u2506 8.3 \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2506 6.5 \u2506 8.5 \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2506 6.2 \u2506 8.2 \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2506 5.9 \u2506 7.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #rename columns by naming expression is concidered experimental pl $ set_polars_options ( named_exprs = TRUE ) #unlock #> $named_exprs #> [1] FALSE #> pl $ DataFrame ( iris ) $ with_columns ( pl $ col ( \"Sepal.Length\" ) $ abs ( ) , #not named expr will keep name \"Sepal.Length\" SW_add_2 = ( pl $ col ( \"Sepal.Width\" ) + 2 ) ) #> polars DataFrame: shape: (150, 6) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2506 SW_add_2 \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2506 5.5 \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2506 5.0 \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2506 5.2 \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2506 5.1 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2506 4.5 \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2506 5.0 \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2506 5.4 \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2506 5.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"with_columns"},{"location":"reference/DataFrame_with_columns/#modifyappend-columns","text":"DataFrame_with_columns ( ... ) DataFrame_with_column ( expr )","title":"modify/append column(s)"},{"location":"reference/DataFrame_with_columns/#arguments","text":"... : any expressions or string column name, or same wrapped in a list expr : a single expression or string","title":"Arguments"},{"location":"reference/DataFrame_with_columns/#returns","text":"DataFrame DataFrame add or modify columns with expressions","title":"Returns"},{"location":"reference/DataFrame_with_columns/#details","text":"Like dplyr mutate() as it keeps unmentioned columns unlike $select(). with_column is derived from with_columns but takes only one expression argument","title":"Details"},{"location":"reference/DataFrame_with_columns/#examples","text":"pl $ DataFrame ( iris ) $ with_columns ( pl $ col ( \"Sepal.Length\" ) $ abs ( ) $ alias ( \"abs_SL\" ) , ( pl $ col ( \"Sepal.Length\" ) + 2 ) $ alias ( \"add_2_SL\" ) ) #> polars DataFrame: shape: (150, 7) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2506 abs_SL \u2506 add_2_SL \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2506 5.1 \u2506 7.1 \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2506 4.9 \u2506 6.9 \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2506 4.7 \u2506 6.7 \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2506 4.6 \u2506 6.6 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2506 6.3 \u2506 8.3 \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2506 6.5 \u2506 8.5 \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2506 6.2 \u2506 8.2 \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2506 5.9 \u2506 7.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #rename columns by naming expression is concidered experimental pl $ set_polars_options ( named_exprs = TRUE ) #unlock #> $named_exprs #> [1] FALSE #> pl $ DataFrame ( iris ) $ with_columns ( pl $ col ( \"Sepal.Length\" ) $ abs ( ) , #not named expr will keep name \"Sepal.Length\" SW_add_2 = ( pl $ col ( \"Sepal.Width\" ) + 2 ) ) #> polars DataFrame: shape: (150, 6) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2506 SW_add_2 \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2506 5.5 \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2506 5.0 \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2506 5.2 \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2506 5.1 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2506 4.5 \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2506 5.0 \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2506 5.4 \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2506 5.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/DataType/","text":"DataTypes polars types DataType any polars type (ported so far) Examples print ( ls ( pl $ dtypes ) ) #> [1] \"Binary\" \"Boolean\" \"Categorical\" \"Date\" \"Datetime\" \"Float32\" \"Float64\" \"Int16\" #> [9] \"Int32\" \"Int64\" \"Int8\" \"List\" \"Null\" \"Struct\" \"Time\" \"UInt16\" #> [17] \"UInt32\" \"UInt64\" \"UInt8\" \"Unknown\" \"Utf8\" pl $ dtypes $ Float64 #> DataType: Float64 pl $ dtypes $ Utf8 #> DataType: Utf8 pl $ List ( pl $ List ( pl $ UInt64 ) ) #> DataType: List( #> List( #> UInt64, #> ), #> ) pl $ Struct ( pl $ Field ( \"CityNames\" , pl $ Utf8 ) ) #> DataType: Struct( #> [ #> Field { #> name: \"CityNames\", #> dtype: Utf8, #> }, #> ], #> ) # Some DataType use case, this user function fails because.... ## Not run: pl $ Series ( 1 : 4 ) $ apply ( \\ ( x ) letters [ x ] ) #> Error: a lambda returned Strings and not the expected Integers . Try strict=FALSE, or change expected output type or rewrite lambda #> when calling : #> source(\"C:/Users/etienne/Desktop/Divers/r-polars/docs/make-docs.R\", #> echo = TRUE) ## End(Not run) #The function changes type from Integer(Int32)[Integers] to char(Utf8)[Strings] #specifying the output DataType: Utf8 solves the problem pl $ Series ( 1 : 4 ) $ apply ( \\ ( x ) letters [ x ] ,datatype = pl $ dtypes $ Utf8 ) #> polars Series: shape: (4,) #> Series: '_apply' [str] #> [ #> \"a\" #> \"b\" #> \"c\" #> \"d\" #> ]","title":"DataType"},{"location":"reference/DataType/#datatypes-polars-types","text":"DataType any polars type (ported so far)","title":"DataTypes polars types"},{"location":"reference/DataType/#examples","text":"print ( ls ( pl $ dtypes ) ) #> [1] \"Binary\" \"Boolean\" \"Categorical\" \"Date\" \"Datetime\" \"Float32\" \"Float64\" \"Int16\" #> [9] \"Int32\" \"Int64\" \"Int8\" \"List\" \"Null\" \"Struct\" \"Time\" \"UInt16\" #> [17] \"UInt32\" \"UInt64\" \"UInt8\" \"Unknown\" \"Utf8\" pl $ dtypes $ Float64 #> DataType: Float64 pl $ dtypes $ Utf8 #> DataType: Utf8 pl $ List ( pl $ List ( pl $ UInt64 ) ) #> DataType: List( #> List( #> UInt64, #> ), #> ) pl $ Struct ( pl $ Field ( \"CityNames\" , pl $ Utf8 ) ) #> DataType: Struct( #> [ #> Field { #> name: \"CityNames\", #> dtype: Utf8, #> }, #> ], #> ) # Some DataType use case, this user function fails because.... ## Not run: pl $ Series ( 1 : 4 ) $ apply ( \\ ( x ) letters [ x ] ) #> Error: a lambda returned Strings and not the expected Integers . Try strict=FALSE, or change expected output type or rewrite lambda #> when calling : #> source(\"C:/Users/etienne/Desktop/Divers/r-polars/docs/make-docs.R\", #> echo = TRUE) ## End(Not run) #The function changes type from Integer(Int32)[Integers] to char(Utf8)[Strings] #specifying the output DataType: Utf8 solves the problem pl $ Series ( 1 : 4 ) $ apply ( \\ ( x ) letters [ x ] ,datatype = pl $ dtypes $ Utf8 ) #> polars Series: shape: (4,) #> Series: '_apply' [str] #> [ #> \"a\" #> \"b\" #> \"c\" #> \"d\" #> ]","title":"Examples"},{"location":"reference/DataType_constructors/","text":"data DataType_constructors (composite DataType's) Format An object of class list of length 3. DataType_constructors Returns DataType List of all composite DataType constructors Details This list is mainly used in zzz.R .onLoad to instantiate singletons of all flag-like DataTypes. Non-flag like DataType called composite DataTypes also carries extra information e.g. Datetime a timeunit and a TimeZone, or List which recursively carries another DataType inside. Composite DataTypes use DataType constructors. Any DataType can be found in pl$dtypes Examples #constructors are finally available via pl$... or pl$dtypes$... pl $ List ( pl $ List ( pl $ Int64 ) ) #> DataType: List( #> List( #> Int64, #> ), #> )","title":"DataType_constructors"},{"location":"reference/DataType_constructors/#datatype_constructors-composite-datatypes","text":"","title":"DataType_constructors (composite DataType's)"},{"location":"reference/DataType_constructors/#format","text":"An object of class list of length 3. DataType_constructors","title":"Format"},{"location":"reference/DataType_constructors/#returns","text":"DataType List of all composite DataType constructors","title":"Returns"},{"location":"reference/DataType_constructors/#details","text":"This list is mainly used in zzz.R .onLoad to instantiate singletons of all flag-like DataTypes. Non-flag like DataType called composite DataTypes also carries extra information e.g. Datetime a timeunit and a TimeZone, or List which recursively carries another DataType inside. Composite DataTypes use DataType constructors. Any DataType can be found in pl$dtypes","title":"Details"},{"location":"reference/DataType_constructors/#examples","text":"#constructors are finally available via pl$... or pl$dtypes$... pl $ List ( pl $ List ( pl $ Int64 ) ) #> DataType: List( #> List( #> Int64, #> ), #> )","title":"Examples"},{"location":"reference/DataType_new/","text":"DataType_new (simple DataType's) DataType_new ( str ) Arguments str : name of DataType to create Returns DataType Create a new flag like DataType Details This function is mainly used in zzz.R .onLoad to instantiate singletons of all flag-like DataType. Non-flag like DataType called composite DataTypes also carries extra information e.g. Datetime a timeunit and a TimeZone, or List which recursively carries another DataType inside. Composite DataTypes use DataType constructors. Any DataType can be found in pl$dtypes Examples polars ::: DataType_new ( \"Int64\" ) #> DataType: Int64","title":"DataType_new"},{"location":"reference/DataType_new/#datatype_new-simple-datatypes","text":"DataType_new ( str )","title":"DataType_new (simple DataType's)"},{"location":"reference/DataType_new/#arguments","text":"str : name of DataType to create","title":"Arguments"},{"location":"reference/DataType_new/#returns","text":"DataType Create a new flag like DataType","title":"Returns"},{"location":"reference/DataType_new/#details","text":"This function is mainly used in zzz.R .onLoad to instantiate singletons of all flag-like DataType. Non-flag like DataType called composite DataTypes also carries extra information e.g. Datetime a timeunit and a TimeZone, or List which recursively carries another DataType inside. Composite DataTypes use DataType constructors. Any DataType can be found in pl$dtypes","title":"Details"},{"location":"reference/DataType_new/#examples","text":"polars ::: DataType_new ( \"Int64\" ) #> DataType: Int64","title":"Examples"},{"location":"reference/Err/","text":"Wrap in Err Err ( x ) Arguments x : any R object Returns same R object wrapped in a Err-result Wrap in Err","title":"Err"},{"location":"reference/Err/#wrap-in-err","text":"Err ( x )","title":"Wrap in Err"},{"location":"reference/Err/#arguments","text":"x : any R object","title":"Arguments"},{"location":"reference/Err/#returns","text":"same R object wrapped in a Err-result Wrap in Err","title":"Returns"},{"location":"reference/Expr-cash-print-open-paren-close-paren/","text":"internal method print Expr Expr_print () internal method print Expr Examples pl $ DataFrame ( iris ) #> polars DataFrame: shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr-cash-print-open-paren-close-paren"},{"location":"reference/Expr-cash-print-open-paren-close-paren/#internal-method-print-expr","text":"Expr_print () internal method print Expr","title":"internal method print Expr"},{"location":"reference/Expr-cash-print-open-paren-close-paren/#examples","text":"pl $ DataFrame ( iris ) #> polars DataFrame: shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr/","text":"Polars Expr Expr_lit ( x ) Expr_suffix ( suffix ) Expr_prefix ( prefix ) Expr_reverse () Arguments x : an R Scalar, or R vector/list (via Series) into Expr suffix : string suffix to be added to a name prefix : string suffix to be added to a name Returns Expr, literal of that value Expr Expr Expr Polars pl$Expr Details pl$lit(NULL) translates into a typeless polars Null Examples 2 + 2 #> [1] 4 #Expr has the following methods/constructors ls ( polars ::: Expr ) #> [1] \"abs\" \"add\" \"agg_groups\" \"alias\" \"all\" \"and\" #> [7] \"any\" \"append\" \"apply\" \"arccos\" \"arccosh\" \"arcsin\" #> [13] \"arcsinh\" \"arctan\" \"arctanh\" \"arg_max\" \"arg_min\" \"arg_sort\" #> [19] \"arg_unique\" \"argsort\" \"arr\" \"backward_fill\" \"bin\" \"cast\" #> [25] \"cat\" \"ceil\" \"clip\" \"clip_max\" \"clip_min\" \"cos\" #> [31] \"cosh\" \"count\" \"cumcount\" \"cummax\" \"cummin\" \"cumprod\" #> [37] \"cumsum\" \"cumulative_eval\" \"diff\" \"div\" \"dot\" \"drop_nans\" #> [43] \"drop_nulls\" \"dt\" \"entropy\" \"eq\" \"ewm_mean\" \"ewm_std\" #> [49] \"ewm_var\" \"exclude\" \"exp\" \"explode\" \"extend_constant\" \"extend_expr\" #> [55] \"fill_nan\" \"fill_null\" \"filter\" \"first\" \"flatten\" \"floor\" #> [61] \"forward_fill\" \"gt\" \"gt_eq\" \"hash\" \"head\" \"inspect\" #> [67] \"interpolate\" \"is_between\" \"is_duplicated\" \"is_finite\" \"is_first\" \"is_in\" #> [73] \"is_infinite\" \"is_nan\" \"is_not\" \"is_not_nan\" \"is_not_null\" \"is_null\" #> [79] \"is_unique\" \"keep_name\" \"kurtosis\" \"last\" \"len\" \"limit\" #> [85] \"list\" \"lit\" \"lit_to_df\" \"lit_to_s\" \"log\" \"log10\" #> [91] \"lower_bound\" \"lt\" \"lt_eq\" \"map\" \"map_alias\" \"max\" #> [97] \"mean\" \"median\" \"meta\" \"min\" \"mode\" \"mul\" #> [103] \"n_unique\" \"nan_max\" \"nan_min\" \"neq\" \"null_count\" \"or\" #> [109] \"over\" \"pct_change\" \"pow\" \"prefix\" \"print\" \"product\" #> [115] \"quantile\" \"rank\" \"rechunk\" \"reinterpret\" \"rep\" \"rep_extend\" #> [121] \"repeat_by\" \"reshape\" \"reverse\" \"rolling_max\" \"rolling_mean\" \"rolling_median\" #> [127] \"rolling_min\" \"rolling_quantile\" \"rolling_skew\" \"rolling_std\" \"rolling_sum\" \"rolling_var\" #> [133] \"round\" \"rpow\" \"sample\" \"search_sorted\" \"set_sorted\" \"shift\" #> [139] \"shift_and_fill\" \"shrink_dtype\" \"shuffle\" \"sign\" \"sin\" \"sinh\" #> [145] \"skew\" \"slice\" \"sort\" \"sort_by\" \"sqrt\" \"std\" #> [151] \"str\" \"struct\" \"sub\" \"suffix\" \"sum\" \"tail\" #> [157] \"take\" \"take_every\" \"tan\" \"tanh\" \"to_physical\" \"to_r\" #> [163] \"to_struct\" \"top_k\" \"unique\" \"unique_counts\" \"upper_bound\" \"value_counts\" #> [169] \"var\" \"where\" \"xor\" pl $ col ( \"this_column\" ) $ sum ( ) $ over ( \"that_column\" ) #> polars Expr: col(\"this_column\").sum().over([col(\"that_column\")]) #scalars to literal, explit `pl$lit(42)` implicit `+ 2` pl $ col ( \"some_column\" ) / pl $ lit ( 42 ) + 2 #> polars Expr: [([(col(\"some_column\")) / (42f64)]) + (2f64)] #vector to literal explicitly via Series and back again #R vector to expression and back again pl $ select ( pl $ lit ( pl $ Series ( 1 : 4 ) ) ) $ to_list ( ) [[ 1L ] ] #> [1] 1 2 3 4 #r vecot to literal and back r vector pl $ lit ( 1 : 4 ) $ to_r ( ) #> [1] 1 2 3 4 #r vector to literal to dataframe pl $ select ( pl $ lit ( 1 : 4 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2502 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 #r vector to literal to Series pl $ lit ( 1 : 4 ) $ lit_to_s ( ) #> polars Series: shape: (4,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> 4 #> ] #vectors to literal implicitly ( pl $ lit ( 2 ) + 1 : 4 ) / 4 : 1 #> polars Expr: [([(2f64) + (Series)]) / (Series)] pl $ col ( \"some\" ) $ suffix ( \"_column\" ) #> polars Expr: RENAME_ALIAS col(\"some\") pl $ col ( \"some\" ) $ suffix ( \"_column\" ) #> polars Expr: RENAME_ALIAS col(\"some\") pl $ DataFrame ( list ( a = 1 : 5 ) ) $ select ( pl $ col ( \"a\" ) $ reverse ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5 \u2502 #> \u2502 4 \u2502 #> \u2502 3 \u2502 #> \u2502 2 \u2502 #> \u2502 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr"},{"location":"reference/Expr/#polars-expr","text":"Expr_lit ( x ) Expr_suffix ( suffix ) Expr_prefix ( prefix ) Expr_reverse ()","title":"Polars Expr"},{"location":"reference/Expr/#arguments","text":"x : an R Scalar, or R vector/list (via Series) into Expr suffix : string suffix to be added to a name prefix : string suffix to be added to a name","title":"Arguments"},{"location":"reference/Expr/#returns","text":"Expr, literal of that value Expr Expr Expr Polars pl$Expr","title":"Returns"},{"location":"reference/Expr/#details","text":"pl$lit(NULL) translates into a typeless polars Null","title":"Details"},{"location":"reference/Expr/#examples","text":"2 + 2 #> [1] 4 #Expr has the following methods/constructors ls ( polars ::: Expr ) #> [1] \"abs\" \"add\" \"agg_groups\" \"alias\" \"all\" \"and\" #> [7] \"any\" \"append\" \"apply\" \"arccos\" \"arccosh\" \"arcsin\" #> [13] \"arcsinh\" \"arctan\" \"arctanh\" \"arg_max\" \"arg_min\" \"arg_sort\" #> [19] \"arg_unique\" \"argsort\" \"arr\" \"backward_fill\" \"bin\" \"cast\" #> [25] \"cat\" \"ceil\" \"clip\" \"clip_max\" \"clip_min\" \"cos\" #> [31] \"cosh\" \"count\" \"cumcount\" \"cummax\" \"cummin\" \"cumprod\" #> [37] \"cumsum\" \"cumulative_eval\" \"diff\" \"div\" \"dot\" \"drop_nans\" #> [43] \"drop_nulls\" \"dt\" \"entropy\" \"eq\" \"ewm_mean\" \"ewm_std\" #> [49] \"ewm_var\" \"exclude\" \"exp\" \"explode\" \"extend_constant\" \"extend_expr\" #> [55] \"fill_nan\" \"fill_null\" \"filter\" \"first\" \"flatten\" \"floor\" #> [61] \"forward_fill\" \"gt\" \"gt_eq\" \"hash\" \"head\" \"inspect\" #> [67] \"interpolate\" \"is_between\" \"is_duplicated\" \"is_finite\" \"is_first\" \"is_in\" #> [73] \"is_infinite\" \"is_nan\" \"is_not\" \"is_not_nan\" \"is_not_null\" \"is_null\" #> [79] \"is_unique\" \"keep_name\" \"kurtosis\" \"last\" \"len\" \"limit\" #> [85] \"list\" \"lit\" \"lit_to_df\" \"lit_to_s\" \"log\" \"log10\" #> [91] \"lower_bound\" \"lt\" \"lt_eq\" \"map\" \"map_alias\" \"max\" #> [97] \"mean\" \"median\" \"meta\" \"min\" \"mode\" \"mul\" #> [103] \"n_unique\" \"nan_max\" \"nan_min\" \"neq\" \"null_count\" \"or\" #> [109] \"over\" \"pct_change\" \"pow\" \"prefix\" \"print\" \"product\" #> [115] \"quantile\" \"rank\" \"rechunk\" \"reinterpret\" \"rep\" \"rep_extend\" #> [121] \"repeat_by\" \"reshape\" \"reverse\" \"rolling_max\" \"rolling_mean\" \"rolling_median\" #> [127] \"rolling_min\" \"rolling_quantile\" \"rolling_skew\" \"rolling_std\" \"rolling_sum\" \"rolling_var\" #> [133] \"round\" \"rpow\" \"sample\" \"search_sorted\" \"set_sorted\" \"shift\" #> [139] \"shift_and_fill\" \"shrink_dtype\" \"shuffle\" \"sign\" \"sin\" \"sinh\" #> [145] \"skew\" \"slice\" \"sort\" \"sort_by\" \"sqrt\" \"std\" #> [151] \"str\" \"struct\" \"sub\" \"suffix\" \"sum\" \"tail\" #> [157] \"take\" \"take_every\" \"tan\" \"tanh\" \"to_physical\" \"to_r\" #> [163] \"to_struct\" \"top_k\" \"unique\" \"unique_counts\" \"upper_bound\" \"value_counts\" #> [169] \"var\" \"where\" \"xor\" pl $ col ( \"this_column\" ) $ sum ( ) $ over ( \"that_column\" ) #> polars Expr: col(\"this_column\").sum().over([col(\"that_column\")]) #scalars to literal, explit `pl$lit(42)` implicit `+ 2` pl $ col ( \"some_column\" ) / pl $ lit ( 42 ) + 2 #> polars Expr: [([(col(\"some_column\")) / (42f64)]) + (2f64)] #vector to literal explicitly via Series and back again #R vector to expression and back again pl $ select ( pl $ lit ( pl $ Series ( 1 : 4 ) ) ) $ to_list ( ) [[ 1L ] ] #> [1] 1 2 3 4 #r vecot to literal and back r vector pl $ lit ( 1 : 4 ) $ to_r ( ) #> [1] 1 2 3 4 #r vector to literal to dataframe pl $ select ( pl $ lit ( 1 : 4 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2502 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 #r vector to literal to Series pl $ lit ( 1 : 4 ) $ lit_to_s ( ) #> polars Series: shape: (4,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> 4 #> ] #vectors to literal implicitly ( pl $ lit ( 2 ) + 1 : 4 ) / 4 : 1 #> polars Expr: [([(2f64) + (Series)]) / (Series)] pl $ col ( \"some\" ) $ suffix ( \"_column\" ) #> polars Expr: RENAME_ALIAS col(\"some\") pl $ col ( \"some\" ) $ suffix ( \"_column\" ) #> polars Expr: RENAME_ALIAS col(\"some\") pl $ DataFrame ( list ( a = 1 : 5 ) ) $ select ( pl $ col ( \"a\" ) $ reverse ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5 \u2502 #> \u2502 4 \u2502 #> \u2502 3 \u2502 #> \u2502 2 \u2502 #> \u2502 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprBin_contains/","text":"contains Arguments lit : The binary substring to look for Returns Expr returning a Boolean R Check if binaries in Series contain a binary substring.","title":"ExprBin_contains"},{"location":"reference/ExprBin_contains/#contains","text":"","title":"contains"},{"location":"reference/ExprBin_contains/#arguments","text":"lit : The binary substring to look for","title":"Arguments"},{"location":"reference/ExprBin_contains/#returns","text":"Expr returning a Boolean R Check if binaries in Series contain a binary substring.","title":"Returns"},{"location":"reference/ExprBin_decode/","text":"decode Arguments encoding : binary choice either 'hex' or 'base64' strict : Raise an error if the underlying value cannot be decoded, otherwise mask out with a null value. Returns binary array with values decoded using provided encoding Decode a value using the provided encoding.","title":"ExprBin_decode"},{"location":"reference/ExprBin_decode/#decode","text":"","title":"decode"},{"location":"reference/ExprBin_decode/#arguments","text":"encoding : binary choice either 'hex' or 'base64' strict : Raise an error if the underlying value cannot be decoded, otherwise mask out with a null value.","title":"Arguments"},{"location":"reference/ExprBin_decode/#returns","text":"binary array with values decoded using provided encoding Decode a value using the provided encoding.","title":"Returns"},{"location":"reference/ExprBin_encode/","text":"encode Arguments encoding : binary choice either 'hex' or 'base64' Returns binary array with values encoded using provided encoding Encode a value using the provided encoding.","title":"ExprBin_encode"},{"location":"reference/ExprBin_encode/#encode","text":"","title":"encode"},{"location":"reference/ExprBin_encode/#arguments","text":"encoding : binary choice either 'hex' or 'base64'","title":"Arguments"},{"location":"reference/ExprBin_encode/#returns","text":"binary array with values encoded using provided encoding Encode a value using the provided encoding.","title":"Returns"},{"location":"reference/ExprBin_ends_with/","text":"ends_with Returns Expr returning a Boolean Check if string values end with a binary substring.","title":"ExprBin_ends_with"},{"location":"reference/ExprBin_ends_with/#ends_with","text":"","title":"ends_with"},{"location":"reference/ExprBin_ends_with/#returns","text":"Expr returning a Boolean Check if string values end with a binary substring.","title":"Returns"},{"location":"reference/ExprBin_starts_with/","text":"starts_with Arguments sub : Prefix substring. Check if values starts with a binary substring.","title":"ExprBin_starts_with"},{"location":"reference/ExprBin_starts_with/#starts_with","text":"","title":"starts_with"},{"location":"reference/ExprBin_starts_with/#arguments","text":"sub : Prefix substring. Check if values starts with a binary substring.","title":"Arguments"},{"location":"reference/ExprCat_set_ordering/","text":"Set Ordering Arguments ordering : string either 'physical' or 'lexical' 'physical' -> Use the physical representation of the categories to determine the order (default). 'lexical' -> Use the string values to determine the ordering. Returns bool: TRUE if equal Determine how this categorical series should be sorted. Examples df = pl $ DataFrame ( cats = c ( \"z\" , \"z\" , \"k\" , \"a\" , \"b\" ) , vals = c ( 3 , 1 , 2 , 2 , 3 ) ) $ with_columns ( pl $ col ( \"cats\" ) $ cast ( pl $ Categorical ) $ cat $ set_ordering ( \"physical\" ) ) df $ select ( pl $ all ( ) $ sort ( ) ) #> polars DataFrame: shape: (5, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cats \u2506 vals \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 cat \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 z \u2506 1.0 \u2502 #> \u2502 z \u2506 2.0 \u2502 #> \u2502 k \u2506 2.0 \u2502 #> \u2502 a \u2506 3.0 \u2502 #> \u2502 b \u2506 3.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprCat_set_ordering"},{"location":"reference/ExprCat_set_ordering/#set-ordering","text":"","title":"Set Ordering"},{"location":"reference/ExprCat_set_ordering/#arguments","text":"ordering : string either 'physical' or 'lexical' 'physical' -> Use the physical representation of the categories to determine the order (default). 'lexical' -> Use the string values to determine the ordering.","title":"Arguments"},{"location":"reference/ExprCat_set_ordering/#returns","text":"bool: TRUE if equal Determine how this categorical series should be sorted.","title":"Returns"},{"location":"reference/ExprCat_set_ordering/#examples","text":"df = pl $ DataFrame ( cats = c ( \"z\" , \"z\" , \"k\" , \"a\" , \"b\" ) , vals = c ( 3 , 1 , 2 , 2 , 3 ) ) $ with_columns ( pl $ col ( \"cats\" ) $ cast ( pl $ Categorical ) $ cat $ set_ordering ( \"physical\" ) ) df $ select ( pl $ all ( ) $ sort ( ) ) #> polars DataFrame: shape: (5, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cats \u2506 vals \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 cat \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 z \u2506 1.0 \u2502 #> \u2502 z \u2506 2.0 \u2502 #> \u2502 k \u2506 2.0 \u2502 #> \u2502 a \u2506 3.0 \u2502 #> \u2502 b \u2506 3.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_cast_time_unit/","text":"cast_time_unit Format function Arguments tu : string option either 'ns', 'us', or 'ms' Returns Expr of i64 Cast the underlying data to another time unit. This may lose precision. The corresponding global timepoint will stay unchanged +/- precision. Examples df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2001-1-1\" ) , high = as.Date ( \"2001-1-3\" ) , interval = \"1d\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ dt $ cast_time_unit ( ) $ alias ( \"cast_time_unit_ns\" ) , pl $ col ( \"date\" ) $ dt $ cast_time_unit ( tu = \"ms\" ) $ alias ( \"cast_time_unit_ms\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 cast_time_unit_ns \u2506 cast_time_unit_ms \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 datetime[ns] \u2506 datetime[ms] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2001-01-01 00:00:00 \u2506 2001-01-01 00:00:00 \u2506 2001-01-01 00:00:00 \u2502 #> \u2502 2001-01-02 00:00:00 \u2506 2001-01-02 00:00:00 \u2506 2001-01-02 00:00:00 \u2502 #> \u2502 2001-01-03 00:00:00 \u2506 2001-01-03 00:00:00 \u2506 2001-01-03 00:00:00 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_cast_time_unit"},{"location":"reference/ExprDT_cast_time_unit/#cast_time_unit","text":"","title":"cast_time_unit"},{"location":"reference/ExprDT_cast_time_unit/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_cast_time_unit/#arguments","text":"tu : string option either 'ns', 'us', or 'ms'","title":"Arguments"},{"location":"reference/ExprDT_cast_time_unit/#returns","text":"Expr of i64 Cast the underlying data to another time unit. This may lose precision. The corresponding global timepoint will stay unchanged +/- precision.","title":"Returns"},{"location":"reference/ExprDT_cast_time_unit/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2001-1-1\" ) , high = as.Date ( \"2001-1-3\" ) , interval = \"1d\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ dt $ cast_time_unit ( ) $ alias ( \"cast_time_unit_ns\" ) , pl $ col ( \"date\" ) $ dt $ cast_time_unit ( tu = \"ms\" ) $ alias ( \"cast_time_unit_ms\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 cast_time_unit_ns \u2506 cast_time_unit_ms \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 datetime[ns] \u2506 datetime[ms] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2001-01-01 00:00:00 \u2506 2001-01-01 00:00:00 \u2506 2001-01-01 00:00:00 \u2502 #> \u2502 2001-01-02 00:00:00 \u2506 2001-01-02 00:00:00 \u2506 2001-01-02 00:00:00 \u2502 #> \u2502 2001-01-03 00:00:00 \u2506 2001-01-03 00:00:00 \u2506 2001-01-03 00:00:00 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_combine/","text":"Combine Data and Time Format function Arguments tm : Expr or numeric or PTime, the number of epoch since or before(if negative) the Date or tm is an Expr e.g. a column of DataType 'Time' or something into an Expr. tu : time unit of epochs, default is \"us\", if tm is a PTime, then tz passed via PTime. Returns Date/Datetime expr Create a naive Datetime from an existing Date/Datetime expression and a Time. Each date/datetime in the first half of the interval is mapped to the start of its bucket. Each date/datetime in the second half of the interval is mapped to the end of its bucket. Details The tu allows the following time time units the following string language: 1ns # 1 nanosecond 1us # 1 microsecond 1ms # 1 millisecond Examples #Using pl$PTime pl $ lit ( as.Date ( \"2021-01-01\" ) ) $ dt $ combine ( pl $ PTime ( \"02:34:12\" ) ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: '' [datetime[ns]] #> [ #> 2021-01-01 02:34:12 #> ] pl $ lit ( as.Date ( \"2021-01-01\" ) ) $ dt $ combine ( pl $ PTime ( 3600 * 1.5 , tu = \"s\" ) ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: '' [datetime[ns]] #> [ #> 2021-01-01 01:30:00 #> ] pl $ lit ( as.Date ( \"2021-01-01\" ) ) $ dt $ combine ( pl $ PTime ( 3600 * 1.5E6 + 123 , tu = \"us\" ) ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: '' [datetime[ns]] #> [ #> 2021-01-01 01:30:00.000123 #> ] #pass double and set tu manually pl $ lit ( as.Date ( \"2021-01-01\" ) ) $ dt $ combine ( 3600 * 1.5E6 + 123 , tu = \"us\" ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: '' [datetime[\u03bcs]] #> [ #> 2021-01-01 01:30:00.000123 #> ] #if needed to convert back to R it is more intuitive to set a specific time zone expr = pl $ lit ( as.Date ( \"2021-01-01\" ) ) $ dt $ combine ( 3600 * 1.5E6 + 123 , tu = \"us\" ) expr $ cast ( pl $ Datetime ( tu = \"us\" , tz = \"GMT\" ) ) $ to_r ( ) #> [1] \"2021-01-01 01:30:00 GMT\"","title":"ExprDT_combine"},{"location":"reference/ExprDT_combine/#combine-data-and-time","text":"","title":"Combine Data and Time"},{"location":"reference/ExprDT_combine/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_combine/#arguments","text":"tm : Expr or numeric or PTime, the number of epoch since or before(if negative) the Date or tm is an Expr e.g. a column of DataType 'Time' or something into an Expr. tu : time unit of epochs, default is \"us\", if tm is a PTime, then tz passed via PTime.","title":"Arguments"},{"location":"reference/ExprDT_combine/#returns","text":"Date/Datetime expr Create a naive Datetime from an existing Date/Datetime expression and a Time. Each date/datetime in the first half of the interval is mapped to the start of its bucket. Each date/datetime in the second half of the interval is mapped to the end of its bucket.","title":"Returns"},{"location":"reference/ExprDT_combine/#details","text":"The tu allows the following time time units the following string language: 1ns # 1 nanosecond 1us # 1 microsecond 1ms # 1 millisecond","title":"Details"},{"location":"reference/ExprDT_combine/#examples","text":"#Using pl$PTime pl $ lit ( as.Date ( \"2021-01-01\" ) ) $ dt $ combine ( pl $ PTime ( \"02:34:12\" ) ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: '' [datetime[ns]] #> [ #> 2021-01-01 02:34:12 #> ] pl $ lit ( as.Date ( \"2021-01-01\" ) ) $ dt $ combine ( pl $ PTime ( 3600 * 1.5 , tu = \"s\" ) ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: '' [datetime[ns]] #> [ #> 2021-01-01 01:30:00 #> ] pl $ lit ( as.Date ( \"2021-01-01\" ) ) $ dt $ combine ( pl $ PTime ( 3600 * 1.5E6 + 123 , tu = \"us\" ) ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: '' [datetime[ns]] #> [ #> 2021-01-01 01:30:00.000123 #> ] #pass double and set tu manually pl $ lit ( as.Date ( \"2021-01-01\" ) ) $ dt $ combine ( 3600 * 1.5E6 + 123 , tu = \"us\" ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: '' [datetime[\u03bcs]] #> [ #> 2021-01-01 01:30:00.000123 #> ] #if needed to convert back to R it is more intuitive to set a specific time zone expr = pl $ lit ( as.Date ( \"2021-01-01\" ) ) $ dt $ combine ( 3600 * 1.5E6 + 123 , tu = \"us\" ) expr $ cast ( pl $ Datetime ( tu = \"us\" , tz = \"GMT\" ) ) $ to_r ( ) #> [1] \"2021-01-01 01:30:00 GMT\"","title":"Examples"},{"location":"reference/ExprDT_convert_time_zone/","text":"With Time Zone Format function Arguments tz : String time zone from base::OlsonNames() Returns Expr of i64 Set time zone for a Series of type Datetime. Use to change time zone annotation, but keep the corresponding global timepoint. Details corresponds to in R manually modifying the tzone attribute of POSIXt objects Examples df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2001-3-1\" ) , high = as.Date ( \"2001-5-1\" ) , interval = \"1mo\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ dt $ replace_time_zone ( \"Europe/Amsterdam\" ) $ dt $ convert_time_zone ( \"Europe/London\" ) $ alias ( \"London_with\" ) , pl $ col ( \"date\" ) $ dt $ tz_localize ( \"Europe/London\" ) $ alias ( \"London_localize\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 London_with \u2506 London_localize \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 datetime[\u03bcs, Europe/London] \u2506 datetime[\u03bcs, Europe/London] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2001-03-01 00:00:00 \u2506 2001-02-28 23:00:00 GMT \u2506 2001-03-01 00:00:00 GMT \u2502 #> \u2502 2001-04-01 00:00:00 \u2506 2001-03-31 23:00:00 BST \u2506 2001-04-01 00:00:00 BST \u2502 #> \u2502 2001-05-01 00:00:00 \u2506 2001-04-30 23:00:00 BST \u2506 2001-05-01 00:00:00 BST \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_convert_time_zone"},{"location":"reference/ExprDT_convert_time_zone/#with-time-zone","text":"","title":"With Time Zone"},{"location":"reference/ExprDT_convert_time_zone/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_convert_time_zone/#arguments","text":"tz : String time zone from base::OlsonNames()","title":"Arguments"},{"location":"reference/ExprDT_convert_time_zone/#returns","text":"Expr of i64 Set time zone for a Series of type Datetime. Use to change time zone annotation, but keep the corresponding global timepoint.","title":"Returns"},{"location":"reference/ExprDT_convert_time_zone/#details","text":"corresponds to in R manually modifying the tzone attribute of POSIXt objects","title":"Details"},{"location":"reference/ExprDT_convert_time_zone/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2001-3-1\" ) , high = as.Date ( \"2001-5-1\" ) , interval = \"1mo\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ dt $ replace_time_zone ( \"Europe/Amsterdam\" ) $ dt $ convert_time_zone ( \"Europe/London\" ) $ alias ( \"London_with\" ) , pl $ col ( \"date\" ) $ dt $ tz_localize ( \"Europe/London\" ) $ alias ( \"London_localize\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 London_with \u2506 London_localize \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 datetime[\u03bcs, Europe/London] \u2506 datetime[\u03bcs, Europe/London] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2001-03-01 00:00:00 \u2506 2001-02-28 23:00:00 GMT \u2506 2001-03-01 00:00:00 GMT \u2502 #> \u2502 2001-04-01 00:00:00 \u2506 2001-03-31 23:00:00 BST \u2506 2001-04-01 00:00:00 BST \u2502 #> \u2502 2001-05-01 00:00:00 \u2506 2001-04-30 23:00:00 BST \u2506 2001-05-01 00:00:00 BST \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_day/","text":"Day Format function Returns Expr of day as UInt32 Extract day from underlying Date representation. Applies to Date and Datetime columns. Returns the day of month starting from 1. The return value ranges from 1 to 31. (The last day of month differs by months.) Examples df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ day ( ) $ alias ( \"day\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 day \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 25 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 26 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 27 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 28 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 2 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 3 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 4 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_day"},{"location":"reference/ExprDT_day/#day","text":"","title":"Day"},{"location":"reference/ExprDT_day/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_day/#returns","text":"Expr of day as UInt32 Extract day from underlying Date representation. Applies to Date and Datetime columns. Returns the day of month starting from 1. The return value ranges from 1 to 31. (The last day of month differs by months.)","title":"Returns"},{"location":"reference/ExprDT_day/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ day ( ) $ alias ( \"day\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 day \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 25 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 26 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 27 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 28 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 2 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 3 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 4 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_days/","text":"Days Format function Returns Expr of i64 Extract the days from a Duration type. Examples df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2020-3-1\" ) , high = as.Date ( \"2020-5-1\" ) , interval = \"1mo\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ diff ( ) $ dt $ days ( ) $ alias ( \"days_diff\" ) ) #> polars DataFrame: shape: (3, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 days_diff \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-03-01 00:00:00 \u2506 null \u2502 #> \u2502 2020-04-01 00:00:00 \u2506 31 \u2502 #> \u2502 2020-05-01 00:00:00 \u2506 30 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_days"},{"location":"reference/ExprDT_days/#days","text":"","title":"Days"},{"location":"reference/ExprDT_days/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_days/#returns","text":"Expr of i64 Extract the days from a Duration type.","title":"Returns"},{"location":"reference/ExprDT_days/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2020-3-1\" ) , high = as.Date ( \"2020-5-1\" ) , interval = \"1mo\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ diff ( ) $ dt $ days ( ) $ alias ( \"days_diff\" ) ) #> polars DataFrame: shape: (3, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 days_diff \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-03-01 00:00:00 \u2506 null \u2502 #> \u2502 2020-04-01 00:00:00 \u2506 31 \u2502 #> \u2502 2020-05-01 00:00:00 \u2506 30 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_epoch/","text":"Epoch Format function Arguments tu : string option either 'ns', 'us', 'ms', 's' or 'd' Returns Expr of epoch as UInt32 Get the time passed since the Unix EPOCH in the give time unit. Details ns and perhaps us will exceed integerish limit if returning to R as flaot64/double. Examples pl $ date_range ( as.Date ( \"2022-1-1\" ) ,lazy = TRUE ) $ dt $ epoch ( \"ns\" ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: 'literal' [i64] #> [ #> 1640995200000000000 #> ] pl $ date_range ( as.Date ( \"2022-1-1\" ) ,lazy = TRUE ) $ dt $ epoch ( \"ms\" ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: 'literal' [i64] #> [ #> 1640995200000 #> ] pl $ date_range ( as.Date ( \"2022-1-1\" ) ,lazy = TRUE ) $ dt $ epoch ( \"s\" ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: 'literal' [i64] #> [ #> 1640995200 #> ] pl $ date_range ( as.Date ( \"2022-1-1\" ) ,lazy = TRUE ) $ dt $ epoch ( \"d\" ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: 'literal' [i32] #> [ #> 18993 #> ]","title":"ExprDT_epoch"},{"location":"reference/ExprDT_epoch/#epoch","text":"","title":"Epoch"},{"location":"reference/ExprDT_epoch/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_epoch/#arguments","text":"tu : string option either 'ns', 'us', 'ms', 's' or 'd'","title":"Arguments"},{"location":"reference/ExprDT_epoch/#returns","text":"Expr of epoch as UInt32 Get the time passed since the Unix EPOCH in the give time unit.","title":"Returns"},{"location":"reference/ExprDT_epoch/#details","text":"ns and perhaps us will exceed integerish limit if returning to R as flaot64/double.","title":"Details"},{"location":"reference/ExprDT_epoch/#examples","text":"pl $ date_range ( as.Date ( \"2022-1-1\" ) ,lazy = TRUE ) $ dt $ epoch ( \"ns\" ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: 'literal' [i64] #> [ #> 1640995200000000000 #> ] pl $ date_range ( as.Date ( \"2022-1-1\" ) ,lazy = TRUE ) $ dt $ epoch ( \"ms\" ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: 'literal' [i64] #> [ #> 1640995200000 #> ] pl $ date_range ( as.Date ( \"2022-1-1\" ) ,lazy = TRUE ) $ dt $ epoch ( \"s\" ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: 'literal' [i64] #> [ #> 1640995200 #> ] pl $ date_range ( as.Date ( \"2022-1-1\" ) ,lazy = TRUE ) $ dt $ epoch ( \"d\" ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: 'literal' [i32] #> [ #> 18993 #> ]","title":"Examples"},{"location":"reference/ExprDT_hour/","text":"Hour Format function Returns Expr of hour as UInt32 Extract hour from underlying Datetime representation. Applies to Datetime columns. Returns the hour number from 0 to 23. Examples df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ hour ( ) $ alias ( \"hour\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 hour \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 0 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_hour"},{"location":"reference/ExprDT_hour/#hour","text":"","title":"Hour"},{"location":"reference/ExprDT_hour/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_hour/#returns","text":"Expr of hour as UInt32 Extract hour from underlying Datetime representation. Applies to Datetime columns. Returns the hour number from 0 to 23.","title":"Returns"},{"location":"reference/ExprDT_hour/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ hour ( ) $ alias ( \"hour\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 hour \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 0 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_hours/","text":"Hours Format function Returns Expr of i64 Extract the hours from a Duration type. Examples df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2020-1-1\" ) , high = as.Date ( \"2020-1-4\" ) , interval = \"1d\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ diff ( ) $ dt $ hours ( ) $ alias ( \"hours_diff\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 hours_diff \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-01-01 00:00:00 \u2506 null \u2502 #> \u2502 2020-01-02 00:00:00 \u2506 24 \u2502 #> \u2502 2020-01-03 00:00:00 \u2506 24 \u2502 #> \u2502 2020-01-04 00:00:00 \u2506 24 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_hours"},{"location":"reference/ExprDT_hours/#hours","text":"","title":"Hours"},{"location":"reference/ExprDT_hours/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_hours/#returns","text":"Expr of i64 Extract the hours from a Duration type.","title":"Returns"},{"location":"reference/ExprDT_hours/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2020-1-1\" ) , high = as.Date ( \"2020-1-4\" ) , interval = \"1d\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ diff ( ) $ dt $ hours ( ) $ alias ( \"hours_diff\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 hours_diff \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-01-01 00:00:00 \u2506 null \u2502 #> \u2502 2020-01-02 00:00:00 \u2506 24 \u2502 #> \u2502 2020-01-03 00:00:00 \u2506 24 \u2502 #> \u2502 2020-01-04 00:00:00 \u2506 24 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_iso_year/","text":"Iso-Year Format function Returns Expr of iso_year as Int32 Extract ISO year from underlying Date representation. Applies to Date and Datetime columns. Returns the year number in the ISO standard. This may not correspond with the calendar year. Examples df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ year ( ) $ alias ( \"year\" ) , pl $ col ( \"date\" ) $ dt $ iso_year ( ) $ alias ( \"iso_year\" ) ) #> polars DataFrame: shape: (12, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 year \u2506 iso_year \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 2021 \u2506 2020 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 2021 \u2506 2020 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 2021 \u2506 2021 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 2021 \u2506 2021 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_iso_year"},{"location":"reference/ExprDT_iso_year/#iso-year","text":"","title":"Iso-Year"},{"location":"reference/ExprDT_iso_year/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_iso_year/#returns","text":"Expr of iso_year as Int32 Extract ISO year from underlying Date representation. Applies to Date and Datetime columns. Returns the year number in the ISO standard. This may not correspond with the calendar year.","title":"Returns"},{"location":"reference/ExprDT_iso_year/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ year ( ) $ alias ( \"year\" ) , pl $ col ( \"date\" ) $ dt $ iso_year ( ) $ alias ( \"iso_year\" ) ) #> polars DataFrame: shape: (12, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 year \u2506 iso_year \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 2021 \u2506 2020 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 2021 \u2506 2020 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 2021 \u2506 2021 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 2021 \u2506 2021 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_microsecond/","text":"Microsecond Format function Returns Expr of microsecond as Int64 Extract microseconds from underlying Datetime representation. Applies to Datetime columns. Examples pl $ DataFrame ( date = pl $ date_range ( as.numeric ( as.POSIXct ( \"2001-1-1\" ) ) * 1E6 + 456789 , #manually convert to us as.numeric ( as.POSIXct ( \"2001-1-1 00:00:6\" ) ) * 1E6 , interval = \"2s654321us\" , time_unit = \"us\" #instruct polars input is us, and store as us ) ) $ with_columns ( pl $ col ( \"date\" ) $ cast ( pl $ Int64 ) $ alias ( \"datetime int64\" ) , pl $ col ( \"date\" ) $ dt $ microsecond ( ) $ alias ( \"microsecond\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 datetime int64 \u2506 microsecond \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2000-12-31 23:00:00.456 \u2506 978303600456000 \u2506 456000 \u2502 #> \u2502 2000-12-31 23:00:03.110 \u2506 978303603110000 \u2506 110000 \u2502 #> \u2502 2000-12-31 23:00:05.764 \u2506 978303605764000 \u2506 764000 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_microsecond"},{"location":"reference/ExprDT_microsecond/#microsecond","text":"","title":"Microsecond"},{"location":"reference/ExprDT_microsecond/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_microsecond/#returns","text":"Expr of microsecond as Int64 Extract microseconds from underlying Datetime representation. Applies to Datetime columns.","title":"Returns"},{"location":"reference/ExprDT_microsecond/#examples","text":"pl $ DataFrame ( date = pl $ date_range ( as.numeric ( as.POSIXct ( \"2001-1-1\" ) ) * 1E6 + 456789 , #manually convert to us as.numeric ( as.POSIXct ( \"2001-1-1 00:00:6\" ) ) * 1E6 , interval = \"2s654321us\" , time_unit = \"us\" #instruct polars input is us, and store as us ) ) $ with_columns ( pl $ col ( \"date\" ) $ cast ( pl $ Int64 ) $ alias ( \"datetime int64\" ) , pl $ col ( \"date\" ) $ dt $ microsecond ( ) $ alias ( \"microsecond\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 datetime int64 \u2506 microsecond \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2000-12-31 23:00:00.456 \u2506 978303600456000 \u2506 456000 \u2502 #> \u2502 2000-12-31 23:00:03.110 \u2506 978303603110000 \u2506 110000 \u2502 #> \u2502 2000-12-31 23:00:05.764 \u2506 978303605764000 \u2506 764000 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_microseconds/","text":"microseconds Format function Returns Expr of i64 Extract the microseconds from a Duration type. Examples df = pl $ DataFrame ( date = pl $ date_range ( low = as.POSIXct ( \"2020-1-1\" , tz = \"GMT\" ) , high = as.POSIXct ( \"2020-1-1 00:00:01\" , tz = \"GMT\" ) , interval = \"1ms\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ diff ( ) $ dt $ microseconds ( ) $ alias ( \"seconds_diff\" ) ) #> polars DataFrame: shape: (1001, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 seconds_diff \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-01-01 00:00:00 \u2506 null \u2502 #> \u2502 2020-01-01 00:00:00.001 \u2506 1000 \u2502 #> \u2502 2020-01-01 00:00:00.002 \u2506 1000 \u2502 #> \u2502 2020-01-01 00:00:00.003 \u2506 1000 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2020-01-01 00:00:00.997 \u2506 1000 \u2502 #> \u2502 2020-01-01 00:00:00.998 \u2506 1000 \u2502 #> \u2502 2020-01-01 00:00:00.999 \u2506 1000 \u2502 #> \u2502 2020-01-01 00:00:01 \u2506 1000 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_microseconds"},{"location":"reference/ExprDT_microseconds/#microseconds","text":"","title":"microseconds"},{"location":"reference/ExprDT_microseconds/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_microseconds/#returns","text":"Expr of i64 Extract the microseconds from a Duration type.","title":"Returns"},{"location":"reference/ExprDT_microseconds/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( low = as.POSIXct ( \"2020-1-1\" , tz = \"GMT\" ) , high = as.POSIXct ( \"2020-1-1 00:00:01\" , tz = \"GMT\" ) , interval = \"1ms\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ diff ( ) $ dt $ microseconds ( ) $ alias ( \"seconds_diff\" ) ) #> polars DataFrame: shape: (1001, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 seconds_diff \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-01-01 00:00:00 \u2506 null \u2502 #> \u2502 2020-01-01 00:00:00.001 \u2506 1000 \u2502 #> \u2502 2020-01-01 00:00:00.002 \u2506 1000 \u2502 #> \u2502 2020-01-01 00:00:00.003 \u2506 1000 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2020-01-01 00:00:00.997 \u2506 1000 \u2502 #> \u2502 2020-01-01 00:00:00.998 \u2506 1000 \u2502 #> \u2502 2020-01-01 00:00:00.999 \u2506 1000 \u2502 #> \u2502 2020-01-01 00:00:01 \u2506 1000 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_millisecond/","text":"Millisecond Format function Returns Expr of millisecond as Int64 Extract milliseconds from underlying Datetime representation. Applies to Datetime columns. Examples pl $ DataFrame ( date = pl $ date_range ( as.numeric ( as.POSIXct ( \"2001-1-1\" ) ) * 1E6 + 456789 , #manually convert to us as.numeric ( as.POSIXct ( \"2001-1-1 00:00:6\" ) ) * 1E6 , interval = \"2s654321us\" , time_unit = \"us\" #instruct polars input is us, and store as us ) ) $ with_columns ( pl $ col ( \"date\" ) $ cast ( pl $ Int64 ) $ alias ( \"datetime int64\" ) , pl $ col ( \"date\" ) $ dt $ millisecond ( ) $ alias ( \"millisecond\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 datetime int64 \u2506 millisecond \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2000-12-31 23:00:00.456 \u2506 978303600456000 \u2506 456 \u2502 #> \u2502 2000-12-31 23:00:03.110 \u2506 978303603110000 \u2506 110 \u2502 #> \u2502 2000-12-31 23:00:05.764 \u2506 978303605764000 \u2506 764 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_millisecond"},{"location":"reference/ExprDT_millisecond/#millisecond","text":"","title":"Millisecond"},{"location":"reference/ExprDT_millisecond/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_millisecond/#returns","text":"Expr of millisecond as Int64 Extract milliseconds from underlying Datetime representation. Applies to Datetime columns.","title":"Returns"},{"location":"reference/ExprDT_millisecond/#examples","text":"pl $ DataFrame ( date = pl $ date_range ( as.numeric ( as.POSIXct ( \"2001-1-1\" ) ) * 1E6 + 456789 , #manually convert to us as.numeric ( as.POSIXct ( \"2001-1-1 00:00:6\" ) ) * 1E6 , interval = \"2s654321us\" , time_unit = \"us\" #instruct polars input is us, and store as us ) ) $ with_columns ( pl $ col ( \"date\" ) $ cast ( pl $ Int64 ) $ alias ( \"datetime int64\" ) , pl $ col ( \"date\" ) $ dt $ millisecond ( ) $ alias ( \"millisecond\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 datetime int64 \u2506 millisecond \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2000-12-31 23:00:00.456 \u2506 978303600456000 \u2506 456 \u2502 #> \u2502 2000-12-31 23:00:03.110 \u2506 978303603110000 \u2506 110 \u2502 #> \u2502 2000-12-31 23:00:05.764 \u2506 978303605764000 \u2506 764 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_milliseconds/","text":"milliseconds Format function Returns Expr of i64 Extract the milliseconds from a Duration type. Examples df = pl $ DataFrame ( date = pl $ date_range ( low = as.POSIXct ( \"2020-1-1\" , tz = \"GMT\" ) , high = as.POSIXct ( \"2020-1-1 00:00:01\" , tz = \"GMT\" ) , interval = \"1ms\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ diff ( ) $ dt $ milliseconds ( ) $ alias ( \"seconds_diff\" ) ) #> polars DataFrame: shape: (1001, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 seconds_diff \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-01-01 00:00:00 \u2506 null \u2502 #> \u2502 2020-01-01 00:00:00.001 \u2506 1 \u2502 #> \u2502 2020-01-01 00:00:00.002 \u2506 1 \u2502 #> \u2502 2020-01-01 00:00:00.003 \u2506 1 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2020-01-01 00:00:00.997 \u2506 1 \u2502 #> \u2502 2020-01-01 00:00:00.998 \u2506 1 \u2502 #> \u2502 2020-01-01 00:00:00.999 \u2506 1 \u2502 #> \u2502 2020-01-01 00:00:01 \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_milliseconds"},{"location":"reference/ExprDT_milliseconds/#milliseconds","text":"","title":"milliseconds"},{"location":"reference/ExprDT_milliseconds/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_milliseconds/#returns","text":"Expr of i64 Extract the milliseconds from a Duration type.","title":"Returns"},{"location":"reference/ExprDT_milliseconds/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( low = as.POSIXct ( \"2020-1-1\" , tz = \"GMT\" ) , high = as.POSIXct ( \"2020-1-1 00:00:01\" , tz = \"GMT\" ) , interval = \"1ms\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ diff ( ) $ dt $ milliseconds ( ) $ alias ( \"seconds_diff\" ) ) #> polars DataFrame: shape: (1001, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 seconds_diff \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-01-01 00:00:00 \u2506 null \u2502 #> \u2502 2020-01-01 00:00:00.001 \u2506 1 \u2502 #> \u2502 2020-01-01 00:00:00.002 \u2506 1 \u2502 #> \u2502 2020-01-01 00:00:00.003 \u2506 1 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2020-01-01 00:00:00.997 \u2506 1 \u2502 #> \u2502 2020-01-01 00:00:00.998 \u2506 1 \u2502 #> \u2502 2020-01-01 00:00:00.999 \u2506 1 \u2502 #> \u2502 2020-01-01 00:00:01 \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_minute/","text":"Minute Format function Returns Expr of minute as UInt32 Extract minutes from underlying Datetime representation. Applies to Datetime columns. Returns the minute number from 0 to 59. Examples df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ minute ( ) $ alias ( \"minute\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 minute \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 0 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_minute"},{"location":"reference/ExprDT_minute/#minute","text":"","title":"Minute"},{"location":"reference/ExprDT_minute/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_minute/#returns","text":"Expr of minute as UInt32 Extract minutes from underlying Datetime representation. Applies to Datetime columns. Returns the minute number from 0 to 59.","title":"Returns"},{"location":"reference/ExprDT_minute/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ minute ( ) $ alias ( \"minute\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 minute \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 0 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 0 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_minutes/","text":"Minutes Format function Returns Expr of i64 Extract the minutes from a Duration type. Examples df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2020-1-1\" ) , high = as.Date ( \"2020-1-4\" ) , interval = \"1d\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ diff ( ) $ dt $ minutes ( ) $ alias ( \"minutes_diff\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 minutes_diff \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-01-01 00:00:00 \u2506 null \u2502 #> \u2502 2020-01-02 00:00:00 \u2506 1440 \u2502 #> \u2502 2020-01-03 00:00:00 \u2506 1440 \u2502 #> \u2502 2020-01-04 00:00:00 \u2506 1440 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_minutes"},{"location":"reference/ExprDT_minutes/#minutes","text":"","title":"Minutes"},{"location":"reference/ExprDT_minutes/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_minutes/#returns","text":"Expr of i64 Extract the minutes from a Duration type.","title":"Returns"},{"location":"reference/ExprDT_minutes/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2020-1-1\" ) , high = as.Date ( \"2020-1-4\" ) , interval = \"1d\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ diff ( ) $ dt $ minutes ( ) $ alias ( \"minutes_diff\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 minutes_diff \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-01-01 00:00:00 \u2506 null \u2502 #> \u2502 2020-01-02 00:00:00 \u2506 1440 \u2502 #> \u2502 2020-01-03 00:00:00 \u2506 1440 \u2502 #> \u2502 2020-01-04 00:00:00 \u2506 1440 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_month/","text":"Month Format function Returns Expr of month as UInt32 Extract month from underlying Date representation. Applies to Date and Datetime columns. Returns the month number starting from 1. The return value ranges from 1 to 12. Examples df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ month ( ) $ alias ( \"month\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 month \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 12 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 12 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 12 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 12 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_month"},{"location":"reference/ExprDT_month/#month","text":"","title":"Month"},{"location":"reference/ExprDT_month/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_month/#returns","text":"Expr of month as UInt32 Extract month from underlying Date representation. Applies to Date and Datetime columns. Returns the month number starting from 1. The return value ranges from 1 to 12.","title":"Returns"},{"location":"reference/ExprDT_month/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ month ( ) $ alias ( \"month\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 month \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 12 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 12 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 12 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 12 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_nanosecond/","text":"Nanosecond Format function Returns Expr of second as Int64 Extract seconds from underlying Datetime representation. Applies to Datetime columns. Returns the integer second number from 0 to 59, or a floating point number from 0 < 60 if fractional=True that includes any milli/micro/nanosecond component. Examples pl $ DataFrame ( date = pl $ date_range ( as.numeric ( as.POSIXct ( \"2001-1-1\" ) ) * 1E9 + 123456789 , #manually convert to us as.numeric ( as.POSIXct ( \"2001-1-1 00:00:6\" ) ) * 1E9 , interval = \"1s987654321ns\" , time_unit = \"ns\" #instruct polars input is us, and store as us ) ) $ with_columns ( pl $ col ( \"date\" ) $ cast ( pl $ Int64 ) $ alias ( \"datetime int64\" ) , pl $ col ( \"date\" ) $ dt $ nanosecond ( ) $ alias ( \"nanosecond\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 datetime int64 \u2506 nanosecond \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[ns] \u2506 i64 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2000-12-31 23:00:00.123 \u2506 978303600123000000 \u2506 123000000 \u2502 #> \u2502 2000-12-31 23:00:02.110 \u2506 978303602110000000 \u2506 110000000 \u2502 #> \u2502 2000-12-31 23:00:04.097 \u2506 978303604097000000 \u2506 97000000 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_nanosecond"},{"location":"reference/ExprDT_nanosecond/#nanosecond","text":"","title":"Nanosecond"},{"location":"reference/ExprDT_nanosecond/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_nanosecond/#returns","text":"Expr of second as Int64 Extract seconds from underlying Datetime representation. Applies to Datetime columns. Returns the integer second number from 0 to 59, or a floating point number from 0 < 60 if fractional=True that includes any milli/micro/nanosecond component.","title":"Returns"},{"location":"reference/ExprDT_nanosecond/#examples","text":"pl $ DataFrame ( date = pl $ date_range ( as.numeric ( as.POSIXct ( \"2001-1-1\" ) ) * 1E9 + 123456789 , #manually convert to us as.numeric ( as.POSIXct ( \"2001-1-1 00:00:6\" ) ) * 1E9 , interval = \"1s987654321ns\" , time_unit = \"ns\" #instruct polars input is us, and store as us ) ) $ with_columns ( pl $ col ( \"date\" ) $ cast ( pl $ Int64 ) $ alias ( \"datetime int64\" ) , pl $ col ( \"date\" ) $ dt $ nanosecond ( ) $ alias ( \"nanosecond\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 datetime int64 \u2506 nanosecond \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[ns] \u2506 i64 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2000-12-31 23:00:00.123 \u2506 978303600123000000 \u2506 123000000 \u2502 #> \u2502 2000-12-31 23:00:02.110 \u2506 978303602110000000 \u2506 110000000 \u2502 #> \u2502 2000-12-31 23:00:04.097 \u2506 978303604097000000 \u2506 97000000 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_nanoseconds/","text":"nanoseconds Format function Returns Expr of i64 Extract the nanoseconds from a Duration type. Examples df = pl $ DataFrame ( date = pl $ date_range ( low = as.POSIXct ( \"2020-1-1\" , tz = \"GMT\" ) , high = as.POSIXct ( \"2020-1-1 00:00:01\" , tz = \"GMT\" ) , interval = \"1ms\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ diff ( ) $ dt $ nanoseconds ( ) $ alias ( \"seconds_diff\" ) ) #> polars DataFrame: shape: (1001, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 seconds_diff \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-01-01 00:00:00 \u2506 null \u2502 #> \u2502 2020-01-01 00:00:00.001 \u2506 1000000 \u2502 #> \u2502 2020-01-01 00:00:00.002 \u2506 1000000 \u2502 #> \u2502 2020-01-01 00:00:00.003 \u2506 1000000 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2020-01-01 00:00:00.997 \u2506 1000000 \u2502 #> \u2502 2020-01-01 00:00:00.998 \u2506 1000000 \u2502 #> \u2502 2020-01-01 00:00:00.999 \u2506 1000000 \u2502 #> \u2502 2020-01-01 00:00:01 \u2506 1000000 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_nanoseconds"},{"location":"reference/ExprDT_nanoseconds/#nanoseconds","text":"","title":"nanoseconds"},{"location":"reference/ExprDT_nanoseconds/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_nanoseconds/#returns","text":"Expr of i64 Extract the nanoseconds from a Duration type.","title":"Returns"},{"location":"reference/ExprDT_nanoseconds/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( low = as.POSIXct ( \"2020-1-1\" , tz = \"GMT\" ) , high = as.POSIXct ( \"2020-1-1 00:00:01\" , tz = \"GMT\" ) , interval = \"1ms\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ diff ( ) $ dt $ nanoseconds ( ) $ alias ( \"seconds_diff\" ) ) #> polars DataFrame: shape: (1001, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 seconds_diff \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-01-01 00:00:00 \u2506 null \u2502 #> \u2502 2020-01-01 00:00:00.001 \u2506 1000000 \u2502 #> \u2502 2020-01-01 00:00:00.002 \u2506 1000000 \u2502 #> \u2502 2020-01-01 00:00:00.003 \u2506 1000000 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2020-01-01 00:00:00.997 \u2506 1000000 \u2502 #> \u2502 2020-01-01 00:00:00.998 \u2506 1000000 \u2502 #> \u2502 2020-01-01 00:00:00.999 \u2506 1000000 \u2502 #> \u2502 2020-01-01 00:00:01 \u2506 1000000 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_offset_by/","text":"Offset By Format function Arguments by : optional string encoding duration see details. Returns Date/Datetime expr Offset this date by a relative time offset. This differs from pl$col(\"foo_datetime_tu\") + value_tu in that it can take months and leap years into account. Note that only a single minus sign is allowed in the by string, as the first character. Details The by are created with the the following string language: 1ns # 1 nanosecond 1us # 1 microsecond 1ms # 1 millisecond 1s # 1 second 1m # 1 minute 1h # 1 hour 1d # 1 day 1w # 1 calendar week 1mo # 1 calendar month 1y # 1 calendar year 1i # 1 index count These strings can be combined: 3d12h4m25s # 3 days, 12 hours, 4 minutes, and 25 seconds Examples df = pl $ DataFrame ( dates = pl $ date_range ( as.Date ( \"2000-1-1\" ) , as.Date ( \"2005-1-1\" ) , \"1y\" ) ) df $ select ( pl $ col ( \"dates\" ) $ dt $ offset_by ( \"1y\" ) $ alias ( \"date_plus_1y\" ) , pl $ col ( \"dates\" ) $ dt $ offset_by ( \"-1y2mo\" ) $ alias ( \"date_min\" ) ) #> polars DataFrame: shape: (6, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date_plus_1y \u2506 date_min \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 datetime[\u03bcs] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2001-01-01 00:00:00 \u2506 1998-11-01 00:00:00 \u2502 #> \u2502 2002-01-01 00:00:00 \u2506 1999-11-01 00:00:00 \u2502 #> \u2502 2003-01-01 00:00:00 \u2506 2000-11-01 00:00:00 \u2502 #> \u2502 2004-01-01 00:00:00 \u2506 2001-11-01 00:00:00 \u2502 #> \u2502 2005-01-01 00:00:00 \u2506 2002-11-01 00:00:00 \u2502 #> \u2502 2006-01-01 00:00:00 \u2506 2003-11-01 00:00:00 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_offset_by"},{"location":"reference/ExprDT_offset_by/#offset-by","text":"","title":"Offset By"},{"location":"reference/ExprDT_offset_by/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_offset_by/#arguments","text":"by : optional string encoding duration see details.","title":"Arguments"},{"location":"reference/ExprDT_offset_by/#returns","text":"Date/Datetime expr Offset this date by a relative time offset. This differs from pl$col(\"foo_datetime_tu\") + value_tu in that it can take months and leap years into account. Note that only a single minus sign is allowed in the by string, as the first character.","title":"Returns"},{"location":"reference/ExprDT_offset_by/#details","text":"The by are created with the the following string language: 1ns # 1 nanosecond 1us # 1 microsecond 1ms # 1 millisecond 1s # 1 second 1m # 1 minute 1h # 1 hour 1d # 1 day 1w # 1 calendar week 1mo # 1 calendar month 1y # 1 calendar year 1i # 1 index count These strings can be combined: 3d12h4m25s # 3 days, 12 hours, 4 minutes, and 25 seconds","title":"Details"},{"location":"reference/ExprDT_offset_by/#examples","text":"df = pl $ DataFrame ( dates = pl $ date_range ( as.Date ( \"2000-1-1\" ) , as.Date ( \"2005-1-1\" ) , \"1y\" ) ) df $ select ( pl $ col ( \"dates\" ) $ dt $ offset_by ( \"1y\" ) $ alias ( \"date_plus_1y\" ) , pl $ col ( \"dates\" ) $ dt $ offset_by ( \"-1y2mo\" ) $ alias ( \"date_min\" ) ) #> polars DataFrame: shape: (6, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date_plus_1y \u2506 date_min \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 datetime[\u03bcs] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2001-01-01 00:00:00 \u2506 1998-11-01 00:00:00 \u2502 #> \u2502 2002-01-01 00:00:00 \u2506 1999-11-01 00:00:00 \u2502 #> \u2502 2003-01-01 00:00:00 \u2506 2000-11-01 00:00:00 \u2502 #> \u2502 2004-01-01 00:00:00 \u2506 2001-11-01 00:00:00 \u2502 #> \u2502 2005-01-01 00:00:00 \u2506 2002-11-01 00:00:00 \u2502 #> \u2502 2006-01-01 00:00:00 \u2506 2003-11-01 00:00:00 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_ordinal_day/","text":"Ordinal Day Format function Returns Expr of ordinal_day as UInt32 Extract ordinal day from underlying Date representation. Applies to Date and Datetime columns. Returns the day of year starting from 1. The return value ranges from 1 to 366. (The last day of year differs by years.) Examples df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ ordinal_day ( ) $ alias ( \"ordinal_day\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 ordinal_day \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 360 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 361 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 362 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 363 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 2 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 3 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 4 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_ordinal_day"},{"location":"reference/ExprDT_ordinal_day/#ordinal-day","text":"","title":"Ordinal Day"},{"location":"reference/ExprDT_ordinal_day/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_ordinal_day/#returns","text":"Expr of ordinal_day as UInt32 Extract ordinal day from underlying Date representation. Applies to Date and Datetime columns. Returns the day of year starting from 1. The return value ranges from 1 to 366. (The last day of year differs by years.)","title":"Returns"},{"location":"reference/ExprDT_ordinal_day/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ ordinal_day ( ) $ alias ( \"ordinal_day\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 ordinal_day \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 360 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 361 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 362 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 363 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 2 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 3 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 4 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_quarter/","text":"Quarter Format function Returns Expr of quater as UInt32 Extract quarter from underlying Date representation. Applies to Date and Datetime columns. Returns the quarter ranging from 1 to 4. Examples df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ quarter ( ) $ alias ( \"quarter\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 quarter \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 4 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 4 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 4 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 4 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_quarter"},{"location":"reference/ExprDT_quarter/#quarter","text":"","title":"Quarter"},{"location":"reference/ExprDT_quarter/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_quarter/#returns","text":"Expr of quater as UInt32 Extract quarter from underlying Date representation. Applies to Date and Datetime columns. Returns the quarter ranging from 1 to 4.","title":"Returns"},{"location":"reference/ExprDT_quarter/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ quarter ( ) $ alias ( \"quarter\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 quarter \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 4 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 4 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 4 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 4 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_replace_time_zone/","text":"replace_time_zone Format function Arguments tz : Null or string time zone from base::OlsonNames() Returns Expr of i64 Cast time zone for a Series of type Datetime. Different from convert_time_zone , this will also modify the underlying timestamp. Use to correct a wrong time zone annotation. This will change the corresponding global timepoint. Examples df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2001-3-1\" ) , high = as.Date ( \"2001-7-1\" ) , interval = \"1mo\" ) ) df = df $ with_columns ( pl $ col ( \"date\" ) $ dt $ replace_time_zone ( \"Europe/Amsterdam\" ) $ dt $ convert_time_zone ( \"Europe/London\" ) $ alias ( \"london_timezone\" ) ) df2 = df $ with_columns ( pl $ col ( \"london_timezone\" ) $ dt $ replace_time_zone ( \"Europe/Amsterdam\" ) $ alias ( \"cast London_to_Amsterdam\" ) , pl $ col ( \"london_timezone\" ) $ dt $ convert_time_zone ( \"Europe/Amsterdam\" ) $ alias ( \"with London_to_Amsterdam\" ) , pl $ col ( \"london_timezone\" ) $ dt $ convert_time_zone ( \"Europe/Amsterdam\" ) $ dt $ replace_time_zone ( NULL ) $ alias ( \"strip tz from with-'Europe/Amsterdam'\" ) ) df2 #> polars DataFrame: shape: (5, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 london_timezone \u2506 cast \u2506 with \u2506 strip tz from with- \u2502 #> \u2502 --- \u2506 --- \u2506 London_to_Amsterdam \u2506 London_to_Amsterdam \u2506 'Europe/Amste... \u2502 #> \u2502 datetime[\u03bcs] \u2506 datetime[\u03bcs, \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 \u2506 Europe/London] \u2506 datetime[\u03bcs, \u2506 datetime[\u03bcs, \u2506 datetime[\u03bcs] \u2502 #> \u2502 \u2506 \u2506 Europe/Amsterdam] \u2506 Europe/Amsterdam] \u2506 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2001-03-01 \u2506 2001-02-28 \u2506 2001-02-28 23:00:00 \u2506 2001-03-01 00:00:00 \u2506 2001-03-01 00:00:00 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 GMT \u2506 CET \u2506 CET \u2506 \u2502 #> \u2502 2001-04-01 \u2506 2001-03-31 \u2506 2001-03-31 23:00:00 \u2506 2001-04-01 00:00:00 \u2506 2001-04-01 00:00:00 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 CEST \u2506 CEST \u2506 \u2502 #> \u2502 2001-05-01 \u2506 2001-04-30 \u2506 2001-04-30 23:00:00 \u2506 2001-05-01 00:00:00 \u2506 2001-05-01 00:00:00 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 CEST \u2506 CEST \u2506 \u2502 #> \u2502 2001-06-01 \u2506 2001-05-31 \u2506 2001-05-31 23:00:00 \u2506 2001-06-01 00:00:00 \u2506 2001-06-01 00:00:00 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 CEST \u2506 CEST \u2506 \u2502 #> \u2502 2001-07-01 \u2506 2001-06-30 \u2506 2001-06-30 23:00:00 \u2506 2001-07-01 00:00:00 \u2506 2001-07-01 00:00:00 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 CEST \u2506 CEST \u2506 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_replace_time_zone"},{"location":"reference/ExprDT_replace_time_zone/#replace_time_zone","text":"","title":"replace_time_zone"},{"location":"reference/ExprDT_replace_time_zone/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_replace_time_zone/#arguments","text":"tz : Null or string time zone from base::OlsonNames()","title":"Arguments"},{"location":"reference/ExprDT_replace_time_zone/#returns","text":"Expr of i64 Cast time zone for a Series of type Datetime. Different from convert_time_zone , this will also modify the underlying timestamp. Use to correct a wrong time zone annotation. This will change the corresponding global timepoint.","title":"Returns"},{"location":"reference/ExprDT_replace_time_zone/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2001-3-1\" ) , high = as.Date ( \"2001-7-1\" ) , interval = \"1mo\" ) ) df = df $ with_columns ( pl $ col ( \"date\" ) $ dt $ replace_time_zone ( \"Europe/Amsterdam\" ) $ dt $ convert_time_zone ( \"Europe/London\" ) $ alias ( \"london_timezone\" ) ) df2 = df $ with_columns ( pl $ col ( \"london_timezone\" ) $ dt $ replace_time_zone ( \"Europe/Amsterdam\" ) $ alias ( \"cast London_to_Amsterdam\" ) , pl $ col ( \"london_timezone\" ) $ dt $ convert_time_zone ( \"Europe/Amsterdam\" ) $ alias ( \"with London_to_Amsterdam\" ) , pl $ col ( \"london_timezone\" ) $ dt $ convert_time_zone ( \"Europe/Amsterdam\" ) $ dt $ replace_time_zone ( NULL ) $ alias ( \"strip tz from with-'Europe/Amsterdam'\" ) ) df2 #> polars DataFrame: shape: (5, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 london_timezone \u2506 cast \u2506 with \u2506 strip tz from with- \u2502 #> \u2502 --- \u2506 --- \u2506 London_to_Amsterdam \u2506 London_to_Amsterdam \u2506 'Europe/Amste... \u2502 #> \u2502 datetime[\u03bcs] \u2506 datetime[\u03bcs, \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 \u2506 Europe/London] \u2506 datetime[\u03bcs, \u2506 datetime[\u03bcs, \u2506 datetime[\u03bcs] \u2502 #> \u2502 \u2506 \u2506 Europe/Amsterdam] \u2506 Europe/Amsterdam] \u2506 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2001-03-01 \u2506 2001-02-28 \u2506 2001-02-28 23:00:00 \u2506 2001-03-01 00:00:00 \u2506 2001-03-01 00:00:00 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 GMT \u2506 CET \u2506 CET \u2506 \u2502 #> \u2502 2001-04-01 \u2506 2001-03-31 \u2506 2001-03-31 23:00:00 \u2506 2001-04-01 00:00:00 \u2506 2001-04-01 00:00:00 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 CEST \u2506 CEST \u2506 \u2502 #> \u2502 2001-05-01 \u2506 2001-04-30 \u2506 2001-04-30 23:00:00 \u2506 2001-05-01 00:00:00 \u2506 2001-05-01 00:00:00 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 CEST \u2506 CEST \u2506 \u2502 #> \u2502 2001-06-01 \u2506 2001-05-31 \u2506 2001-05-31 23:00:00 \u2506 2001-06-01 00:00:00 \u2506 2001-06-01 00:00:00 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 CEST \u2506 CEST \u2506 \u2502 #> \u2502 2001-07-01 \u2506 2001-06-30 \u2506 2001-06-30 23:00:00 \u2506 2001-07-01 00:00:00 \u2506 2001-07-01 00:00:00 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 CEST \u2506 CEST \u2506 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_round/","text":"Round datetime Format function Arguments every : string encoding duration see details. ofset : optional string encoding duration see details. Returns Date/Datetime expr Divide the date/datetime range into buckets. Each date/datetime in the first half of the interval is mapped to the start of its bucket. Each date/datetime in the second half of the interval is mapped to the end of its bucket. Details The every and offset argument are created with the the following string language: 1ns # 1 nanosecond 1us # 1 microsecond 1ms # 1 millisecond 1s # 1 second 1m # 1 minute 1h # 1 hour 1d # 1 day 1w # 1 calendar week 1mo # 1 calendar month 1y # 1 calendar year These strings can be combined: 3d12h4m25s # 3 days, 12 hours, 4 minutes, and 25 seconds This functionality is currently experimental and may change without it being considered a breaking change. Examples t1 = as.POSIXct ( \"3040-01-01\" ,tz = \"GMT\" ) t2 = t1 + as.difftime ( 25 ,units = \"secs\" ) s = pl $ date_range ( t1 , t2 , interval = \"2s\" , time_unit = \"ms\" ) #use a dt namespace function df = pl $ DataFrame ( datetime = s ) $ with_columns ( pl $ col ( \"datetime\" ) $ dt $ truncate ( \"4s\" ) $ alias ( \"truncated_4s\" ) , pl $ col ( \"datetime\" ) $ dt $ truncate ( \"4s\" , offset ( \"3s\" ) ) $ alias ( \"truncated_4s_offset_2s\" ) ) df #> polars DataFrame: shape: (13, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 datetime \u2506 truncated_4s \u2506 truncated_4s_offset_2s \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[ms] \u2506 datetime[ms] \u2506 datetime[ms] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3040-01-01 00:00:00 \u2506 3040-01-01 00:00:00 \u2506 3040-01-01 00:00:03 \u2502 #> \u2502 3040-01-01 00:00:02 \u2506 3040-01-01 00:00:00 \u2506 3040-01-01 00:00:03 \u2502 #> \u2502 3040-01-01 00:00:04 \u2506 3040-01-01 00:00:04 \u2506 3040-01-01 00:00:07 \u2502 #> \u2502 3040-01-01 00:00:06 \u2506 3040-01-01 00:00:04 \u2506 3040-01-01 00:00:07 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2502 #> \u2502 3040-01-01 00:00:18 \u2506 3040-01-01 00:00:16 \u2506 3040-01-01 00:00:19 \u2502 #> \u2502 3040-01-01 00:00:20 \u2506 3040-01-01 00:00:20 \u2506 3040-01-01 00:00:23 \u2502 #> \u2502 3040-01-01 00:00:22 \u2506 3040-01-01 00:00:20 \u2506 3040-01-01 00:00:23 \u2502 #> \u2502 3040-01-01 00:00:24 \u2506 3040-01-01 00:00:24 \u2506 3040-01-01 00:00:27 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_round"},{"location":"reference/ExprDT_round/#round-datetime","text":"","title":"Round datetime"},{"location":"reference/ExprDT_round/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_round/#arguments","text":"every : string encoding duration see details. ofset : optional string encoding duration see details.","title":"Arguments"},{"location":"reference/ExprDT_round/#returns","text":"Date/Datetime expr Divide the date/datetime range into buckets. Each date/datetime in the first half of the interval is mapped to the start of its bucket. Each date/datetime in the second half of the interval is mapped to the end of its bucket.","title":"Returns"},{"location":"reference/ExprDT_round/#details","text":"The every and offset argument are created with the the following string language: 1ns # 1 nanosecond 1us # 1 microsecond 1ms # 1 millisecond 1s # 1 second 1m # 1 minute 1h # 1 hour 1d # 1 day 1w # 1 calendar week 1mo # 1 calendar month 1y # 1 calendar year These strings can be combined: 3d12h4m25s # 3 days, 12 hours, 4 minutes, and 25 seconds This functionality is currently experimental and may change without it being considered a breaking change.","title":"Details"},{"location":"reference/ExprDT_round/#examples","text":"t1 = as.POSIXct ( \"3040-01-01\" ,tz = \"GMT\" ) t2 = t1 + as.difftime ( 25 ,units = \"secs\" ) s = pl $ date_range ( t1 , t2 , interval = \"2s\" , time_unit = \"ms\" ) #use a dt namespace function df = pl $ DataFrame ( datetime = s ) $ with_columns ( pl $ col ( \"datetime\" ) $ dt $ truncate ( \"4s\" ) $ alias ( \"truncated_4s\" ) , pl $ col ( \"datetime\" ) $ dt $ truncate ( \"4s\" , offset ( \"3s\" ) ) $ alias ( \"truncated_4s_offset_2s\" ) ) df #> polars DataFrame: shape: (13, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 datetime \u2506 truncated_4s \u2506 truncated_4s_offset_2s \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[ms] \u2506 datetime[ms] \u2506 datetime[ms] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3040-01-01 00:00:00 \u2506 3040-01-01 00:00:00 \u2506 3040-01-01 00:00:03 \u2502 #> \u2502 3040-01-01 00:00:02 \u2506 3040-01-01 00:00:00 \u2506 3040-01-01 00:00:03 \u2502 #> \u2502 3040-01-01 00:00:04 \u2506 3040-01-01 00:00:04 \u2506 3040-01-01 00:00:07 \u2502 #> \u2502 3040-01-01 00:00:06 \u2506 3040-01-01 00:00:04 \u2506 3040-01-01 00:00:07 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2502 #> \u2502 3040-01-01 00:00:18 \u2506 3040-01-01 00:00:16 \u2506 3040-01-01 00:00:19 \u2502 #> \u2502 3040-01-01 00:00:20 \u2506 3040-01-01 00:00:20 \u2506 3040-01-01 00:00:23 \u2502 #> \u2502 3040-01-01 00:00:22 \u2506 3040-01-01 00:00:20 \u2506 3040-01-01 00:00:23 \u2502 #> \u2502 3040-01-01 00:00:24 \u2506 3040-01-01 00:00:24 \u2506 3040-01-01 00:00:27 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_second/","text":"Second Format function Returns Expr of second as UInt32 Extract seconds from underlying Datetime representation. Applies to Datetime columns. Returns the integer second number from 0 to 59, or a floating point number from 0 < 60 if fractional=True that includes any milli/micro/nanosecond component. Examples pl $ DataFrame ( date = pl $ date_range ( as.numeric ( as.POSIXct ( \"2001-1-1\" ) ) * 1E6 + 456789 , #manually convert to us as.numeric ( as.POSIXct ( \"2001-1-1 00:00:6\" ) ) * 1E6 , interval = \"2s654321us\" , time_unit = \"us\" #instruct polars input is us, and store as us ) ) $ with_columns ( pl $ col ( \"date\" ) $ dt $ second ( ) $ alias ( \"second\" ) , pl $ col ( \"date\" ) $ dt $ second ( fractional = TRUE ) $ alias ( \"second_frac\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 second \u2506 second_frac \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 u32 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2000-12-31 23:00:00.456 \u2506 0 \u2506 0.456 \u2502 #> \u2502 2000-12-31 23:00:03.110 \u2506 3 \u2506 3.11 \u2502 #> \u2502 2000-12-31 23:00:05.764 \u2506 5 \u2506 5.764 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_second"},{"location":"reference/ExprDT_second/#second","text":"","title":"Second"},{"location":"reference/ExprDT_second/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_second/#returns","text":"Expr of second as UInt32 Extract seconds from underlying Datetime representation. Applies to Datetime columns. Returns the integer second number from 0 to 59, or a floating point number from 0 < 60 if fractional=True that includes any milli/micro/nanosecond component.","title":"Returns"},{"location":"reference/ExprDT_second/#examples","text":"pl $ DataFrame ( date = pl $ date_range ( as.numeric ( as.POSIXct ( \"2001-1-1\" ) ) * 1E6 + 456789 , #manually convert to us as.numeric ( as.POSIXct ( \"2001-1-1 00:00:6\" ) ) * 1E6 , interval = \"2s654321us\" , time_unit = \"us\" #instruct polars input is us, and store as us ) ) $ with_columns ( pl $ col ( \"date\" ) $ dt $ second ( ) $ alias ( \"second\" ) , pl $ col ( \"date\" ) $ dt $ second ( fractional = TRUE ) $ alias ( \"second_frac\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 second \u2506 second_frac \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 u32 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2000-12-31 23:00:00.456 \u2506 0 \u2506 0.456 \u2502 #> \u2502 2000-12-31 23:00:03.110 \u2506 3 \u2506 3.11 \u2502 #> \u2502 2000-12-31 23:00:05.764 \u2506 5 \u2506 5.764 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_seconds/","text":"Seconds Format function Returns Expr of i64 Extract the seconds from a Duration type. Examples df = pl $ DataFrame ( date = pl $ date_range ( low = as.POSIXct ( \"2020-1-1\" , tz = \"GMT\" ) , high = as.POSIXct ( \"2020-1-1 00:04:00\" , tz = \"GMT\" ) , interval = \"1m\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ diff ( ) $ dt $ seconds ( ) $ alias ( \"seconds_diff\" ) ) #> polars DataFrame: shape: (5, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 seconds_diff \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-01-01 00:00:00 \u2506 null \u2502 #> \u2502 2020-01-01 00:01:00 \u2506 60 \u2502 #> \u2502 2020-01-01 00:02:00 \u2506 60 \u2502 #> \u2502 2020-01-01 00:03:00 \u2506 60 \u2502 #> \u2502 2020-01-01 00:04:00 \u2506 60 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_seconds"},{"location":"reference/ExprDT_seconds/#seconds","text":"","title":"Seconds"},{"location":"reference/ExprDT_seconds/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_seconds/#returns","text":"Expr of i64 Extract the seconds from a Duration type.","title":"Returns"},{"location":"reference/ExprDT_seconds/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( low = as.POSIXct ( \"2020-1-1\" , tz = \"GMT\" ) , high = as.POSIXct ( \"2020-1-1 00:04:00\" , tz = \"GMT\" ) , interval = \"1m\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ diff ( ) $ dt $ seconds ( ) $ alias ( \"seconds_diff\" ) ) #> polars DataFrame: shape: (5, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 seconds_diff \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-01-01 00:00:00 \u2506 null \u2502 #> \u2502 2020-01-01 00:01:00 \u2506 60 \u2502 #> \u2502 2020-01-01 00:02:00 \u2506 60 \u2502 #> \u2502 2020-01-01 00:03:00 \u2506 60 \u2502 #> \u2502 2020-01-01 00:04:00 \u2506 60 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_strftime/","text":"strftime Format function Arguments fmt : string format very much like in R passed to chrono Returns Date/Datetime expr Format Date/Datetime with a formatting rule. See chrono strftime/strptime<https://docs.rs/chrono/latest/chrono/format/strftime/index.html> _. Examples pl $ lit ( as.POSIXct ( \"2021-01-02 12:13:14\" ,tz = \"GMT\" ) ) $ dt $ strftime ( \"this is the year: %Y\" ) $ to_r ( ) #> [1] \"this is the year: 2021\"","title":"ExprDT_strftime"},{"location":"reference/ExprDT_strftime/#strftime","text":"","title":"strftime"},{"location":"reference/ExprDT_strftime/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_strftime/#arguments","text":"fmt : string format very much like in R passed to chrono","title":"Arguments"},{"location":"reference/ExprDT_strftime/#returns","text":"Date/Datetime expr Format Date/Datetime with a formatting rule. See chrono strftime/strptime<https://docs.rs/chrono/latest/chrono/format/strftime/index.html> _.","title":"Returns"},{"location":"reference/ExprDT_strftime/#examples","text":"pl $ lit ( as.POSIXct ( \"2021-01-02 12:13:14\" ,tz = \"GMT\" ) ) $ dt $ strftime ( \"this is the year: %Y\" ) $ to_r ( ) #> [1] \"this is the year: 2021\"","title":"Examples"},{"location":"reference/ExprDT_timestamp/","text":"timestamp Format function Arguments tu : string option either 'ns', 'us', or 'ms' Returns Expr of i64 Return a timestamp in the given time unit. Examples df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2001-1-1\" ) , high = as.Date ( \"2001-1-3\" ) , interval = \"1d\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ dt $ timestamp ( ) $ alias ( \"timestamp_ns\" ) , pl $ col ( \"date\" ) $ dt $ timestamp ( tu = \"ms\" ) $ alias ( \"timestamp_ms\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 timestamp_ns \u2506 timestamp_ms \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2001-01-01 00:00:00 \u2506 978307200000000000 \u2506 978307200000 \u2502 #> \u2502 2001-01-02 00:00:00 \u2506 978393600000000000 \u2506 978393600000 \u2502 #> \u2502 2001-01-03 00:00:00 \u2506 978480000000000000 \u2506 978480000000 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_timestamp"},{"location":"reference/ExprDT_timestamp/#timestamp","text":"","title":"timestamp"},{"location":"reference/ExprDT_timestamp/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_timestamp/#arguments","text":"tu : string option either 'ns', 'us', or 'ms'","title":"Arguments"},{"location":"reference/ExprDT_timestamp/#returns","text":"Expr of i64 Return a timestamp in the given time unit.","title":"Returns"},{"location":"reference/ExprDT_timestamp/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2001-1-1\" ) , high = as.Date ( \"2001-1-3\" ) , interval = \"1d\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ dt $ timestamp ( ) $ alias ( \"timestamp_ns\" ) , pl $ col ( \"date\" ) $ dt $ timestamp ( tu = \"ms\" ) $ alias ( \"timestamp_ms\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 timestamp_ns \u2506 timestamp_ms \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 i64 \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2001-01-01 00:00:00 \u2506 978307200000000000 \u2506 978307200000 \u2502 #> \u2502 2001-01-02 00:00:00 \u2506 978393600000000000 \u2506 978393600000 \u2502 #> \u2502 2001-01-03 00:00:00 \u2506 978480000000000000 \u2506 978480000000 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_truncate/","text":"Truncate datetime Format function Arguments every : string encoding duration see details. ofset : optional string encoding duration see details. Returns Date/Datetime expr Divide the date/datetime range into buckets. Each date/datetime is mapped to the start of its bucket. Details The every and offset argument are created with the the following string language: 1ns # 1 nanosecond 1us # 1 microsecond 1ms # 1 millisecond 1s # 1 second 1m # 1 minute 1h # 1 hour 1d # 1 day 1w # 1 calendar week 1mo # 1 calendar month 1y # 1 calendar year These strings can be combined: 3d12h4m25s # 3 days, 12 hours, 4 minutes, and 25 seconds Examples t1 = as.POSIXct ( \"3040-01-01\" ,tz = \"GMT\" ) t2 = t1 + as.difftime ( 25 ,units = \"secs\" ) s = pl $ date_range ( t1 , t2 , interval = \"2s\" , time_unit = \"ms\" ) #use a dt namespace function df = pl $ DataFrame ( datetime = s ) $ with_columns ( pl $ col ( \"datetime\" ) $ dt $ truncate ( \"4s\" ) $ alias ( \"truncated_4s\" ) , pl $ col ( \"datetime\" ) $ dt $ truncate ( \"4s\" , offset ( \"3s\" ) ) $ alias ( \"truncated_4s_offset_2s\" ) ) df #> polars DataFrame: shape: (13, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 datetime \u2506 truncated_4s \u2506 truncated_4s_offset_2s \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[ms] \u2506 datetime[ms] \u2506 datetime[ms] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3040-01-01 00:00:00 \u2506 3040-01-01 00:00:00 \u2506 3040-01-01 00:00:03 \u2502 #> \u2502 3040-01-01 00:00:02 \u2506 3040-01-01 00:00:00 \u2506 3040-01-01 00:00:03 \u2502 #> \u2502 3040-01-01 00:00:04 \u2506 3040-01-01 00:00:04 \u2506 3040-01-01 00:00:07 \u2502 #> \u2502 3040-01-01 00:00:06 \u2506 3040-01-01 00:00:04 \u2506 3040-01-01 00:00:07 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2502 #> \u2502 3040-01-01 00:00:18 \u2506 3040-01-01 00:00:16 \u2506 3040-01-01 00:00:19 \u2502 #> \u2502 3040-01-01 00:00:20 \u2506 3040-01-01 00:00:20 \u2506 3040-01-01 00:00:23 \u2502 #> \u2502 3040-01-01 00:00:22 \u2506 3040-01-01 00:00:20 \u2506 3040-01-01 00:00:23 \u2502 #> \u2502 3040-01-01 00:00:24 \u2506 3040-01-01 00:00:24 \u2506 3040-01-01 00:00:27 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_truncate"},{"location":"reference/ExprDT_truncate/#truncate-datetime","text":"","title":"Truncate datetime"},{"location":"reference/ExprDT_truncate/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_truncate/#arguments","text":"every : string encoding duration see details. ofset : optional string encoding duration see details.","title":"Arguments"},{"location":"reference/ExprDT_truncate/#returns","text":"Date/Datetime expr Divide the date/datetime range into buckets. Each date/datetime is mapped to the start of its bucket.","title":"Returns"},{"location":"reference/ExprDT_truncate/#details","text":"The every and offset argument are created with the the following string language: 1ns # 1 nanosecond 1us # 1 microsecond 1ms # 1 millisecond 1s # 1 second 1m # 1 minute 1h # 1 hour 1d # 1 day 1w # 1 calendar week 1mo # 1 calendar month 1y # 1 calendar year These strings can be combined: 3d12h4m25s # 3 days, 12 hours, 4 minutes, and 25 seconds","title":"Details"},{"location":"reference/ExprDT_truncate/#examples","text":"t1 = as.POSIXct ( \"3040-01-01\" ,tz = \"GMT\" ) t2 = t1 + as.difftime ( 25 ,units = \"secs\" ) s = pl $ date_range ( t1 , t2 , interval = \"2s\" , time_unit = \"ms\" ) #use a dt namespace function df = pl $ DataFrame ( datetime = s ) $ with_columns ( pl $ col ( \"datetime\" ) $ dt $ truncate ( \"4s\" ) $ alias ( \"truncated_4s\" ) , pl $ col ( \"datetime\" ) $ dt $ truncate ( \"4s\" , offset ( \"3s\" ) ) $ alias ( \"truncated_4s_offset_2s\" ) ) df #> polars DataFrame: shape: (13, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 datetime \u2506 truncated_4s \u2506 truncated_4s_offset_2s \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[ms] \u2506 datetime[ms] \u2506 datetime[ms] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3040-01-01 00:00:00 \u2506 3040-01-01 00:00:00 \u2506 3040-01-01 00:00:03 \u2502 #> \u2502 3040-01-01 00:00:02 \u2506 3040-01-01 00:00:00 \u2506 3040-01-01 00:00:03 \u2502 #> \u2502 3040-01-01 00:00:04 \u2506 3040-01-01 00:00:04 \u2506 3040-01-01 00:00:07 \u2502 #> \u2502 3040-01-01 00:00:06 \u2506 3040-01-01 00:00:04 \u2506 3040-01-01 00:00:07 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2502 #> \u2502 3040-01-01 00:00:18 \u2506 3040-01-01 00:00:16 \u2506 3040-01-01 00:00:19 \u2502 #> \u2502 3040-01-01 00:00:20 \u2506 3040-01-01 00:00:20 \u2506 3040-01-01 00:00:23 \u2502 #> \u2502 3040-01-01 00:00:22 \u2506 3040-01-01 00:00:20 \u2506 3040-01-01 00:00:23 \u2502 #> \u2502 3040-01-01 00:00:24 \u2506 3040-01-01 00:00:24 \u2506 3040-01-01 00:00:27 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_tz_localize/","text":"Localize time zone Format function Arguments tz : string of time zone (no NULL allowed) see allowed timezone in base::OlsonNames() Returns Expr of i64 Localize tz-naive Datetime Series to tz-aware Datetime Series. This method takes a naive Datetime Series and makes this time zone aware. It does not move the time to another time zone. Details In R as modifying tzone attribute manually but takes into account summertime. See unittest \"dt$convert_time_zone dt$tz_localize\" for a more detailed comparison to base R. Examples df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2001-3-1\" ) , high = as.Date ( \"2001-7-1\" ) , interval = \"1mo\" ) ) df = df $ with_columns ( pl $ col ( \"date\" ) $ dt $ replace_time_zone ( \"Europe/Amsterdam\" ) $ dt $ convert_time_zone ( \"Europe/London\" ) $ alias ( \"london_timezone\" ) , pl $ col ( \"date\" ) $ dt $ tz_localize ( \"Europe/London\" ) $ alias ( \"tz_loc_london\" ) ) df2 = df $ with_columns ( pl $ col ( \"london_timezone\" ) $ dt $ replace_time_zone ( \"Europe/Amsterdam\" ) $ alias ( \"cast London_to_Amsterdam\" ) , pl $ col ( \"london_timezone\" ) $ dt $ convert_time_zone ( \"Europe/Amsterdam\" ) $ alias ( \"with London_to_Amsterdam\" ) , pl $ col ( \"london_timezone\" ) $ dt $ convert_time_zone ( \"Europe/Amsterdam\" ) $ dt $ replace_time_zone ( NULL ) $ alias ( \"strip tz from with-'Europe/Amsterdam'\" ) ) df2 #> polars DataFrame: shape: (5, 6) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 london_timezon \u2506 tz_loc_london \u2506 cast London_t \u2506 with London_t \u2506 strip tz from \u2502 #> \u2502 --- \u2506 e \u2506 --- \u2506 o_Amsterdam \u2506 o_Amsterdam \u2506 with-'Europe/ \u2502 #> \u2502 datetime[\u03bcs] \u2506 --- \u2506 datetime[\u03bcs, \u2506 --- \u2506 --- \u2506 Amste... \u2502 #> \u2502 \u2506 datetime[\u03bcs, \u2506 Europe/London] \u2506 datetime[\u03bcs, \u2506 datetime[\u03bcs, \u2506 --- \u2502 #> \u2502 \u2506 Europe/London] \u2506 \u2506 Europe/Amster \u2506 Europe/Amster \u2506 datetime[\u03bcs] \u2502 #> \u2502 \u2506 \u2506 \u2506 dam] \u2506 dam] \u2506 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2001-03-01 \u2506 2001-02-28 \u2506 2001-03-01 \u2506 2001-02-28 \u2506 2001-03-01 \u2506 2001-03-01 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 GMT \u2506 00:00:00 GMT \u2506 23:00:00 CET \u2506 00:00:00 CET \u2506 00:00:00 \u2502 #> \u2502 2001-04-01 \u2506 2001-03-31 \u2506 2001-04-01 \u2506 2001-03-31 \u2506 2001-04-01 \u2506 2001-04-01 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 00:00:00 BST \u2506 23:00:00 CEST \u2506 00:00:00 CEST \u2506 00:00:00 \u2502 #> \u2502 2001-05-01 \u2506 2001-04-30 \u2506 2001-05-01 \u2506 2001-04-30 \u2506 2001-05-01 \u2506 2001-05-01 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 00:00:00 BST \u2506 23:00:00 CEST \u2506 00:00:00 CEST \u2506 00:00:00 \u2502 #> \u2502 2001-06-01 \u2506 2001-05-31 \u2506 2001-06-01 \u2506 2001-05-31 \u2506 2001-06-01 \u2506 2001-06-01 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 00:00:00 BST \u2506 23:00:00 CEST \u2506 00:00:00 CEST \u2506 00:00:00 \u2502 #> \u2502 2001-07-01 \u2506 2001-06-30 \u2506 2001-07-01 \u2506 2001-06-30 \u2506 2001-07-01 \u2506 2001-07-01 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 00:00:00 BST \u2506 23:00:00 CEST \u2506 00:00:00 CEST \u2506 00:00:00 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_tz_localize"},{"location":"reference/ExprDT_tz_localize/#localize-time-zone","text":"","title":"Localize time zone"},{"location":"reference/ExprDT_tz_localize/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_tz_localize/#arguments","text":"tz : string of time zone (no NULL allowed) see allowed timezone in base::OlsonNames()","title":"Arguments"},{"location":"reference/ExprDT_tz_localize/#returns","text":"Expr of i64 Localize tz-naive Datetime Series to tz-aware Datetime Series. This method takes a naive Datetime Series and makes this time zone aware. It does not move the time to another time zone.","title":"Returns"},{"location":"reference/ExprDT_tz_localize/#details","text":"In R as modifying tzone attribute manually but takes into account summertime. See unittest \"dt$convert_time_zone dt$tz_localize\" for a more detailed comparison to base R.","title":"Details"},{"location":"reference/ExprDT_tz_localize/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2001-3-1\" ) , high = as.Date ( \"2001-7-1\" ) , interval = \"1mo\" ) ) df = df $ with_columns ( pl $ col ( \"date\" ) $ dt $ replace_time_zone ( \"Europe/Amsterdam\" ) $ dt $ convert_time_zone ( \"Europe/London\" ) $ alias ( \"london_timezone\" ) , pl $ col ( \"date\" ) $ dt $ tz_localize ( \"Europe/London\" ) $ alias ( \"tz_loc_london\" ) ) df2 = df $ with_columns ( pl $ col ( \"london_timezone\" ) $ dt $ replace_time_zone ( \"Europe/Amsterdam\" ) $ alias ( \"cast London_to_Amsterdam\" ) , pl $ col ( \"london_timezone\" ) $ dt $ convert_time_zone ( \"Europe/Amsterdam\" ) $ alias ( \"with London_to_Amsterdam\" ) , pl $ col ( \"london_timezone\" ) $ dt $ convert_time_zone ( \"Europe/Amsterdam\" ) $ dt $ replace_time_zone ( NULL ) $ alias ( \"strip tz from with-'Europe/Amsterdam'\" ) ) df2 #> polars DataFrame: shape: (5, 6) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 london_timezon \u2506 tz_loc_london \u2506 cast London_t \u2506 with London_t \u2506 strip tz from \u2502 #> \u2502 --- \u2506 e \u2506 --- \u2506 o_Amsterdam \u2506 o_Amsterdam \u2506 with-'Europe/ \u2502 #> \u2502 datetime[\u03bcs] \u2506 --- \u2506 datetime[\u03bcs, \u2506 --- \u2506 --- \u2506 Amste... \u2502 #> \u2502 \u2506 datetime[\u03bcs, \u2506 Europe/London] \u2506 datetime[\u03bcs, \u2506 datetime[\u03bcs, \u2506 --- \u2502 #> \u2502 \u2506 Europe/London] \u2506 \u2506 Europe/Amster \u2506 Europe/Amster \u2506 datetime[\u03bcs] \u2502 #> \u2502 \u2506 \u2506 \u2506 dam] \u2506 dam] \u2506 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2001-03-01 \u2506 2001-02-28 \u2506 2001-03-01 \u2506 2001-02-28 \u2506 2001-03-01 \u2506 2001-03-01 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 GMT \u2506 00:00:00 GMT \u2506 23:00:00 CET \u2506 00:00:00 CET \u2506 00:00:00 \u2502 #> \u2502 2001-04-01 \u2506 2001-03-31 \u2506 2001-04-01 \u2506 2001-03-31 \u2506 2001-04-01 \u2506 2001-04-01 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 00:00:00 BST \u2506 23:00:00 CEST \u2506 00:00:00 CEST \u2506 00:00:00 \u2502 #> \u2502 2001-05-01 \u2506 2001-04-30 \u2506 2001-05-01 \u2506 2001-04-30 \u2506 2001-05-01 \u2506 2001-05-01 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 00:00:00 BST \u2506 23:00:00 CEST \u2506 00:00:00 CEST \u2506 00:00:00 \u2502 #> \u2502 2001-06-01 \u2506 2001-05-31 \u2506 2001-06-01 \u2506 2001-05-31 \u2506 2001-06-01 \u2506 2001-06-01 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 00:00:00 BST \u2506 23:00:00 CEST \u2506 00:00:00 CEST \u2506 00:00:00 \u2502 #> \u2502 2001-07-01 \u2506 2001-06-30 \u2506 2001-07-01 \u2506 2001-06-30 \u2506 2001-07-01 \u2506 2001-07-01 \u2502 #> \u2502 00:00:00 \u2506 23:00:00 BST \u2506 00:00:00 BST \u2506 23:00:00 CEST \u2506 00:00:00 CEST \u2506 00:00:00 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_week/","text":"Week Format function Returns Expr of week as UInt32 Extract the week from the underlying Date representation. Applies to Date and Datetime columns. Returns the ISO week number starting from 1. The return value ranges from 1 to 53. (The last week of year differs by years.) Examples df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ week ( ) $ alias ( \"week\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 week \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 52 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 52 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 52 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 53 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 53 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 53 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_week"},{"location":"reference/ExprDT_week/#week","text":"","title":"Week"},{"location":"reference/ExprDT_week/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_week/#returns","text":"Expr of week as UInt32 Extract the week from the underlying Date representation. Applies to Date and Datetime columns. Returns the ISO week number starting from 1. The return value ranges from 1 to 53. (The last week of year differs by years.)","title":"Returns"},{"location":"reference/ExprDT_week/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ week ( ) $ alias ( \"week\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 week \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 52 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 52 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 52 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 53 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 53 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 53 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_weekday/","text":"Weekday Format function Returns Expr of weekday as UInt32 Extract the week day from the underlying Date representation. Applies to Date and Datetime columns. Returns the ISO weekday number where monday = 1 and sunday = 7 Examples df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ weekday ( ) $ alias ( \"weekday\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 weekday \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 5 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 6 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 7 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 1 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 6 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 7 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_weekday"},{"location":"reference/ExprDT_weekday/#weekday","text":"","title":"Weekday"},{"location":"reference/ExprDT_weekday/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_weekday/#returns","text":"Expr of weekday as UInt32 Extract the week day from the underlying Date representation. Applies to Date and Datetime columns. Returns the ISO weekday number where monday = 1 and sunday = 7","title":"Returns"},{"location":"reference/ExprDT_weekday/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ weekday ( ) $ alias ( \"weekday\" ) ) #> polars DataFrame: shape: (12, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 weekday \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 5 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 6 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 7 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 1 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 6 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 7 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 1 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_with_time_unit/","text":"with_time_unit Format function Arguments tu : string option either 'ns', 'us', or 'ms' Returns Expr of i64 Set time unit of a Series of dtype Datetime or Duration. This does not modify underlying data, and should be used to fix an incorrect time unit. The corresponding global timepoint will change. Examples df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2001-1-1\" ) , high = as.Date ( \"2001-1-3\" ) , interval = \"1d\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ dt $ with_time_unit ( ) $ alias ( \"with_time_unit_ns\" ) , pl $ col ( \"date\" ) $ dt $ with_time_unit ( tu = \"ms\" ) $ alias ( \"with_time_unit_ms\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 with_time_unit_ns \u2506 with_time_unit_ms \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 datetime[ns] \u2506 datetime[ms] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2001-01-01 00:00:00 \u2506 1970-01-12 07:45:07.200 \u2506 +32971-04-28 00:00:00 \u2502 #> \u2502 2001-01-02 00:00:00 \u2506 1970-01-12 07:46:33.600 \u2506 +32974-01-22 00:00:00 \u2502 #> \u2502 2001-01-03 00:00:00 \u2506 1970-01-12 07:48:00 \u2506 +32976-10-18 00:00:00 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_with_time_unit"},{"location":"reference/ExprDT_with_time_unit/#with_time_unit","text":"","title":"with_time_unit"},{"location":"reference/ExprDT_with_time_unit/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_with_time_unit/#arguments","text":"tu : string option either 'ns', 'us', or 'ms'","title":"Arguments"},{"location":"reference/ExprDT_with_time_unit/#returns","text":"Expr of i64 Set time unit of a Series of dtype Datetime or Duration. This does not modify underlying data, and should be used to fix an incorrect time unit. The corresponding global timepoint will change.","title":"Returns"},{"location":"reference/ExprDT_with_time_unit/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( low = as.Date ( \"2001-1-1\" ) , high = as.Date ( \"2001-1-3\" ) , interval = \"1d\" ) ) df $ select ( pl $ col ( \"date\" ) , pl $ col ( \"date\" ) $ dt $ with_time_unit ( ) $ alias ( \"with_time_unit_ns\" ) , pl $ col ( \"date\" ) $ dt $ with_time_unit ( tu = \"ms\" ) $ alias ( \"with_time_unit_ms\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 with_time_unit_ns \u2506 with_time_unit_ms \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs] \u2506 datetime[ns] \u2506 datetime[ms] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2001-01-01 00:00:00 \u2506 1970-01-12 07:45:07.200 \u2506 +32971-04-28 00:00:00 \u2502 #> \u2502 2001-01-02 00:00:00 \u2506 1970-01-12 07:46:33.600 \u2506 +32974-01-22 00:00:00 \u2502 #> \u2502 2001-01-03 00:00:00 \u2506 1970-01-12 07:48:00 \u2506 +32976-10-18 00:00:00 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprDT_year/","text":"Year Format function Returns Expr of Year as Int32 Extract year from underlying Date representation. Applies to Date and Datetime columns. Returns the year number in the calendar date. Examples df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ year ( ) $ alias ( \"year\" ) , pl $ col ( \"date\" ) $ dt $ iso_year ( ) $ alias ( \"iso_year\" ) ) #> polars DataFrame: shape: (12, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 year \u2506 iso_year \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 2021 \u2506 2020 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 2021 \u2506 2020 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 2021 \u2506 2021 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 2021 \u2506 2021 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprDT_year"},{"location":"reference/ExprDT_year/#year","text":"","title":"Year"},{"location":"reference/ExprDT_year/#format","text":"function","title":"Format"},{"location":"reference/ExprDT_year/#returns","text":"Expr of Year as Int32 Extract year from underlying Date representation. Applies to Date and Datetime columns. Returns the year number in the calendar date.","title":"Returns"},{"location":"reference/ExprDT_year/#examples","text":"df = pl $ DataFrame ( date = pl $ date_range ( as.Date ( \"2020-12-25\" ) , as.Date ( \"2021-1-05\" ) , interval = \"1d\" , time_zone = \"GMT\" ) ) df $ with_columns ( pl $ col ( \"date\" ) $ dt $ year ( ) $ alias ( \"year\" ) , pl $ col ( \"date\" ) $ dt $ iso_year ( ) $ alias ( \"iso_year\" ) ) #> polars DataFrame: shape: (12, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2506 year \u2506 iso_year \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 datetime[\u03bcs, GMT] \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2020-12-25 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 2020-12-26 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 2020-12-27 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 2020-12-28 00:00:00 GMT \u2506 2020 \u2506 2020 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2502 #> \u2502 2021-01-02 00:00:00 GMT \u2506 2021 \u2506 2020 \u2502 #> \u2502 2021-01-03 00:00:00 GMT \u2506 2021 \u2506 2020 \u2502 #> \u2502 2021-01-04 00:00:00 GMT \u2506 2021 \u2506 2021 \u2502 #> \u2502 2021-01-05 00:00:00 GMT \u2506 2021 \u2506 2021 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprMeta_eq/","text":"Meta Equal Arguments other : Expr to compare with Returns bool: TRUE if equal Are two expressions on a meta level equal Examples #three naive expression literals e1 = pl $ lit ( 40 ) + 2 e2 = pl $ lit ( 42 ) e3 = pl $ lit ( 40 ) + 2 #e1 and e3 are identical expressions e1 $ meta $ eq ( e3 ) #> [1] TRUE #e_test is an expression testing whether e1 and e2 evaluates to the same value. e_test = e1 == e2 # or e_test = e1$eq(e2) #direct evaluate e_test, possible because only made up of literals e_test $ to_r ( ) #> [1] TRUE #e1 and e2 are on the meta-level NOT identical expressions e1 $ meta $ neq ( e2 ) #> [1] TRUE","title":"ExprMeta_eq"},{"location":"reference/ExprMeta_eq/#meta-equal","text":"","title":"Meta Equal"},{"location":"reference/ExprMeta_eq/#arguments","text":"other : Expr to compare with","title":"Arguments"},{"location":"reference/ExprMeta_eq/#returns","text":"bool: TRUE if equal Are two expressions on a meta level equal","title":"Returns"},{"location":"reference/ExprMeta_eq/#examples","text":"#three naive expression literals e1 = pl $ lit ( 40 ) + 2 e2 = pl $ lit ( 42 ) e3 = pl $ lit ( 40 ) + 2 #e1 and e3 are identical expressions e1 $ meta $ eq ( e3 ) #> [1] TRUE #e_test is an expression testing whether e1 and e2 evaluates to the same value. e_test = e1 == e2 # or e_test = e1$eq(e2) #direct evaluate e_test, possible because only made up of literals e_test $ to_r ( ) #> [1] TRUE #e1 and e2 are on the meta-level NOT identical expressions e1 $ meta $ neq ( e2 ) #> [1] TRUE","title":"Examples"},{"location":"reference/ExprMeta_has_multiple_outputs/","text":"Has multiple outputs Returns Bool Whether this expression expands into multiple expressions. Examples pl $ all ( ) $ meta $ has_multiple_outputs ( ) #> [1] TRUE pl $ col ( \"some_colname\" ) $ meta $ has_multiple_outputs ( ) #> [1] FALSE","title":"ExprMeta_has_multiple_outputs"},{"location":"reference/ExprMeta_has_multiple_outputs/#has-multiple-outputs","text":"","title":"Has multiple outputs"},{"location":"reference/ExprMeta_has_multiple_outputs/#returns","text":"Bool Whether this expression expands into multiple expressions.","title":"Returns"},{"location":"reference/ExprMeta_has_multiple_outputs/#examples","text":"pl $ all ( ) $ meta $ has_multiple_outputs ( ) #> [1] TRUE pl $ col ( \"some_colname\" ) $ meta $ has_multiple_outputs ( ) #> [1] FALSE","title":"Examples"},{"location":"reference/ExprMeta_is_regex_projection/","text":"Is regex projecion. Returns Bool Whether this expression expands to columns that match a regex pattern. Examples pl $ col ( \"^Sepal.*$\" ) $ meta $ is_regex_projection ( ) #> [1] TRUE pl $ col ( \"Sepal.Length\" ) $ meta $ is_regex_projection ( ) #> [1] FALSE","title":"ExprMeta_is_regex_projection"},{"location":"reference/ExprMeta_is_regex_projection/#is-regex-projecion","text":"","title":"Is regex projecion."},{"location":"reference/ExprMeta_is_regex_projection/#returns","text":"Bool Whether this expression expands to columns that match a regex pattern.","title":"Returns"},{"location":"reference/ExprMeta_is_regex_projection/#examples","text":"pl $ col ( \"^Sepal.*$\" ) $ meta $ is_regex_projection ( ) #> [1] TRUE pl $ col ( \"Sepal.Length\" ) $ meta $ is_regex_projection ( ) #> [1] FALSE","title":"Examples"},{"location":"reference/ExprMeta_neq/","text":"Meta Not Equal Arguments other : Expr to compare with Returns bool: TRUE if NOT equal Are two expressions on a meta level NOT equal Examples #three naive expression literals e1 = pl $ lit ( 40 ) + 2 e2 = pl $ lit ( 42 ) e3 = pl $ lit ( 40 ) + 2 #e1 and e3 are identical expressions e1 $ meta $ eq ( e3 ) #> [1] TRUE #e_test is an expression testing whether e1 and e2 evaluates to the same value. e_test = e1 == e2 # or e_test = e1$eq(e2) #direct evaluate e_test, possible because only made up of literals e_test $ to_r ( ) #> [1] TRUE #e1 and e2 are on the meta-level NOT identical expressions e1 $ meta $ neq ( e2 ) #> [1] TRUE","title":"ExprMeta_neq"},{"location":"reference/ExprMeta_neq/#meta-not-equal","text":"","title":"Meta Not Equal"},{"location":"reference/ExprMeta_neq/#arguments","text":"other : Expr to compare with","title":"Arguments"},{"location":"reference/ExprMeta_neq/#returns","text":"bool: TRUE if NOT equal Are two expressions on a meta level NOT equal","title":"Returns"},{"location":"reference/ExprMeta_neq/#examples","text":"#three naive expression literals e1 = pl $ lit ( 40 ) + 2 e2 = pl $ lit ( 42 ) e3 = pl $ lit ( 40 ) + 2 #e1 and e3 are identical expressions e1 $ meta $ eq ( e3 ) #> [1] TRUE #e_test is an expression testing whether e1 and e2 evaluates to the same value. e_test = e1 == e2 # or e_test = e1$eq(e2) #direct evaluate e_test, possible because only made up of literals e_test $ to_r ( ) #> [1] TRUE #e1 and e2 are on the meta-level NOT identical expressions e1 $ meta $ neq ( e2 ) #> [1] TRUE","title":"Examples"},{"location":"reference/ExprMeta_output_name/","text":"Output Name Returns R charvec of output names. Get the column name that this expression would produce. It might not always be possible to determine the output name as it might depend on the schema of the context. In that case this will raise an error. Examples e = pl $ col ( \"alice\" ) $ alias ( \"bob\" ) e $ meta $ root_names ( ) == \"alice\" #> [1] TRUE e $ meta $ output_name ( ) == \"bob\" #> [1] TRUE e $ meta $ undo_aliases ( ) $ meta $ output_name ( ) == \"alice\" #> [1] TRUE","title":"ExprMeta_output_name"},{"location":"reference/ExprMeta_output_name/#output-name","text":"","title":"Output Name"},{"location":"reference/ExprMeta_output_name/#returns","text":"R charvec of output names. Get the column name that this expression would produce. It might not always be possible to determine the output name as it might depend on the schema of the context. In that case this will raise an error.","title":"Returns"},{"location":"reference/ExprMeta_output_name/#examples","text":"e = pl $ col ( \"alice\" ) $ alias ( \"bob\" ) e $ meta $ root_names ( ) == \"alice\" #> [1] TRUE e $ meta $ output_name ( ) == \"bob\" #> [1] TRUE e $ meta $ undo_aliases ( ) $ meta $ output_name ( ) == \"alice\" #> [1] TRUE","title":"Examples"},{"location":"reference/ExprMeta_pop/","text":"Pop Returns R list of Expr(s) usually one, only multiple if top Expr took more Expr as input. Pop the latest expression and return the input(s) of the popped expression. Examples e1 = pl $ lit ( 40 ) + 2 e2 = pl $ lit ( 42 ) $ sum ( ) e1 #> polars Expr: [(40f64) + (2f64)] e1 $ meta $ pop ( ) #> [[1]] #> polars Expr: 2f64 #> #> [[2]] #> polars Expr: 40f64 #> e2 #> polars Expr: 42f64.sum() e2 $ meta $ pop ( ) #> [[1]] #> polars Expr: 42f64 #>","title":"ExprMeta_pop"},{"location":"reference/ExprMeta_pop/#pop","text":"","title":"Pop"},{"location":"reference/ExprMeta_pop/#returns","text":"R list of Expr(s) usually one, only multiple if top Expr took more Expr as input. Pop the latest expression and return the input(s) of the popped expression.","title":"Returns"},{"location":"reference/ExprMeta_pop/#examples","text":"e1 = pl $ lit ( 40 ) + 2 e2 = pl $ lit ( 42 ) $ sum ( ) e1 #> polars Expr: [(40f64) + (2f64)] e1 $ meta $ pop ( ) #> [[1]] #> polars Expr: 2f64 #> #> [[2]] #> polars Expr: 40f64 #> e2 #> polars Expr: 42f64.sum() e2 $ meta $ pop ( ) #> [[1]] #> polars Expr: 42f64 #>","title":"Examples"},{"location":"reference/ExprMeta_root_names/","text":"Root Name Returns R charvec of root names. Get a vector with the root column name Examples e = pl $ col ( \"alice\" ) $ alias ( \"bob\" ) e $ meta $ root_names ( ) == \"alice\" #> [1] TRUE e $ meta $ output_name ( ) == \"bob\" #> [1] TRUE e $ meta $ undo_aliases ( ) $ meta $ output_name ( ) == \"alice\" #> [1] TRUE","title":"ExprMeta_root_names"},{"location":"reference/ExprMeta_root_names/#root-name","text":"","title":"Root Name"},{"location":"reference/ExprMeta_root_names/#returns","text":"R charvec of root names. Get a vector with the root column name","title":"Returns"},{"location":"reference/ExprMeta_root_names/#examples","text":"e = pl $ col ( \"alice\" ) $ alias ( \"bob\" ) e $ meta $ root_names ( ) == \"alice\" #> [1] TRUE e $ meta $ output_name ( ) == \"bob\" #> [1] TRUE e $ meta $ undo_aliases ( ) $ meta $ output_name ( ) == \"alice\" #> [1] TRUE","title":"Examples"},{"location":"reference/ExprMeta_undo_aliases/","text":"Undo aliases Returns Expr with aliases undone Undo any renaming operation like alias or keep_name . Examples e = pl $ col ( \"alice\" ) $ alias ( \"bob\" ) e $ meta $ root_names ( ) == \"alice\" #> [1] TRUE e $ meta $ output_name ( ) == \"bob\" #> [1] TRUE e $ meta $ undo_aliases ( ) $ meta $ output_name ( ) == \"alice\" #> [1] TRUE","title":"ExprMeta_undo_aliases"},{"location":"reference/ExprMeta_undo_aliases/#undo-aliases","text":"","title":"Undo aliases"},{"location":"reference/ExprMeta_undo_aliases/#returns","text":"Expr with aliases undone Undo any renaming operation like alias or keep_name .","title":"Returns"},{"location":"reference/ExprMeta_undo_aliases/#examples","text":"e = pl $ col ( \"alice\" ) $ alias ( \"bob\" ) e $ meta $ root_names ( ) == \"alice\" #> [1] TRUE e $ meta $ output_name ( ) == \"bob\" #> [1] TRUE e $ meta $ undo_aliases ( ) $ meta $ output_name ( ) == \"alice\" #> [1] TRUE","title":"Examples"},{"location":"reference/ExprStr_concat/","text":"Concat Arguments delimiter : string The delimiter to insert between consecutive string values. Returns Expr of Utf8 concatenated Vertically concat the values in the Series to a single string value. Examples #concatenate a Series of strings to a single string df = pl $ DataFrame ( foo = c ( \"1\" , NA , 2 ) ) df $ select ( pl $ col ( \"foo\" ) $ str $ concat ( \"-\" ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1-null-2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #Series list of strings to Series of concatenated strings df = pl $ DataFrame ( list ( bar = list ( c ( \"a\" , \"b\" , \"c\" ) , c ( \"1\" , \"2\" , NA ) ) ) ) df $ select ( pl $ col ( \"bar\" ) $ arr $ eval ( pl $ col ( ) $ str $ concat ( ) ) $ arr $ first ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 bar \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 a-b-c \u2502 #> \u2502 1-2-null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_concat"},{"location":"reference/ExprStr_concat/#concat","text":"","title":"Concat"},{"location":"reference/ExprStr_concat/#arguments","text":"delimiter : string The delimiter to insert between consecutive string values.","title":"Arguments"},{"location":"reference/ExprStr_concat/#returns","text":"Expr of Utf8 concatenated Vertically concat the values in the Series to a single string value.","title":"Returns"},{"location":"reference/ExprStr_concat/#examples","text":"#concatenate a Series of strings to a single string df = pl $ DataFrame ( foo = c ( \"1\" , NA , 2 ) ) df $ select ( pl $ col ( \"foo\" ) $ str $ concat ( \"-\" ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1-null-2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #Series list of strings to Series of concatenated strings df = pl $ DataFrame ( list ( bar = list ( c ( \"a\" , \"b\" , \"c\" ) , c ( \"1\" , \"2\" , NA ) ) ) ) df $ select ( pl $ col ( \"bar\" ) $ arr $ eval ( pl $ col ( ) $ str $ concat ( ) ) $ arr $ first ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 bar \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 a-b-c \u2502 #> \u2502 1-2-null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_contains/","text":"contains Arguments pattern : String or Expr of a string, a valid regex pattern. literal : bool, treat pattern as a literal string. NULL is aliased with FALSE. strict : bool, raise an error if the underlying pattern is not a valid regex expression, otherwise mask out with a null value. Returns Expr returning a Boolean R Check if string contains a substring that matches a regex. Details starts_with : Check if string values start with a substring. ends_with : Check if string values end with a substring. Examples df = pl $ DataFrame ( a = c ( \"Crab\" , \"cat and dog\" , \"rab$bit\" , NA ) ) df $ select ( pl $ col ( \"a\" ) , pl $ col ( \"a\" ) $ str $ contains ( \"cat|bit\" ) $ alias ( \"regex\" ) , pl $ col ( \"a\" ) $ str $ contains ( \"rab$\" , literal = TRUE ) $ alias ( \"literal\" ) ) #> polars DataFrame: shape: (4, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 regex \u2506 literal \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 bool \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Crab \u2506 false \u2506 false \u2502 #> \u2502 cat and dog \u2506 true \u2506 false \u2502 #> \u2502 rab$bit \u2506 true \u2506 true \u2502 #> \u2502 null \u2506 null \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_contains"},{"location":"reference/ExprStr_contains/#contains","text":"","title":"contains"},{"location":"reference/ExprStr_contains/#arguments","text":"pattern : String or Expr of a string, a valid regex pattern. literal : bool, treat pattern as a literal string. NULL is aliased with FALSE. strict : bool, raise an error if the underlying pattern is not a valid regex expression, otherwise mask out with a null value.","title":"Arguments"},{"location":"reference/ExprStr_contains/#returns","text":"Expr returning a Boolean R Check if string contains a substring that matches a regex.","title":"Returns"},{"location":"reference/ExprStr_contains/#details","text":"starts_with : Check if string values start with a substring. ends_with : Check if string values end with a substring.","title":"Details"},{"location":"reference/ExprStr_contains/#examples","text":"df = pl $ DataFrame ( a = c ( \"Crab\" , \"cat and dog\" , \"rab$bit\" , NA ) ) df $ select ( pl $ col ( \"a\" ) , pl $ col ( \"a\" ) $ str $ contains ( \"cat|bit\" ) $ alias ( \"regex\" ) , pl $ col ( \"a\" ) $ str $ contains ( \"rab$\" , literal = TRUE ) $ alias ( \"literal\" ) ) #> polars DataFrame: shape: (4, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 regex \u2506 literal \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 bool \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Crab \u2506 false \u2506 false \u2502 #> \u2502 cat and dog \u2506 true \u2506 false \u2502 #> \u2502 rab$bit \u2506 true \u2506 true \u2502 #> \u2502 null \u2506 null \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_count_match/","text":"count_match Arguments pattern : A valid regex pattern Returns UInt32 array. Contain null if original value is null or regex capture nothing. Count all successive non-overlapping regex matches. Examples df = pl $ DataFrame ( foo = c ( \"123 bla 45 asd\" , \"xyz 678 910t\" ) ) df $ select ( pl $ col ( \"foo\" ) $ str $ count_match ( r\"{(\\d)}\" ) $ alias ( \"count digits\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 count digits \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5 \u2502 #> \u2502 6 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_count_match"},{"location":"reference/ExprStr_count_match/#count_match","text":"","title":"count_match"},{"location":"reference/ExprStr_count_match/#arguments","text":"pattern : A valid regex pattern","title":"Arguments"},{"location":"reference/ExprStr_count_match/#returns","text":"UInt32 array. Contain null if original value is null or regex capture nothing. Count all successive non-overlapping regex matches.","title":"Returns"},{"location":"reference/ExprStr_count_match/#examples","text":"df = pl $ DataFrame ( foo = c ( \"123 bla 45 asd\" , \"xyz 678 910t\" ) ) df $ select ( pl $ col ( \"foo\" ) $ str $ count_match ( r\"{(\\d)}\" ) $ alias ( \"count digits\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 count digits \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5 \u2502 #> \u2502 6 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_decode/","text":"decode Arguments encoding : string choice either 'hex' or 'base64' ... : not used currently strict : Raise an error if the underlying value cannot be decoded, otherwise mask out with a null value. Returns Utf8 array with values decoded using provided encoding Decode a value using the provided encoding. Examples df = pl $ DataFrame ( strings = c ( \"foo\" , \"bar\" , NA ) ) df $ select ( pl $ col ( \"strings\" ) $ str $ encode ( \"hex\" ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 strings \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 666f6f \u2502 #> \u2502 626172 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ with_columns ( pl $ col ( \"strings\" ) $ str $ encode ( \"base64\" ) $ alias ( \"base64\" ) , #notice DataType is not encoded pl $ col ( \"strings\" ) $ str $ encode ( \"hex\" ) $ alias ( \"hex\" ) #... and must restored with cast ) $ with_columns ( pl $ col ( \"base64\" ) $ str $ decode ( \"base64\" ) $ alias ( \"base64_decoded\" ) $ cast ( pl $ Utf8 ) , pl $ col ( \"hex\" ) $ str $ decode ( \"hex\" ) $ alias ( \"hex_decoded\" ) $ cast ( pl $ Utf8 ) ) #> polars DataFrame: shape: (3, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 strings \u2506 base64 \u2506 hex \u2506 base64_decoded \u2506 hex_decoded \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 str \u2506 str \u2506 str \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 foo \u2506 Zm9v \u2506 666f6f \u2506 foo \u2506 foo \u2502 #> \u2502 bar \u2506 YmFy \u2506 626172 \u2506 bar \u2506 bar \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_decode"},{"location":"reference/ExprStr_decode/#decode","text":"","title":"decode"},{"location":"reference/ExprStr_decode/#arguments","text":"encoding : string choice either 'hex' or 'base64' ... : not used currently strict : Raise an error if the underlying value cannot be decoded, otherwise mask out with a null value.","title":"Arguments"},{"location":"reference/ExprStr_decode/#returns","text":"Utf8 array with values decoded using provided encoding Decode a value using the provided encoding.","title":"Returns"},{"location":"reference/ExprStr_decode/#examples","text":"df = pl $ DataFrame ( strings = c ( \"foo\" , \"bar\" , NA ) ) df $ select ( pl $ col ( \"strings\" ) $ str $ encode ( \"hex\" ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 strings \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 666f6f \u2502 #> \u2502 626172 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ with_columns ( pl $ col ( \"strings\" ) $ str $ encode ( \"base64\" ) $ alias ( \"base64\" ) , #notice DataType is not encoded pl $ col ( \"strings\" ) $ str $ encode ( \"hex\" ) $ alias ( \"hex\" ) #... and must restored with cast ) $ with_columns ( pl $ col ( \"base64\" ) $ str $ decode ( \"base64\" ) $ alias ( \"base64_decoded\" ) $ cast ( pl $ Utf8 ) , pl $ col ( \"hex\" ) $ str $ decode ( \"hex\" ) $ alias ( \"hex_decoded\" ) $ cast ( pl $ Utf8 ) ) #> polars DataFrame: shape: (3, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 strings \u2506 base64 \u2506 hex \u2506 base64_decoded \u2506 hex_decoded \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 str \u2506 str \u2506 str \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 foo \u2506 Zm9v \u2506 666f6f \u2506 foo \u2506 foo \u2502 #> \u2502 bar \u2506 YmFy \u2506 626172 \u2506 bar \u2506 bar \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_encode/","text":"encode Arguments encoding : string choice either 'hex' or 'base64' Returns Utf8 array with values encoded using provided encoding Encode a value using the provided encoding. Examples df = pl $ DataFrame ( strings = c ( \"foo\" , \"bar\" , NA ) ) df $ select ( pl $ col ( \"strings\" ) $ str $ encode ( \"hex\" ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 strings \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 666f6f \u2502 #> \u2502 626172 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ with_columns ( pl $ col ( \"strings\" ) $ str $ encode ( \"base64\" ) $ alias ( \"base64\" ) , #notice DataType is not encoded pl $ col ( \"strings\" ) $ str $ encode ( \"hex\" ) $ alias ( \"hex\" ) #... and must restored with cast ) $ with_columns ( pl $ col ( \"base64\" ) $ str $ decode ( \"base64\" ) $ alias ( \"base64_decoded\" ) $ cast ( pl $ Utf8 ) , pl $ col ( \"hex\" ) $ str $ decode ( \"hex\" ) $ alias ( \"hex_decoded\" ) $ cast ( pl $ Utf8 ) ) #> polars DataFrame: shape: (3, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 strings \u2506 base64 \u2506 hex \u2506 base64_decoded \u2506 hex_decoded \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 str \u2506 str \u2506 str \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 foo \u2506 Zm9v \u2506 666f6f \u2506 foo \u2506 foo \u2502 #> \u2502 bar \u2506 YmFy \u2506 626172 \u2506 bar \u2506 bar \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_encode"},{"location":"reference/ExprStr_encode/#encode","text":"","title":"encode"},{"location":"reference/ExprStr_encode/#arguments","text":"encoding : string choice either 'hex' or 'base64'","title":"Arguments"},{"location":"reference/ExprStr_encode/#returns","text":"Utf8 array with values encoded using provided encoding Encode a value using the provided encoding.","title":"Returns"},{"location":"reference/ExprStr_encode/#examples","text":"df = pl $ DataFrame ( strings = c ( \"foo\" , \"bar\" , NA ) ) df $ select ( pl $ col ( \"strings\" ) $ str $ encode ( \"hex\" ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 strings \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 666f6f \u2502 #> \u2502 626172 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ with_columns ( pl $ col ( \"strings\" ) $ str $ encode ( \"base64\" ) $ alias ( \"base64\" ) , #notice DataType is not encoded pl $ col ( \"strings\" ) $ str $ encode ( \"hex\" ) $ alias ( \"hex\" ) #... and must restored with cast ) $ with_columns ( pl $ col ( \"base64\" ) $ str $ decode ( \"base64\" ) $ alias ( \"base64_decoded\" ) $ cast ( pl $ Utf8 ) , pl $ col ( \"hex\" ) $ str $ decode ( \"hex\" ) $ alias ( \"hex_decoded\" ) $ cast ( pl $ Utf8 ) ) #> polars DataFrame: shape: (3, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 strings \u2506 base64 \u2506 hex \u2506 base64_decoded \u2506 hex_decoded \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 str \u2506 str \u2506 str \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 foo \u2506 Zm9v \u2506 666f6f \u2506 foo \u2506 foo \u2502 #> \u2502 bar \u2506 YmFy \u2506 626172 \u2506 bar \u2506 bar \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_ends_with/","text":"ends_with Arguments sub : Suffix substring or Expr. Returns Expr returning a Boolean Check if string values end with a substring. Details contains : Check if string contains a substring that matches a regex. starts_with : Check if string values start with a substring. Examples df = pl $ DataFrame ( fruits = c ( \"apple\" , \"mango\" , NA ) ) df $ select ( pl $ col ( \"fruits\" ) , pl $ col ( \"fruits\" ) $ str $ ends_with ( \"go\" ) $ alias ( \"has_suffix\" ) ) #> polars DataFrame: shape: (3, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 fruits \u2506 has_suffix \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 str \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 apple \u2506 false \u2502 #> \u2502 mango \u2506 true \u2502 #> \u2502 null \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_ends_with"},{"location":"reference/ExprStr_ends_with/#ends_with","text":"","title":"ends_with"},{"location":"reference/ExprStr_ends_with/#arguments","text":"sub : Suffix substring or Expr.","title":"Arguments"},{"location":"reference/ExprStr_ends_with/#returns","text":"Expr returning a Boolean Check if string values end with a substring.","title":"Returns"},{"location":"reference/ExprStr_ends_with/#details","text":"contains : Check if string contains a substring that matches a regex. starts_with : Check if string values start with a substring.","title":"Details"},{"location":"reference/ExprStr_ends_with/#examples","text":"df = pl $ DataFrame ( fruits = c ( \"apple\" , \"mango\" , NA ) ) df $ select ( pl $ col ( \"fruits\" ) , pl $ col ( \"fruits\" ) $ str $ ends_with ( \"go\" ) $ alias ( \"has_suffix\" ) ) #> polars DataFrame: shape: (3, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 fruits \u2506 has_suffix \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 str \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 apple \u2506 false \u2502 #> \u2502 mango \u2506 true \u2502 #> \u2502 null \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_explode/","text":"explode Returns Expr: Series of dtype Utf8. Returns a column with a separate row for every string character. Examples df = pl $ DataFrame ( a = c ( \"foo\" , \"bar\" ) ) df $ select ( pl $ col ( \"a\" ) $ str $ explode ( ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 f \u2502 #> \u2502 o \u2502 #> \u2502 o \u2502 #> \u2502 b \u2502 #> \u2502 a \u2502 #> \u2502 r \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_explode"},{"location":"reference/ExprStr_explode/#explode","text":"","title":"explode"},{"location":"reference/ExprStr_explode/#returns","text":"Expr: Series of dtype Utf8. Returns a column with a separate row for every string character.","title":"Returns"},{"location":"reference/ExprStr_explode/#examples","text":"df = pl $ DataFrame ( a = c ( \"foo\" , \"bar\" ) ) df $ select ( pl $ col ( \"a\" ) $ str $ explode ( ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 f \u2502 #> \u2502 o \u2502 #> \u2502 o \u2502 #> \u2502 b \u2502 #> \u2502 a \u2502 #> \u2502 r \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_extract/","text":"extract Arguments pattern : A valid regex pattern group_index : Index of the targeted capture group. Group 0 mean the whole pattern, first group begin at index 1. Default to the first capture group. Returns Utf8 array. Contain null if original value is null or regex capture nothing. Extract the target capture group from provided patterns. Examples df = pl $ DataFrame ( a = c ( \"http://vote.com/ballon_dor?candidate=messi&ref=polars\" , \"http://vote.com/ballon_dor?candidat=jorginho&ref=polars\" , \"http://vote.com/ballon_dor?candidate=ronaldo&ref=polars\" ) ) df $ select ( pl $ col ( \"a\" ) $ str $ extract ( r\"(candidate=(\\w+))\" , 1 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 messi \u2502 #> \u2502 null \u2502 #> \u2502 ronaldo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_extract"},{"location":"reference/ExprStr_extract/#extract","text":"","title":"extract"},{"location":"reference/ExprStr_extract/#arguments","text":"pattern : A valid regex pattern group_index : Index of the targeted capture group. Group 0 mean the whole pattern, first group begin at index 1. Default to the first capture group.","title":"Arguments"},{"location":"reference/ExprStr_extract/#returns","text":"Utf8 array. Contain null if original value is null or regex capture nothing. Extract the target capture group from provided patterns.","title":"Returns"},{"location":"reference/ExprStr_extract/#examples","text":"df = pl $ DataFrame ( a = c ( \"http://vote.com/ballon_dor?candidate=messi&ref=polars\" , \"http://vote.com/ballon_dor?candidat=jorginho&ref=polars\" , \"http://vote.com/ballon_dor?candidate=ronaldo&ref=polars\" ) ) df $ select ( pl $ col ( \"a\" ) $ str $ extract ( r\"(candidate=(\\w+))\" , 1 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 messi \u2502 #> \u2502 null \u2502 #> \u2502 ronaldo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_extract_all/","text":"extract_all Arguments pattern : A valid regex pattern Returns List[Utf8] array. Contain null if original value is null or regex capture nothing. Extracts all matches for the given regex pattern. Extracts each successive non-overlapping regex match in an individual string as an array. Examples df = pl $ DataFrame ( foo = c ( \"123 bla 45 asd\" , \"xyz 678 910t\" ) ) df $ select ( pl $ col ( \"foo\" ) $ str $ extract_all ( r\"((\\d+))\" ) $ alias ( \"extracted_nrs\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 extracted_nrs \u2502 #> \u2502 --- \u2502 #> \u2502 list[str] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [\"123\", \"45\"] \u2502 #> \u2502 [\"678\", \"910\"] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_extract_all"},{"location":"reference/ExprStr_extract_all/#extract_all","text":"","title":"extract_all"},{"location":"reference/ExprStr_extract_all/#arguments","text":"pattern : A valid regex pattern","title":"Arguments"},{"location":"reference/ExprStr_extract_all/#returns","text":"List[Utf8] array. Contain null if original value is null or regex capture nothing. Extracts all matches for the given regex pattern. Extracts each successive non-overlapping regex match in an individual string as an array.","title":"Returns"},{"location":"reference/ExprStr_extract_all/#examples","text":"df = pl $ DataFrame ( foo = c ( \"123 bla 45 asd\" , \"xyz 678 910t\" ) ) df $ select ( pl $ col ( \"foo\" ) $ str $ extract_all ( r\"((\\d+))\" ) $ alias ( \"extracted_nrs\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 extracted_nrs \u2502 #> \u2502 --- \u2502 #> \u2502 list[str] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [\"123\", \"45\"] \u2502 #> \u2502 [\"678\", \"910\"] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_json_extract/","text":"json_extract Arguments dtype : The dtype to cast the extracted value to. If None, the dtype will be inferred from the JSON value. Returns Expr returning a boolean Parse string values as JSON. Details Throw errors if encounter invalid json strings. Examples df = pl $ DataFrame ( json_val = c ( '{\"a\":1, \"b\": true}' , NA , '{\"a\":2, \"b\": false}' ) ) dtype = pl $ Struct ( pl $ Field ( \"a\" , pl $ Int64 ) , pl $ Field ( \"b\" , pl $ Boolean ) ) df $ select ( pl $ col ( \"json_val\" ) $ str $ json_extract ( dtype ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 json_val \u2502 #> \u2502 --- \u2502 #> \u2502 struct[2] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {1,true} \u2502 #> \u2502 {null,null} \u2502 #> \u2502 {2,false} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_json_extract"},{"location":"reference/ExprStr_json_extract/#json_extract","text":"","title":"json_extract"},{"location":"reference/ExprStr_json_extract/#arguments","text":"dtype : The dtype to cast the extracted value to. If None, the dtype will be inferred from the JSON value.","title":"Arguments"},{"location":"reference/ExprStr_json_extract/#returns","text":"Expr returning a boolean Parse string values as JSON.","title":"Returns"},{"location":"reference/ExprStr_json_extract/#details","text":"Throw errors if encounter invalid json strings.","title":"Details"},{"location":"reference/ExprStr_json_extract/#examples","text":"df = pl $ DataFrame ( json_val = c ( '{\"a\":1, \"b\": true}' , NA , '{\"a\":2, \"b\": false}' ) ) dtype = pl $ Struct ( pl $ Field ( \"a\" , pl $ Int64 ) , pl $ Field ( \"b\" , pl $ Boolean ) ) df $ select ( pl $ col ( \"json_val\" ) $ str $ json_extract ( dtype ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 json_val \u2502 #> \u2502 --- \u2502 #> \u2502 struct[2] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {1,true} \u2502 #> \u2502 {null,null} \u2502 #> \u2502 {2,false} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_json_path_match/","text":"json_path_match Arguments json_path : A valid JSON path query string. Returns Utf8 array. Contain null if original value is null or the json_path return nothing. Extract the first match of json string with provided JSONPath expression. Details Throw errors if encounter invalid json strings. All return value will be casted to Utf8 regardless of the original value. Documentation on JSONPath standard can be found here <https://goessner.net/articles/JsonPath/> _. Examples df = pl $ DataFrame ( json_val = c ( '{\"a\":\"1\"}' , NA , '{\"a\":2}' , '{\"a\":2.1}' , '{\"a\":true}' ) ) df $ select ( pl $ col ( \"json_val\" ) $ str $ json_path_match ( \"$.a\" ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 json_val \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 null \u2502 #> \u2502 2 \u2502 #> \u2502 2.1 \u2502 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_json_path_match"},{"location":"reference/ExprStr_json_path_match/#json_path_match","text":"","title":"json_path_match"},{"location":"reference/ExprStr_json_path_match/#arguments","text":"json_path : A valid JSON path query string.","title":"Arguments"},{"location":"reference/ExprStr_json_path_match/#returns","text":"Utf8 array. Contain null if original value is null or the json_path return nothing. Extract the first match of json string with provided JSONPath expression.","title":"Returns"},{"location":"reference/ExprStr_json_path_match/#details","text":"Throw errors if encounter invalid json strings. All return value will be casted to Utf8 regardless of the original value. Documentation on JSONPath standard can be found here <https://goessner.net/articles/JsonPath/> _.","title":"Details"},{"location":"reference/ExprStr_json_path_match/#examples","text":"df = pl $ DataFrame ( json_val = c ( '{\"a\":\"1\"}' , NA , '{\"a\":2}' , '{\"a\":2.1}' , '{\"a\":true}' ) ) df $ select ( pl $ col ( \"json_val\" ) $ str $ json_path_match ( \"$.a\" ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 json_val \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 null \u2502 #> \u2502 2 \u2502 #> \u2502 2.1 \u2502 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_lengths/","text":"lengths Format function Returns Expr of u32 lengths Get length of the strings as UInt32 (as number of bytes). Details The returned lengths are equal to the number of bytes in the UTF8 string. If you need the length in terms of the number of characters, use n_chars instead. Examples pl $ DataFrame ( s = c ( \"Caf\u00e9\" , NA , \"345\" , \"\u00e6\u00f8\u00e5\" ) ) $ select ( pl $ col ( \"s\" ) , pl $ col ( \"s\" ) $ str $ lengths ( ) $ alias ( \"lengths\" ) , pl $ col ( \"s\" ) $ str $ n_chars ( ) $ alias ( \"n_chars\" ) ) #> polars DataFrame: shape: (4, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2506 lengths \u2506 n_chars \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 u32 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Caf\u00e9 \u2506 5 \u2506 4 \u2502 #> \u2502 null \u2506 null \u2506 null \u2502 #> \u2502 345 \u2506 3 \u2506 3 \u2502 #> \u2502 \u00e6\u00f8\u00e5 \u2506 6 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_lengths"},{"location":"reference/ExprStr_lengths/#lengths","text":"","title":"lengths"},{"location":"reference/ExprStr_lengths/#format","text":"function","title":"Format"},{"location":"reference/ExprStr_lengths/#returns","text":"Expr of u32 lengths Get length of the strings as UInt32 (as number of bytes).","title":"Returns"},{"location":"reference/ExprStr_lengths/#details","text":"The returned lengths are equal to the number of bytes in the UTF8 string. If you need the length in terms of the number of characters, use n_chars instead.","title":"Details"},{"location":"reference/ExprStr_lengths/#examples","text":"pl $ DataFrame ( s = c ( \"Caf\u00e9\" , NA , \"345\" , \"\u00e6\u00f8\u00e5\" ) ) $ select ( pl $ col ( \"s\" ) , pl $ col ( \"s\" ) $ str $ lengths ( ) $ alias ( \"lengths\" ) , pl $ col ( \"s\" ) $ str $ n_chars ( ) $ alias ( \"n_chars\" ) ) #> polars DataFrame: shape: (4, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2506 lengths \u2506 n_chars \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 u32 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Caf\u00e9 \u2506 5 \u2506 4 \u2502 #> \u2502 null \u2506 null \u2506 null \u2502 #> \u2502 345 \u2506 3 \u2506 3 \u2502 #> \u2502 \u00e6\u00f8\u00e5 \u2506 6 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_ljust/","text":"ljust Arguments width : Justify left to this length. fillchar : Fill with this ASCII character. Returns Expr of Utf8 Return the string left justified in a string of length width . Details Padding is done using the specified fillchar . The original string is returned if width is less than or equal to len(s) . Examples df = pl $ DataFrame ( a = c ( \"cow\" , \"monkey\" , NA , \"hippopotamus\" ) ) df $ select ( pl $ col ( \"a\" ) $ str $ ljust ( 8 , \"*\" ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 cow***** \u2502 #> \u2502 monkey** \u2502 #> \u2502 null \u2502 #> \u2502 hippopotamus \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_ljust"},{"location":"reference/ExprStr_ljust/#ljust","text":"","title":"ljust"},{"location":"reference/ExprStr_ljust/#arguments","text":"width : Justify left to this length. fillchar : Fill with this ASCII character.","title":"Arguments"},{"location":"reference/ExprStr_ljust/#returns","text":"Expr of Utf8 Return the string left justified in a string of length width .","title":"Returns"},{"location":"reference/ExprStr_ljust/#details","text":"Padding is done using the specified fillchar . The original string is returned if width is less than or equal to len(s) .","title":"Details"},{"location":"reference/ExprStr_ljust/#examples","text":"df = pl $ DataFrame ( a = c ( \"cow\" , \"monkey\" , NA , \"hippopotamus\" ) ) df $ select ( pl $ col ( \"a\" ) $ str $ ljust ( 8 , \"*\" ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 cow***** \u2502 #> \u2502 monkey** \u2502 #> \u2502 null \u2502 #> \u2502 hippopotamus \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_lstrip/","text":"lstrip Arguments matches : The set of characters to be removed. All combinations of this set of characters will be stripped. If set to NULL (default), all whitespace is removed instead. Returns Expr of Utf8 lowercase chars Remove leading characters. Details will not strip anyt chars beyond the first char not matched. strip() starts from both left and right. Whereas lstrip() and rstrip() starts from left and right respectively. Examples df = pl $ DataFrame ( foo = c ( \" hello\" , \"\\tworld\" ) ) df $ select ( pl $ col ( \"foo\" ) $ str $ strip ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 world \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ strip ( \" hel rld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 o \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ lstrip ( \" hel rld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 o \u2502 #> \u2502 world \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ rstrip ( \" hel\\trld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ rstrip ( \"rldhel\\t \" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_lstrip"},{"location":"reference/ExprStr_lstrip/#lstrip","text":"","title":"lstrip"},{"location":"reference/ExprStr_lstrip/#arguments","text":"matches : The set of characters to be removed. All combinations of this set of characters will be stripped. If set to NULL (default), all whitespace is removed instead.","title":"Arguments"},{"location":"reference/ExprStr_lstrip/#returns","text":"Expr of Utf8 lowercase chars Remove leading characters.","title":"Returns"},{"location":"reference/ExprStr_lstrip/#details","text":"will not strip anyt chars beyond the first char not matched. strip() starts from both left and right. Whereas lstrip() and rstrip() starts from left and right respectively.","title":"Details"},{"location":"reference/ExprStr_lstrip/#examples","text":"df = pl $ DataFrame ( foo = c ( \" hello\" , \"\\tworld\" ) ) df $ select ( pl $ col ( \"foo\" ) $ str $ strip ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 world \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ strip ( \" hel rld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 o \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ lstrip ( \" hel rld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 o \u2502 #> \u2502 world \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ rstrip ( \" hel\\trld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ rstrip ( \"rldhel\\t \" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_n_chars/","text":"n_chars Format function Returns Expr of u32 n_chars Get length of the strings as UInt32 (as number of chars). Details If you know that you are working with ASCII text, lengths will be equivalent, and faster (returns length in terms of the number of bytes). Examples pl $ DataFrame ( s = c ( \"Caf\u00e9\" , NA , \"345\" , \"\u00e6\u00f8\u00e5\" ) ) $ select ( pl $ col ( \"s\" ) , pl $ col ( \"s\" ) $ str $ lengths ( ) $ alias ( \"lengths\" ) , pl $ col ( \"s\" ) $ str $ n_chars ( ) $ alias ( \"n_chars\" ) ) #> polars DataFrame: shape: (4, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2506 lengths \u2506 n_chars \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 u32 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Caf\u00e9 \u2506 5 \u2506 4 \u2502 #> \u2502 null \u2506 null \u2506 null \u2502 #> \u2502 345 \u2506 3 \u2506 3 \u2502 #> \u2502 \u00e6\u00f8\u00e5 \u2506 6 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_n_chars"},{"location":"reference/ExprStr_n_chars/#n_chars","text":"","title":"n_chars"},{"location":"reference/ExprStr_n_chars/#format","text":"function","title":"Format"},{"location":"reference/ExprStr_n_chars/#returns","text":"Expr of u32 n_chars Get length of the strings as UInt32 (as number of chars).","title":"Returns"},{"location":"reference/ExprStr_n_chars/#details","text":"If you know that you are working with ASCII text, lengths will be equivalent, and faster (returns length in terms of the number of bytes).","title":"Details"},{"location":"reference/ExprStr_n_chars/#examples","text":"pl $ DataFrame ( s = c ( \"Caf\u00e9\" , NA , \"345\" , \"\u00e6\u00f8\u00e5\" ) ) $ select ( pl $ col ( \"s\" ) , pl $ col ( \"s\" ) $ str $ lengths ( ) $ alias ( \"lengths\" ) , pl $ col ( \"s\" ) $ str $ n_chars ( ) $ alias ( \"n_chars\" ) ) #> polars DataFrame: shape: (4, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2506 lengths \u2506 n_chars \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 u32 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Caf\u00e9 \u2506 5 \u2506 4 \u2502 #> \u2502 null \u2506 null \u2506 null \u2502 #> \u2502 345 \u2506 3 \u2506 3 \u2502 #> \u2502 \u00e6\u00f8\u00e5 \u2506 6 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_parse_int/","text":"parse_int Arguments radix : Positive integer which is the base of the string we are parsing. Default: 2 Returns Expr: Series of dtype i32. Parse integers with base radix from strings. By default base 2. Examples df = pl $ DataFrame ( bin = c ( \"110\" , \"101\" , \"010\" ) ) df $ select ( pl $ col ( \"bin\" ) $ str $ parse_int ( 2 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 bin \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6 \u2502 #> \u2502 5 \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_parse_int"},{"location":"reference/ExprStr_parse_int/#parse_int","text":"","title":"parse_int"},{"location":"reference/ExprStr_parse_int/#arguments","text":"radix : Positive integer which is the base of the string we are parsing. Default: 2","title":"Arguments"},{"location":"reference/ExprStr_parse_int/#returns","text":"Expr: Series of dtype i32. Parse integers with base radix from strings. By default base 2.","title":"Returns"},{"location":"reference/ExprStr_parse_int/#examples","text":"df = pl $ DataFrame ( bin = c ( \"110\" , \"101\" , \"010\" ) ) df $ select ( pl $ col ( \"bin\" ) $ str $ parse_int ( 2 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 bin \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6 \u2502 #> \u2502 5 \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_replace/","text":"replace Arguments pattern : Into , regex pattern value : Into replcacement literal : bool, Treat pattern as a literal string. Returns Expr of Utf8 Series Replace first matching regex/literal substring with a new string value. Examples df = pl $ DataFrame ( id = c ( 1 , 2 ) , text = c ( \"123abc\" , \"abc456\" ) ) df $ with_columns ( pl $ col ( \"text\" ) $ str $ replace ( r\"{abc\\b}\" , \"ABC\" ) ) #> polars DataFrame: shape: (2, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 id \u2506 text \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 123ABC \u2502 #> \u2502 2.0 \u2506 abc456 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_replace"},{"location":"reference/ExprStr_replace/#replace","text":"","title":"replace"},{"location":"reference/ExprStr_replace/#arguments","text":"pattern : Into , regex pattern value : Into replcacement literal : bool, Treat pattern as a literal string.","title":"Arguments"},{"location":"reference/ExprStr_replace/#returns","text":"Expr of Utf8 Series Replace first matching regex/literal substring with a new string value.","title":"Returns"},{"location":"reference/ExprStr_replace/#examples","text":"df = pl $ DataFrame ( id = c ( 1 , 2 ) , text = c ( \"123abc\" , \"abc456\" ) ) df $ with_columns ( pl $ col ( \"text\" ) $ str $ replace ( r\"{abc\\b}\" , \"ABC\" ) ) #> polars DataFrame: shape: (2, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 id \u2506 text \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 123ABC \u2502 #> \u2502 2.0 \u2506 abc456 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_replace_all/","text":"replace_all Arguments pattern : Into , regex pattern value : Into replcacement literal : bool, treat pattern as a literal string. Returns Expr of Utf8 Series Replace all matching regex/literal substrings with a new string value. Examples df = pl $ DataFrame ( id = c ( 1 , 2 ) , text = c ( \"abcabc\" , \"123a123\" ) ) df $ with_columns ( pl $ col ( \"text\" ) $ str $ replace_all ( \"a\" , \"-\" ) ) #> polars DataFrame: shape: (2, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 id \u2506 text \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 -bc-bc \u2502 #> \u2502 2.0 \u2506 123-123 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_replace_all"},{"location":"reference/ExprStr_replace_all/#replace_all","text":"","title":"replace_all"},{"location":"reference/ExprStr_replace_all/#arguments","text":"pattern : Into , regex pattern value : Into replcacement literal : bool, treat pattern as a literal string.","title":"Arguments"},{"location":"reference/ExprStr_replace_all/#returns","text":"Expr of Utf8 Series Replace all matching regex/literal substrings with a new string value.","title":"Returns"},{"location":"reference/ExprStr_replace_all/#examples","text":"df = pl $ DataFrame ( id = c ( 1 , 2 ) , text = c ( \"abcabc\" , \"123a123\" ) ) df $ with_columns ( pl $ col ( \"text\" ) $ str $ replace_all ( \"a\" , \"-\" ) ) #> polars DataFrame: shape: (2, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 id \u2506 text \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 -bc-bc \u2502 #> \u2502 2.0 \u2506 123-123 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_rjust/","text":"rjust Arguments width : Justify left to this length. fillchar : Fill with this ASCII character. Returns Expr of Utf8 Return the string left justified in a string of length width . Details Padding is done using the specified fillchar . The original string is returned if width is less than or equal to len(s) . Examples df = pl $ DataFrame ( a = c ( \"cow\" , \"monkey\" , NA , \"hippopotamus\" ) ) df $ select ( pl $ col ( \"a\" ) $ str $ rjust ( 8 , \"*\" ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 *****cow \u2502 #> \u2502 **monkey \u2502 #> \u2502 null \u2502 #> \u2502 hippopotamus \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_rjust"},{"location":"reference/ExprStr_rjust/#rjust","text":"","title":"rjust"},{"location":"reference/ExprStr_rjust/#arguments","text":"width : Justify left to this length. fillchar : Fill with this ASCII character.","title":"Arguments"},{"location":"reference/ExprStr_rjust/#returns","text":"Expr of Utf8 Return the string left justified in a string of length width .","title":"Returns"},{"location":"reference/ExprStr_rjust/#details","text":"Padding is done using the specified fillchar . The original string is returned if width is less than or equal to len(s) .","title":"Details"},{"location":"reference/ExprStr_rjust/#examples","text":"df = pl $ DataFrame ( a = c ( \"cow\" , \"monkey\" , NA , \"hippopotamus\" ) ) df $ select ( pl $ col ( \"a\" ) $ str $ rjust ( 8 , \"*\" ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 *****cow \u2502 #> \u2502 **monkey \u2502 #> \u2502 null \u2502 #> \u2502 hippopotamus \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_rstrip/","text":"rstrip Arguments matches : The set of characters to be removed. All combinations of this set of characters will be stripped. If set to NULL (default), all whitespace is removed instead. Returns Expr of Utf8 lowercase chars Remove leading characters. Details will not strip anyt chars beyond the first char not matched. strip() starts from both left and right. Whereas rstrip() and rstrip() starts from left and right respectively. Examples df = pl $ DataFrame ( foo = c ( \" hello\" , \"\\tworld\" ) ) df $ select ( pl $ col ( \"foo\" ) $ str $ strip ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 world \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ strip ( \" hel rld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 o \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ lstrip ( \" hel rld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 o \u2502 #> \u2502 world \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ rstrip ( \" hel\\trld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ rstrip ( \"rldhel\\t \" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_rstrip"},{"location":"reference/ExprStr_rstrip/#rstrip","text":"","title":"rstrip"},{"location":"reference/ExprStr_rstrip/#arguments","text":"matches : The set of characters to be removed. All combinations of this set of characters will be stripped. If set to NULL (default), all whitespace is removed instead.","title":"Arguments"},{"location":"reference/ExprStr_rstrip/#returns","text":"Expr of Utf8 lowercase chars Remove leading characters.","title":"Returns"},{"location":"reference/ExprStr_rstrip/#details","text":"will not strip anyt chars beyond the first char not matched. strip() starts from both left and right. Whereas rstrip() and rstrip() starts from left and right respectively.","title":"Details"},{"location":"reference/ExprStr_rstrip/#examples","text":"df = pl $ DataFrame ( foo = c ( \" hello\" , \"\\tworld\" ) ) df $ select ( pl $ col ( \"foo\" ) $ str $ strip ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 world \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ strip ( \" hel rld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 o \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ lstrip ( \" hel rld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 o \u2502 #> \u2502 world \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ rstrip ( \" hel\\trld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ rstrip ( \"rldhel\\t \" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_slice/","text":"slice Arguments pattern : Into , regex pattern value : Into replcacement literal : bool, treat pattern as a literal string. Returns Expr: Series of dtype Utf8. Create subslices of the string values of a Utf8 Series. Examples df = pl $ DataFrame ( s = c ( \"pear\" , NA , \"papaya\" , \"dragonfruit\" ) ) df $ with_columns ( pl $ col ( \"s\" ) $ str $ slice ( - 3 ) $ alias ( \"s_sliced\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2506 s_sliced \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 str \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 pear \u2506 ear \u2502 #> \u2502 null \u2506 null \u2502 #> \u2502 papaya \u2506 aya \u2502 #> \u2502 dragonfruit \u2506 uit \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_slice"},{"location":"reference/ExprStr_slice/#slice","text":"","title":"slice"},{"location":"reference/ExprStr_slice/#arguments","text":"pattern : Into , regex pattern value : Into replcacement literal : bool, treat pattern as a literal string.","title":"Arguments"},{"location":"reference/ExprStr_slice/#returns","text":"Expr: Series of dtype Utf8. Create subslices of the string values of a Utf8 Series.","title":"Returns"},{"location":"reference/ExprStr_slice/#examples","text":"df = pl $ DataFrame ( s = c ( \"pear\" , NA , \"papaya\" , \"dragonfruit\" ) ) df $ with_columns ( pl $ col ( \"s\" ) $ str $ slice ( - 3 ) $ alias ( \"s_sliced\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2506 s_sliced \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 str \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 pear \u2506 ear \u2502 #> \u2502 null \u2506 null \u2502 #> \u2502 papaya \u2506 aya \u2502 #> \u2502 dragonfruit \u2506 uit \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_split/","text":"split Arguments by : Substring to split by. inclusive : If True, include the split character/string in the results. Returns List of Utf8 type Split the string by a substring. Examples df = pl $ DataFrame ( s = c ( \"foo bar\" , \"foo-bar\" , \"foo bar baz\" ) ) df $ select ( pl $ col ( \"s\" ) $ str $ split ( by = \" \" ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 list[str] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [\"foo\", \"bar\"] \u2502 #> \u2502 [\"foo-bar\"] \u2502 #> \u2502 [\"foo\", \"bar\", \"baz\"] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_split"},{"location":"reference/ExprStr_split/#split","text":"","title":"split"},{"location":"reference/ExprStr_split/#arguments","text":"by : Substring to split by. inclusive : If True, include the split character/string in the results.","title":"Arguments"},{"location":"reference/ExprStr_split/#returns","text":"List of Utf8 type Split the string by a substring.","title":"Returns"},{"location":"reference/ExprStr_split/#examples","text":"df = pl $ DataFrame ( s = c ( \"foo bar\" , \"foo-bar\" , \"foo bar baz\" ) ) df $ select ( pl $ col ( \"s\" ) $ str $ split ( by = \" \" ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 list[str] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [\"foo\", \"bar\"] \u2502 #> \u2502 [\"foo-bar\"] \u2502 #> \u2502 [\"foo\", \"bar\", \"baz\"] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_split_exact/","text":"split_exact Arguments by : Substring to split by. n : Number of splits to make. inclusive : If True, include the split_exact character/string in the results. Returns Struct where each of n+1 fields is of Utf8 type Split the string by a substring using n splits. Results in a struct of n+1 fields. If it cannot make n splits, the remaining field elements will be null. Examples df = pl $ DataFrame ( s = c ( \"a_1\" , NA , \"c\" , \"d_4\" ) ) df $ select ( pl $ col ( \"s\" ) $ str $ split_exact ( by = \"_\" , 1 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 struct[2] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {\"a\",\"1\"} \u2502 #> \u2502 {null,null} \u2502 #> \u2502 {\"c\",null} \u2502 #> \u2502 {\"d\",\"4\"} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_split_exact"},{"location":"reference/ExprStr_split_exact/#split_exact","text":"","title":"split_exact"},{"location":"reference/ExprStr_split_exact/#arguments","text":"by : Substring to split by. n : Number of splits to make. inclusive : If True, include the split_exact character/string in the results.","title":"Arguments"},{"location":"reference/ExprStr_split_exact/#returns","text":"Struct where each of n+1 fields is of Utf8 type Split the string by a substring using n splits. Results in a struct of n+1 fields. If it cannot make n splits, the remaining field elements will be null.","title":"Returns"},{"location":"reference/ExprStr_split_exact/#examples","text":"df = pl $ DataFrame ( s = c ( \"a_1\" , NA , \"c\" , \"d_4\" ) ) df $ select ( pl $ col ( \"s\" ) $ str $ split_exact ( by = \"_\" , 1 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 struct[2] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {\"a\",\"1\"} \u2502 #> \u2502 {null,null} \u2502 #> \u2502 {\"c\",null} \u2502 #> \u2502 {\"d\",\"4\"} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_splitn/","text":"splitn Arguments by : Substring to split by. n : Number of splits to make. Returns Struct where each of n+1 fields is of Utf8 type Split the string by a substring, restricted to returning at most n items. If the number of possible splits is less than n-1 , the remaining field elements will be null. If the number of possible splits is n-1 or greater, the last (nth) substring will contain the remainder of the string. Examples df = pl $ DataFrame ( s = c ( \"a_1\" , NA , \"c\" , \"d_4\" ) ) df $ select ( pl $ col ( \"s\" ) $ str $ splitn ( by = \"_\" , 0 ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 struct[1] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {null} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"s\" ) $ str $ splitn ( by = \"_\" , 1 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 struct[1] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {\"a_1\"} \u2502 #> \u2502 {null} \u2502 #> \u2502 {\"c\"} \u2502 #> \u2502 {\"d_4\"} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"s\" ) $ str $ splitn ( by = \"_\" , 2 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 struct[2] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {\"a\",\"1\"} \u2502 #> \u2502 {null,null} \u2502 #> \u2502 {\"c\",null} \u2502 #> \u2502 {\"d\",\"4\"} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_splitn"},{"location":"reference/ExprStr_splitn/#splitn","text":"","title":"splitn"},{"location":"reference/ExprStr_splitn/#arguments","text":"by : Substring to split by. n : Number of splits to make.","title":"Arguments"},{"location":"reference/ExprStr_splitn/#returns","text":"Struct where each of n+1 fields is of Utf8 type Split the string by a substring, restricted to returning at most n items. If the number of possible splits is less than n-1 , the remaining field elements will be null. If the number of possible splits is n-1 or greater, the last (nth) substring will contain the remainder of the string.","title":"Returns"},{"location":"reference/ExprStr_splitn/#examples","text":"df = pl $ DataFrame ( s = c ( \"a_1\" , NA , \"c\" , \"d_4\" ) ) df $ select ( pl $ col ( \"s\" ) $ str $ splitn ( by = \"_\" , 0 ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 struct[1] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {null} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"s\" ) $ str $ splitn ( by = \"_\" , 1 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 struct[1] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {\"a_1\"} \u2502 #> \u2502 {null} \u2502 #> \u2502 {\"c\"} \u2502 #> \u2502 {\"d_4\"} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"s\" ) $ str $ splitn ( by = \"_\" , 2 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 struct[2] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {\"a\",\"1\"} \u2502 #> \u2502 {null,null} \u2502 #> \u2502 {\"c\",null} \u2502 #> \u2502 {\"d\",\"4\"} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_starts_with/","text":"starts_with Arguments sub : Prefix substring or Expr. Returns Expr returning a Boolean Check if string values starts with a substring. Details contains : Check if string contains a substring that matches a regex. ends_with : Check if string values end with a substring. Examples df = pl $ DataFrame ( fruits = c ( \"apple\" , \"mango\" , NA ) ) df $ select ( pl $ col ( \"fruits\" ) , pl $ col ( \"fruits\" ) $ str $ starts_with ( \"app\" ) $ alias ( \"has_suffix\" ) ) #> polars DataFrame: shape: (3, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 fruits \u2506 has_suffix \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 str \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 apple \u2506 true \u2502 #> \u2502 mango \u2506 false \u2502 #> \u2502 null \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_starts_with"},{"location":"reference/ExprStr_starts_with/#starts_with","text":"","title":"starts_with"},{"location":"reference/ExprStr_starts_with/#arguments","text":"sub : Prefix substring or Expr.","title":"Arguments"},{"location":"reference/ExprStr_starts_with/#returns","text":"Expr returning a Boolean Check if string values starts with a substring.","title":"Returns"},{"location":"reference/ExprStr_starts_with/#details","text":"contains : Check if string contains a substring that matches a regex. ends_with : Check if string values end with a substring.","title":"Details"},{"location":"reference/ExprStr_starts_with/#examples","text":"df = pl $ DataFrame ( fruits = c ( \"apple\" , \"mango\" , NA ) ) df $ select ( pl $ col ( \"fruits\" ) , pl $ col ( \"fruits\" ) $ str $ starts_with ( \"app\" ) $ alias ( \"has_suffix\" ) ) #> polars DataFrame: shape: (3, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 fruits \u2506 has_suffix \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 str \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 apple \u2506 true \u2502 #> \u2502 mango \u2506 false \u2502 #> \u2502 null \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_strip/","text":"Strip Arguments matches : The set of characters to be removed. All combinations of this set of characters will be stripped. If set to NULL (default), all whitespace is removed instead. Returns Expr of Utf8 lowercase chars Remove leading and trailing characters. Details will not strip anyt chars beyond the first char not matched. strip() starts from both left and right. Whereas lstrip() and rstrip() starts from left and right respectively. Examples df = pl $ DataFrame ( foo = c ( \" hello\" , \"\\tworld\" ) ) df $ select ( pl $ col ( \"foo\" ) $ str $ strip ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 world \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ strip ( \" hel rld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 o \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ lstrip ( \" hel rld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 o \u2502 #> \u2502 world \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ rstrip ( \" hel\\trld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ rstrip ( \"rldhel\\t \" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStr_strip"},{"location":"reference/ExprStr_strip/#strip","text":"","title":"Strip"},{"location":"reference/ExprStr_strip/#arguments","text":"matches : The set of characters to be removed. All combinations of this set of characters will be stripped. If set to NULL (default), all whitespace is removed instead.","title":"Arguments"},{"location":"reference/ExprStr_strip/#returns","text":"Expr of Utf8 lowercase chars Remove leading and trailing characters.","title":"Returns"},{"location":"reference/ExprStr_strip/#details","text":"will not strip anyt chars beyond the first char not matched. strip() starts from both left and right. Whereas lstrip() and rstrip() starts from left and right respectively.","title":"Details"},{"location":"reference/ExprStr_strip/#examples","text":"df = pl $ DataFrame ( foo = c ( \" hello\" , \"\\tworld\" ) ) df $ select ( pl $ col ( \"foo\" ) $ str $ strip ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 world \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ strip ( \" hel rld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 o \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ lstrip ( \" hel rld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 o \u2502 #> \u2502 world \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ rstrip ( \" hel\\trld\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"foo\" ) $ str $ rstrip ( \"rldhel\\t \" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 hello \u2502 #> \u2502 wo \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStr_strptime/","text":"strptime Arguments datatype : a temporal data type either pl$Date, pl$Time or pl$Datetime fmt : fmt string for parsenig see see details here https://docs.rs/chrono/latest/chrono/format/strftime/index.html#fn6 Notice time_zone %Z is not supported and will just ignore timezones. Numeric tz like %z, %:z .... are supported. strict : bool, if true raise error if a single string cannot be parsed, else produce a polars null . exact : bool , If True, require an exact format match. If False, allow the format to match anywhere in the target string. cache : Use a cache of unique, converted dates to apply the datetime conversion. tz_aware : bool, Parse timezone aware datetimes. This may be automatically toggled by the \u2018fmt\u2019 given. utc : bool Parse timezone aware datetimes as UTC. This may be useful if you have data with mixed offsets. Returns Expr of a Data, Datetime or Time Series Parse a Series of dtype Utf8 to a Date/Datetime Series. Details Notes When parsing a Datetime the column precision will be inferred from the format string, if given, eg: \u201c%F %T%.3f\u201d => Datetime(\u201cms\u201d). If no fractional second component is found then the default is \u201cus\u201d. Examples s = pl $ Series ( c ( \"2021-04-22\" , \"2022-01-04 00:00:00\" , \"01/31/22\" , \"Sun Jul 8 00:34:60 2001\" ) , \"date\" ) #' #join multiple passes with different fmt s $ to_frame ( ) $ with_columns ( pl $ col ( \"date\" ) $ str $ strptime ( pl $ Date , \"%F\" , strict = FALSE ) $ fill_null ( pl $ col ( \"date\" ) $ str $ strptime ( pl $ Date , \"%F %T\" , strict = FALSE ) ) $ fill_null ( pl $ col ( \"date\" ) $ str $ strptime ( pl $ Date , \"%D\" , strict = FALSE ) ) $ fill_null ( pl $ col ( \"date\" ) $ str $ strptime ( pl $ Date , \"%c\" , strict = FALSE ) ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2502 #> \u2502 --- \u2502 #> \u2502 date \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2021-04-22 \u2502 #> \u2502 2022-01-04 \u2502 #> \u2502 2022-01-31 \u2502 #> \u2502 2001-07-08 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 txt_datetimes = c ( \"2023-01-01 11:22:33 -0100\" , \"2023-01-01 11:22:33 +0300\" , \"invalid time\" ) pl $ lit ( txt_datetimes ) $ str $ strptime ( pl $ Datetime ( \"ns\" ) ,fmt = \"%Y-%m-%d %H:%M:%S %z\" , strict = FALSE , tz_aware = TRUE , utc = TRUE ) $ lit_to_s ( ) #> polars Series: shape: (3,) #> Series: '' [datetime[ns, UTC]] #> [ #> 2023-01-01 12:22:33 UTC #> 2023-01-01 08:22:33 UTC #> null #> ]","title":"ExprStr_strptime"},{"location":"reference/ExprStr_strptime/#strptime","text":"","title":"strptime"},{"location":"reference/ExprStr_strptime/#arguments","text":"datatype : a temporal data type either pl$Date, pl$Time or pl$Datetime fmt : fmt string for parsenig see see details here https://docs.rs/chrono/latest/chrono/format/strftime/index.html#fn6 Notice time_zone %Z is not supported and will just ignore timezones. Numeric tz like %z, %:z .... are supported. strict : bool, if true raise error if a single string cannot be parsed, else produce a polars null . exact : bool , If True, require an exact format match. If False, allow the format to match anywhere in the target string. cache : Use a cache of unique, converted dates to apply the datetime conversion. tz_aware : bool, Parse timezone aware datetimes. This may be automatically toggled by the \u2018fmt\u2019 given. utc : bool Parse timezone aware datetimes as UTC. This may be useful if you have data with mixed offsets.","title":"Arguments"},{"location":"reference/ExprStr_strptime/#returns","text":"Expr of a Data, Datetime or Time Series Parse a Series of dtype Utf8 to a Date/Datetime Series.","title":"Returns"},{"location":"reference/ExprStr_strptime/#details","text":"Notes When parsing a Datetime the column precision will be inferred from the format string, if given, eg: \u201c%F %T%.3f\u201d => Datetime(\u201cms\u201d). If no fractional second component is found then the default is \u201cus\u201d.","title":"Details"},{"location":"reference/ExprStr_strptime/#examples","text":"s = pl $ Series ( c ( \"2021-04-22\" , \"2022-01-04 00:00:00\" , \"01/31/22\" , \"Sun Jul 8 00:34:60 2001\" ) , \"date\" ) #' #join multiple passes with different fmt s $ to_frame ( ) $ with_columns ( pl $ col ( \"date\" ) $ str $ strptime ( pl $ Date , \"%F\" , strict = FALSE ) $ fill_null ( pl $ col ( \"date\" ) $ str $ strptime ( pl $ Date , \"%F %T\" , strict = FALSE ) ) $ fill_null ( pl $ col ( \"date\" ) $ str $ strptime ( pl $ Date , \"%D\" , strict = FALSE ) ) $ fill_null ( pl $ col ( \"date\" ) $ str $ strptime ( pl $ Date , \"%c\" , strict = FALSE ) ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 date \u2502 #> \u2502 --- \u2502 #> \u2502 date \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2021-04-22 \u2502 #> \u2502 2022-01-04 \u2502 #> \u2502 2022-01-31 \u2502 #> \u2502 2001-07-08 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 txt_datetimes = c ( \"2023-01-01 11:22:33 -0100\" , \"2023-01-01 11:22:33 +0300\" , \"invalid time\" ) pl $ lit ( txt_datetimes ) $ str $ strptime ( pl $ Datetime ( \"ns\" ) ,fmt = \"%Y-%m-%d %H:%M:%S %z\" , strict = FALSE , tz_aware = TRUE , utc = TRUE ) $ lit_to_s ( ) #> polars Series: shape: (3,) #> Series: '' [datetime[ns, UTC]] #> [ #> 2023-01-01 12:22:33 UTC #> 2023-01-01 08:22:33 UTC #> null #> ]","title":"Examples"},{"location":"reference/ExprStr_to_lowercase/","text":"To lowercase Returns Expr of Utf8 lowercase chars Transform to lowercase variant. Examples pl $ lit ( c ( \"A\" , \"b\" , \"c\" , \"1\" , NA ) ) $ str $ to_lowercase ( ) $ lit_to_s ( ) #> polars Series: shape: (5,) #> Series: '' [str] #> [ #> \"a\" #> \"b\" #> \"c\" #> \"1\" #> null #> ]","title":"ExprStr_to_lowercase"},{"location":"reference/ExprStr_to_lowercase/#to-lowercase","text":"","title":"To lowercase"},{"location":"reference/ExprStr_to_lowercase/#returns","text":"Expr of Utf8 lowercase chars Transform to lowercase variant.","title":"Returns"},{"location":"reference/ExprStr_to_lowercase/#examples","text":"pl $ lit ( c ( \"A\" , \"b\" , \"c\" , \"1\" , NA ) ) $ str $ to_lowercase ( ) $ lit_to_s ( ) #> polars Series: shape: (5,) #> Series: '' [str] #> [ #> \"a\" #> \"b\" #> \"c\" #> \"1\" #> null #> ]","title":"Examples"},{"location":"reference/ExprStr_to_uppercase/","text":"To uppercase Returns Expr of Utf8 uppercase chars Transform to uppercase variant. Examples pl $ lit ( c ( \"A\" , \"b\" , \"c\" , \"1\" , NA ) ) $ str $ to_uppercase ( ) $ lit_to_s ( ) #> polars Series: shape: (5,) #> Series: '' [str] #> [ #> \"A\" #> \"B\" #> \"C\" #> \"1\" #> null #> ]","title":"ExprStr_to_uppercase"},{"location":"reference/ExprStr_to_uppercase/#to-uppercase","text":"","title":"To uppercase"},{"location":"reference/ExprStr_to_uppercase/#returns","text":"Expr of Utf8 uppercase chars Transform to uppercase variant.","title":"Returns"},{"location":"reference/ExprStr_to_uppercase/#examples","text":"pl $ lit ( c ( \"A\" , \"b\" , \"c\" , \"1\" , NA ) ) $ str $ to_uppercase ( ) $ lit_to_s ( ) #> polars Series: shape: (5,) #> Series: '' [str] #> [ #> \"A\" #> \"B\" #> \"C\" #> \"1\" #> null #> ]","title":"Examples"},{"location":"reference/ExprStr_zfill/","text":"zfill Arguments alignment : Fill the value up to this length Returns Expr Fills the string with zeroes. Details Return a copy of the string left filled with ASCII '0' digits to make a string of length width. A leading sign prefix ('+'/'-') is handled by inserting the padding after the sign character rather than before. The original string is returned if width is less than or equal to len(s) . Examples some_floats_expr = pl $ lit ( c ( 0 , 10 , - 5 , 5 ) ) #cast to Utf8 and ljust alignment = 5, and view as R char vector some_floats_expr $ cast ( pl $ Utf8 ) $ str $ zfill ( 5 ) $ to_r ( ) #> [1] \"000.0\" \"010.0\" \"-05.0\" \"005.0\" #cast to int and the to utf8 and then ljust alignment = 5, and view as R char vector some_floats_expr $ cast ( pl $ Int64 ) $ cast ( pl $ Utf8 ) $ str $ zfill ( 5 ) $ to_r ( ) #> [1] \"00000\" \"00010\" \"-0005\" \"00005\"","title":"ExprStr_zfill"},{"location":"reference/ExprStr_zfill/#zfill","text":"","title":"zfill"},{"location":"reference/ExprStr_zfill/#arguments","text":"alignment : Fill the value up to this length","title":"Arguments"},{"location":"reference/ExprStr_zfill/#returns","text":"Expr Fills the string with zeroes.","title":"Returns"},{"location":"reference/ExprStr_zfill/#details","text":"Return a copy of the string left filled with ASCII '0' digits to make a string of length width. A leading sign prefix ('+'/'-') is handled by inserting the padding after the sign character rather than before. The original string is returned if width is less than or equal to len(s) .","title":"Details"},{"location":"reference/ExprStr_zfill/#examples","text":"some_floats_expr = pl $ lit ( c ( 0 , 10 , - 5 , 5 ) ) #cast to Utf8 and ljust alignment = 5, and view as R char vector some_floats_expr $ cast ( pl $ Utf8 ) $ str $ zfill ( 5 ) $ to_r ( ) #> [1] \"000.0\" \"010.0\" \"-05.0\" \"005.0\" #cast to int and the to utf8 and then ljust alignment = 5, and view as R char vector some_floats_expr $ cast ( pl $ Int64 ) $ cast ( pl $ Utf8 ) $ str $ zfill ( 5 ) $ to_r ( ) #> [1] \"00000\" \"00010\" \"-0005\" \"00005\"","title":"Examples"},{"location":"reference/ExprStruct_field/","text":"field Arguments name : string, the Name of the struct field to retrieve. Returns Expr: Series of same and name selected field. Retrieve a Struct field as a new Series. By default base 2. Examples df = pl $ DataFrame ( aaa = c ( 1 , 2 ) , bbb = c ( \"ab\" , \"cd\" ) , ccc = c ( TRUE , NA ) , ddd = list ( c ( 1 , 2 ) , 3 ) ) $ select ( pl $ struct ( pl $ all ( ) ) $ alias ( \"struct_col\" ) ) #struct field into a new Series df $ select ( pl $ col ( \"struct_col\" ) $ struct $ field ( \"bbb\" ) , pl $ col ( \"struct_col\" ) $ struct $ field ( \"ddd\" ) ) #> polars DataFrame: shape: (2, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 bbb \u2506 ddd \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 str \u2506 list[f64] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 ab \u2506 [1.0, 2.0] \u2502 #> \u2502 cd \u2506 [3.0] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStruct_field"},{"location":"reference/ExprStruct_field/#field","text":"","title":"field"},{"location":"reference/ExprStruct_field/#arguments","text":"name : string, the Name of the struct field to retrieve.","title":"Arguments"},{"location":"reference/ExprStruct_field/#returns","text":"Expr: Series of same and name selected field. Retrieve a Struct field as a new Series. By default base 2.","title":"Returns"},{"location":"reference/ExprStruct_field/#examples","text":"df = pl $ DataFrame ( aaa = c ( 1 , 2 ) , bbb = c ( \"ab\" , \"cd\" ) , ccc = c ( TRUE , NA ) , ddd = list ( c ( 1 , 2 ) , 3 ) ) $ select ( pl $ struct ( pl $ all ( ) ) $ alias ( \"struct_col\" ) ) #struct field into a new Series df $ select ( pl $ col ( \"struct_col\" ) $ struct $ field ( \"bbb\" ) , pl $ col ( \"struct_col\" ) $ struct $ field ( \"ddd\" ) ) #> polars DataFrame: shape: (2, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 bbb \u2506 ddd \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 str \u2506 list[f64] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 ab \u2506 [1.0, 2.0] \u2502 #> \u2502 cd \u2506 [3.0] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/ExprStruct_rename_fields/","text":"rename fields Arguments names : char vec or list of strings given in the same order as the struct's fields. Providing fewer names will drop the latter fields. Providing too many names is ignored. Returns Expr: struct-series with new names for the fields Rename the fields of the struct. By default base 2. Examples df = pl $ DataFrame ( aaa = 1 : 2 , bbb = c ( \"ab\" , \"cd\" ) , ccc = c ( TRUE , NA ) , ddd = list ( 1 : 2 , 3L ) ) $ select ( pl $ struct ( pl $ all ( ) ) $ alias ( \"struct_col\" ) ) $ select ( pl $ col ( \"struct_col\" ) $ struct $ rename_fields ( c ( \"www\" , \"xxx\" , \"yyy\" , \"zzz\" ) ) ) df $ unnest ( ) #> polars DataFrame: shape: (2, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 www \u2506 xxx \u2506 yyy \u2506 zzz \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2506 bool \u2506 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 ab \u2506 true \u2506 [1, 2] \u2502 #> \u2502 2 \u2506 cd \u2506 null \u2506 [3] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"ExprStruct_rename_fields"},{"location":"reference/ExprStruct_rename_fields/#rename-fields","text":"","title":"rename fields"},{"location":"reference/ExprStruct_rename_fields/#arguments","text":"names : char vec or list of strings given in the same order as the struct's fields. Providing fewer names will drop the latter fields. Providing too many names is ignored.","title":"Arguments"},{"location":"reference/ExprStruct_rename_fields/#returns","text":"Expr: struct-series with new names for the fields Rename the fields of the struct. By default base 2.","title":"Returns"},{"location":"reference/ExprStruct_rename_fields/#examples","text":"df = pl $ DataFrame ( aaa = 1 : 2 , bbb = c ( \"ab\" , \"cd\" ) , ccc = c ( TRUE , NA ) , ddd = list ( 1 : 2 , 3L ) ) $ select ( pl $ struct ( pl $ all ( ) ) $ alias ( \"struct_col\" ) ) $ select ( pl $ col ( \"struct_col\" ) $ struct $ rename_fields ( c ( \"www\" , \"xxx\" , \"yyy\" , \"zzz\" ) ) ) df $ unnest ( ) #> polars DataFrame: shape: (2, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 www \u2506 xxx \u2506 yyy \u2506 zzz \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2506 bool \u2506 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 ab \u2506 true \u2506 [1, 2] \u2502 #> \u2502 2 \u2506 cd \u2506 null \u2506 [3] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_abs/","text":"data Abs Format An object of class character of length 1. Expr_abs Returns Exprs abs Compute absolute values Examples pl $ DataFrame ( list ( a = - 1 : 1 ) ) $ select ( pl $ col ( \"a\" ) , pl $ col ( \"a\" ) $ abs ( ) $ alias ( \"abs\" ) ) #> polars DataFrame: shape: (3, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 abs \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -1 \u2506 1 \u2502 #> \u2502 0 \u2506 0 \u2502 #> \u2502 1 \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_abs"},{"location":"reference/Expr_abs/#abs","text":"","title":"Abs"},{"location":"reference/Expr_abs/#format","text":"An object of class character of length 1. Expr_abs","title":"Format"},{"location":"reference/Expr_abs/#returns","text":"Exprs abs Compute absolute values","title":"Returns"},{"location":"reference/Expr_abs/#examples","text":"pl $ DataFrame ( list ( a = - 1 : 1 ) ) $ select ( pl $ col ( \"a\" ) , pl $ col ( \"a\" ) $ abs ( ) $ alias ( \"abs\" ) ) #> polars DataFrame: shape: (3, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 abs \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -1 \u2506 1 \u2502 #> \u2502 0 \u2506 0 \u2502 #> \u2502 1 \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_add/","text":"Add Expr_add ( other ) ## S3 method for class 'Expr' e1 + e2 Arguments other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression Returns Exprs Addition Examples #three syntaxes same result pl $ lit ( 5 ) + 10 #> polars Expr: [(5f64) + (10f64)] pl $ lit ( 5 ) + pl $ lit ( 10 ) #> polars Expr: [(5f64) + (10f64)] pl $ lit ( 5 ) $ add ( pl $ lit ( 10 ) ) #> polars Expr: [(5f64) + (10f64)] + pl $ lit ( 5 ) #unary use resolves to same as pl$lit(5) #> polars Expr: 5f64","title":"Expr_add"},{"location":"reference/Expr_add/#add","text":"Expr_add ( other ) ## S3 method for class 'Expr' e1 + e2","title":"Add"},{"location":"reference/Expr_add/#arguments","text":"other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression","title":"Arguments"},{"location":"reference/Expr_add/#returns","text":"Exprs Addition","title":"Returns"},{"location":"reference/Expr_add/#examples","text":"#three syntaxes same result pl $ lit ( 5 ) + 10 #> polars Expr: [(5f64) + (10f64)] pl $ lit ( 5 ) + pl $ lit ( 10 ) #> polars Expr: [(5f64) + (10f64)] pl $ lit ( 5 ) $ add ( pl $ lit ( 10 ) ) #> polars Expr: [(5f64) + (10f64)] + pl $ lit ( 5 ) #unary use resolves to same as pl$lit(5) #> polars Expr: 5f64","title":"Examples"},{"location":"reference/Expr_agg_groups/","text":"data aggregate groups Format An object of class character of length 1. Expr_agg_groups Returns Exprs Get the group indexes of the group by operation. Should be used in aggregation context only. Examples df = pl $ DataFrame ( list ( group = c ( \"one\" , \"one\" , \"one\" , \"two\" , \"two\" , \"two\" ) , value = c ( 94 , 95 , 96 , 97 , 97 , 99 ) ) ) df $ groupby ( \"group\" , maintain_order = TRUE ) $ agg ( pl $ col ( \"value\" ) $ agg_groups ( ) ) #> polars DataFrame: shape: (2, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 group \u2506 value \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 str \u2506 list[u32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 one \u2506 [0, 1, 2] \u2502 #> \u2502 two \u2506 [3, 4, 5] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_agg_groups"},{"location":"reference/Expr_agg_groups/#aggregate-groups","text":"","title":"aggregate groups"},{"location":"reference/Expr_agg_groups/#format","text":"An object of class character of length 1. Expr_agg_groups","title":"Format"},{"location":"reference/Expr_agg_groups/#returns","text":"Exprs Get the group indexes of the group by operation. Should be used in aggregation context only.","title":"Returns"},{"location":"reference/Expr_agg_groups/#examples","text":"df = pl $ DataFrame ( list ( group = c ( \"one\" , \"one\" , \"one\" , \"two\" , \"two\" , \"two\" ) , value = c ( 94 , 95 , 96 , 97 , 97 , 99 ) ) ) df $ groupby ( \"group\" , maintain_order = TRUE ) $ agg ( pl $ col ( \"value\" ) $ agg_groups ( ) ) #> polars DataFrame: shape: (2, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 group \u2506 value \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 str \u2506 list[u32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 one \u2506 [0, 1, 2] \u2502 #> \u2502 two \u2506 [3, 4, 5] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_alias/","text":"data Rename Expr output Format An object of class character of length 1. Expr_alias ( name ) Arguments name : string new name of output Returns Expr Rename the output of an expression. Examples pl $ col ( \"bob\" ) $ alias ( \"alice\" ) #> polars Expr: col(\"bob\").alias(\"alice\")","title":"Expr_alias"},{"location":"reference/Expr_alias/#rename-expr-output","text":"","title":"Rename Expr output"},{"location":"reference/Expr_alias/#format","text":"An object of class character of length 1. Expr_alias ( name )","title":"Format"},{"location":"reference/Expr_alias/#arguments","text":"name : string new name of output","title":"Arguments"},{"location":"reference/Expr_alias/#returns","text":"Expr Rename the output of an expression.","title":"Returns"},{"location":"reference/Expr_alias/#examples","text":"pl $ col ( \"bob\" ) $ alias ( \"alice\" ) #> polars Expr: col(\"bob\").alias(\"alice\")","title":"Examples"},{"location":"reference/Expr_all/","text":"data All, is true Format An object of class character of length 1. Expr_all Returns Boolean literal Check if all boolean values in a Boolean column are TRUE . This method is an expression - not to be confused with pl$all which is a function to select all columns. Details last all() in example is this Expr method, the first pl$all() refers to \"all-columns\" and is an expression constructor Examples pl $ DataFrame ( all = c ( TRUE , TRUE ) , any = c ( TRUE , FALSE ) , none = c ( FALSE , FALSE ) ) $ select ( pl $ all ( ) $ all ( ) ) #> polars DataFrame: shape: (1, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 all \u2506 any \u2506 none \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 bool \u2506 bool \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2506 false \u2506 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_all"},{"location":"reference/Expr_all/#all-is-true","text":"","title":"All, is true"},{"location":"reference/Expr_all/#format","text":"An object of class character of length 1. Expr_all","title":"Format"},{"location":"reference/Expr_all/#returns","text":"Boolean literal Check if all boolean values in a Boolean column are TRUE . This method is an expression - not to be confused with pl$all which is a function to select all columns.","title":"Returns"},{"location":"reference/Expr_all/#details","text":"last all() in example is this Expr method, the first pl$all() refers to \"all-columns\" and is an expression constructor","title":"Details"},{"location":"reference/Expr_all/#examples","text":"pl $ DataFrame ( all = c ( TRUE , TRUE ) , any = c ( TRUE , FALSE ) , none = c ( FALSE , FALSE ) ) $ select ( pl $ all ( ) $ all ( ) ) #> polars DataFrame: shape: (1, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 all \u2506 any \u2506 none \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 bool \u2506 bool \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2506 false \u2506 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_and/","text":"data And Format An object of class character of length 1. Expr_and ( other ) Arguments other : literal or Robj which can become a literal Returns Expr combine to boolean exprresions with AND Examples pl $ lit ( TRUE ) & TRUE #> polars Expr: [(true) & (true)] pl $ lit ( TRUE ) $ and ( pl $ lit ( TRUE ) ) #> polars Expr: [(true) & (true)]","title":"Expr_and"},{"location":"reference/Expr_and/#and","text":"","title":"And"},{"location":"reference/Expr_and/#format","text":"An object of class character of length 1. Expr_and ( other )","title":"Format"},{"location":"reference/Expr_and/#arguments","text":"other : literal or Robj which can become a literal","title":"Arguments"},{"location":"reference/Expr_and/#returns","text":"Expr combine to boolean exprresions with AND","title":"Returns"},{"location":"reference/Expr_and/#examples","text":"pl $ lit ( TRUE ) & TRUE #> polars Expr: [(true) & (true)] pl $ lit ( TRUE ) $ and ( pl $ lit ( TRUE ) ) #> polars Expr: [(true) & (true)]","title":"Examples"},{"location":"reference/Expr_any/","text":"data Any (is true) Format An object of class character of length 1. Expr_any Returns Boolean literal Check if any boolean value in a Boolean column is TRUE . Examples pl $ DataFrame ( all = c ( TRUE , TRUE ) , any = c ( TRUE , FALSE ) , none = c ( FALSE , FALSE ) ) $ select ( pl $ all ( ) $ any ( ) ) #> polars DataFrame: shape: (1, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 all \u2506 any \u2506 none \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 bool \u2506 bool \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2506 true \u2506 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_any"},{"location":"reference/Expr_any/#any-is-true","text":"","title":"Any (is true)"},{"location":"reference/Expr_any/#format","text":"An object of class character of length 1. Expr_any","title":"Format"},{"location":"reference/Expr_any/#returns","text":"Boolean literal Check if any boolean value in a Boolean column is TRUE .","title":"Returns"},{"location":"reference/Expr_any/#examples","text":"pl $ DataFrame ( all = c ( TRUE , TRUE ) , any = c ( TRUE , FALSE ) , none = c ( FALSE , FALSE ) ) $ select ( pl $ all ( ) $ any ( ) ) #> polars DataFrame: shape: (1, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 all \u2506 any \u2506 none \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 bool \u2506 bool \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2506 true \u2506 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_append/","text":"Append expressions Format a method Expr_append ( other , upcast = TRUE ) Arguments other : Expr, into Expr upcast : bool upcast to, if any supertype of two non equal datatypes. Returns Expr This is done by adding the chunks of other to this output . Examples #append bottom to to row df = pl $ DataFrame ( list ( a = 1 : 3 , b = c ( NA_real_ , 4 , 5 ) ) ) df $ select ( pl $ all ( ) $ head ( 1 ) $ append ( pl $ all ( ) $ tail ( 1 ) ) ) #> polars DataFrame: shape: (2, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 null \u2502 #> \u2502 3 \u2506 5.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #implicit upcast, when default = TRUE pl $ DataFrame ( list ( ) ) $ select ( pl $ lit ( 42 ) $ append ( 42L ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 literal \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 42.0 \u2502 #> \u2502 42.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( list ( ) ) $ select ( pl $ lit ( 42 ) $ append ( FALSE ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 literal \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 42.0 \u2502 #> \u2502 0.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( list ( ) ) $ select ( pl $ lit ( \"Bob\" ) $ append ( FALSE ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 literal \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Bob \u2502 #> \u2502 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_append"},{"location":"reference/Expr_append/#append-expressions","text":"","title":"Append expressions"},{"location":"reference/Expr_append/#format","text":"a method Expr_append ( other , upcast = TRUE )","title":"Format"},{"location":"reference/Expr_append/#arguments","text":"other : Expr, into Expr upcast : bool upcast to, if any supertype of two non equal datatypes.","title":"Arguments"},{"location":"reference/Expr_append/#returns","text":"Expr This is done by adding the chunks of other to this output .","title":"Returns"},{"location":"reference/Expr_append/#examples","text":"#append bottom to to row df = pl $ DataFrame ( list ( a = 1 : 3 , b = c ( NA_real_ , 4 , 5 ) ) ) df $ select ( pl $ all ( ) $ head ( 1 ) $ append ( pl $ all ( ) $ tail ( 1 ) ) ) #> polars DataFrame: shape: (2, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 null \u2502 #> \u2502 3 \u2506 5.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #implicit upcast, when default = TRUE pl $ DataFrame ( list ( ) ) $ select ( pl $ lit ( 42 ) $ append ( 42L ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 literal \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 42.0 \u2502 #> \u2502 42.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( list ( ) ) $ select ( pl $ lit ( 42 ) $ append ( FALSE ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 literal \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 42.0 \u2502 #> \u2502 0.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( list ( ) ) $ select ( pl $ lit ( \"Bob\" ) $ append ( FALSE ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 literal \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Bob \u2502 #> \u2502 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_apply/","text":"Expr_apply Expr_apply ( f , return_type = NULL , strict_return_type = TRUE , allow_fail_eval = FALSE ) Arguments f : r function see details depending on context return_type : NULL or one of pl$dtypes, the output datatype, NULL is the same as input. strict_return_type : bool (default TRUE), error if not correct datatype returned from R, if FALSE will convert to a Polars Null and carry on. allow_fail_eval : bool (default FALSE), if TRUE will not raise user function error but convert result to a polars Null and carry on. Returns Expr Apply a custom/user-defined function (UDF) in a GroupBy or Projection context. Depending on the context it has the following behavior: -Selection Details Apply a user function in a groupby or projection(select) context Depending on context the following behaviour: Projection/Selection: Expects an f to operate on R scalar values. Polars will convert each element into an R value and pass it to the function The output of the user function will be converted back into a polars type. Return type must match. See param return type. Apply in selection context should be avoided as a lapply() has half the overhead. Groupby Expects a user function f to take a Series and return a Series or Robj convertable to Series , eg. R vector. GroupBy context much faster if number groups are quite fewer than number of rows, as the iteration is only across the groups. The r user function could e.g. do vectorized operations and stay quite performant. use s$to_r() to convert input Series to an r vector or list. use s$to_r_vector and s$to_r_list() to force conversion to vector or list. Implementing logic using an R function is almost always significantly slower and more memory intensive than implementing the same logic using the native expression API because: - The native expression engine runs in Rust; functions run in R. - Use of R functions forces the DataFrame to be materialized in memory. - Polars-native expressions can be parallelised (R functions cannot*). - Polars-native expressions can be logically optimised (R functions cannot). Wherever possible you should strongly prefer the native expression API to achieve the best performance. Examples #apply over groups - normal usage # s is a series of all values for one column within group, here Species e_all = pl $ all ( ) #perform groupby agg on all columns otherwise e.g. pl$col(\"Sepal.Length\") e_sum = e_all $ apply ( \\ ( s ) sum ( s $ to_r ( ) ) ) $ suffix ( \"_sum\" ) e_head = e_all $ apply ( \\ ( s ) head ( s $ to_r ( ) , 2 ) ) $ suffix ( \"_head\" ) pl $ DataFrame ( iris ) $ groupby ( \"Species\" ) $ agg ( e_sum , e_head ) #> polars DataFrame: shape: (3, 9) #> \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 S \u2506 Sepal.Leng \u2506 Sepal.Widt \u2506 Petal.Leng \u2506 ... \u2506 Sepal.Leng \u2506 Sepal.Widt \u2506 Petal.Leng \u2506 Petal.Widt \u2502 #> \u2502 p \u2506 th_sum \u2506 h_sum \u2506 th_sum \u2506 \u2506 th_head \u2506 h_head \u2506 th_head \u2506 h_head \u2502 #> \u2502 e \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 c \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 list[f64] \u2506 list[f64] \u2506 list[f64] \u2506 list[f64] \u2502 #> \u2502 i \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 e \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 s \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 - \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 - \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 - \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 c \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 a \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 t \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u255e\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 s \u2506 250.3 \u2506 171.4 \u2506 73.1 \u2506 ... \u2506 [5.1, 4.9] \u2506 [3.5, 3.0] \u2506 [1.4, 1.4] \u2506 [0.2, 0.2] \u2502 #> \u2502 e \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 t \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 o \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 s \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 a \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 v \u2506 296.8 \u2506 138.5 \u2506 213.0 \u2506 ... \u2506 [7.0, 6.4] \u2506 [3.2, 3.2] \u2506 [4.7, 4.5] \u2506 [1.4, 1.5] \u2502 #> \u2502 e \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 r \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 s \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 i \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 c \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 o \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 l \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 o \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 r \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 v \u2506 329.4 \u2506 148.7 \u2506 277.6 \u2506 ... \u2506 [6.3, 5.8] \u2506 [3.3, 2.7] \u2506 [6.0, 5.1] \u2506 [2.5, 1.9] \u2502 #> \u2502 i \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 r \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 g \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 i \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 n \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 i \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 c \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 a \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 # apply over single values (should be avoided as it takes ~2.5us overhead + R function exec time # on a 2015 MacBook Pro) x is an R scalar #perform on all Float64 columns, using pl$all requires user function can handle any input type e_all = pl $ col ( pl $ dtypes $ Float64 ) e_add10 = e_all $ apply ( \\ ( x ) { x + 10 } ) $ suffix ( \"_sum\" ) #quite silly index into alphabet(letters) by ceil of float value #must set return_type as not the same as input e_letter = e_all $ apply ( \\ ( x ) letters [ ceiling ( x ) ] , return_type = pl $ dtypes $ Utf8 ) $ suffix ( \"_letter\" ) pl $ DataFrame ( iris ) $ select ( e_add10 , e_letter ) #> polars DataFrame: shape: (150, 8) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Leng \u2506 Sepal.Widt \u2506 Petal.Leng \u2506 Petal.Widt \u2506 Sepal.Leng \u2506 Sepal.Widt \u2506 Petal.Leng \u2506 Petal.Widt \u2502 #> \u2502 th_sum \u2506 h_sum \u2506 th_sum \u2506 h_sum \u2506 th_letter \u2506 h_letter \u2506 th_letter \u2506 h_letter \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 str \u2506 str \u2506 str \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 15.1 \u2506 13.5 \u2506 11.4 \u2506 10.2 \u2506 f \u2506 d \u2506 b \u2506 a \u2502 #> \u2502 14.9 \u2506 13.0 \u2506 11.4 \u2506 10.2 \u2506 e \u2506 c \u2506 b \u2506 a \u2502 #> \u2502 14.7 \u2506 13.2 \u2506 11.3 \u2506 10.2 \u2506 e \u2506 d \u2506 b \u2506 a \u2502 #> \u2502 14.6 \u2506 13.1 \u2506 11.5 \u2506 10.2 \u2506 e \u2506 d \u2506 b \u2506 a \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 16.3 \u2506 12.5 \u2506 15.0 \u2506 11.9 \u2506 g \u2506 c \u2506 e \u2506 b \u2502 #> \u2502 16.5 \u2506 13.0 \u2506 15.2 \u2506 12.0 \u2506 g \u2506 c \u2506 f \u2506 b \u2502 #> \u2502 16.2 \u2506 13.4 \u2506 15.4 \u2506 12.3 \u2506 g \u2506 d \u2506 f \u2506 c \u2502 #> \u2502 15.9 \u2506 13.0 \u2506 15.1 \u2506 11.8 \u2506 f \u2506 c \u2506 f \u2506 b \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ##timing \"slow\" apply in select /with_columns context, this makes apply n = 1000000L set.seed ( 1 ) df = pl $ DataFrame ( list ( a = 1 : n , b = sample ( letters , n ,replace = TRUE ) ) ) print ( \"apply over 1 million values takes ~2.5 sec on 2015 MacBook Pro\" ) #> [1] \"apply over 1 million values takes ~2.5 sec on 2015 MacBook Pro\" system.time ( { rdf = df $ with_columns ( pl $ col ( \"a\" ) $ apply ( \\ ( x ) { x * 2L } ) $ alias ( \"bob\" ) ) } ) #> user system elapsed #> 2.30 0.33 2.95 print ( \"R lapply 1 million values take ~1sec on 2015 MacBook Pro\" ) #> [1] \"R lapply 1 million values take ~1sec on 2015 MacBook Pro\" system.time ( { lapply ( df $ get_column ( \"a\" ) $ to_r ( ) ,\\ ( x ) x * 2L ) } ) #> user system elapsed #> 1.11 0.00 1.11 print ( \"using polars syntax takes ~1ms\" ) #> [1] \"using polars syntax takes ~1ms\" system.time ( { ( df $ get_column ( \"a\" ) * 2L ) } ) #> user system elapsed #> 0 0 0 print ( \"using R vector syntax takes ~4ms\" ) #> [1] \"using R vector syntax takes ~4ms\" r_vec = df $ get_column ( \"a\" ) $ to_r ( ) system.time ( { r_vec * 2L } ) #> user system elapsed #> 0.02 0.00 0.02","title":"Expr_apply"},{"location":"reference/Expr_apply/#expr_apply","text":"Expr_apply ( f , return_type = NULL , strict_return_type = TRUE , allow_fail_eval = FALSE )","title":"Expr_apply"},{"location":"reference/Expr_apply/#arguments","text":"f : r function see details depending on context return_type : NULL or one of pl$dtypes, the output datatype, NULL is the same as input. strict_return_type : bool (default TRUE), error if not correct datatype returned from R, if FALSE will convert to a Polars Null and carry on. allow_fail_eval : bool (default FALSE), if TRUE will not raise user function error but convert result to a polars Null and carry on.","title":"Arguments"},{"location":"reference/Expr_apply/#returns","text":"Expr Apply a custom/user-defined function (UDF) in a GroupBy or Projection context. Depending on the context it has the following behavior: -Selection","title":"Returns"},{"location":"reference/Expr_apply/#details","text":"Apply a user function in a groupby or projection(select) context Depending on context the following behaviour: Projection/Selection: Expects an f to operate on R scalar values. Polars will convert each element into an R value and pass it to the function The output of the user function will be converted back into a polars type. Return type must match. See param return type. Apply in selection context should be avoided as a lapply() has half the overhead. Groupby Expects a user function f to take a Series and return a Series or Robj convertable to Series , eg. R vector. GroupBy context much faster if number groups are quite fewer than number of rows, as the iteration is only across the groups. The r user function could e.g. do vectorized operations and stay quite performant. use s$to_r() to convert input Series to an r vector or list. use s$to_r_vector and s$to_r_list() to force conversion to vector or list. Implementing logic using an R function is almost always significantly slower and more memory intensive than implementing the same logic using the native expression API because: - The native expression engine runs in Rust; functions run in R. - Use of R functions forces the DataFrame to be materialized in memory. - Polars-native expressions can be parallelised (R functions cannot*). - Polars-native expressions can be logically optimised (R functions cannot). Wherever possible you should strongly prefer the native expression API to achieve the best performance.","title":"Details"},{"location":"reference/Expr_apply/#examples","text":"#apply over groups - normal usage # s is a series of all values for one column within group, here Species e_all = pl $ all ( ) #perform groupby agg on all columns otherwise e.g. pl$col(\"Sepal.Length\") e_sum = e_all $ apply ( \\ ( s ) sum ( s $ to_r ( ) ) ) $ suffix ( \"_sum\" ) e_head = e_all $ apply ( \\ ( s ) head ( s $ to_r ( ) , 2 ) ) $ suffix ( \"_head\" ) pl $ DataFrame ( iris ) $ groupby ( \"Species\" ) $ agg ( e_sum , e_head ) #> polars DataFrame: shape: (3, 9) #> \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 S \u2506 Sepal.Leng \u2506 Sepal.Widt \u2506 Petal.Leng \u2506 ... \u2506 Sepal.Leng \u2506 Sepal.Widt \u2506 Petal.Leng \u2506 Petal.Widt \u2502 #> \u2502 p \u2506 th_sum \u2506 h_sum \u2506 th_sum \u2506 \u2506 th_head \u2506 h_head \u2506 th_head \u2506 h_head \u2502 #> \u2502 e \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 c \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 list[f64] \u2506 list[f64] \u2506 list[f64] \u2506 list[f64] \u2502 #> \u2502 i \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 e \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 s \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 - \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 - \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 - \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 c \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 a \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 t \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u255e\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 s \u2506 250.3 \u2506 171.4 \u2506 73.1 \u2506 ... \u2506 [5.1, 4.9] \u2506 [3.5, 3.0] \u2506 [1.4, 1.4] \u2506 [0.2, 0.2] \u2502 #> \u2502 e \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 t \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 o \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 s \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 a \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 v \u2506 296.8 \u2506 138.5 \u2506 213.0 \u2506 ... \u2506 [7.0, 6.4] \u2506 [3.2, 3.2] \u2506 [4.7, 4.5] \u2506 [1.4, 1.5] \u2502 #> \u2502 e \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 r \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 s \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 i \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 c \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 o \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 l \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 o \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 r \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 v \u2506 329.4 \u2506 148.7 \u2506 277.6 \u2506 ... \u2506 [6.3, 5.8] \u2506 [3.3, 2.7] \u2506 [6.0, 5.1] \u2506 [2.5, 1.9] \u2502 #> \u2502 i \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 r \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 g \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 i \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 n \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 i \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 c \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2502 a \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 # apply over single values (should be avoided as it takes ~2.5us overhead + R function exec time # on a 2015 MacBook Pro) x is an R scalar #perform on all Float64 columns, using pl$all requires user function can handle any input type e_all = pl $ col ( pl $ dtypes $ Float64 ) e_add10 = e_all $ apply ( \\ ( x ) { x + 10 } ) $ suffix ( \"_sum\" ) #quite silly index into alphabet(letters) by ceil of float value #must set return_type as not the same as input e_letter = e_all $ apply ( \\ ( x ) letters [ ceiling ( x ) ] , return_type = pl $ dtypes $ Utf8 ) $ suffix ( \"_letter\" ) pl $ DataFrame ( iris ) $ select ( e_add10 , e_letter ) #> polars DataFrame: shape: (150, 8) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Leng \u2506 Sepal.Widt \u2506 Petal.Leng \u2506 Petal.Widt \u2506 Sepal.Leng \u2506 Sepal.Widt \u2506 Petal.Leng \u2506 Petal.Widt \u2502 #> \u2502 th_sum \u2506 h_sum \u2506 th_sum \u2506 h_sum \u2506 th_letter \u2506 h_letter \u2506 th_letter \u2506 h_letter \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 str \u2506 str \u2506 str \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 15.1 \u2506 13.5 \u2506 11.4 \u2506 10.2 \u2506 f \u2506 d \u2506 b \u2506 a \u2502 #> \u2502 14.9 \u2506 13.0 \u2506 11.4 \u2506 10.2 \u2506 e \u2506 c \u2506 b \u2506 a \u2502 #> \u2502 14.7 \u2506 13.2 \u2506 11.3 \u2506 10.2 \u2506 e \u2506 d \u2506 b \u2506 a \u2502 #> \u2502 14.6 \u2506 13.1 \u2506 11.5 \u2506 10.2 \u2506 e \u2506 d \u2506 b \u2506 a \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 16.3 \u2506 12.5 \u2506 15.0 \u2506 11.9 \u2506 g \u2506 c \u2506 e \u2506 b \u2502 #> \u2502 16.5 \u2506 13.0 \u2506 15.2 \u2506 12.0 \u2506 g \u2506 c \u2506 f \u2506 b \u2502 #> \u2502 16.2 \u2506 13.4 \u2506 15.4 \u2506 12.3 \u2506 g \u2506 d \u2506 f \u2506 c \u2502 #> \u2502 15.9 \u2506 13.0 \u2506 15.1 \u2506 11.8 \u2506 f \u2506 c \u2506 f \u2506 b \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ##timing \"slow\" apply in select /with_columns context, this makes apply n = 1000000L set.seed ( 1 ) df = pl $ DataFrame ( list ( a = 1 : n , b = sample ( letters , n ,replace = TRUE ) ) ) print ( \"apply over 1 million values takes ~2.5 sec on 2015 MacBook Pro\" ) #> [1] \"apply over 1 million values takes ~2.5 sec on 2015 MacBook Pro\" system.time ( { rdf = df $ with_columns ( pl $ col ( \"a\" ) $ apply ( \\ ( x ) { x * 2L } ) $ alias ( \"bob\" ) ) } ) #> user system elapsed #> 2.30 0.33 2.95 print ( \"R lapply 1 million values take ~1sec on 2015 MacBook Pro\" ) #> [1] \"R lapply 1 million values take ~1sec on 2015 MacBook Pro\" system.time ( { lapply ( df $ get_column ( \"a\" ) $ to_r ( ) ,\\ ( x ) x * 2L ) } ) #> user system elapsed #> 1.11 0.00 1.11 print ( \"using polars syntax takes ~1ms\" ) #> [1] \"using polars syntax takes ~1ms\" system.time ( { ( df $ get_column ( \"a\" ) * 2L ) } ) #> user system elapsed #> 0 0 0 print ( \"using R vector syntax takes ~4ms\" ) #> [1] \"using R vector syntax takes ~4ms\" r_vec = df $ get_column ( \"a\" ) $ to_r ( ) system.time ( { r_vec * 2L } ) #> user system elapsed #> 0.02 0.00 0.02","title":"Examples"},{"location":"reference/Expr_arccos/","text":"data Arccos Format Method Expr_arccos Returns Expr Compute the element-wise value for the inverse cosine. Details Evaluated Series has dtype Float64 Examples pl $ DataFrame ( a = c ( - 1 , cos ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ arccos ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3.141593 \u2502 #> \u2502 0.5 \u2502 #> \u2502 1.570796 \u2502 #> \u2502 0.0 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_arccos"},{"location":"reference/Expr_arccos/#arccos","text":"","title":"Arccos"},{"location":"reference/Expr_arccos/#format","text":"Method Expr_arccos","title":"Format"},{"location":"reference/Expr_arccos/#returns","text":"Expr Compute the element-wise value for the inverse cosine.","title":"Returns"},{"location":"reference/Expr_arccos/#details","text":"Evaluated Series has dtype Float64","title":"Details"},{"location":"reference/Expr_arccos/#examples","text":"pl $ DataFrame ( a = c ( - 1 , cos ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ arccos ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3.141593 \u2502 #> \u2502 0.5 \u2502 #> \u2502 1.570796 \u2502 #> \u2502 0.0 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_arccosh/","text":"data Arccosh Format Method Expr_arccosh Returns Expr Compute the element-wise value for the inverse hyperbolic cosine. Details Evaluated Series has dtype Float64 Examples pl $ DataFrame ( a = c ( - 1 , cosh ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ arccosh ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 NaN \u2502 #> \u2502 0.5 \u2502 #> \u2502 NaN \u2502 #> \u2502 0.0 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_arccosh"},{"location":"reference/Expr_arccosh/#arccosh","text":"","title":"Arccosh"},{"location":"reference/Expr_arccosh/#format","text":"Method Expr_arccosh","title":"Format"},{"location":"reference/Expr_arccosh/#returns","text":"Expr Compute the element-wise value for the inverse hyperbolic cosine.","title":"Returns"},{"location":"reference/Expr_arccosh/#details","text":"Evaluated Series has dtype Float64","title":"Details"},{"location":"reference/Expr_arccosh/#examples","text":"pl $ DataFrame ( a = c ( - 1 , cosh ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ arccosh ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 NaN \u2502 #> \u2502 0.5 \u2502 #> \u2502 NaN \u2502 #> \u2502 0.0 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_arcsin/","text":"data Arcsin Format Method Expr_arcsin Returns Expr Compute the element-wise value for the inverse sine. Details Evaluated Series has dtype Float64 Examples pl $ DataFrame ( a = c ( - 1 , sin ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ arcsin ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -1.570796 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.0 \u2502 #> \u2502 1.570796 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_arcsin"},{"location":"reference/Expr_arcsin/#arcsin","text":"","title":"Arcsin"},{"location":"reference/Expr_arcsin/#format","text":"Method Expr_arcsin","title":"Format"},{"location":"reference/Expr_arcsin/#returns","text":"Expr Compute the element-wise value for the inverse sine.","title":"Returns"},{"location":"reference/Expr_arcsin/#details","text":"Evaluated Series has dtype Float64","title":"Details"},{"location":"reference/Expr_arcsin/#examples","text":"pl $ DataFrame ( a = c ( - 1 , sin ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ arcsin ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -1.570796 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.0 \u2502 #> \u2502 1.570796 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_arcsinh/","text":"data Arcsinh Format Method Expr_arcsinh Returns Expr Compute the element-wise value for the inverse hyperbolic sine. Details Evaluated Series has dtype Float64 Examples pl $ DataFrame ( a = c ( - 1 , sinh ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ arcsinh ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -0.881374 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.0 \u2502 #> \u2502 0.881374 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_arcsinh"},{"location":"reference/Expr_arcsinh/#arcsinh","text":"","title":"Arcsinh"},{"location":"reference/Expr_arcsinh/#format","text":"Method Expr_arcsinh","title":"Format"},{"location":"reference/Expr_arcsinh/#returns","text":"Expr Compute the element-wise value for the inverse hyperbolic sine.","title":"Returns"},{"location":"reference/Expr_arcsinh/#details","text":"Evaluated Series has dtype Float64","title":"Details"},{"location":"reference/Expr_arcsinh/#examples","text":"pl $ DataFrame ( a = c ( - 1 , sinh ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ arcsinh ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -0.881374 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.0 \u2502 #> \u2502 0.881374 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_arctan/","text":"data Arctan Format Method Expr_arctan Returns Expr Compute the element-wise value for the inverse tangent. Details Evaluated Series has dtype Float64 Examples pl $ DataFrame ( a = c ( - 1 , tan ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ arctan ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -0.785398 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.0 \u2502 #> \u2502 0.785398 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_arctan"},{"location":"reference/Expr_arctan/#arctan","text":"","title":"Arctan"},{"location":"reference/Expr_arctan/#format","text":"Method Expr_arctan","title":"Format"},{"location":"reference/Expr_arctan/#returns","text":"Expr Compute the element-wise value for the inverse tangent.","title":"Returns"},{"location":"reference/Expr_arctan/#details","text":"Evaluated Series has dtype Float64","title":"Details"},{"location":"reference/Expr_arctan/#examples","text":"pl $ DataFrame ( a = c ( - 1 , tan ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ arctan ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -0.785398 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.0 \u2502 #> \u2502 0.785398 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_arctanh/","text":"data Arctanh Format Method Expr_arctanh Returns Expr Compute the element-wise value for the inverse hyperbolic tangent. Details Evaluated Series has dtype Float64 Examples pl $ DataFrame ( a = c ( - 1 , tanh ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ arctanh ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -inf \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.0 \u2502 #> \u2502 inf \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_arctanh"},{"location":"reference/Expr_arctanh/#arctanh","text":"","title":"Arctanh"},{"location":"reference/Expr_arctanh/#format","text":"Method Expr_arctanh","title":"Format"},{"location":"reference/Expr_arctanh/#returns","text":"Expr Compute the element-wise value for the inverse hyperbolic tangent.","title":"Returns"},{"location":"reference/Expr_arctanh/#details","text":"Evaluated Series has dtype Float64","title":"Details"},{"location":"reference/Expr_arctanh/#examples","text":"pl $ DataFrame ( a = c ( - 1 , tanh ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ arctanh ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -inf \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.0 \u2502 #> \u2502 inf \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_arg_max/","text":"data Index of min value Format a method Expr_arg_max Returns Expr Get the index of the minimal value. Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( a = c ( 6 , 1 , 0 , NA , Inf , NaN ) ) ) $ select ( pl $ col ( \"a\" ) $ arg_max ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_arg_max"},{"location":"reference/Expr_arg_max/#index-of-min-value","text":"","title":"Index of min value"},{"location":"reference/Expr_arg_max/#format","text":"a method Expr_arg_max","title":"Format"},{"location":"reference/Expr_arg_max/#returns","text":"Expr Get the index of the minimal value.","title":"Returns"},{"location":"reference/Expr_arg_max/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_arg_max/#examples","text":"pl $ DataFrame ( list ( a = c ( 6 , 1 , 0 , NA , Inf , NaN ) ) ) $ select ( pl $ col ( \"a\" ) $ arg_max ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_arg_min/","text":"data Index of min value Format a method Expr_arg_min Returns Expr Get the index of the minimal value. Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( a = c ( 6 , 1 , 0 , NA , Inf , NaN ) ) ) $ select ( pl $ col ( \"a\" ) $ arg_min ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_arg_min"},{"location":"reference/Expr_arg_min/#index-of-min-value","text":"","title":"Index of min value"},{"location":"reference/Expr_arg_min/#format","text":"a method Expr_arg_min","title":"Format"},{"location":"reference/Expr_arg_min/#returns","text":"Expr Get the index of the minimal value.","title":"Returns"},{"location":"reference/Expr_arg_min/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_arg_min/#examples","text":"pl $ DataFrame ( list ( a = c ( 6 , 1 , 0 , NA , Inf , NaN ) ) ) $ select ( pl $ col ( \"a\" ) $ arg_min ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_arg_sort/","text":"Index of a sort Format a method Expr_arg_sort ( reverse = FALSE , nulls_last = FALSE ) Expr_argsort ( reverse = FALSE , nulls_last = FALSE ) Arguments reverse : bool default FALSE, reverses sort nulls_last : bool, default FALSE, place Nulls last Returns Expr Get the index values that would sort this column. If 'reverse=True` the smallest elements will be given. argsort is a alias for arg_sort Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( a = c ( 6 , 1 , 0 , NA , Inf , NaN ) ) ) $ select ( pl $ col ( \"a\" ) $ arg_sort ( ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 2 \u2502 #> \u2502 1 \u2502 #> \u2502 0 \u2502 #> \u2502 4 \u2502 #> \u2502 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_arg_sort"},{"location":"reference/Expr_arg_sort/#index-of-a-sort","text":"","title":"Index of a sort"},{"location":"reference/Expr_arg_sort/#format","text":"a method Expr_arg_sort ( reverse = FALSE , nulls_last = FALSE ) Expr_argsort ( reverse = FALSE , nulls_last = FALSE )","title":"Format"},{"location":"reference/Expr_arg_sort/#arguments","text":"reverse : bool default FALSE, reverses sort nulls_last : bool, default FALSE, place Nulls last","title":"Arguments"},{"location":"reference/Expr_arg_sort/#returns","text":"Expr Get the index values that would sort this column. If 'reverse=True` the smallest elements will be given. argsort is a alias for arg_sort","title":"Returns"},{"location":"reference/Expr_arg_sort/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_arg_sort/#examples","text":"pl $ DataFrame ( list ( a = c ( 6 , 1 , 0 , NA , Inf , NaN ) ) ) $ select ( pl $ col ( \"a\" ) $ arg_sort ( ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 2 \u2502 #> \u2502 1 \u2502 #> \u2502 0 \u2502 #> \u2502 4 \u2502 #> \u2502 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_arg_unique/","text":"data Index of First Unique Value. Format An object of class character of length 1. Expr_arg_unique Returns Expr Index of First Unique Value. Examples pl $ select ( pl $ lit ( c ( 1 : 2 , 1 : 3 ) ) $ arg_unique ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0 \u2502 #> \u2502 1 \u2502 #> \u2502 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_arg_unique"},{"location":"reference/Expr_arg_unique/#index-of-first-unique-value","text":"","title":"Index of First Unique Value."},{"location":"reference/Expr_arg_unique/#format","text":"An object of class character of length 1. Expr_arg_unique","title":"Format"},{"location":"reference/Expr_arg_unique/#returns","text":"Expr Index of First Unique Value.","title":"Returns"},{"location":"reference/Expr_arg_unique/#examples","text":"pl $ select ( pl $ lit ( c ( 1 : 2 , 1 : 3 ) ) $ arg_unique ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0 \u2502 #> \u2502 1 \u2502 #> \u2502 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_arr/","text":"arr: list related methods Expr_arr () Returns Expr Create an object namespace of all list related methods. See the individual method pages for full details Examples df_with_list = pl $ DataFrame ( group = c ( 1 , 1 , 2 , 2 , 3 ) , value = c ( 1 : 5 ) ) $ groupby ( \"group\" ,maintain_order = TRUE ) $ agg ( pl $ col ( \"value\" ) * 3L ) df_with_list $ with_column ( pl $ col ( \"value\" ) $ arr $ lengths ( ) $ alias ( \"group_size\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 group \u2506 value \u2506 group_size \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 list[i32] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 [3, 6] \u2506 2 \u2502 #> \u2502 2.0 \u2506 [9, 12] \u2506 2 \u2502 #> \u2502 3.0 \u2506 [15] \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_arr"},{"location":"reference/Expr_arr/#arr-list-related-methods","text":"Expr_arr ()","title":"arr: list related methods"},{"location":"reference/Expr_arr/#returns","text":"Expr Create an object namespace of all list related methods. See the individual method pages for full details","title":"Returns"},{"location":"reference/Expr_arr/#examples","text":"df_with_list = pl $ DataFrame ( group = c ( 1 , 1 , 2 , 2 , 3 ) , value = c ( 1 : 5 ) ) $ groupby ( \"group\" ,maintain_order = TRUE ) $ agg ( pl $ col ( \"value\" ) * 3L ) df_with_list $ with_column ( pl $ col ( \"value\" ) $ arr $ lengths ( ) $ alias ( \"group_size\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 group \u2506 value \u2506 group_size \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 list[i32] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 [3, 6] \u2506 2 \u2502 #> \u2502 2.0 \u2506 [9, 12] \u2506 2 \u2502 #> \u2502 3.0 \u2506 [15] \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_backward_fill/","text":"Fill Nulls Backward Format a method Expr_backward_fill ( limit = NULL ) Arguments limit : Expr or Into<Expr> The number of consecutive null values to backward fill. Returns Expr Fill missing values with the next to be seen values. Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples l = list ( a = c ( 1L , rep ( NA_integer_ , 3L ) , 10 ) ) pl $ DataFrame ( l ) $ select ( pl $ col ( \"a\" ) $ backward_fill ( ) $ alias ( \"bf_null\" ) , pl $ col ( \"a\" ) $ backward_fill ( limit = 0 ) $ alias ( \"bf_l0\" ) , pl $ col ( \"a\" ) $ backward_fill ( limit = 1 ) $ alias ( \"bf_l1\" ) ) $ to_list ( ) #> $bf_null #> [1] 1 10 10 10 10 #> #> $bf_l0 #> [1] 1 NA NA NA 10 #> #> $bf_l1 #> [1] 1 NA NA 10 10 #>","title":"Expr_backward_fill"},{"location":"reference/Expr_backward_fill/#fill-nulls-backward","text":"","title":"Fill Nulls Backward"},{"location":"reference/Expr_backward_fill/#format","text":"a method Expr_backward_fill ( limit = NULL )","title":"Format"},{"location":"reference/Expr_backward_fill/#arguments","text":"limit : Expr or Into<Expr> The number of consecutive null values to backward fill.","title":"Arguments"},{"location":"reference/Expr_backward_fill/#returns","text":"Expr Fill missing values with the next to be seen values.","title":"Returns"},{"location":"reference/Expr_backward_fill/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_backward_fill/#examples","text":"l = list ( a = c ( 1L , rep ( NA_integer_ , 3L ) , 10 ) ) pl $ DataFrame ( l ) $ select ( pl $ col ( \"a\" ) $ backward_fill ( ) $ alias ( \"bf_null\" ) , pl $ col ( \"a\" ) $ backward_fill ( limit = 0 ) $ alias ( \"bf_l0\" ) , pl $ col ( \"a\" ) $ backward_fill ( limit = 1 ) $ alias ( \"bf_l1\" ) ) $ to_list ( ) #> $bf_null #> [1] 1 10 10 10 10 #> #> $bf_l0 #> [1] 1 NA NA NA 10 #> #> $bf_l1 #> [1] 1 NA NA 10 10 #>","title":"Examples"},{"location":"reference/Expr_bin/","text":"bin: binary related methods Expr_bin () Returns Expr Create an object namespace of all binary related methods. See the individual method pages for full details Examples #missing","title":"Expr_bin"},{"location":"reference/Expr_bin/#bin-binary-related-methods","text":"Expr_bin ()","title":"bin: binary related methods"},{"location":"reference/Expr_bin/#returns","text":"Expr Create an object namespace of all binary related methods. See the individual method pages for full details","title":"Returns"},{"location":"reference/Expr_bin/#examples","text":"#missing","title":"Examples"},{"location":"reference/Expr_cast/","text":"Cast between DataType(s) Expr_cast ( dtype , strict = TRUE ) Arguments dtype : DataType to cast to. strict : bool if true an error will be thrown if cast failed at resolve time. Returns Expr Cast between DataType(s) Examples df = pl $ DataFrame ( list ( a = 1 : 3 , b = 1 : 3 ) ) df $ with_columns ( pl $ col ( \"a\" ) $ cast ( pl $ dtypes $ Float64 , TRUE ) , pl $ col ( \"a\" ) $ cast ( pl $ dtypes $ Int32 , TRUE ) ) #> polars DataFrame: shape: (3, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 1 \u2502 #> \u2502 2 \u2506 2 \u2502 #> \u2502 3 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_cast"},{"location":"reference/Expr_cast/#cast-between-datatypes","text":"Expr_cast ( dtype , strict = TRUE )","title":"Cast between DataType(s)"},{"location":"reference/Expr_cast/#arguments","text":"dtype : DataType to cast to. strict : bool if true an error will be thrown if cast failed at resolve time.","title":"Arguments"},{"location":"reference/Expr_cast/#returns","text":"Expr Cast between DataType(s)","title":"Returns"},{"location":"reference/Expr_cast/#examples","text":"df = pl $ DataFrame ( list ( a = 1 : 3 , b = 1 : 3 ) ) df $ with_columns ( pl $ col ( \"a\" ) $ cast ( pl $ dtypes $ Float64 , TRUE ) , pl $ col ( \"a\" ) $ cast ( pl $ dtypes $ Int32 , TRUE ) ) #> polars DataFrame: shape: (3, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 1 \u2502 #> \u2502 2 \u2506 2 \u2502 #> \u2502 3 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_cat/","text":"cat: related methods Expr_cat () Returns Expr Create an object namespace of all cat related methods. See the individual method pages for full details Examples #missing","title":"Expr_cat"},{"location":"reference/Expr_cat/#cat-related-methods","text":"Expr_cat ()","title":"cat: related methods"},{"location":"reference/Expr_cat/#returns","text":"Expr Create an object namespace of all cat related methods. See the individual method pages for full details","title":"Returns"},{"location":"reference/Expr_cat/#examples","text":"#missing","title":"Examples"},{"location":"reference/Expr_ceil/","text":"data Ceiling Format a method Expr_ceil Returns Expr Rounds up to the nearest integer value. Only works on floating point Series. Examples pl $ DataFrame ( list ( a = c ( 0.33 , 0.5 , 1.02 , 1.5 , NaN , NA , Inf , - Inf ) ) ) $ select ( pl $ col ( \"a\" ) $ ceil ( ) ) #> polars DataFrame: shape: (8, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 NaN \u2502 #> \u2502 null \u2502 #> \u2502 inf \u2502 #> \u2502 -inf \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_ceil"},{"location":"reference/Expr_ceil/#ceiling","text":"","title":"Ceiling"},{"location":"reference/Expr_ceil/#format","text":"a method Expr_ceil","title":"Format"},{"location":"reference/Expr_ceil/#returns","text":"Expr Rounds up to the nearest integer value. Only works on floating point Series.","title":"Returns"},{"location":"reference/Expr_ceil/#examples","text":"pl $ DataFrame ( list ( a = c ( 0.33 , 0.5 , 1.02 , 1.5 , NaN , NA , Inf , - Inf ) ) ) $ select ( pl $ col ( \"a\" ) $ ceil ( ) ) #> polars DataFrame: shape: (8, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 NaN \u2502 #> \u2502 null \u2502 #> \u2502 inf \u2502 #> \u2502 -inf \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_clip/","text":"Clip Expr_clip ( min , max ) Expr_clip_min ( min ) Expr_clip_max ( max ) Arguments min : Minimum Value, ints and floats or any literal expression of ints and floats max : Maximum Value, ints and floats or any literal expression of ints and floats Returns Expr Clip (limit) the values in an array to a min and max boundary. Details Only works for numerical types. If you want to clip other dtypes, consider writing a \"when, then, otherwise\" expression. See :func: when for more information. Examples df = pl $ DataFrame ( foo = c ( - 50L , 5L , NA_integer_ , 50L ) ) df $ with_column ( pl $ col ( \"foo\" ) $ clip ( 1L , 10L ) $ alias ( \"foo_clipped\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 foo_clipped \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -50 \u2506 1 \u2502 #> \u2502 5 \u2506 5 \u2502 #> \u2502 null \u2506 null \u2502 #> \u2502 50 \u2506 10 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ with_column ( pl $ col ( \"foo\" ) $ clip_min ( 1L ) $ alias ( \"foo_clipped\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 foo_clipped \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -50 \u2506 1 \u2502 #> \u2502 5 \u2506 5 \u2502 #> \u2502 null \u2506 null \u2502 #> \u2502 50 \u2506 50 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ with_column ( pl $ col ( \"foo\" ) $ clip_max ( 10L ) $ alias ( \"foo_clipped\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 foo_clipped \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -50 \u2506 -50 \u2502 #> \u2502 5 \u2506 5 \u2502 #> \u2502 null \u2506 null \u2502 #> \u2502 50 \u2506 10 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_clip"},{"location":"reference/Expr_clip/#clip","text":"Expr_clip ( min , max ) Expr_clip_min ( min ) Expr_clip_max ( max )","title":"Clip"},{"location":"reference/Expr_clip/#arguments","text":"min : Minimum Value, ints and floats or any literal expression of ints and floats max : Maximum Value, ints and floats or any literal expression of ints and floats","title":"Arguments"},{"location":"reference/Expr_clip/#returns","text":"Expr Clip (limit) the values in an array to a min and max boundary.","title":"Returns"},{"location":"reference/Expr_clip/#details","text":"Only works for numerical types. If you want to clip other dtypes, consider writing a \"when, then, otherwise\" expression. See :func: when for more information.","title":"Details"},{"location":"reference/Expr_clip/#examples","text":"df = pl $ DataFrame ( foo = c ( - 50L , 5L , NA_integer_ , 50L ) ) df $ with_column ( pl $ col ( \"foo\" ) $ clip ( 1L , 10L ) $ alias ( \"foo_clipped\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 foo_clipped \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -50 \u2506 1 \u2502 #> \u2502 5 \u2506 5 \u2502 #> \u2502 null \u2506 null \u2502 #> \u2502 50 \u2506 10 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ with_column ( pl $ col ( \"foo\" ) $ clip_min ( 1L ) $ alias ( \"foo_clipped\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 foo_clipped \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -50 \u2506 1 \u2502 #> \u2502 5 \u2506 5 \u2502 #> \u2502 null \u2506 null \u2502 #> \u2502 50 \u2506 50 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ with_column ( pl $ col ( \"foo\" ) $ clip_max ( 10L ) $ alias ( \"foo_clipped\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 foo_clipped \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -50 \u2506 -50 \u2502 #> \u2502 5 \u2506 5 \u2502 #> \u2502 null \u2506 null \u2502 #> \u2502 50 \u2506 10 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_cos/","text":"data Cos Format Method Expr_cos Returns Expr Compute the element-wise value for the cosine. Details Evaluated Series has dtype Float64 Examples pl $ DataFrame ( a = c ( 0 , pi / 2 , pi , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ cos ( ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 6.1230e-17 \u2502 #> \u2502 -1.0 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_cos"},{"location":"reference/Expr_cos/#cos","text":"","title":"Cos"},{"location":"reference/Expr_cos/#format","text":"Method Expr_cos","title":"Format"},{"location":"reference/Expr_cos/#returns","text":"Expr Compute the element-wise value for the cosine.","title":"Returns"},{"location":"reference/Expr_cos/#details","text":"Evaluated Series has dtype Float64","title":"Details"},{"location":"reference/Expr_cos/#examples","text":"pl $ DataFrame ( a = c ( 0 , pi / 2 , pi , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ cos ( ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 6.1230e-17 \u2502 #> \u2502 -1.0 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_cosh/","text":"data Cosh Format Method Expr_cosh Returns Expr Compute the element-wise value for the hyperbolic cosine. Details Evaluated Series has dtype Float64 Examples pl $ DataFrame ( a = c ( - 1 , acosh ( 1.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ cosh ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.543081 \u2502 #> \u2502 1.5 \u2502 #> \u2502 1.0 \u2502 #> \u2502 1.543081 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_cosh"},{"location":"reference/Expr_cosh/#cosh","text":"","title":"Cosh"},{"location":"reference/Expr_cosh/#format","text":"Method Expr_cosh","title":"Format"},{"location":"reference/Expr_cosh/#returns","text":"Expr Compute the element-wise value for the hyperbolic cosine.","title":"Returns"},{"location":"reference/Expr_cosh/#details","text":"Evaluated Series has dtype Float64","title":"Details"},{"location":"reference/Expr_cosh/#examples","text":"pl $ DataFrame ( a = c ( - 1 , acosh ( 1.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ cosh ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.543081 \u2502 #> \u2502 1.5 \u2502 #> \u2502 1.0 \u2502 #> \u2502 1.543081 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_count/","text":"data Count values (len is a alias) Format An object of class character of length 1. An object of class character of length 1. Expr_count Expr_len Returns Expr Expr Count the number of values in this expression. Similar to R length() Examples pl $ DataFrame ( all = c ( TRUE , TRUE ) , any = c ( TRUE , FALSE ) , none = c ( FALSE , FALSE ) ) $ select ( pl $ all ( ) $ count ( ) ) #> polars DataFrame: shape: (1, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 all \u2506 any \u2506 none \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 u32 \u2506 u32 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2 \u2506 2 \u2506 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( all = c ( TRUE , TRUE ) , any = c ( TRUE , FALSE ) , none = c ( FALSE , FALSE ) ) $ select ( pl $ all ( ) $ len ( ) , pl $ col ( \"all\" ) $ first ( ) $ len ( ) $ alias ( \"all_first\" ) ) #> polars DataFrame: shape: (1, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 all \u2506 any \u2506 none \u2506 all_first \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 u32 \u2506 u32 \u2506 u32 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2 \u2506 2 \u2506 2 \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_count"},{"location":"reference/Expr_count/#count-values-len-is-a-alias","text":"","title":"Count values (len is a alias)"},{"location":"reference/Expr_count/#format","text":"An object of class character of length 1. An object of class character of length 1. Expr_count Expr_len","title":"Format"},{"location":"reference/Expr_count/#returns","text":"Expr Expr Count the number of values in this expression. Similar to R length()","title":"Returns"},{"location":"reference/Expr_count/#examples","text":"pl $ DataFrame ( all = c ( TRUE , TRUE ) , any = c ( TRUE , FALSE ) , none = c ( FALSE , FALSE ) ) $ select ( pl $ all ( ) $ count ( ) ) #> polars DataFrame: shape: (1, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 all \u2506 any \u2506 none \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 u32 \u2506 u32 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2 \u2506 2 \u2506 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( all = c ( TRUE , TRUE ) , any = c ( TRUE , FALSE ) , none = c ( FALSE , FALSE ) ) $ select ( pl $ all ( ) $ len ( ) , pl $ col ( \"all\" ) $ first ( ) $ len ( ) $ alias ( \"all_first\" ) ) #> polars DataFrame: shape: (1, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 all \u2506 any \u2506 none \u2506 all_first \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 u32 \u2506 u32 \u2506 u32 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2 \u2506 2 \u2506 2 \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_cumcount/","text":"Cumulative count Format a method Expr_cumcount ( reverse = FALSE ) Arguments reverse : bool, default FALSE, if true roll over vector from back to forth Returns Expr Get an array with the cumulative count computed at every element. Counting from 0 to len Details Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues. cumcount does not seem to count within lists. Examples pl $ DataFrame ( list ( a = 1 : 4 ) ) $ select ( pl $ col ( \"a\" ) $ cumcount ( ) $ alias ( \"cumcount\" ) , pl $ col ( \"a\" ) $ cumcount ( reverse = TRUE ) $ alias ( \"cumcount_reversed\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cumcount \u2506 cumcount_reversed \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 u32 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0 \u2506 3 \u2502 #> \u2502 1 \u2506 2 \u2502 #> \u2502 2 \u2506 1 \u2502 #> \u2502 3 \u2506 0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_cumcount"},{"location":"reference/Expr_cumcount/#cumulative-count","text":"","title":"Cumulative count"},{"location":"reference/Expr_cumcount/#format","text":"a method Expr_cumcount ( reverse = FALSE )","title":"Format"},{"location":"reference/Expr_cumcount/#arguments","text":"reverse : bool, default FALSE, if true roll over vector from back to forth","title":"Arguments"},{"location":"reference/Expr_cumcount/#returns","text":"Expr Get an array with the cumulative count computed at every element. Counting from 0 to len","title":"Returns"},{"location":"reference/Expr_cumcount/#details","text":"Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues. cumcount does not seem to count within lists.","title":"Details"},{"location":"reference/Expr_cumcount/#examples","text":"pl $ DataFrame ( list ( a = 1 : 4 ) ) $ select ( pl $ col ( \"a\" ) $ cumcount ( ) $ alias ( \"cumcount\" ) , pl $ col ( \"a\" ) $ cumcount ( reverse = TRUE ) $ alias ( \"cumcount_reversed\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cumcount \u2506 cumcount_reversed \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 u32 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0 \u2506 3 \u2502 #> \u2502 1 \u2506 2 \u2502 #> \u2502 2 \u2506 1 \u2502 #> \u2502 3 \u2506 0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_cummin/","text":"Cumulative minimum Format a method a method Expr_cummin ( reverse = FALSE ) Expr_cummax ( reverse = FALSE ) Arguments reverse : bool, default FALSE, if true roll over vector from back to forth Returns Expr Expr Get an array with the cumulative min computed at every element. Get an array with the cumulative max computed at every element. Details Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues. See Inf,NaN,NULL,Null/NA translations here docs_translations Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues. See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( a = 1 : 4 ) ) $ select ( pl $ col ( \"a\" ) $ cummin ( ) $ alias ( \"cummin\" ) , pl $ col ( \"a\" ) $ cummin ( reverse = TRUE ) $ alias ( \"cummin_reversed\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cummin \u2506 cummin_reversed \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 1 \u2502 #> \u2502 1 \u2506 2 \u2502 #> \u2502 1 \u2506 3 \u2502 #> \u2502 1 \u2506 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( list ( a = 1 : 4 ) ) $ select ( pl $ col ( \"a\" ) $ cummax ( ) $ alias ( \"cummux\" ) , pl $ col ( \"a\" ) $ cummax ( reverse = TRUE ) $ alias ( \"cummax_reversed\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cummux \u2506 cummax_reversed \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 4 \u2502 #> \u2502 2 \u2506 4 \u2502 #> \u2502 3 \u2506 4 \u2502 #> \u2502 4 \u2506 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_cummin"},{"location":"reference/Expr_cummin/#cumulative-minimum","text":"","title":"Cumulative minimum"},{"location":"reference/Expr_cummin/#format","text":"a method a method Expr_cummin ( reverse = FALSE ) Expr_cummax ( reverse = FALSE )","title":"Format"},{"location":"reference/Expr_cummin/#arguments","text":"reverse : bool, default FALSE, if true roll over vector from back to forth","title":"Arguments"},{"location":"reference/Expr_cummin/#returns","text":"Expr Expr Get an array with the cumulative min computed at every element. Get an array with the cumulative max computed at every element.","title":"Returns"},{"location":"reference/Expr_cummin/#details","text":"Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues. See Inf,NaN,NULL,Null/NA translations here docs_translations Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues. See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_cummin/#examples","text":"pl $ DataFrame ( list ( a = 1 : 4 ) ) $ select ( pl $ col ( \"a\" ) $ cummin ( ) $ alias ( \"cummin\" ) , pl $ col ( \"a\" ) $ cummin ( reverse = TRUE ) $ alias ( \"cummin_reversed\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cummin \u2506 cummin_reversed \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 1 \u2502 #> \u2502 1 \u2506 2 \u2502 #> \u2502 1 \u2506 3 \u2502 #> \u2502 1 \u2506 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( list ( a = 1 : 4 ) ) $ select ( pl $ col ( \"a\" ) $ cummax ( ) $ alias ( \"cummux\" ) , pl $ col ( \"a\" ) $ cummax ( reverse = TRUE ) $ alias ( \"cummax_reversed\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cummux \u2506 cummax_reversed \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 4 \u2502 #> \u2502 2 \u2506 4 \u2502 #> \u2502 3 \u2506 4 \u2502 #> \u2502 4 \u2506 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_cumprod/","text":"Cumulative product Format a method Expr_cumprod ( reverse = FALSE ) Arguments reverse : bool, default FALSE, if true roll over vector from back to forth Returns Expr Get an array with the cumulative product computed at every element. Details Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues. Examples pl $ DataFrame ( list ( a = 1 : 4 ) ) $ select ( pl $ col ( \"a\" ) $ cumprod ( ) $ alias ( \"cumprod\" ) , pl $ col ( \"a\" ) $ cumprod ( reverse = TRUE ) $ alias ( \"cumprod_reversed\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cumprod \u2506 cumprod_reversed \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i64 \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 24 \u2502 #> \u2502 2 \u2506 24 \u2502 #> \u2502 6 \u2506 12 \u2502 #> \u2502 24 \u2506 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_cumprod"},{"location":"reference/Expr_cumprod/#cumulative-product","text":"","title":"Cumulative product"},{"location":"reference/Expr_cumprod/#format","text":"a method Expr_cumprod ( reverse = FALSE )","title":"Format"},{"location":"reference/Expr_cumprod/#arguments","text":"reverse : bool, default FALSE, if true roll over vector from back to forth","title":"Arguments"},{"location":"reference/Expr_cumprod/#returns","text":"Expr Get an array with the cumulative product computed at every element.","title":"Returns"},{"location":"reference/Expr_cumprod/#details","text":"Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues.","title":"Details"},{"location":"reference/Expr_cumprod/#examples","text":"pl $ DataFrame ( list ( a = 1 : 4 ) ) $ select ( pl $ col ( \"a\" ) $ cumprod ( ) $ alias ( \"cumprod\" ) , pl $ col ( \"a\" ) $ cumprod ( reverse = TRUE ) $ alias ( \"cumprod_reversed\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cumprod \u2506 cumprod_reversed \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i64 \u2506 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 24 \u2502 #> \u2502 2 \u2506 24 \u2502 #> \u2502 6 \u2506 12 \u2502 #> \u2502 24 \u2506 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_cumsum/","text":"Cumulative sum Format a method Expr_cumsum ( reverse = FALSE ) Arguments reverse : bool, default FALSE, if true roll over vector from back to forth Returns Expr Get an array with the cumulative sum computed at every element. Details Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues. Examples pl $ DataFrame ( list ( a = 1 : 4 ) ) $ select ( pl $ col ( \"a\" ) $ cumsum ( ) $ alias ( \"cumsum\" ) , pl $ col ( \"a\" ) $ cumsum ( reverse = TRUE ) $ alias ( \"cumsum_reversed\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cumsum \u2506 cumsum_reversed \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 10 \u2502 #> \u2502 3 \u2506 9 \u2502 #> \u2502 6 \u2506 7 \u2502 #> \u2502 10 \u2506 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_cumsum"},{"location":"reference/Expr_cumsum/#cumulative-sum","text":"","title":"Cumulative sum"},{"location":"reference/Expr_cumsum/#format","text":"a method Expr_cumsum ( reverse = FALSE )","title":"Format"},{"location":"reference/Expr_cumsum/#arguments","text":"reverse : bool, default FALSE, if true roll over vector from back to forth","title":"Arguments"},{"location":"reference/Expr_cumsum/#returns","text":"Expr Get an array with the cumulative sum computed at every element.","title":"Returns"},{"location":"reference/Expr_cumsum/#details","text":"Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues.","title":"Details"},{"location":"reference/Expr_cumsum/#examples","text":"pl $ DataFrame ( list ( a = 1 : 4 ) ) $ select ( pl $ col ( \"a\" ) $ cumsum ( ) $ alias ( \"cumsum\" ) , pl $ col ( \"a\" ) $ cumsum ( reverse = TRUE ) $ alias ( \"cumsum_reversed\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cumsum \u2506 cumsum_reversed \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 10 \u2502 #> \u2502 3 \u2506 9 \u2502 #> \u2502 6 \u2506 7 \u2502 #> \u2502 10 \u2506 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_cumulative_eval/","text":"Cumulative eval Expr_cumulative_eval ( expr , min_periods = 1L , parallel = FALSE ) Arguments expr : Expression to evaluate min_periods : Number of valid values there should be in the window before the expression is evaluated. valid values = length - null_count parallel : Run in parallel. Don't do this in a groupby or another operation that already has much parallelization. Returns Expr Run an expression over a sliding window that increases 1 slot every iteration. Details Warnings This functionality is experimental and may change without it being considered a breaking change. This can be really slow as it can have O(n^2) complexity. Don't use this for operations that visit all elements. Examples pl $ lit ( 1 : 5 ) $ cumulative_eval ( pl $ element ( ) $ first ( ) - pl $ element ( ) $ last ( ) ** 2 ) $ to_r ( ) #> [1] 0 -3 -8 -15 -24","title":"Expr_cumulative_eval"},{"location":"reference/Expr_cumulative_eval/#cumulative-eval","text":"Expr_cumulative_eval ( expr , min_periods = 1L , parallel = FALSE )","title":"Cumulative eval"},{"location":"reference/Expr_cumulative_eval/#arguments","text":"expr : Expression to evaluate min_periods : Number of valid values there should be in the window before the expression is evaluated. valid values = length - null_count parallel : Run in parallel. Don't do this in a groupby or another operation that already has much parallelization.","title":"Arguments"},{"location":"reference/Expr_cumulative_eval/#returns","text":"Expr Run an expression over a sliding window that increases 1 slot every iteration.","title":"Returns"},{"location":"reference/Expr_cumulative_eval/#details","text":"Warnings This functionality is experimental and may change without it being considered a breaking change. This can be really slow as it can have O(n^2) complexity. Don't use this for operations that visit all elements.","title":"Details"},{"location":"reference/Expr_cumulative_eval/#examples","text":"pl $ lit ( 1 : 5 ) $ cumulative_eval ( pl $ element ( ) $ first ( ) - pl $ element ( ) $ last ( ) ** 2 ) $ to_r ( ) #> [1] 0 -3 -8 -15 -24","title":"Examples"},{"location":"reference/Expr_diff/","text":"Diff Expr_diff ( n = 1 , null_behavior = \"ignore\" ) Arguments n : Integerish Number of slots to shift. null_behavior : option default 'ignore', else 'drop' Returns Expr Calculate the n-th discrete difference. Examples pl $ DataFrame ( list ( a = c ( 20L , 10L , 30L , 40L ) ) ) $ select ( pl $ col ( \"a\" ) $ diff ( ) $ alias ( \"diff_default\" ) , pl $ col ( \"a\" ) $ diff ( 2 , \"ignore\" ) $ alias ( \"diff_2_ignore\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 diff_default \u2506 diff_2_ignore \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2506 null \u2502 #> \u2502 -10 \u2506 null \u2502 #> \u2502 20 \u2506 10 \u2502 #> \u2502 10 \u2506 30 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_diff"},{"location":"reference/Expr_diff/#diff","text":"Expr_diff ( n = 1 , null_behavior = \"ignore\" )","title":"Diff"},{"location":"reference/Expr_diff/#arguments","text":"n : Integerish Number of slots to shift. null_behavior : option default 'ignore', else 'drop'","title":"Arguments"},{"location":"reference/Expr_diff/#returns","text":"Expr Calculate the n-th discrete difference.","title":"Returns"},{"location":"reference/Expr_diff/#examples","text":"pl $ DataFrame ( list ( a = c ( 20L , 10L , 30L , 40L ) ) ) $ select ( pl $ col ( \"a\" ) $ diff ( ) $ alias ( \"diff_default\" ) , pl $ col ( \"a\" ) $ diff ( 2 , \"ignore\" ) $ alias ( \"diff_2_ignore\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 diff_default \u2506 diff_2_ignore \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2506 null \u2502 #> \u2502 -10 \u2506 null \u2502 #> \u2502 20 \u2506 10 \u2502 #> \u2502 10 \u2506 30 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_div/","text":"Div Expr_div ( other ) ## S3 method for class 'Expr' e1 / e2 Arguments other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression Returns Exprs Divide Examples #three syntaxes same result pl $ lit ( 5 ) / 10 #> polars Expr: [(5f64) / (10f64)] pl $ lit ( 5 ) / pl $ lit ( 10 ) #> polars Expr: [(5f64) / (10f64)] pl $ lit ( 5 ) $ div ( pl $ lit ( 10 ) ) #> polars Expr: [(5f64) / (10f64)]","title":"Expr_div"},{"location":"reference/Expr_div/#div","text":"Expr_div ( other ) ## S3 method for class 'Expr' e1 / e2","title":"Div"},{"location":"reference/Expr_div/#arguments","text":"other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression","title":"Arguments"},{"location":"reference/Expr_div/#returns","text":"Exprs Divide","title":"Returns"},{"location":"reference/Expr_div/#examples","text":"#three syntaxes same result pl $ lit ( 5 ) / 10 #> polars Expr: [(5f64) / (10f64)] pl $ lit ( 5 ) / pl $ lit ( 10 ) #> polars Expr: [(5f64) / (10f64)] pl $ lit ( 5 ) $ div ( pl $ lit ( 10 ) ) #> polars Expr: [(5f64) / (10f64)]","title":"Examples"},{"location":"reference/Expr_dot/","text":"Dot product Format a method Expr_dot ( other ) Arguments other : Expr to compute dot product with. Returns Expr Compute the dot/inner product between two Expressions. Examples pl $ DataFrame ( a = 1 : 4 ,b = c ( 1 , 2 , 3 , 4 ) ,c = \"bob\" ) $ select ( pl $ col ( \"a\" ) $ dot ( pl $ col ( \"b\" ) ) $ alias ( \"a dot b\" ) , pl $ col ( \"a\" ) $ dot ( pl $ col ( \"a\" ) ) $ alias ( \"a dot a\" ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a dot b \u2506 a dot a \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 30.0 \u2506 30 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_dot"},{"location":"reference/Expr_dot/#dot-product","text":"","title":"Dot product"},{"location":"reference/Expr_dot/#format","text":"a method Expr_dot ( other )","title":"Format"},{"location":"reference/Expr_dot/#arguments","text":"other : Expr to compute dot product with.","title":"Arguments"},{"location":"reference/Expr_dot/#returns","text":"Expr Compute the dot/inner product between two Expressions.","title":"Returns"},{"location":"reference/Expr_dot/#examples","text":"pl $ DataFrame ( a = 1 : 4 ,b = c ( 1 , 2 , 3 , 4 ) ,c = \"bob\" ) $ select ( pl $ col ( \"a\" ) $ dot ( pl $ col ( \"b\" ) ) $ alias ( \"a dot b\" ) , pl $ col ( \"a\" ) $ dot ( pl $ col ( \"a\" ) ) $ alias ( \"a dot a\" ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a dot b \u2506 a dot a \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 30.0 \u2506 30 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_drop_nans/","text":"data Drop NaN(s) Format An object of class character of length 1. Expr_drop_nans Returns Expr Drop floating point NaN values. Similar to R syntax x[!is.nan(x)] Details Note that NaN values are not null values! (null corrosponds to R NA, not R NULL) To drop null values, use method drop_nulls . See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( x = c ( 1 , 2 , NaN , NA ) ) ) $ select ( pl $ col ( \"x\" ) $ drop_nans ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_drop_nans"},{"location":"reference/Expr_drop_nans/#drop-nans","text":"","title":"Drop NaN(s)"},{"location":"reference/Expr_drop_nans/#format","text":"An object of class character of length 1. Expr_drop_nans","title":"Format"},{"location":"reference/Expr_drop_nans/#returns","text":"Expr Drop floating point NaN values. Similar to R syntax x[!is.nan(x)]","title":"Returns"},{"location":"reference/Expr_drop_nans/#details","text":"Note that NaN values are not null values! (null corrosponds to R NA, not R NULL) To drop null values, use method drop_nulls . See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_drop_nans/#examples","text":"pl $ DataFrame ( list ( x = c ( 1 , 2 , NaN , NA ) ) ) $ select ( pl $ col ( \"x\" ) $ drop_nans ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_drop_nulls/","text":"data Drop null(s) Format An object of class character of length 1. Expr_drop_nulls Returns Expr Drop null values. Similar to R syntax x[!(is.na(x) & !is.nan(x))] Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( x = c ( 1 , 2 , NaN , NA ) ) ) $ select ( pl $ col ( \"x\" ) $ drop_nulls ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 NaN \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_drop_nulls"},{"location":"reference/Expr_drop_nulls/#drop-nulls","text":"","title":"Drop null(s)"},{"location":"reference/Expr_drop_nulls/#format","text":"An object of class character of length 1. Expr_drop_nulls","title":"Format"},{"location":"reference/Expr_drop_nulls/#returns","text":"Expr Drop null values. Similar to R syntax x[!(is.na(x) & !is.nan(x))]","title":"Returns"},{"location":"reference/Expr_drop_nulls/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_drop_nulls/#examples","text":"pl $ DataFrame ( list ( x = c ( 1 , 2 , NaN , NA ) ) ) $ select ( pl $ col ( \"x\" ) $ drop_nulls ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 NaN \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_dt/","text":"dt: datetime related methods Expr_dt () Returns Expr Create an object namespace of all datetime related methods. See the individual method pages for full details Examples #missing","title":"Expr_dt"},{"location":"reference/Expr_dt/#dt-datetime-related-methods","text":"Expr_dt ()","title":"dt: datetime related methods"},{"location":"reference/Expr_dt/#returns","text":"Expr Create an object namespace of all datetime related methods. See the individual method pages for full details","title":"Returns"},{"location":"reference/Expr_dt/#examples","text":"#missing","title":"Examples"},{"location":"reference/Expr_entropy/","text":"Entropy Expr_entropy ( base = base :: exp ( 1 ), normalize = TRUE ) Arguments base : Given exponential base, defaults to e normalize : Normalize pk if it doesn't sum to 1. Returns Expr Computes the entropy. Uses the formula -sum(pk * log(pk)) where pk are discrete probabilities. Return Null if input is not values Examples pl $ select ( pl $ lit ( c ( \"a\" , \"b\" , \"b\" , \"c\" , \"c\" , \"c\" ) ) $ unique_counts ( ) $ entropy ( base = 2 ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.459148 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_entropy"},{"location":"reference/Expr_entropy/#entropy","text":"Expr_entropy ( base = base :: exp ( 1 ), normalize = TRUE )","title":"Entropy"},{"location":"reference/Expr_entropy/#arguments","text":"base : Given exponential base, defaults to e normalize : Normalize pk if it doesn't sum to 1.","title":"Arguments"},{"location":"reference/Expr_entropy/#returns","text":"Expr Computes the entropy. Uses the formula -sum(pk * log(pk)) where pk are discrete probabilities. Return Null if input is not values","title":"Returns"},{"location":"reference/Expr_entropy/#examples","text":"pl $ select ( pl $ lit ( c ( \"a\" , \"b\" , \"b\" , \"c\" , \"c\" , \"c\" ) ) $ unique_counts ( ) $ entropy ( base = 2 ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.459148 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_eq/","text":"Equal == Expr_eq ( other ) ## S3 method for class 'Expr' e1 == e2 Arguments other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression Returns Exprs eq method and operator Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples #' #three syntaxes same result pl $ lit ( 2 ) == 2 #> polars Expr: [(2f64) == (2f64)] pl $ lit ( 2 ) == pl $ lit ( 2 ) #> polars Expr: [(2f64) == (2f64)] pl $ lit ( 2 ) $ eq ( pl $ lit ( 2 ) ) #> polars Expr: [(2f64) == (2f64)]","title":"Expr_eq"},{"location":"reference/Expr_eq/#equal","text":"Expr_eq ( other ) ## S3 method for class 'Expr' e1 == e2","title":"Equal =="},{"location":"reference/Expr_eq/#arguments","text":"other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression","title":"Arguments"},{"location":"reference/Expr_eq/#returns","text":"Exprs eq method and operator","title":"Returns"},{"location":"reference/Expr_eq/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_eq/#examples","text":"#' #three syntaxes same result pl $ lit ( 2 ) == 2 #> polars Expr: [(2f64) == (2f64)] pl $ lit ( 2 ) == pl $ lit ( 2 ) #> polars Expr: [(2f64) == (2f64)] pl $ lit ( 2 ) $ eq ( pl $ lit ( 2 ) ) #> polars Expr: [(2f64) == (2f64)]","title":"Examples"},{"location":"reference/Expr_ewm_mean_std_var/","text":"Exponentially-weighted moving average/std/var. Format Method Expr_ewm_mean ( com = NULL , span = NULL , half_life = NULL , alpha = NULL , adjust = TRUE , min_periods = 1L , ignore_nulls = TRUE ) Expr_ewm_std ( com = NULL , span = NULL , half_life = NULL , alpha = NULL , adjust = TRUE , bias = FALSE , min_periods = 1L , ignore_nulls = TRUE ) Expr_ewm_var ( com = NULL , span = NULL , half_life = NULL , alpha = NULL , adjust = TRUE , bias = FALSE , min_periods = 1L , ignore_nulls = TRUE ) Arguments com : Specify decay in terms of center of mass, \\gamma , with c(\" \\n \", \" \\\\alpha = \\\\frac{1}{1 + \\\\gamma} \\\\; \\\\forall \\\\; \\\\gamma \\\\geq 0\\n \", \" \") span : Specify decay in terms of span, \\theta , with \\alpha = \\frac{2}{\\theta + 1} \\; \\forall \\; \\theta \\geq 1 half_life : Specify decay in terms of half-life, :math: \\lambda , with \\alpha = 1 - \\exp \\left\\{ \\frac{ -\\ln(2) }{ \\lambda } \\right\\} \\forall \\; \\lambda > 0 - alpha : Specify smoothing factor alpha directly, 0 < \\alpha \\leq 1 . - adjust : Divide by decaying adjustment factor in beginning periods to account for imbalance in relative weightings When adjust=TRUE the EW function is calculated using weights w_i = (1 - \\alpha)^i When adjust=FALSE the EW function is calculated recursively by c(\" \\n \", \" y_0 = x_0 \\\\\\\\\\n \", \" y_t = (1 - \\\\alpha)y_{t - 1} + \\\\alpha x_t\\n \") min_periods : Minimum number of observations in window required to have a value (otherwise result is null). ignore_nulls : ignore_nulls Ignore missing values when calculating weights. When ignore_nulls=FALSE (default), weights are based on absolute positions. For example, the weights of :math: x_0 and :math: x_2 used in calculating the final weighted average of [ x_0 , None, x_2 `] are 1-\\alpha)^2 and 1 if adjust=TRUE , and (1-\\alpha)^2 and \\alpha if adjust=FALSE`. When ignore_nulls=TRUE , weights are based on relative positions. For example, the weights of x_0 and x_2 used in calculating the final weighted average of [ x_0 , None, x_2``] are 1-\\alpha and 1 if adjust=TRUE , and 1-\\alpha and \\alpha if adjust=FALSE . bias : When bias=FALSE`, apply a correction to make the estimate statistically unbiased. Returns Expr Exponentially-weighted moving average/std/var. Ewm_std Ewm_var Examples pl $ DataFrame ( a = 1 : 3 ) $ select ( pl $ col ( \"a\" ) $ ewm_mean ( com = 1 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 1.666667 \u2502 #> \u2502 2.428571 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( a = 1 : 3 ) $ select ( pl $ col ( \"a\" ) $ ewm_std ( com = 1 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.0 \u2502 #> \u2502 0.707107 \u2502 #> \u2502 0.963624 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( a = 1 : 3 ) $ select ( pl $ col ( \"a\" ) $ ewm_std ( com = 1 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.0 \u2502 #> \u2502 0.707107 \u2502 #> \u2502 0.963624 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_ewm_mean_std_var"},{"location":"reference/Expr_ewm_mean_std_var/#exponentially-weighted-moving-averagestdvar","text":"","title":"Exponentially-weighted moving average/std/var."},{"location":"reference/Expr_ewm_mean_std_var/#format","text":"Method Expr_ewm_mean ( com = NULL , span = NULL , half_life = NULL , alpha = NULL , adjust = TRUE , min_periods = 1L , ignore_nulls = TRUE ) Expr_ewm_std ( com = NULL , span = NULL , half_life = NULL , alpha = NULL , adjust = TRUE , bias = FALSE , min_periods = 1L , ignore_nulls = TRUE ) Expr_ewm_var ( com = NULL , span = NULL , half_life = NULL , alpha = NULL , adjust = TRUE , bias = FALSE , min_periods = 1L , ignore_nulls = TRUE )","title":"Format"},{"location":"reference/Expr_ewm_mean_std_var/#arguments","text":"com : Specify decay in terms of center of mass, \\gamma , with c(\" \\n \", \" \\\\alpha = \\\\frac{1}{1 + \\\\gamma} \\\\; \\\\forall \\\\; \\\\gamma \\\\geq 0\\n \", \" \") span : Specify decay in terms of span, \\theta , with \\alpha = \\frac{2}{\\theta + 1} \\; \\forall \\; \\theta \\geq 1 half_life : Specify decay in terms of half-life, :math: \\lambda , with \\alpha = 1 - \\exp \\left\\{ \\frac{ -\\ln(2) }{ \\lambda } \\right\\} \\forall \\; \\lambda > 0 - alpha : Specify smoothing factor alpha directly, 0 < \\alpha \\leq 1 . - adjust : Divide by decaying adjustment factor in beginning periods to account for imbalance in relative weightings When adjust=TRUE the EW function is calculated using weights w_i = (1 - \\alpha)^i When adjust=FALSE the EW function is calculated recursively by c(\" \\n \", \" y_0 = x_0 \\\\\\\\\\n \", \" y_t = (1 - \\\\alpha)y_{t - 1} + \\\\alpha x_t\\n \") min_periods : Minimum number of observations in window required to have a value (otherwise result is null). ignore_nulls : ignore_nulls Ignore missing values when calculating weights. When ignore_nulls=FALSE (default), weights are based on absolute positions. For example, the weights of :math: x_0 and :math: x_2 used in calculating the final weighted average of [ x_0 , None, x_2 `] are 1-\\alpha)^2 and 1 if adjust=TRUE , and (1-\\alpha)^2 and \\alpha if adjust=FALSE`. When ignore_nulls=TRUE , weights are based on relative positions. For example, the weights of x_0 and x_2 used in calculating the final weighted average of [ x_0 , None, x_2``] are 1-\\alpha and 1 if adjust=TRUE , and 1-\\alpha and \\alpha if adjust=FALSE . bias : When bias=FALSE`, apply a correction to make the estimate statistically unbiased.","title":"Arguments"},{"location":"reference/Expr_ewm_mean_std_var/#returns","text":"Expr Exponentially-weighted moving average/std/var. Ewm_std Ewm_var","title":"Returns"},{"location":"reference/Expr_ewm_mean_std_var/#examples","text":"pl $ DataFrame ( a = 1 : 3 ) $ select ( pl $ col ( \"a\" ) $ ewm_mean ( com = 1 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 1.666667 \u2502 #> \u2502 2.428571 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( a = 1 : 3 ) $ select ( pl $ col ( \"a\" ) $ ewm_std ( com = 1 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.0 \u2502 #> \u2502 0.707107 \u2502 #> \u2502 0.963624 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( a = 1 : 3 ) $ select ( pl $ col ( \"a\" ) $ ewm_std ( com = 1 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.0 \u2502 #> \u2502 0.707107 \u2502 #> \u2502 0.963624 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_exclude/","text":"Exclude certain columns from a wildcard/regex selection. Expr_exclude ( columns ) Arguments columns : given param type: string: exclude name of column or exclude regex starting with ^and ending with$ character vector: exclude all these column names, no regex allowed DataType: Exclude any of this DataType List(DataType): Excldue any of these DataType(s) Returns Expr You may also use regexes in the exclude list. They must start with ^ and end with $ . Examples #make DataFrame df = pl $ DataFrame ( iris ) #by name(s) df $ select ( pl $ all ( ) $ exclude ( \"Species\" ) ) #> polars DataFrame: shape: (150, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #by type df $ select ( pl $ all ( ) $ exclude ( pl $ Categorical ) ) #> polars DataFrame: shape: (150, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ all ( ) $ exclude ( list ( pl $ Categorical , pl $ Float64 ) ) ) #> polars DataFrame: shape: (0, 0) #> \u250c\u2510 #> \u255e\u2561 #> \u2514\u2518 #by regex df $ select ( pl $ all ( ) $ exclude ( \"^Sepal.*$\" ) ) #> polars DataFrame: shape: (150, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2502 #> \u2502 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_exclude"},{"location":"reference/Expr_exclude/#exclude-certain-columns-from-a-wildcardregex-selection","text":"Expr_exclude ( columns )","title":"Exclude certain columns from a wildcard/regex selection."},{"location":"reference/Expr_exclude/#arguments","text":"columns : given param type: string: exclude name of column or exclude regex starting with ^and ending with$ character vector: exclude all these column names, no regex allowed DataType: Exclude any of this DataType List(DataType): Excldue any of these DataType(s)","title":"Arguments"},{"location":"reference/Expr_exclude/#returns","text":"Expr You may also use regexes in the exclude list. They must start with ^ and end with $ .","title":"Returns"},{"location":"reference/Expr_exclude/#examples","text":"#make DataFrame df = pl $ DataFrame ( iris ) #by name(s) df $ select ( pl $ all ( ) $ exclude ( \"Species\" ) ) #> polars DataFrame: shape: (150, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #by type df $ select ( pl $ all ( ) $ exclude ( pl $ Categorical ) ) #> polars DataFrame: shape: (150, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ all ( ) $ exclude ( list ( pl $ Categorical , pl $ Float64 ) ) ) #> polars DataFrame: shape: (0, 0) #> \u250c\u2510 #> \u255e\u2561 #> \u2514\u2518 #by regex df $ select ( pl $ all ( ) $ exclude ( \"^Sepal.*$\" ) ) #> polars DataFrame: shape: (150, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2502 #> \u2502 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_exp/","text":"data Compute the exponential, element-wise. Format a method Expr_exp Returns Expr Compute the exponential, element-wise. Examples log10123 = suppressWarnings ( log ( - 1 : 3 ) ) all.equal ( pl $ DataFrame ( list ( a = log10123 ) ) $ select ( pl $ col ( \"a\" ) $ exp ( ) ) $ as_data_frame ( ) $ a , exp ( 1 ) ^ log10123 ) #> [1] TRUE","title":"Expr_exp"},{"location":"reference/Expr_exp/#compute-the-exponential-element-wise","text":"","title":"Compute the exponential, element-wise."},{"location":"reference/Expr_exp/#format","text":"a method Expr_exp","title":"Format"},{"location":"reference/Expr_exp/#returns","text":"Expr Compute the exponential, element-wise.","title":"Returns"},{"location":"reference/Expr_exp/#examples","text":"log10123 = suppressWarnings ( log ( - 1 : 3 ) ) all.equal ( pl $ DataFrame ( list ( a = log10123 ) ) $ select ( pl $ col ( \"a\" ) $ exp ( ) ) $ as_data_frame ( ) $ a , exp ( 1 ) ^ log10123 ) #> [1] TRUE","title":"Examples"},{"location":"reference/Expr_explode/","text":"data Explode a list or utf8 Series. Format a method a method Expr_explode Expr_flatten Returns Expr This means that every item is expanded to a new row. ( flatten is an alias for explode ) Details explode/flatten does not support categorical Examples pl $ DataFrame ( list ( a = letters ) ) $ select ( pl $ col ( \"a\" ) $ explode ( ) $ take ( 0 : 5 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 a \u2502 #> \u2502 b \u2502 #> \u2502 c \u2502 #> \u2502 d \u2502 #> \u2502 e \u2502 #> \u2502 f \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 listed_group_df = pl $ DataFrame ( iris [ c ( 1 : 3 , 51 : 53 ) , ] ) $ groupby ( \"Species\" ) $ agg ( pl $ all ( ) ) print ( listed_group_df ) #> polars DataFrame: shape: (2, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Species \u2506 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 cat \u2506 list[f64] \u2506 list[f64] \u2506 list[f64] \u2506 list[f64] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 setosa \u2506 [5.1, 4.9, 4.7] \u2506 [3.5, 3.0, 3.2] \u2506 [1.4, 1.4, 1.3] \u2506 [0.2, 0.2, 0.2] \u2502 #> \u2502 versicolor \u2506 [7.0, 6.4, 6.9] \u2506 [3.2, 3.2, 3.1] \u2506 [4.7, 4.5, 4.9] \u2506 [1.4, 1.5, 1.5] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 vectors_df = listed_group_df $ select ( pl $ col ( c ( \"Sepal.Width\" , \"Sepal.Length\" ) ) $ explode ( ) ) print ( vectors_df ) #> polars DataFrame: shape: (6, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Width \u2506 Sepal.Length \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3.5 \u2506 5.1 \u2502 #> \u2502 3.0 \u2506 4.9 \u2502 #> \u2502 3.2 \u2506 4.7 \u2502 #> \u2502 3.2 \u2506 7.0 \u2502 #> \u2502 3.2 \u2506 6.4 \u2502 #> \u2502 3.1 \u2506 6.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_explode"},{"location":"reference/Expr_explode/#explode-a-list-or-utf8-series","text":"","title":"Explode a list or utf8 Series."},{"location":"reference/Expr_explode/#format","text":"a method a method Expr_explode Expr_flatten","title":"Format"},{"location":"reference/Expr_explode/#returns","text":"Expr This means that every item is expanded to a new row. ( flatten is an alias for explode )","title":"Returns"},{"location":"reference/Expr_explode/#details","text":"explode/flatten does not support categorical","title":"Details"},{"location":"reference/Expr_explode/#examples","text":"pl $ DataFrame ( list ( a = letters ) ) $ select ( pl $ col ( \"a\" ) $ explode ( ) $ take ( 0 : 5 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 a \u2502 #> \u2502 b \u2502 #> \u2502 c \u2502 #> \u2502 d \u2502 #> \u2502 e \u2502 #> \u2502 f \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 listed_group_df = pl $ DataFrame ( iris [ c ( 1 : 3 , 51 : 53 ) , ] ) $ groupby ( \"Species\" ) $ agg ( pl $ all ( ) ) print ( listed_group_df ) #> polars DataFrame: shape: (2, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Species \u2506 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 cat \u2506 list[f64] \u2506 list[f64] \u2506 list[f64] \u2506 list[f64] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 setosa \u2506 [5.1, 4.9, 4.7] \u2506 [3.5, 3.0, 3.2] \u2506 [1.4, 1.4, 1.3] \u2506 [0.2, 0.2, 0.2] \u2502 #> \u2502 versicolor \u2506 [7.0, 6.4, 6.9] \u2506 [3.2, 3.2, 3.1] \u2506 [4.7, 4.5, 4.9] \u2506 [1.4, 1.5, 1.5] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 vectors_df = listed_group_df $ select ( pl $ col ( c ( \"Sepal.Width\" , \"Sepal.Length\" ) ) $ explode ( ) ) print ( vectors_df ) #> polars DataFrame: shape: (6, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Width \u2506 Sepal.Length \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3.5 \u2506 5.1 \u2502 #> \u2502 3.0 \u2506 4.9 \u2502 #> \u2502 3.2 \u2506 4.7 \u2502 #> \u2502 3.2 \u2506 7.0 \u2502 #> \u2502 3.2 \u2506 6.4 \u2502 #> \u2502 3.1 \u2506 6.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_extend_constant/","text":"Extend_constant Format Method Expr_extend_constant ( value , n ) Arguments value : The value to extend the Series with. This value may be None to fill with nulls. n : The number of values to extend. Returns Expr Extend the Series with given number of values. Examples pl $ select ( pl $ lit ( c ( \"5\" , \"Bob_is_not_a_number\" ) ) $ cast ( pl $ dtypes $ UInt64 , strict = FALSE ) $ extend_constant ( 10.1 , 2 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 u64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5 \u2502 #> \u2502 null \u2502 #> \u2502 10 \u2502 #> \u2502 10 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ select ( pl $ lit ( c ( \"5\" , \"Bob_is_not_a_number\" ) ) $ cast ( pl $ dtypes $ Utf8 , strict = FALSE ) $ extend_constant ( \"chuchu\" , 2 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5 \u2502 #> \u2502 Bob_is_not_a_number \u2502 #> \u2502 chuchu \u2502 #> \u2502 chuchu \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_extend_constant"},{"location":"reference/Expr_extend_constant/#extend_constant","text":"","title":"Extend_constant"},{"location":"reference/Expr_extend_constant/#format","text":"Method Expr_extend_constant ( value , n )","title":"Format"},{"location":"reference/Expr_extend_constant/#arguments","text":"value : The value to extend the Series with. This value may be None to fill with nulls. n : The number of values to extend.","title":"Arguments"},{"location":"reference/Expr_extend_constant/#returns","text":"Expr Extend the Series with given number of values.","title":"Returns"},{"location":"reference/Expr_extend_constant/#examples","text":"pl $ select ( pl $ lit ( c ( \"5\" , \"Bob_is_not_a_number\" ) ) $ cast ( pl $ dtypes $ UInt64 , strict = FALSE ) $ extend_constant ( 10.1 , 2 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 u64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5 \u2502 #> \u2502 null \u2502 #> \u2502 10 \u2502 #> \u2502 10 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ select ( pl $ lit ( c ( \"5\" , \"Bob_is_not_a_number\" ) ) $ cast ( pl $ dtypes $ Utf8 , strict = FALSE ) $ extend_constant ( \"chuchu\" , 2 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5 \u2502 #> \u2502 Bob_is_not_a_number \u2502 #> \u2502 chuchu \u2502 #> \u2502 chuchu \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_extend_expr/","text":"Extend_expr Format Method Expr_extend_expr ( value , n ) Arguments value : The expr to extend the Series with. This value may be None to fill with nulls. n : The number of values to extend. Returns Expr Extend the Series with a expression repeated a number of times Examples pl $ select ( pl $ lit ( c ( \"5\" , \"Bob_is_not_a_number\" ) ) $ cast ( pl $ dtypes $ UInt64 , strict = FALSE ) $ extend_expr ( 10.1 , 2 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 u64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5 \u2502 #> \u2502 null \u2502 #> \u2502 10 \u2502 #> \u2502 10 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ select ( pl $ lit ( c ( \"5\" , \"Bob_is_not_a_number\" ) ) $ cast ( pl $ dtypes $ Utf8 , strict = FALSE ) $ extend_expr ( \"chuchu\" , 2 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5 \u2502 #> \u2502 Bob_is_not_a_number \u2502 #> \u2502 chuchu \u2502 #> \u2502 chuchu \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_extend_expr"},{"location":"reference/Expr_extend_expr/#extend_expr","text":"","title":"Extend_expr"},{"location":"reference/Expr_extend_expr/#format","text":"Method Expr_extend_expr ( value , n )","title":"Format"},{"location":"reference/Expr_extend_expr/#arguments","text":"value : The expr to extend the Series with. This value may be None to fill with nulls. n : The number of values to extend.","title":"Arguments"},{"location":"reference/Expr_extend_expr/#returns","text":"Expr Extend the Series with a expression repeated a number of times","title":"Returns"},{"location":"reference/Expr_extend_expr/#examples","text":"pl $ select ( pl $ lit ( c ( \"5\" , \"Bob_is_not_a_number\" ) ) $ cast ( pl $ dtypes $ UInt64 , strict = FALSE ) $ extend_expr ( 10.1 , 2 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 u64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5 \u2502 #> \u2502 null \u2502 #> \u2502 10 \u2502 #> \u2502 10 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ select ( pl $ lit ( c ( \"5\" , \"Bob_is_not_a_number\" ) ) $ cast ( pl $ dtypes $ Utf8 , strict = FALSE ) $ extend_expr ( \"chuchu\" , 2 ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5 \u2502 #> \u2502 Bob_is_not_a_number \u2502 #> \u2502 chuchu \u2502 #> \u2502 chuchu \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_fill_nan/","text":"Fill Nulls Forward Format a method Expr_fill_nan ( expr = NULL ) Arguments expr : Expr or into Expr, value to fill NaNs with Returns Expr Fill missing values with last seen values. Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples l = list ( a = c ( 1 , NaN , NaN , 3 ) ) pl $ DataFrame ( l ) $ select ( pl $ col ( \"a\" ) $ fill_nan ( ) $ alias ( \"fill_default\" ) , pl $ col ( \"a\" ) $ fill_nan ( pl $ lit ( NA ) ) $ alias ( \"fill_NA\" ) , #same as default pl $ col ( \"a\" ) $ fill_nan ( 2 ) $ alias ( \"fill_float2\" ) , pl $ col ( \"a\" ) $ fill_nan ( \"hej\" ) $ alias ( \"fill_str\" ) #implicit cast to Utf8 ) $ to_list ( ) #> $fill_default #> [1] 1 NA NA 3 #> #> $fill_NA #> [1] 1 NA NA 3 #> #> $fill_float2 #> [1] 1 2 2 3 #> #> $fill_str #> [1] \"1.0\" \"hej\" \"hej\" \"3.0\" #>","title":"Expr_fill_nan"},{"location":"reference/Expr_fill_nan/#fill-nulls-forward","text":"","title":"Fill Nulls Forward"},{"location":"reference/Expr_fill_nan/#format","text":"a method Expr_fill_nan ( expr = NULL )","title":"Format"},{"location":"reference/Expr_fill_nan/#arguments","text":"expr : Expr or into Expr, value to fill NaNs with","title":"Arguments"},{"location":"reference/Expr_fill_nan/#returns","text":"Expr Fill missing values with last seen values.","title":"Returns"},{"location":"reference/Expr_fill_nan/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_fill_nan/#examples","text":"l = list ( a = c ( 1 , NaN , NaN , 3 ) ) pl $ DataFrame ( l ) $ select ( pl $ col ( \"a\" ) $ fill_nan ( ) $ alias ( \"fill_default\" ) , pl $ col ( \"a\" ) $ fill_nan ( pl $ lit ( NA ) ) $ alias ( \"fill_NA\" ) , #same as default pl $ col ( \"a\" ) $ fill_nan ( 2 ) $ alias ( \"fill_float2\" ) , pl $ col ( \"a\" ) $ fill_nan ( \"hej\" ) $ alias ( \"fill_str\" ) #implicit cast to Utf8 ) $ to_list ( ) #> $fill_default #> [1] 1 NA NA 3 #> #> $fill_NA #> [1] 1 NA NA 3 #> #> $fill_float2 #> [1] 1 2 2 3 #> #> $fill_str #> [1] \"1.0\" \"hej\" \"hej\" \"3.0\" #>","title":"Examples"},{"location":"reference/Expr_fill_null/","text":"Fill Nulls with a value or strategy. Format a method Expr_fill_null ( value = NULL , strategy = NULL , limit = NULL ) Arguments value : Expr or Into<Expr> to fill Null values with strategy : default NULL else 'forward', 'backward', 'min', 'max', 'mean', 'zero', 'one' limit : Number of consecutive null values to fill when using the 'forward' or 'backward' strategy. Returns Expr Shift the values by value or as strategy. Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ select ( pl $ lit ( 0 : 3 ) $ shift_and_fill ( - 2 , fill_value = 42 ) $ alias ( \"shift-2\" ) , pl $ lit ( 0 : 3 ) $ shift_and_fill ( 2 , fill_value = pl $ lit ( 42 ) / 2 ) $ alias ( \"shift+2\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 shift-2 \u2506 shift+2 \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2.0 \u2506 21.0 \u2502 #> \u2502 3.0 \u2506 21.0 \u2502 #> \u2502 42.0 \u2506 0.0 \u2502 #> \u2502 42.0 \u2506 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_fill_null"},{"location":"reference/Expr_fill_null/#fill-nulls-with-a-value-or-strategy","text":"","title":"Fill Nulls with a value or strategy."},{"location":"reference/Expr_fill_null/#format","text":"a method Expr_fill_null ( value = NULL , strategy = NULL , limit = NULL )","title":"Format"},{"location":"reference/Expr_fill_null/#arguments","text":"value : Expr or Into<Expr> to fill Null values with strategy : default NULL else 'forward', 'backward', 'min', 'max', 'mean', 'zero', 'one' limit : Number of consecutive null values to fill when using the 'forward' or 'backward' strategy.","title":"Arguments"},{"location":"reference/Expr_fill_null/#returns","text":"Expr Shift the values by value or as strategy.","title":"Returns"},{"location":"reference/Expr_fill_null/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_fill_null/#examples","text":"pl $ select ( pl $ lit ( 0 : 3 ) $ shift_and_fill ( - 2 , fill_value = 42 ) $ alias ( \"shift-2\" ) , pl $ lit ( 0 : 3 ) $ shift_and_fill ( 2 , fill_value = pl $ lit ( 42 ) / 2 ) $ alias ( \"shift+2\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 shift-2 \u2506 shift+2 \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2.0 \u2506 21.0 \u2502 #> \u2502 3.0 \u2506 21.0 \u2502 #> \u2502 42.0 \u2506 0.0 \u2502 #> \u2502 42.0 \u2506 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_filter/","text":"Filter a single column. Format a method Expr_filter ( predicate ) Expr_where ( predicate ) Arguments predicate : Expr or something Into<Expr> . Should be a boolean expression. Returns Expr Mostly useful in an aggregation context. If you want to filter on a DataFrame level, use LazyFrame.filter . where() is an alias for pl$filter Examples df = pl $ DataFrame ( list ( group_col = c ( \"g1\" , \"g1\" , \"g2\" ) , b = c ( 1 , 2 , 3 ) ) ) df $ groupby ( \"group_col\" ) $ agg ( pl $ col ( \"b\" ) $ filter ( pl $ col ( \"b\" ) < 2 ) $ sum ( ) $ alias ( \"lt\" ) , pl $ col ( \"b\" ) $ filter ( pl $ col ( \"b\" ) >= 2 ) $ sum ( ) $ alias ( \"gte\" ) ) #> polars DataFrame: shape: (2, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 group_col \u2506 lt \u2506 gte \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 g1 \u2506 1.0 \u2506 2.0 \u2502 #> \u2502 g2 \u2506 null \u2506 3.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_filter"},{"location":"reference/Expr_filter/#filter-a-single-column","text":"","title":"Filter a single column."},{"location":"reference/Expr_filter/#format","text":"a method Expr_filter ( predicate ) Expr_where ( predicate )","title":"Format"},{"location":"reference/Expr_filter/#arguments","text":"predicate : Expr or something Into<Expr> . Should be a boolean expression.","title":"Arguments"},{"location":"reference/Expr_filter/#returns","text":"Expr Mostly useful in an aggregation context. If you want to filter on a DataFrame level, use LazyFrame.filter . where() is an alias for pl$filter","title":"Returns"},{"location":"reference/Expr_filter/#examples","text":"df = pl $ DataFrame ( list ( group_col = c ( \"g1\" , \"g1\" , \"g2\" ) , b = c ( 1 , 2 , 3 ) ) ) df $ groupby ( \"group_col\" ) $ agg ( pl $ col ( \"b\" ) $ filter ( pl $ col ( \"b\" ) < 2 ) $ sum ( ) $ alias ( \"lt\" ) , pl $ col ( \"b\" ) $ filter ( pl $ col ( \"b\" ) >= 2 ) $ sum ( ) $ alias ( \"gte\" ) ) #> polars DataFrame: shape: (2, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 group_col \u2506 lt \u2506 gte \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 g1 \u2506 1.0 \u2506 2.0 \u2502 #> \u2502 g2 \u2506 null \u2506 3.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_first/","text":"data First Format An object of class character of length 1. Expr_first Returns Expr Get the first value. Similar to R head(x,1) Examples pl $ DataFrame ( list ( x = c ( 1 , 2 , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ first ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_first"},{"location":"reference/Expr_first/#first","text":"","title":"First"},{"location":"reference/Expr_first/#format","text":"An object of class character of length 1. Expr_first","title":"Format"},{"location":"reference/Expr_first/#returns","text":"Expr Get the first value. Similar to R head(x,1)","title":"Returns"},{"location":"reference/Expr_first/#examples","text":"pl $ DataFrame ( list ( x = c ( 1 , 2 , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ first ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_floor/","text":"data Floor Format a method Expr_floor Returns Expr Rounds down to the nearest integer value. Only works on floating point Series. Examples pl $ DataFrame ( list ( a = c ( 0.33 , 0.5 , 1.02 , 1.5 , NaN , NA , Inf , - Inf ) ) ) $ select ( pl $ col ( \"a\" ) $ floor ( ) ) #> polars DataFrame: shape: (8, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.0 \u2502 #> \u2502 0.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 NaN \u2502 #> \u2502 null \u2502 #> \u2502 inf \u2502 #> \u2502 -inf \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_floor"},{"location":"reference/Expr_floor/#floor","text":"","title":"Floor"},{"location":"reference/Expr_floor/#format","text":"a method Expr_floor","title":"Format"},{"location":"reference/Expr_floor/#returns","text":"Expr Rounds down to the nearest integer value. Only works on floating point Series.","title":"Returns"},{"location":"reference/Expr_floor/#examples","text":"pl $ DataFrame ( list ( a = c ( 0.33 , 0.5 , 1.02 , 1.5 , NaN , NA , Inf , - Inf ) ) ) $ select ( pl $ col ( \"a\" ) $ floor ( ) ) #> polars DataFrame: shape: (8, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.0 \u2502 #> \u2502 0.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 NaN \u2502 #> \u2502 null \u2502 #> \u2502 inf \u2502 #> \u2502 -inf \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_forward_fill/","text":"Fill Nulls Forward Format a method Expr_forward_fill ( limit = NULL ) Arguments limit : Expr or Into<Expr> The number of consecutive null values to forward fill. Returns Expr Fill missing values with last seen values. Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples l = list ( a = c ( 1L , rep ( NA_integer_ , 3L ) , 10 ) ) pl $ DataFrame ( l ) $ select ( pl $ col ( \"a\" ) $ forward_fill ( ) $ alias ( \"ff_null\" ) , pl $ col ( \"a\" ) $ forward_fill ( limit = 0 ) $ alias ( \"ff_l0\" ) , pl $ col ( \"a\" ) $ forward_fill ( limit = 1 ) $ alias ( \"ff_l1\" ) ) $ to_list ( ) #> $ff_null #> [1] 1 1 1 1 10 #> #> $ff_l0 #> [1] 1 NA NA NA 10 #> #> $ff_l1 #> [1] 1 1 NA NA 10 #>","title":"Expr_forward_fill"},{"location":"reference/Expr_forward_fill/#fill-nulls-forward","text":"","title":"Fill Nulls Forward"},{"location":"reference/Expr_forward_fill/#format","text":"a method Expr_forward_fill ( limit = NULL )","title":"Format"},{"location":"reference/Expr_forward_fill/#arguments","text":"limit : Expr or Into<Expr> The number of consecutive null values to forward fill.","title":"Arguments"},{"location":"reference/Expr_forward_fill/#returns","text":"Expr Fill missing values with last seen values.","title":"Returns"},{"location":"reference/Expr_forward_fill/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_forward_fill/#examples","text":"l = list ( a = c ( 1L , rep ( NA_integer_ , 3L ) , 10 ) ) pl $ DataFrame ( l ) $ select ( pl $ col ( \"a\" ) $ forward_fill ( ) $ alias ( \"ff_null\" ) , pl $ col ( \"a\" ) $ forward_fill ( limit = 0 ) $ alias ( \"ff_l0\" ) , pl $ col ( \"a\" ) $ forward_fill ( limit = 1 ) $ alias ( \"ff_l1\" ) ) $ to_list ( ) #> $ff_null #> [1] 1 1 1 1 10 #> #> $ff_l0 #> [1] 1 NA NA NA 10 #> #> $ff_l1 #> [1] 1 1 NA NA 10 #>","title":"Examples"},{"location":"reference/Expr_gt/","text":"GreaterThan < Expr_gt ( other ) ## S3 method for class 'Expr' e1 > e2 Arguments other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression Returns Exprs gt method and operator Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples #' #three syntaxes same result pl $ lit ( 2 ) > 1 #> polars Expr: [(2f64) > (1f64)] pl $ lit ( 2 ) > pl $ lit ( 1 ) #> polars Expr: [(2f64) > (1f64)] pl $ lit ( 2 ) $ gt ( pl $ lit ( 1 ) ) #> polars Expr: [(2f64) > (1f64)]","title":"Expr_gt"},{"location":"reference/Expr_gt/#greaterthan","text":"Expr_gt ( other ) ## S3 method for class 'Expr' e1 > e2","title":"GreaterThan &lt;"},{"location":"reference/Expr_gt/#arguments","text":"other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression","title":"Arguments"},{"location":"reference/Expr_gt/#returns","text":"Exprs gt method and operator","title":"Returns"},{"location":"reference/Expr_gt/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_gt/#examples","text":"#' #three syntaxes same result pl $ lit ( 2 ) > 1 #> polars Expr: [(2f64) > (1f64)] pl $ lit ( 2 ) > pl $ lit ( 1 ) #> polars Expr: [(2f64) > (1f64)] pl $ lit ( 2 ) $ gt ( pl $ lit ( 1 ) ) #> polars Expr: [(2f64) > (1f64)]","title":"Examples"},{"location":"reference/Expr_gt_eq/","text":"Greater Than Or Equal <= Expr_gt_eq ( other ) ## S3 method for class 'Expr' e1 >= e2 Arguments other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression Returns Exprs gt_eq method and operator Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples #' #three syntaxes same result pl $ lit ( 2 ) >= 2 #> polars Expr: [(2f64) >= (2f64)] pl $ lit ( 2 ) >= pl $ lit ( 2 ) #> polars Expr: [(2f64) >= (2f64)] pl $ lit ( 2 ) $ gt_eq ( pl $ lit ( 2 ) ) #> polars Expr: [(2f64) >= (2f64)]","title":"Expr_gt_eq"},{"location":"reference/Expr_gt_eq/#greater-than-or-equal","text":"Expr_gt_eq ( other ) ## S3 method for class 'Expr' e1 >= e2","title":"Greater Than Or Equal &lt;="},{"location":"reference/Expr_gt_eq/#arguments","text":"other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression","title":"Arguments"},{"location":"reference/Expr_gt_eq/#returns","text":"Exprs gt_eq method and operator","title":"Returns"},{"location":"reference/Expr_gt_eq/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_gt_eq/#examples","text":"#' #three syntaxes same result pl $ lit ( 2 ) >= 2 #> polars Expr: [(2f64) >= (2f64)] pl $ lit ( 2 ) >= pl $ lit ( 2 ) #> polars Expr: [(2f64) >= (2f64)] pl $ lit ( 2 ) $ gt_eq ( pl $ lit ( 2 ) ) #> polars Expr: [(2f64) >= (2f64)]","title":"Examples"},{"location":"reference/Expr_hash/","text":"hash Expr_hash ( seed = 0 , seed_1 = NULL , seed_2 = NULL , seed_3 = NULL ) Arguments seed : Random seed parameter. Defaults to 0. seed_1 : Random seed parameter. Defaults to arg seed. seed_2 : Random seed parameter. Defaults to arg seed. seed_3 : Random seed parameter. Defaults to arg seed. The column will be coerced to UInt32. Give this dtype to make the coercion a no-op. Returns Expr Hash the elements in the selection. The hash value is of type UInt64 . Examples df = pl $ DataFrame ( iris ) df $ select ( pl $ all ( ) $ head ( 2 ) $ hash ( 1234 ) $ cast ( pl $ Utf8 ) ) $ to_list ( ) #> $Sepal.Length #> [1] \"8787545805499047296\" \"3480667128160896\" #> #> $Sepal.Width #> [1] \"10016005571271983104\" \"12826251738751172608\" #> #> $Petal.Length #> [1] \"11417647987883416960\" \"11417647987883416960\" #> #> $Petal.Width #> [1] \"15099546618074063488\" \"15099546618074063488\" #> #> $Species #> [1] \"0\" \"0\" #>","title":"Expr_hash"},{"location":"reference/Expr_hash/#hash","text":"Expr_hash ( seed = 0 , seed_1 = NULL , seed_2 = NULL , seed_3 = NULL )","title":"hash"},{"location":"reference/Expr_hash/#arguments","text":"seed : Random seed parameter. Defaults to 0. seed_1 : Random seed parameter. Defaults to arg seed. seed_2 : Random seed parameter. Defaults to arg seed. seed_3 : Random seed parameter. Defaults to arg seed. The column will be coerced to UInt32. Give this dtype to make the coercion a no-op.","title":"Arguments"},{"location":"reference/Expr_hash/#returns","text":"Expr Hash the elements in the selection. The hash value is of type UInt64 .","title":"Returns"},{"location":"reference/Expr_hash/#examples","text":"df = pl $ DataFrame ( iris ) df $ select ( pl $ all ( ) $ head ( 2 ) $ hash ( 1234 ) $ cast ( pl $ Utf8 ) ) $ to_list ( ) #> $Sepal.Length #> [1] \"8787545805499047296\" \"3480667128160896\" #> #> $Sepal.Width #> [1] \"10016005571271983104\" \"12826251738751172608\" #> #> $Petal.Length #> [1] \"11417647987883416960\" \"11417647987883416960\" #> #> $Petal.Width #> [1] \"15099546618074063488\" \"15099546618074063488\" #> #> $Species #> [1] \"0\" \"0\" #>","title":"Examples"},{"location":"reference/Expr_head/","text":"Head Expr_head ( n = 10 ) Arguments n : numeric number of elements to select from head Returns Expr Get the head n elements. Similar to R head(x) Examples #get 3 first elements pl $ DataFrame ( list ( x = 1 : 11 ) ) $ select ( pl $ col ( \"x\" ) $ head ( 3 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_head"},{"location":"reference/Expr_head/#head","text":"Expr_head ( n = 10 )","title":"Head"},{"location":"reference/Expr_head/#arguments","text":"n : numeric number of elements to select from head","title":"Arguments"},{"location":"reference/Expr_head/#returns","text":"Expr Get the head n elements. Similar to R head(x)","title":"Returns"},{"location":"reference/Expr_head/#examples","text":"#get 3 first elements pl $ DataFrame ( list ( x = 1 : 11 ) ) $ select ( pl $ col ( \"x\" ) $ head ( 3 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_inspect/","text":"Inspect evaluated Series Expr_inspect ( fmt = \"{}\" ) Arguments fmt : format string, should contain one set of {} where object will be printed This formatting mimics python \"string\".format() use in pypolars. The string can contain any thing but should have exactly one set of curly bracket . Returns Expr Print the value that this expression evaluates to and pass on the value. The printing will happen when the expression evaluates, not when it is formed. Examples pl $ select ( pl $ lit ( 1 : 5 ) $ inspect ( \"before dropping half the column it was:{}and not it is dropped\" ) $ head ( 2 ) ) #> before dropping half the column it was:shape: (5,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> 4 #> 5 #> ] #> and not it is dropped #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_inspect"},{"location":"reference/Expr_inspect/#inspect-evaluated-series","text":"Expr_inspect ( fmt = \"{}\" )","title":"Inspect evaluated Series"},{"location":"reference/Expr_inspect/#arguments","text":"fmt : format string, should contain one set of {} where object will be printed This formatting mimics python \"string\".format() use in pypolars. The string can contain any thing but should have exactly one set of curly bracket .","title":"Arguments"},{"location":"reference/Expr_inspect/#returns","text":"Expr Print the value that this expression evaluates to and pass on the value. The printing will happen when the expression evaluates, not when it is formed.","title":"Returns"},{"location":"reference/Expr_inspect/#examples","text":"pl $ select ( pl $ lit ( 1 : 5 ) $ inspect ( \"before dropping half the column it was:{}and not it is dropped\" ) $ head ( 2 ) ) #> before dropping half the column it was:shape: (5,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> 4 #> 5 #> ] #> and not it is dropped #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_interpolate/","text":"Interpolate Nulls Expr_interpolate ( method = \"linear\" ) Arguments method : string 'linear' or 'nearest', default \"linear\" Returns Expr Fill nulls with linear interpolation over missing values. Can also be used to regrid data to a new grid - see examples below. Examples pl $ select ( pl $ lit ( c ( 1 , NA , 4 , NA , 100 , NaN , 150 ) ) $ interpolate ( ) ) #> polars DataFrame: shape: (7, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 2.5 \u2502 #> \u2502 4.0 \u2502 #> \u2502 52.0 \u2502 #> \u2502 100.0 \u2502 #> \u2502 NaN \u2502 #> \u2502 150.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #x, y interpolation over a grid df_original_grid = pl $ DataFrame ( list ( grid_points = c ( 1 , 3 , 10 ) , values = c ( 2.0 , 6.0 , 20.0 ) ) ) df_new_grid = pl $ DataFrame ( list ( grid_points = ( 1 : 10 ) * 1.0 ) ) # Interpolate from this to the new grid df_new_grid $ join ( df_original_grid , on = \"grid_points\" , how = \"left\" ) $ with_columns ( pl $ col ( \"values\" ) $ interpolate ( ) ) #> polars DataFrame: shape: (10, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 grid_points \u2506 values \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 2.0 \u2502 #> \u2502 2.0 \u2506 4.0 \u2502 #> \u2502 3.0 \u2506 6.0 \u2502 #> \u2502 4.0 \u2506 8.0 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 7.0 \u2506 14.0 \u2502 #> \u2502 8.0 \u2506 16.0 \u2502 #> \u2502 9.0 \u2506 18.0 \u2502 #> \u2502 10.0 \u2506 20.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_interpolate"},{"location":"reference/Expr_interpolate/#interpolate-nulls","text":"Expr_interpolate ( method = \"linear\" )","title":"Interpolate Nulls"},{"location":"reference/Expr_interpolate/#arguments","text":"method : string 'linear' or 'nearest', default \"linear\"","title":"Arguments"},{"location":"reference/Expr_interpolate/#returns","text":"Expr Fill nulls with linear interpolation over missing values. Can also be used to regrid data to a new grid - see examples below.","title":"Returns"},{"location":"reference/Expr_interpolate/#examples","text":"pl $ select ( pl $ lit ( c ( 1 , NA , 4 , NA , 100 , NaN , 150 ) ) $ interpolate ( ) ) #> polars DataFrame: shape: (7, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 2.5 \u2502 #> \u2502 4.0 \u2502 #> \u2502 52.0 \u2502 #> \u2502 100.0 \u2502 #> \u2502 NaN \u2502 #> \u2502 150.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #x, y interpolation over a grid df_original_grid = pl $ DataFrame ( list ( grid_points = c ( 1 , 3 , 10 ) , values = c ( 2.0 , 6.0 , 20.0 ) ) ) df_new_grid = pl $ DataFrame ( list ( grid_points = ( 1 : 10 ) * 1.0 ) ) # Interpolate from this to the new grid df_new_grid $ join ( df_original_grid , on = \"grid_points\" , how = \"left\" ) $ with_columns ( pl $ col ( \"values\" ) $ interpolate ( ) ) #> polars DataFrame: shape: (10, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 grid_points \u2506 values \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 2.0 \u2502 #> \u2502 2.0 \u2506 4.0 \u2502 #> \u2502 3.0 \u2506 6.0 \u2502 #> \u2502 4.0 \u2506 8.0 \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 7.0 \u2506 14.0 \u2502 #> \u2502 8.0 \u2506 16.0 \u2502 #> \u2502 9.0 \u2506 18.0 \u2502 #> \u2502 10.0 \u2506 20.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_is_between/","text":"is in between Expr_is_between ( start , end , include_bounds = FALSE ) Arguments start : Lower bound as primitive or datetime end : Lower bound as primitive or datetime include_bounds : bool vector or scalar: FALSE: Exclude both start and end (default). TRUE: Include both start and end. c(FALSE, FALSE): Exclude start and exclude end. c(TRUE, TRUE): Include start and include end. c(FALSE, TRUE): Exclude start and include end. c(TRUE, FALSE): Include start and exclude end. Returns Expr Check if this expression is between start and end. Details alias the column to 'in_between' This function is equivalent to a combination of < <= >= and the &-and operator. Examples df = pl $ DataFrame ( list ( num = 1 : 5 ) ) df $ select ( pl $ col ( \"num\" ) $ is_between ( 2 , 4 ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 is_between \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 false \u2502 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2502 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"num\" ) $ is_between ( 2 , 4 , TRUE ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 is_between \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2502 true \u2502 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"num\" ) $ is_between ( 2 , 4 , c ( FALSE , TRUE ) ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 is_between \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 false \u2502 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #start end can be a vector/expr with same length as column df $ select ( pl $ col ( \"num\" ) $ is_between ( c ( 0 , 2 , 3 , 3 , 3 ) , 6 ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 is_between \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_is_between"},{"location":"reference/Expr_is_between/#is-in-between","text":"Expr_is_between ( start , end , include_bounds = FALSE )","title":"is in between"},{"location":"reference/Expr_is_between/#arguments","text":"start : Lower bound as primitive or datetime end : Lower bound as primitive or datetime include_bounds : bool vector or scalar: FALSE: Exclude both start and end (default). TRUE: Include both start and end. c(FALSE, FALSE): Exclude start and exclude end. c(TRUE, TRUE): Include start and include end. c(FALSE, TRUE): Exclude start and include end. c(TRUE, FALSE): Include start and exclude end.","title":"Arguments"},{"location":"reference/Expr_is_between/#returns","text":"Expr Check if this expression is between start and end.","title":"Returns"},{"location":"reference/Expr_is_between/#details","text":"alias the column to 'in_between' This function is equivalent to a combination of < <= >= and the &-and operator.","title":"Details"},{"location":"reference/Expr_is_between/#examples","text":"df = pl $ DataFrame ( list ( num = 1 : 5 ) ) df $ select ( pl $ col ( \"num\" ) $ is_between ( 2 , 4 ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 is_between \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 false \u2502 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2502 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"num\" ) $ is_between ( 2 , 4 , TRUE ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 is_between \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2502 true \u2502 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"num\" ) $ is_between ( 2 , 4 , c ( FALSE , TRUE ) ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 is_between \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 false \u2502 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #start end can be a vector/expr with same length as column df $ select ( pl $ col ( \"num\" ) $ is_between ( c ( 0 , 2 , 3 , 3 , 3 ) , 6 ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 is_between \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_is_duplicated/","text":"data Get mask of duplicated values. Format a method Expr_is_duplicated Returns Expr (boolean) Get mask of duplicated values. Details is_duplicated is the opposite of is_unique() Looking for R like duplicated() ?, use some_expr$is_first()$is_not() Examples v = c ( 1 , 1 , 2 , 2 , 3 , NA , NaN , Inf ) all.equal ( pl $ select ( pl $ lit ( v ) $ is_unique ( ) $ alias ( \"is_unique\" ) , pl $ lit ( v ) $ is_first ( ) $ alias ( \"is_first\" ) , pl $ lit ( v ) $ is_duplicated ( ) $ alias ( \"is_duplicated\" ) , pl $ lit ( v ) $ is_first ( ) $ is_not ( ) $ alias ( \"R_duplicated\" ) ) $ to_list ( ) , list ( is_unique = ! v %in% v [ duplicated ( v ) ] , is_first = ! duplicated ( v ) , is_duplicated = v %in% v [ duplicated ( v ) ] , R_duplicated = duplicated ( v ) ) ) #> [1] TRUE","title":"Expr_is_duplicated"},{"location":"reference/Expr_is_duplicated/#get-mask-of-duplicated-values","text":"","title":"Get mask of duplicated values."},{"location":"reference/Expr_is_duplicated/#format","text":"a method Expr_is_duplicated","title":"Format"},{"location":"reference/Expr_is_duplicated/#returns","text":"Expr (boolean) Get mask of duplicated values.","title":"Returns"},{"location":"reference/Expr_is_duplicated/#details","text":"is_duplicated is the opposite of is_unique() Looking for R like duplicated() ?, use some_expr$is_first()$is_not()","title":"Details"},{"location":"reference/Expr_is_duplicated/#examples","text":"v = c ( 1 , 1 , 2 , 2 , 3 , NA , NaN , Inf ) all.equal ( pl $ select ( pl $ lit ( v ) $ is_unique ( ) $ alias ( \"is_unique\" ) , pl $ lit ( v ) $ is_first ( ) $ alias ( \"is_first\" ) , pl $ lit ( v ) $ is_duplicated ( ) $ alias ( \"is_duplicated\" ) , pl $ lit ( v ) $ is_first ( ) $ is_not ( ) $ alias ( \"R_duplicated\" ) ) $ to_list ( ) , list ( is_unique = ! v %in% v [ duplicated ( v ) ] , is_first = ! duplicated ( v ) , is_duplicated = v %in% v [ duplicated ( v ) ] , R_duplicated = duplicated ( v ) ) ) #> [1] TRUE","title":"Examples"},{"location":"reference/Expr_is_finite/","text":"data Are elements finite Format a method Expr_is_finite Returns Expr Returns a boolean output indicating which values are finite. Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( alice = c ( 0 , NaN , NA , Inf , - Inf ) ) ) $ select ( pl $ col ( \"alice\" ) $ is_finite ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 alice \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2502 null \u2502 #> \u2502 false \u2502 #> \u2502 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_is_finite"},{"location":"reference/Expr_is_finite/#are-elements-finite","text":"","title":"Are elements finite"},{"location":"reference/Expr_is_finite/#format","text":"a method Expr_is_finite","title":"Format"},{"location":"reference/Expr_is_finite/#returns","text":"Expr Returns a boolean output indicating which values are finite.","title":"Returns"},{"location":"reference/Expr_is_finite/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_is_finite/#examples","text":"pl $ DataFrame ( list ( alice = c ( 0 , NaN , NA , Inf , - Inf ) ) ) $ select ( pl $ col ( \"alice\" ) $ is_finite ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 alice \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2502 null \u2502 #> \u2502 false \u2502 #> \u2502 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_is_first/","text":"data Get a mask of the first unique value. Format a method Expr_is_first Returns Expr (boolean) Get a mask of the first unique value. Examples v = c ( 1 , 1 , 2 , 2 , 3 , NA , NaN , Inf ) all.equal ( pl $ select ( pl $ lit ( v ) $ is_unique ( ) $ alias ( \"is_unique\" ) , pl $ lit ( v ) $ is_first ( ) $ alias ( \"is_first\" ) , pl $ lit ( v ) $ is_duplicated ( ) $ alias ( \"is_duplicated\" ) , pl $ lit ( v ) $ is_first ( ) $ is_not ( ) $ alias ( \"R_duplicated\" ) ) $ to_list ( ) , list ( is_unique = ! v %in% v [ duplicated ( v ) ] , is_first = ! duplicated ( v ) , is_duplicated = v %in% v [ duplicated ( v ) ] , R_duplicated = duplicated ( v ) ) ) #> [1] TRUE","title":"Expr_is_first"},{"location":"reference/Expr_is_first/#get-a-mask-of-the-first-unique-value","text":"","title":"Get a mask of the first unique value."},{"location":"reference/Expr_is_first/#format","text":"a method Expr_is_first","title":"Format"},{"location":"reference/Expr_is_first/#returns","text":"Expr (boolean) Get a mask of the first unique value.","title":"Returns"},{"location":"reference/Expr_is_first/#examples","text":"v = c ( 1 , 1 , 2 , 2 , 3 , NA , NaN , Inf ) all.equal ( pl $ select ( pl $ lit ( v ) $ is_unique ( ) $ alias ( \"is_unique\" ) , pl $ lit ( v ) $ is_first ( ) $ alias ( \"is_first\" ) , pl $ lit ( v ) $ is_duplicated ( ) $ alias ( \"is_duplicated\" ) , pl $ lit ( v ) $ is_first ( ) $ is_not ( ) $ alias ( \"R_duplicated\" ) ) $ to_list ( ) , list ( is_unique = ! v %in% v [ duplicated ( v ) ] , is_first = ! duplicated ( v ) , is_duplicated = v %in% v [ duplicated ( v ) ] , R_duplicated = duplicated ( v ) ) ) #> [1] TRUE","title":"Examples"},{"location":"reference/Expr_is_in/","text":"data is_in Format An object of class character of length 1. Expr_is_in ( other ) Arguments other : literal or Robj which can become a literal Returns Expr combine to boolean expresions with similar to %in% Examples #R Na_integer -> polars Null(Int32) is in polars Null(Int32) pl $ DataFrame ( list ( a = c ( 1 : 4 , NA_integer_ ) ) ) $ select ( pl $ col ( \"a\" ) $ is_in ( pl $ lit ( NA_real_ ) ) ) $ as_data_frame ( ) [[ 1L ] ] #> [1] FALSE FALSE FALSE FALSE TRUE","title":"Expr_is_in"},{"location":"reference/Expr_is_in/#is_in","text":"","title":"is_in"},{"location":"reference/Expr_is_in/#format","text":"An object of class character of length 1. Expr_is_in ( other )","title":"Format"},{"location":"reference/Expr_is_in/#arguments","text":"other : literal or Robj which can become a literal","title":"Arguments"},{"location":"reference/Expr_is_in/#returns","text":"Expr combine to boolean expresions with similar to %in%","title":"Returns"},{"location":"reference/Expr_is_in/#examples","text":"#R Na_integer -> polars Null(Int32) is in polars Null(Int32) pl $ DataFrame ( list ( a = c ( 1 : 4 , NA_integer_ ) ) ) $ select ( pl $ col ( \"a\" ) $ is_in ( pl $ lit ( NA_real_ ) ) ) $ as_data_frame ( ) [[ 1L ] ] #> [1] FALSE FALSE FALSE FALSE TRUE","title":"Examples"},{"location":"reference/Expr_is_infinite/","text":"data Are elements infinite Format a method Expr_is_infinite Returns Expr Returns a boolean output indicating which values are infinite. Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( alice = c ( 0 , NaN , NA , Inf , - Inf ) ) ) $ select ( pl $ col ( \"alice\" ) $ is_infinite ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 alice \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 false \u2502 #> \u2502 false \u2502 #> \u2502 null \u2502 #> \u2502 true \u2502 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_is_infinite"},{"location":"reference/Expr_is_infinite/#are-elements-infinite","text":"","title":"Are elements infinite"},{"location":"reference/Expr_is_infinite/#format","text":"a method Expr_is_infinite","title":"Format"},{"location":"reference/Expr_is_infinite/#returns","text":"Expr Returns a boolean output indicating which values are infinite.","title":"Returns"},{"location":"reference/Expr_is_infinite/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_is_infinite/#examples","text":"pl $ DataFrame ( list ( alice = c ( 0 , NaN , NA , Inf , - Inf ) ) ) $ select ( pl $ col ( \"alice\" ) $ is_infinite ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 alice \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 false \u2502 #> \u2502 false \u2502 #> \u2502 null \u2502 #> \u2502 true \u2502 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_is_nan/","text":"data Are elements NaN's Format a method Expr_is_nan Returns Expr Returns a boolean Series indicating which values are NaN. Details Floating point NaN's are a different flag from Null(polars) which is the same as NA_real_(R). See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( alice = c ( 0 , NaN , NA , Inf , - Inf ) ) ) $ select ( pl $ col ( \"alice\" ) $ is_nan ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 alice \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2502 null \u2502 #> \u2502 false \u2502 #> \u2502 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_is_nan"},{"location":"reference/Expr_is_nan/#are-elements-nans","text":"","title":"Are elements NaN's"},{"location":"reference/Expr_is_nan/#format","text":"a method Expr_is_nan","title":"Format"},{"location":"reference/Expr_is_nan/#returns","text":"Expr Returns a boolean Series indicating which values are NaN.","title":"Returns"},{"location":"reference/Expr_is_nan/#details","text":"Floating point NaN's are a different flag from Null(polars) which is the same as NA_real_(R). See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_is_nan/#examples","text":"pl $ DataFrame ( list ( alice = c ( 0 , NaN , NA , Inf , - Inf ) ) ) $ select ( pl $ col ( \"alice\" ) $ is_nan ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 alice \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2502 null \u2502 #> \u2502 false \u2502 #> \u2502 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_is_not/","text":"data Not ! Format An object of class character of length 1. Expr_is_not ( other ) ## S3 method for class 'Expr' ! x Arguments x : Expr other : literal or Robj which can become a literal Returns Exprs not method and operator Examples #two syntaxes same result pl $ lit ( TRUE ) $ is_not ( ) #> polars Expr: true.is_not() ! pl $ lit ( TRUE ) #> polars Expr: true.is_not()","title":"Expr_is_not"},{"location":"reference/Expr_is_not/#not","text":"","title":"Not !"},{"location":"reference/Expr_is_not/#format","text":"An object of class character of length 1. Expr_is_not ( other ) ## S3 method for class 'Expr' ! x","title":"Format"},{"location":"reference/Expr_is_not/#arguments","text":"x : Expr other : literal or Robj which can become a literal","title":"Arguments"},{"location":"reference/Expr_is_not/#returns","text":"Exprs not method and operator","title":"Returns"},{"location":"reference/Expr_is_not/#examples","text":"#two syntaxes same result pl $ lit ( TRUE ) $ is_not ( ) #> polars Expr: true.is_not() ! pl $ lit ( TRUE ) #> polars Expr: true.is_not()","title":"Examples"},{"location":"reference/Expr_is_not_nan/","text":"data Are elements not NaN's Format a method Expr_is_not_nan Returns Expr Returns a boolean Series indicating which values are not NaN. Details Floating point NaN's are a different flag from Null(polars) which is the same as NA_real_(R). See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( alice = c ( 0 , NaN , NA , Inf , - Inf ) ) ) $ select ( pl $ col ( \"alice\" ) $ is_not_nan ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 alice \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2502 true \u2502 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_is_not_nan"},{"location":"reference/Expr_is_not_nan/#are-elements-not-nans","text":"","title":"Are elements not NaN's"},{"location":"reference/Expr_is_not_nan/#format","text":"a method Expr_is_not_nan","title":"Format"},{"location":"reference/Expr_is_not_nan/#returns","text":"Expr Returns a boolean Series indicating which values are not NaN.","title":"Returns"},{"location":"reference/Expr_is_not_nan/#details","text":"Floating point NaN's are a different flag from Null(polars) which is the same as NA_real_(R). See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_is_not_nan/#examples","text":"pl $ DataFrame ( list ( alice = c ( 0 , NaN , NA , Inf , - Inf ) ) ) $ select ( pl $ col ( \"alice\" ) $ is_not_nan ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 alice \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2502 true \u2502 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_is_not_null/","text":"data is_not_null Format An object of class character of length 1. Expr_is_not_null Returns Expr Returns a boolean Series indicating which values are not null. Similar to R syntax !is.na(x) null polars about the same as R NA Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( x = c ( 1 , NA , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ is_not_null ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_is_not_null"},{"location":"reference/Expr_is_not_null/#is_not_null","text":"","title":"is_not_null"},{"location":"reference/Expr_is_not_null/#format","text":"An object of class character of length 1. Expr_is_not_null","title":"Format"},{"location":"reference/Expr_is_not_null/#returns","text":"Expr Returns a boolean Series indicating which values are not null. Similar to R syntax !is.na(x) null polars about the same as R NA","title":"Returns"},{"location":"reference/Expr_is_not_null/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_is_not_null/#examples","text":"pl $ DataFrame ( list ( x = c ( 1 , NA , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ is_not_null ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_is_null/","text":"data is_null Format An object of class character of length 1. Expr_is_null Returns Expr Returns a boolean Series indicating which values are null. Similar to R syntax is.na(x) null polars about the same as R NA Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( x = c ( 1 , NA , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ is_null ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_is_null"},{"location":"reference/Expr_is_null/#is_null","text":"","title":"is_null"},{"location":"reference/Expr_is_null/#format","text":"An object of class character of length 1. Expr_is_null","title":"Format"},{"location":"reference/Expr_is_null/#returns","text":"Expr Returns a boolean Series indicating which values are null. Similar to R syntax is.na(x) null polars about the same as R NA","title":"Returns"},{"location":"reference/Expr_is_null/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_is_null/#examples","text":"pl $ DataFrame ( list ( x = c ( 1 , NA , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ is_null ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_is_unique/","text":"data Get mask of unique values Format a method Expr_is_unique Returns Expr (boolean) Get mask of unique values Examples v = c ( 1 , 1 , 2 , 2 , 3 , NA , NaN , Inf ) all.equal ( pl $ select ( pl $ lit ( v ) $ is_unique ( ) $ alias ( \"is_unique\" ) , pl $ lit ( v ) $ is_first ( ) $ alias ( \"is_first\" ) , pl $ lit ( v ) $ is_duplicated ( ) $ alias ( \"is_duplicated\" ) , pl $ lit ( v ) $ is_first ( ) $ is_not ( ) $ alias ( \"R_duplicated\" ) ) $ to_list ( ) , list ( is_unique = ! v %in% v [ duplicated ( v ) ] , is_first = ! duplicated ( v ) , is_duplicated = v %in% v [ duplicated ( v ) ] , R_duplicated = duplicated ( v ) ) ) #> [1] TRUE","title":"Expr_is_unique"},{"location":"reference/Expr_is_unique/#get-mask-of-unique-values","text":"","title":"Get mask of unique values"},{"location":"reference/Expr_is_unique/#format","text":"a method Expr_is_unique","title":"Format"},{"location":"reference/Expr_is_unique/#returns","text":"Expr (boolean) Get mask of unique values","title":"Returns"},{"location":"reference/Expr_is_unique/#examples","text":"v = c ( 1 , 1 , 2 , 2 , 3 , NA , NaN , Inf ) all.equal ( pl $ select ( pl $ lit ( v ) $ is_unique ( ) $ alias ( \"is_unique\" ) , pl $ lit ( v ) $ is_first ( ) $ alias ( \"is_first\" ) , pl $ lit ( v ) $ is_duplicated ( ) $ alias ( \"is_duplicated\" ) , pl $ lit ( v ) $ is_first ( ) $ is_not ( ) $ alias ( \"R_duplicated\" ) ) $ to_list ( ) , list ( is_unique = ! v %in% v [ duplicated ( v ) ] , is_first = ! duplicated ( v ) , is_duplicated = v %in% v [ duplicated ( v ) ] , R_duplicated = duplicated ( v ) ) ) #> [1] TRUE","title":"Examples"},{"location":"reference/Expr_keep_name/","text":"data Keep the original root name of the expression. Format a method Expr_keep_name Returns Expr Keep the original root name of the expression. Examples pl $ DataFrame ( list ( alice = 1 : 3 ) ) $ select ( pl $ col ( \"alice\" ) $ alias ( \"bob\" ) $ keep_name ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 alice \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_keep_name"},{"location":"reference/Expr_keep_name/#keep-the-original-root-name-of-the-expression","text":"","title":"Keep the original root name of the expression."},{"location":"reference/Expr_keep_name/#format","text":"a method Expr_keep_name","title":"Format"},{"location":"reference/Expr_keep_name/#returns","text":"Expr Keep the original root name of the expression.","title":"Returns"},{"location":"reference/Expr_keep_name/#examples","text":"pl $ DataFrame ( list ( alice = 1 : 3 ) ) $ select ( pl $ col ( \"alice\" ) $ alias ( \"bob\" ) $ keep_name ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 alice \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_kurtosis/","text":"Kurtosis Expr_kurtosis ( fisher = TRUE , bias = TRUE ) Arguments fisher : bool se details bias : bool, If FALSE, then the calculations are corrected for statistical bias. Returns Expr Compute the kurtosis (Fisher or Pearson) of a dataset. Details Kurtosis is the fourth central moment divided by the square of the variance. If Fisher's definition is used, then 3.0 is subtracted from the result to give 0.0 for a normal distribution. If bias is False then the kurtosis is calculated using k statistics to eliminate bias coming from biased moment estimators See scipy.stats for more information ' See scipy.stats for more information. Examples df = pl $ DataFrame ( list ( a = c ( 1 : 3 , 2 : 1 ) ) ) df $ select ( pl $ col ( \"a\" ) $ kurtosis ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -1.153061 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_kurtosis"},{"location":"reference/Expr_kurtosis/#kurtosis","text":"Expr_kurtosis ( fisher = TRUE , bias = TRUE )","title":"Kurtosis"},{"location":"reference/Expr_kurtosis/#arguments","text":"fisher : bool se details bias : bool, If FALSE, then the calculations are corrected for statistical bias.","title":"Arguments"},{"location":"reference/Expr_kurtosis/#returns","text":"Expr Compute the kurtosis (Fisher or Pearson) of a dataset.","title":"Returns"},{"location":"reference/Expr_kurtosis/#details","text":"Kurtosis is the fourth central moment divided by the square of the variance. If Fisher's definition is used, then 3.0 is subtracted from the result to give 0.0 for a normal distribution. If bias is False then the kurtosis is calculated using k statistics to eliminate bias coming from biased moment estimators See scipy.stats for more information","title":"Details"},{"location":"reference/Expr_kurtosis/#see-scipystats-for-more-information","text":"","title":"' See scipy.stats for more information."},{"location":"reference/Expr_kurtosis/#examples","text":"df = pl $ DataFrame ( list ( a = c ( 1 : 3 , 2 : 1 ) ) ) df $ select ( pl $ col ( \"a\" ) $ kurtosis ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -1.153061 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_last/","text":"data Last Format An object of class character of length 1. Expr_last Returns Expr Get the lastvalue. Similar to R syntax tail(x,1) Examples pl $ DataFrame ( list ( x = c ( 1 , 2 , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ last ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_last"},{"location":"reference/Expr_last/#last","text":"","title":"Last"},{"location":"reference/Expr_last/#format","text":"An object of class character of length 1. Expr_last","title":"Format"},{"location":"reference/Expr_last/#returns","text":"Expr Get the lastvalue. Similar to R syntax tail(x,1)","title":"Returns"},{"location":"reference/Expr_last/#examples","text":"pl $ DataFrame ( list ( x = c ( 1 , 2 , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ last ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_limit/","text":"Limit Expr_limit ( n = 10 ) Arguments n : numeric number of elements to select from head Returns Expr Alias for Head Get the head n elements. Similar to R head(x) Examples #get 3 first elements pl $ DataFrame ( list ( x = 1 : 11 ) ) $ select ( pl $ col ( \"x\" ) $ limit ( 3 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_limit"},{"location":"reference/Expr_limit/#limit","text":"Expr_limit ( n = 10 )","title":"Limit"},{"location":"reference/Expr_limit/#arguments","text":"n : numeric number of elements to select from head","title":"Arguments"},{"location":"reference/Expr_limit/#returns","text":"Expr Alias for Head Get the head n elements. Similar to R head(x)","title":"Returns"},{"location":"reference/Expr_limit/#examples","text":"#get 3 first elements pl $ DataFrame ( list ( x = 1 : 11 ) ) $ select ( pl $ col ( \"x\" ) $ limit ( 3 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_list/","text":"data Wrap column in list Format a method Expr_list Returns Expr Aggregate to list. Details use to_struct to wrap a DataFrame Examples pl $ select ( pl $ lit ( 1 : 4 ) $ list ( ) , pl $ lit ( c ( \"a\" ) ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2506 literal \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 list[i32] \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [1, 2, ... 4] \u2506 a \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_list"},{"location":"reference/Expr_list/#wrap-column-in-list","text":"","title":"Wrap column in list"},{"location":"reference/Expr_list/#format","text":"a method Expr_list","title":"Format"},{"location":"reference/Expr_list/#returns","text":"Expr Aggregate to list.","title":"Returns"},{"location":"reference/Expr_list/#details","text":"use to_struct to wrap a DataFrame","title":"Details"},{"location":"reference/Expr_list/#examples","text":"pl $ select ( pl $ lit ( 1 : 4 ) $ list ( ) , pl $ lit ( c ( \"a\" ) ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2506 literal \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 list[i32] \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [1, 2, ... 4] \u2506 a \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_lit_to_df/","text":"Literal to DataFrame Expr_lit_to_df () Returns Series collect an expression based on literals into a DataFrame Examples ( pl $ Series ( list ( 1 : 1 , 1 : 2 , 1 : 3 , 1 : 4 ) ) $ print ( ) $ to_lit ( ) $ arr $ lengths ( ) $ sum ( ) $ cast ( pl $ dtypes $ Int8 ) $ lit_to_df ( ) ) #> shape: (4,) #> Series: '' [list[i32]] #> [ #> [1] #> [1, 2] #> [1, 2, 3] #> [1, 2, ... 4] #> ] #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 i8 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 10 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_lit_to_df"},{"location":"reference/Expr_lit_to_df/#literal-to-dataframe","text":"Expr_lit_to_df ()","title":"Literal to DataFrame"},{"location":"reference/Expr_lit_to_df/#returns","text":"Series collect an expression based on literals into a DataFrame","title":"Returns"},{"location":"reference/Expr_lit_to_df/#examples","text":"( pl $ Series ( list ( 1 : 1 , 1 : 2 , 1 : 3 , 1 : 4 ) ) $ print ( ) $ to_lit ( ) $ arr $ lengths ( ) $ sum ( ) $ cast ( pl $ dtypes $ Int8 ) $ lit_to_df ( ) ) #> shape: (4,) #> Series: '' [list[i32]] #> [ #> [1] #> [1, 2] #> [1, 2, 3] #> [1, 2, ... 4] #> ] #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 i8 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 10 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_lit_to_s/","text":"Literal to Series Expr_lit_to_s () Returns Series collect an expression based on literals into a Series Examples ( pl $ Series ( list ( 1 : 1 , 1 : 2 , 1 : 3 , 1 : 4 ) ) $ print ( ) $ to_lit ( ) $ arr $ lengths ( ) $ sum ( ) $ cast ( pl $ dtypes $ Int8 ) $ lit_to_s ( ) ) #> shape: (4,) #> Series: '' [list[i32]] #> [ #> [1] #> [1, 2] #> [1, 2, 3] #> [1, 2, ... 4] #> ] #> polars Series: shape: (1,) #> Series: '' [i8] #> [ #> 10 #> ]","title":"Expr_lit_to_s"},{"location":"reference/Expr_lit_to_s/#literal-to-series","text":"Expr_lit_to_s ()","title":"Literal to Series"},{"location":"reference/Expr_lit_to_s/#returns","text":"Series collect an expression based on literals into a Series","title":"Returns"},{"location":"reference/Expr_lit_to_s/#examples","text":"( pl $ Series ( list ( 1 : 1 , 1 : 2 , 1 : 3 , 1 : 4 ) ) $ print ( ) $ to_lit ( ) $ arr $ lengths ( ) $ sum ( ) $ cast ( pl $ dtypes $ Int8 ) $ lit_to_s ( ) ) #> shape: (4,) #> Series: '' [list[i32]] #> [ #> [1] #> [1, 2] #> [1, 2, 3] #> [1, 2, ... 4] #> ] #> polars Series: shape: (1,) #> Series: '' [i8] #> [ #> 10 #> ]","title":"Examples"},{"location":"reference/Expr_log/","text":"Natural Log Expr_log ( base = base :: exp ( 1 )) Arguments base : numeric base value for log, default base::exp(1) Returns Expr Compute the base x logarithm of the input array, element-wise. Examples pl $ DataFrame ( list ( a = exp ( 1 ) ^ ( - 1 : 3 ) ) ) $ select ( pl $ col ( \"a\" ) $ log ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -1.0 \u2502 #> \u2502 0.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 3.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_log"},{"location":"reference/Expr_log/#natural-log","text":"Expr_log ( base = base :: exp ( 1 ))","title":"Natural Log"},{"location":"reference/Expr_log/#arguments","text":"base : numeric base value for log, default base::exp(1)","title":"Arguments"},{"location":"reference/Expr_log/#returns","text":"Expr Compute the base x logarithm of the input array, element-wise.","title":"Returns"},{"location":"reference/Expr_log/#examples","text":"pl $ DataFrame ( list ( a = exp ( 1 ) ^ ( - 1 : 3 ) ) ) $ select ( pl $ col ( \"a\" ) $ log ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -1.0 \u2502 #> \u2502 0.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 3.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_log10/","text":"data 10-base log Format a method Expr_log10 Returns Expr Compute the base 10 logarithm of the input array, element-wise. Examples pl $ DataFrame ( list ( a = 10 ^ ( - 1 : 3 ) ) ) $ select ( pl $ col ( \"a\" ) $ log10 ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -1.0 \u2502 #> \u2502 0.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 3.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_log10"},{"location":"reference/Expr_log10/#10-base-log","text":"","title":"10-base log"},{"location":"reference/Expr_log10/#format","text":"a method Expr_log10","title":"Format"},{"location":"reference/Expr_log10/#returns","text":"Expr Compute the base 10 logarithm of the input array, element-wise.","title":"Returns"},{"location":"reference/Expr_log10/#examples","text":"pl $ DataFrame ( list ( a = 10 ^ ( - 1 : 3 ) ) ) $ select ( pl $ col ( \"a\" ) $ log10 ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -1.0 \u2502 #> \u2502 0.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 3.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_lt/","text":"Less Than < Expr_lt ( other ) ## S3 method for class 'Expr' e1 < e2 Arguments other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression Returns Exprs lt method and operator Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples #' #three syntaxes same result pl $ lit ( 5 ) < 10 #> polars Expr: [(5f64) < (10f64)] pl $ lit ( 5 ) < pl $ lit ( 10 ) #> polars Expr: [(5f64) < (10f64)] pl $ lit ( 5 ) $ lt ( pl $ lit ( 10 ) ) #> polars Expr: [(5f64) < (10f64)]","title":"Expr_lt"},{"location":"reference/Expr_lt/#less-than","text":"Expr_lt ( other ) ## S3 method for class 'Expr' e1 < e2","title":"Less Than &lt;"},{"location":"reference/Expr_lt/#arguments","text":"other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression","title":"Arguments"},{"location":"reference/Expr_lt/#returns","text":"Exprs lt method and operator","title":"Returns"},{"location":"reference/Expr_lt/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_lt/#examples","text":"#' #three syntaxes same result pl $ lit ( 5 ) < 10 #> polars Expr: [(5f64) < (10f64)] pl $ lit ( 5 ) < pl $ lit ( 10 ) #> polars Expr: [(5f64) < (10f64)] pl $ lit ( 5 ) $ lt ( pl $ lit ( 10 ) ) #> polars Expr: [(5f64) < (10f64)]","title":"Examples"},{"location":"reference/Expr_lt_eq/","text":"Less Than Or Equal <= Expr_lt_eq ( other ) ## S3 method for class 'Expr' e1 <= e2 Arguments other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression Returns Exprs lt_eq method and operator Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples #' #three syntaxes same result pl $ lit ( 2 ) <= 2 #> polars Expr: [(2f64) <= (2f64)] pl $ lit ( 2 ) <= pl $ lit ( 2 ) #> polars Expr: [(2f64) <= (2f64)] pl $ lit ( 2 ) $ lt_eq ( pl $ lit ( 2 ) ) #> polars Expr: [(2f64) <= (2f64)]","title":"Expr_lt_eq"},{"location":"reference/Expr_lt_eq/#less-than-or-equal","text":"Expr_lt_eq ( other ) ## S3 method for class 'Expr' e1 <= e2","title":"Less Than Or Equal &lt;="},{"location":"reference/Expr_lt_eq/#arguments","text":"other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression","title":"Arguments"},{"location":"reference/Expr_lt_eq/#returns","text":"Exprs lt_eq method and operator","title":"Returns"},{"location":"reference/Expr_lt_eq/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_lt_eq/#examples","text":"#' #three syntaxes same result pl $ lit ( 2 ) <= 2 #> polars Expr: [(2f64) <= (2f64)] pl $ lit ( 2 ) <= pl $ lit ( 2 ) #> polars Expr: [(2f64) <= (2f64)] pl $ lit ( 2 ) $ lt_eq ( pl $ lit ( 2 ) ) #> polars Expr: [(2f64) <= (2f64)]","title":"Examples"},{"location":"reference/Expr_map/","text":"Expr_map Expr_map ( f , output_type = NULL , agg_list = FALSE ) Arguments f : a function mapping a series output_type : NULL or one of pl$dtypes$..., the output datatype, NULL is the same as input. agg_list : Aggregate list. Map from vector to group in groupby context. Likely not so useful. Returns Expr Expr_map Details user function return should be a series or any Robj convertable into a Series. In PyPolars likely return must be Series. User functions do fully support browser() , helpful to investigate. Examples pl $ DataFrame ( iris ) $ select ( pl $ col ( \"Sepal.Length\" ) $ map ( \\ ( x ) { paste ( \"cheese\" , as.character ( x $ to_r_vector ( ) ) ) } , pl $ dtypes $ Utf8 ) ) #> polars DataFrame: shape: (150, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 cheese 5.1 \u2502 #> \u2502 cheese 4.9 \u2502 #> \u2502 cheese 4.7 \u2502 #> \u2502 cheese 4.6 \u2502 #> \u2502 ... \u2502 #> \u2502 cheese 6.3 \u2502 #> \u2502 cheese 6.5 \u2502 #> \u2502 cheese 6.2 \u2502 #> \u2502 cheese 5.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_map"},{"location":"reference/Expr_map/#expr_map","text":"Expr_map ( f , output_type = NULL , agg_list = FALSE )","title":"Expr_map"},{"location":"reference/Expr_map/#arguments","text":"f : a function mapping a series output_type : NULL or one of pl$dtypes$..., the output datatype, NULL is the same as input. agg_list : Aggregate list. Map from vector to group in groupby context. Likely not so useful.","title":"Arguments"},{"location":"reference/Expr_map/#returns","text":"Expr Expr_map","title":"Returns"},{"location":"reference/Expr_map/#details","text":"user function return should be a series or any Robj convertable into a Series. In PyPolars likely return must be Series. User functions do fully support browser() , helpful to investigate.","title":"Details"},{"location":"reference/Expr_map/#examples","text":"pl $ DataFrame ( iris ) $ select ( pl $ col ( \"Sepal.Length\" ) $ map ( \\ ( x ) { paste ( \"cheese\" , as.character ( x $ to_r_vector ( ) ) ) } , pl $ dtypes $ Utf8 ) ) #> polars DataFrame: shape: (150, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 cheese 5.1 \u2502 #> \u2502 cheese 4.9 \u2502 #> \u2502 cheese 4.7 \u2502 #> \u2502 cheese 4.6 \u2502 #> \u2502 ... \u2502 #> \u2502 cheese 6.3 \u2502 #> \u2502 cheese 6.5 \u2502 #> \u2502 cheese 6.2 \u2502 #> \u2502 cheese 5.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_map_alias/","text":"Map alias of expression with an R function Expr_map_alias ( fun ) Arguments fun : an R function which takes a string as input and return a string Returns Expr Rename the output of an expression by mapping a function over the root name. Examples pl $ DataFrame ( list ( alice = 1 : 3 ) ) $ select ( pl $ col ( \"alice\" ) $ alias ( \"joe_is_not_root\" ) $ map_alias ( \\ ( x ) paste0 ( x , \"_and_bob\" ) ) ) #> map_alias function is experimentally without some thread-safeguards, please report any crashes #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 alice_and_bob \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_map_alias"},{"location":"reference/Expr_map_alias/#map-alias-of-expression-with-an-r-function","text":"Expr_map_alias ( fun )","title":"Map alias of expression with an R function"},{"location":"reference/Expr_map_alias/#arguments","text":"fun : an R function which takes a string as input and return a string","title":"Arguments"},{"location":"reference/Expr_map_alias/#returns","text":"Expr Rename the output of an expression by mapping a function over the root name.","title":"Returns"},{"location":"reference/Expr_map_alias/#examples","text":"pl $ DataFrame ( list ( alice = 1 : 3 ) ) $ select ( pl $ col ( \"alice\" ) $ alias ( \"joe_is_not_root\" ) $ map_alias ( \\ ( x ) paste0 ( x , \"_and_bob\" ) ) ) #> map_alias function is experimentally without some thread-safeguards, please report any crashes #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 alice_and_bob \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_max/","text":"data max Format An object of class character of length 1. Expr_max Returns Expr Get maximum value. Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( x = c ( 1 , NA , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ max ( ) == 3 ) #is true #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_max"},{"location":"reference/Expr_max/#max","text":"","title":"max"},{"location":"reference/Expr_max/#format","text":"An object of class character of length 1. Expr_max","title":"Format"},{"location":"reference/Expr_max/#returns","text":"Expr Get maximum value.","title":"Returns"},{"location":"reference/Expr_max/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_max/#examples","text":"pl $ DataFrame ( list ( x = c ( 1 , NA , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ max ( ) == 3 ) #is true #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_mean/","text":"data mean Format An object of class character of length 1. Expr_mean Returns Expr Get mean value. Examples pl $ DataFrame ( list ( x = c ( 1 , NA , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ mean ( ) == 2 ) #is true #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_mean"},{"location":"reference/Expr_mean/#mean","text":"","title":"mean"},{"location":"reference/Expr_mean/#format","text":"An object of class character of length 1. Expr_mean","title":"Format"},{"location":"reference/Expr_mean/#returns","text":"Expr Get mean value.","title":"Returns"},{"location":"reference/Expr_mean/#examples","text":"pl $ DataFrame ( list ( x = c ( 1 , NA , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ mean ( ) == 2 ) #is true #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_median/","text":"data median Format An object of class character of length 1. Expr_median Returns Expr Get median value. Examples pl $ DataFrame ( list ( x = c ( 1 , NA , 2 ) ) ) $ select ( pl $ col ( \"x\" ) $ median ( ) == 1.5 ) #is true #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_median"},{"location":"reference/Expr_median/#median","text":"","title":"median"},{"location":"reference/Expr_median/#format","text":"An object of class character of length 1. Expr_median","title":"Format"},{"location":"reference/Expr_median/#returns","text":"Expr Get median value.","title":"Returns"},{"location":"reference/Expr_median/#examples","text":"pl $ DataFrame ( list ( x = c ( 1 , NA , 2 ) ) ) $ select ( pl $ col ( \"x\" ) $ median ( ) == 1.5 ) #is true #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_meta/","text":"meta: related methods Expr_meta () Returns Expr Create an object namespace of all meta related methods. See the individual method pages for full details Examples #missing","title":"Expr_meta"},{"location":"reference/Expr_meta/#meta-related-methods","text":"Expr_meta ()","title":"meta: related methods"},{"location":"reference/Expr_meta/#returns","text":"Expr Create an object namespace of all meta related methods. See the individual method pages for full details","title":"Returns"},{"location":"reference/Expr_meta/#examples","text":"#missing","title":"Examples"},{"location":"reference/Expr_min/","text":"data min Format An object of class character of length 1. Expr_min Returns Expr Get minimum value. Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( x = c ( 1 , NA , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ min ( ) == 1 ) #is true #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_min"},{"location":"reference/Expr_min/#min","text":"","title":"min"},{"location":"reference/Expr_min/#format","text":"An object of class character of length 1. Expr_min","title":"Format"},{"location":"reference/Expr_min/#returns","text":"Expr Get minimum value.","title":"Returns"},{"location":"reference/Expr_min/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_min/#examples","text":"pl $ DataFrame ( list ( x = c ( 1 , NA , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ min ( ) == 1 ) #is true #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_mode/","text":"data Mode Format a method Expr_mode Returns Expr Compute the most occurring value(s). Can return multiple Values. Examples df = pl $ DataFrame ( list ( a = 1 : 6 ,b = c ( 1L , 1L , 3L , 3L , 5L , 6L ) , c = c ( 1L , 1L , 2L , 2L , 3L , 3L ) ) ) df $ select ( pl $ col ( \"a\" ) $ mode ( ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 5 \u2502 #> \u2502 2 \u2502 #> \u2502 4 \u2502 #> \u2502 1 \u2502 #> \u2502 6 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"b\" ) $ mode ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 b \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"c\" ) $ mode ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 c \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 3 \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_mode"},{"location":"reference/Expr_mode/#mode","text":"","title":"Mode"},{"location":"reference/Expr_mode/#format","text":"a method Expr_mode","title":"Format"},{"location":"reference/Expr_mode/#returns","text":"Expr Compute the most occurring value(s). Can return multiple Values.","title":"Returns"},{"location":"reference/Expr_mode/#examples","text":"df = pl $ DataFrame ( list ( a = 1 : 6 ,b = c ( 1L , 1L , 3L , 3L , 5L , 6L ) , c = c ( 1L , 1L , 2L , 2L , 3L , 3L ) ) ) df $ select ( pl $ col ( \"a\" ) $ mode ( ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 5 \u2502 #> \u2502 2 \u2502 #> \u2502 4 \u2502 #> \u2502 1 \u2502 #> \u2502 6 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"b\" ) $ mode ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 b \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"c\" ) $ mode ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 c \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 3 \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_mul/","text":"Mul * Expr_mul ( other ) ## S3 method for class 'Expr' e1 * e2 Arguments other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression Returns Exprs Multiplication Examples #three syntaxes same result pl $ lit ( 5 ) * 10 #> polars Expr: [(5f64) * (10f64)] pl $ lit ( 5 ) * pl $ lit ( 10 ) #> polars Expr: [(5f64) * (10f64)] pl $ lit ( 5 ) $ mul ( pl $ lit ( 10 ) ) #> polars Expr: [(5f64) * (10f64)]","title":"Expr_mul"},{"location":"reference/Expr_mul/#mul","text":"Expr_mul ( other ) ## S3 method for class 'Expr' e1 * e2","title":"Mul *"},{"location":"reference/Expr_mul/#arguments","text":"other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression","title":"Arguments"},{"location":"reference/Expr_mul/#returns","text":"Exprs Multiplication","title":"Returns"},{"location":"reference/Expr_mul/#examples","text":"#three syntaxes same result pl $ lit ( 5 ) * 10 #> polars Expr: [(5f64) * (10f64)] pl $ lit ( 5 ) * pl $ lit ( 10 ) #> polars Expr: [(5f64) * (10f64)] pl $ lit ( 5 ) $ mul ( pl $ lit ( 10 ) ) #> polars Expr: [(5f64) * (10f64)]","title":"Examples"},{"location":"reference/Expr_n_unique/","text":"data Count number of unique values Format An object of class character of length 1. Expr_n_unique Returns Expr Count number of unique values. Similar to R length(unique(x)) Examples pl $ DataFrame ( iris ) $ select ( pl $ col ( \"Species\" ) $ n_unique ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Species \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_n_unique"},{"location":"reference/Expr_n_unique/#count-number-of-unique-values","text":"","title":"Count number of unique values"},{"location":"reference/Expr_n_unique/#format","text":"An object of class character of length 1. Expr_n_unique","title":"Format"},{"location":"reference/Expr_n_unique/#returns","text":"Expr Count number of unique values. Similar to R length(unique(x))","title":"Returns"},{"location":"reference/Expr_n_unique/#examples","text":"pl $ DataFrame ( iris ) $ select ( pl $ col ( \"Species\" ) $ n_unique ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Species \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_nan_max/","text":"data max Format An object of class character of length 1. Expr_nan_max Returns Expr Get maximum value, but propagate/poison encountered NaN values. Get maximum value. Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( x = c ( 1 , NaN , Inf , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ nan_max ( ) $ is_nan ( ) ) #is true #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_nan_max"},{"location":"reference/Expr_nan_max/#max","text":"","title":"max"},{"location":"reference/Expr_nan_max/#format","text":"An object of class character of length 1. Expr_nan_max","title":"Format"},{"location":"reference/Expr_nan_max/#returns","text":"Expr Get maximum value, but propagate/poison encountered NaN values. Get maximum value.","title":"Returns"},{"location":"reference/Expr_nan_max/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_nan_max/#examples","text":"pl $ DataFrame ( list ( x = c ( 1 , NaN , Inf , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ nan_max ( ) $ is_nan ( ) ) #is true #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_nan_min/","text":"data min propagate NaN Format An object of class character of length 1. Expr_nan_min Returns Expr Get minimum value, but propagate/poison encountered NaN values. Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( x = c ( 1 , NaN , - Inf , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ nan_min ( ) $ is_nan ( ) ) #is true #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_nan_min"},{"location":"reference/Expr_nan_min/#min-propagate-nan","text":"","title":"min propagate NaN"},{"location":"reference/Expr_nan_min/#format","text":"An object of class character of length 1. Expr_nan_min","title":"Format"},{"location":"reference/Expr_nan_min/#returns","text":"Expr Get minimum value, but propagate/poison encountered NaN values.","title":"Returns"},{"location":"reference/Expr_nan_min/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_nan_min/#examples","text":"pl $ DataFrame ( list ( x = c ( 1 , NaN , - Inf , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ nan_min ( ) $ is_nan ( ) ) #is true #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_neq/","text":"Not Equal != Expr_neq ( other ) ## S3 method for class 'Expr' e1 != e2 Arguments other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression Returns Exprs neq method and operator Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples #' #three syntaxes same result pl $ lit ( 1 ) != 2 #> polars Expr: [(1f64) != (2f64)] pl $ lit ( 1 ) != pl $ lit ( 2 ) #> polars Expr: [(1f64) != (2f64)] pl $ lit ( 1 ) $ neq ( pl $ lit ( 2 ) ) #> polars Expr: [(1f64) != (2f64)]","title":"Expr_neq"},{"location":"reference/Expr_neq/#not-equal","text":"Expr_neq ( other ) ## S3 method for class 'Expr' e1 != e2","title":"Not Equal !="},{"location":"reference/Expr_neq/#arguments","text":"other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression","title":"Arguments"},{"location":"reference/Expr_neq/#returns","text":"Exprs neq method and operator","title":"Returns"},{"location":"reference/Expr_neq/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_neq/#examples","text":"#' #three syntaxes same result pl $ lit ( 1 ) != 2 #> polars Expr: [(1f64) != (2f64)] pl $ lit ( 1 ) != pl $ lit ( 2 ) #> polars Expr: [(1f64) != (2f64)] pl $ lit ( 1 ) $ neq ( pl $ lit ( 2 ) ) #> polars Expr: [(1f64) != (2f64)]","title":"Examples"},{"location":"reference/Expr_null_count/","text":"data Count Nulls Format An object of class character of length 1. Expr_null_count Returns Expr Count Nulls Examples pl $ select ( pl $ lit ( c ( NA , \"a\" , NA , \"b\" ) ) $ null_count ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_null_count"},{"location":"reference/Expr_null_count/#count-nulls","text":"","title":"Count Nulls"},{"location":"reference/Expr_null_count/#format","text":"An object of class character of length 1. Expr_null_count","title":"Format"},{"location":"reference/Expr_null_count/#returns","text":"Expr Count Nulls","title":"Returns"},{"location":"reference/Expr_null_count/#examples","text":"pl $ select ( pl $ lit ( c ( NA , \"a\" , NA , \"b\" ) ) $ null_count ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_or/","text":"data Or Format An object of class character of length 1. Expr_or ( other ) Arguments other : Expr or into Expr Returns Expr combine to boolean expresions with OR Examples pl $ lit ( TRUE ) | FALSE #> polars Expr: [(true) | (false)] pl $ lit ( TRUE ) $ or ( pl $ lit ( TRUE ) ) #> polars Expr: [(true) | (true)]","title":"Expr_or"},{"location":"reference/Expr_or/#or","text":"","title":"Or"},{"location":"reference/Expr_or/#format","text":"An object of class character of length 1. Expr_or ( other )","title":"Format"},{"location":"reference/Expr_or/#arguments","text":"other : Expr or into Expr","title":"Arguments"},{"location":"reference/Expr_or/#returns","text":"Expr combine to boolean expresions with OR","title":"Returns"},{"location":"reference/Expr_or/#examples","text":"pl $ lit ( TRUE ) | FALSE #> polars Expr: [(true) | (false)] pl $ lit ( TRUE ) $ or ( pl $ lit ( TRUE ) ) #> polars Expr: [(true) | (true)]","title":"Examples"},{"location":"reference/Expr_over/","text":"over Expr_over ( ... ) Arguments ... : of strings or columns to group by Returns Expr Apply window function over a subgroup. This is similar to a groupby + aggregation + self join. Or similar to window functions in Postgres<https://www.postgresql.org/docs/current/tutorial-window.html> _. Examples pl $ DataFrame ( val = 1 : 5 , a = c ( \"+\" , \"+\" , \"-\" , \"-\" , \"+\" ) , b = c ( \"+\" , \"-\" , \"+\" , \"-\" , \"+\" ) ) $ select ( pl $ col ( \"val\" ) $ count ( ) $ over ( \"a\" , \"b\" ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 val \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2 \u2502 #> \u2502 1 \u2502 #> \u2502 1 \u2502 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_over"},{"location":"reference/Expr_over/#over","text":"Expr_over ( ... )","title":"over"},{"location":"reference/Expr_over/#arguments","text":"... : of strings or columns to group by","title":"Arguments"},{"location":"reference/Expr_over/#returns","text":"Expr Apply window function over a subgroup. This is similar to a groupby + aggregation + self join. Or similar to window functions in Postgres<https://www.postgresql.org/docs/current/tutorial-window.html> _.","title":"Returns"},{"location":"reference/Expr_over/#examples","text":"pl $ DataFrame ( val = 1 : 5 , a = c ( \"+\" , \"+\" , \"-\" , \"-\" , \"+\" ) , b = c ( \"+\" , \"-\" , \"+\" , \"-\" , \"+\" ) ) $ select ( pl $ col ( \"val\" ) $ count ( ) $ over ( \"a\" , \"b\" ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 val \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2 \u2502 #> \u2502 1 \u2502 #> \u2502 1 \u2502 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_pct_change/","text":"Pct change Expr_pct_change ( n = 1 ) Arguments n : periods to shift for forming percent change. Returns Expr Computes percentage change between values. Percentage change (as fraction) between current element and most-recent non-null element at least n period(s) before the current element. Computes the change from the previous row by default. Examples df = pl $ DataFrame ( list ( a = c ( 10L , 11L , 12L , NA_integer_ , 12L ) ) ) df $ with_column ( pl $ col ( \"a\" ) $ pct_change ( ) $ alias ( \"pct_change\" ) ) #> polars DataFrame: shape: (5, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 pct_change \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 10 \u2506 null \u2502 #> \u2502 11 \u2506 0.1 \u2502 #> \u2502 12 \u2506 0.090909 \u2502 #> \u2502 null \u2506 0.0 \u2502 #> \u2502 12 \u2506 0.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_pct_change"},{"location":"reference/Expr_pct_change/#pct-change","text":"Expr_pct_change ( n = 1 )","title":"Pct change"},{"location":"reference/Expr_pct_change/#arguments","text":"n : periods to shift for forming percent change.","title":"Arguments"},{"location":"reference/Expr_pct_change/#returns","text":"Expr Computes percentage change between values. Percentage change (as fraction) between current element and most-recent non-null element at least n period(s) before the current element. Computes the change from the previous row by default.","title":"Returns"},{"location":"reference/Expr_pct_change/#examples","text":"df = pl $ DataFrame ( list ( a = c ( 10L , 11L , 12L , NA_integer_ , 12L ) ) ) df $ with_column ( pl $ col ( \"a\" ) $ pct_change ( ) $ alias ( \"pct_change\" ) ) #> polars DataFrame: shape: (5, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 pct_change \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 10 \u2506 null \u2502 #> \u2502 11 \u2506 0.1 \u2502 #> \u2502 12 \u2506 0.090909 \u2502 #> \u2502 null \u2506 0.0 \u2502 #> \u2502 12 \u2506 0.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_pow/","text":"Exponentiation ^ or ** Expr_pow ( exponent ) Arguments exponent : exponent Returns Expr Raise expression to the power of exponent. Examples pl $ DataFrame ( a = - 1 : 3 ) $ select ( pl $ lit ( 2 ) $ pow ( pl $ col ( \"a\" ) ) ) $ get_column ( \"literal\" ) $ to_r ( ) == 2 ^ ( - 1 : 3 ) #> [1] TRUE TRUE TRUE TRUE TRUE pl $ DataFrame ( a = - 1 : 3 ) $ select ( pl $ lit ( 2 ) ^ ( pl $ col ( \"a\" ) ) ) $ get_column ( \"literal\" ) $ to_r ( ) == 2 ^ ( - 1 : 3 ) #> [1] TRUE TRUE TRUE TRUE TRUE","title":"Expr_pow"},{"location":"reference/Expr_pow/#exponentiation-or","text":"Expr_pow ( exponent )","title":"Exponentiation ^ or **"},{"location":"reference/Expr_pow/#arguments","text":"exponent : exponent","title":"Arguments"},{"location":"reference/Expr_pow/#returns","text":"Expr Raise expression to the power of exponent.","title":"Returns"},{"location":"reference/Expr_pow/#examples","text":"pl $ DataFrame ( a = - 1 : 3 ) $ select ( pl $ lit ( 2 ) $ pow ( pl $ col ( \"a\" ) ) ) $ get_column ( \"literal\" ) $ to_r ( ) == 2 ^ ( - 1 : 3 ) #> [1] TRUE TRUE TRUE TRUE TRUE pl $ DataFrame ( a = - 1 : 3 ) $ select ( pl $ lit ( 2 ) ^ ( pl $ col ( \"a\" ) ) ) $ get_column ( \"literal\" ) $ to_r ( ) == 2 ^ ( - 1 : 3 ) #> [1] TRUE TRUE TRUE TRUE TRUE","title":"Examples"},{"location":"reference/Expr_product/","text":"data Product Format An object of class character of length 1. Expr_product Returns Expr Compute the product of an expression. Details does not support integer32 currently, .cast() to f64 or i64 first. Examples pl $ DataFrame ( list ( x = c ( 1 , 2 , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ product ( ) == 6 ) #is true #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_product"},{"location":"reference/Expr_product/#product","text":"","title":"Product"},{"location":"reference/Expr_product/#format","text":"An object of class character of length 1. Expr_product","title":"Format"},{"location":"reference/Expr_product/#returns","text":"Expr Compute the product of an expression.","title":"Returns"},{"location":"reference/Expr_product/#details","text":"does not support integer32 currently, .cast() to f64 or i64 first.","title":"Details"},{"location":"reference/Expr_product/#examples","text":"pl $ DataFrame ( list ( x = c ( 1 , 2 , 3 ) ) ) $ select ( pl $ col ( \"x\" ) $ product ( ) == 6 ) #is true #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_quantile/","text":"Get quantile value. Format a method Expr_quantile ( quantile , interpolation = \"nearest\" ) Arguments quantile : numeric/Expression 0.0 to 1.0 interpolation : string value from choices \"nearest\", \"higher\", \"lower\", \"midpoint\", \"linear\" Returns Expr Get quantile value. Details Nulls are ignored and NaNs are ranked as the largest value. For linear interpolation NaN poisons Inf , that poisons any other value. Examples pl $ select ( pl $ lit ( - 5 : 5 ) $ quantile ( .5 ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_quantile"},{"location":"reference/Expr_quantile/#get-quantile-value","text":"","title":"Get quantile value."},{"location":"reference/Expr_quantile/#format","text":"a method Expr_quantile ( quantile , interpolation = \"nearest\" )","title":"Format"},{"location":"reference/Expr_quantile/#arguments","text":"quantile : numeric/Expression 0.0 to 1.0 interpolation : string value from choices \"nearest\", \"higher\", \"lower\", \"midpoint\", \"linear\"","title":"Arguments"},{"location":"reference/Expr_quantile/#returns","text":"Expr Get quantile value.","title":"Returns"},{"location":"reference/Expr_quantile/#details","text":"Nulls are ignored and NaNs are ranked as the largest value. For linear interpolation NaN poisons Inf , that poisons any other value.","title":"Details"},{"location":"reference/Expr_quantile/#examples","text":"pl $ select ( pl $ lit ( - 5 : 5 ) $ quantile ( .5 ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_rank/","text":"Rank Expr_rank ( method = \"average\" , reverse = FALSE ) Arguments method : string option 'average', 'min', 'max', 'dense', 'ordinal', 'random' ' The method used to assign ranks to tied elements. The following methods are available (default is 'average'): 'average' : The average of the ranks that would have been assigned to all the tied values is assigned to each value. 'min' : The minimum of the ranks that would have been assigned to all the tied values is assigned to each value. (This is also referred to as \"competition\" ranking.) 'max' : The maximum of the ranks that would have been assigned to all the tied values is assigned to each value. 'dense' : Like 'min', but the rank of the next highest element is assigned the rank immediately after those assigned to the tied elements. 'ordinal' : All values are given a distinct rank, corresponding to the order that the values occur in the Series. 'random' : Like 'ordinal', but the rank for ties is not dependent on the order that the values occur in the Series. reverse : bool, reverse the operation Returns Expr Assign ranks to data, dealing with ties appropriately. Examples # The 'average' method: df = pl $ DataFrame ( list ( a = c ( 3 , 6 , 1 , 1 , 6 ) ) ) df $ select ( pl $ col ( \"a\" ) $ rank ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3.0 \u2502 #> \u2502 4.5 \u2502 #> \u2502 1.5 \u2502 #> \u2502 1.5 \u2502 #> \u2502 4.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 # The 'ordinal' method: df = pl $ DataFrame ( list ( a = c ( 3 , 6 , 1 , 1 , 6 ) ) ) df $ select ( pl $ col ( \"a\" ) $ rank ( \"ordinal\" ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 4 \u2502 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_rank"},{"location":"reference/Expr_rank/#rank","text":"Expr_rank ( method = \"average\" , reverse = FALSE )","title":"Rank"},{"location":"reference/Expr_rank/#arguments","text":"method : string option 'average', 'min', 'max', 'dense', 'ordinal', 'random'","title":"Arguments"},{"location":"reference/Expr_rank/#the-method-used-to-assign-ranks-to-tied-elements-the-following-methods-are-available-default-is-average","text":"'average' : The average of the ranks that would have been assigned to all the tied values is assigned to each value. 'min' : The minimum of the ranks that would have been assigned to all the tied values is assigned to each value. (This is also referred to as \"competition\" ranking.) 'max' : The maximum of the ranks that would have been assigned to all the tied values is assigned to each value. 'dense' : Like 'min', but the rank of the next highest element is assigned the rank immediately after those assigned to the tied elements. 'ordinal' : All values are given a distinct rank, corresponding to the order that the values occur in the Series. 'random' : Like 'ordinal', but the rank for ties is not dependent on the order that the values occur in the Series. reverse : bool, reverse the operation","title":"' The method used to assign ranks to tied elements. The following methods are available (default is 'average'):"},{"location":"reference/Expr_rank/#returns","text":"Expr Assign ranks to data, dealing with ties appropriately.","title":"Returns"},{"location":"reference/Expr_rank/#examples","text":"# The 'average' method: df = pl $ DataFrame ( list ( a = c ( 3 , 6 , 1 , 1 , 6 ) ) ) df $ select ( pl $ col ( \"a\" ) $ rank ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3.0 \u2502 #> \u2502 4.5 \u2502 #> \u2502 1.5 \u2502 #> \u2502 1.5 \u2502 #> \u2502 4.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 # The 'ordinal' method: df = pl $ DataFrame ( list ( a = c ( 3 , 6 , 1 , 1 , 6 ) ) ) df $ select ( pl $ col ( \"a\" ) $ rank ( \"ordinal\" ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 4 \u2502 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_rechunk/","text":"data Rechunk memory layout Format a method Expr_rechunk Returns Expr Create a single chunk of memory for this Series. Details See rechunk() explained here docs_translations Examples #get chunked lengths with/without rechunk series_list = pl $ DataFrame ( list ( a = 1 : 3 ,b = 4 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ append ( pl $ col ( \"b\" ) ) $ alias ( \"a_chunked\" ) , pl $ col ( \"a\" ) $ append ( pl $ col ( \"b\" ) ) $ rechunk ( ) $ alias ( \"a_rechunked\" ) ) $ get_columns ( ) lapply ( series_list , \\ ( x ) x $ chunk_lengths ( ) ) #> $a_chunked #> [1] 3 3 #> #> $a_rechunked #> [1] 6 #>","title":"Expr_rechunk"},{"location":"reference/Expr_rechunk/#rechunk-memory-layout","text":"","title":"Rechunk memory layout"},{"location":"reference/Expr_rechunk/#format","text":"a method Expr_rechunk","title":"Format"},{"location":"reference/Expr_rechunk/#returns","text":"Expr Create a single chunk of memory for this Series.","title":"Returns"},{"location":"reference/Expr_rechunk/#details","text":"See rechunk() explained here docs_translations","title":"Details"},{"location":"reference/Expr_rechunk/#examples","text":"#get chunked lengths with/without rechunk series_list = pl $ DataFrame ( list ( a = 1 : 3 ,b = 4 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ append ( pl $ col ( \"b\" ) ) $ alias ( \"a_chunked\" ) , pl $ col ( \"a\" ) $ append ( pl $ col ( \"b\" ) ) $ rechunk ( ) $ alias ( \"a_rechunked\" ) ) $ get_columns ( ) lapply ( series_list , \\ ( x ) x $ chunk_lengths ( ) ) #> $a_chunked #> [1] 3 3 #> #> $a_rechunked #> [1] 6 #>","title":"Examples"},{"location":"reference/Expr_reinterpret/","text":"reinterpret bits Expr_reinterpret ( signed = TRUE ) Arguments signed : bool reinterpret into Int64 else UInt64 Returns Expr Reinterpret the underlying bits as a signed/unsigned integer. This operation is only allowed for 64bit integers. For lower bits integers, you can safely use that cast operation. Examples df = pl $ DataFrame ( iris ) df $ select ( pl $ all ( ) $ head ( 2 ) $ hash ( 1 , 2 , 3 , 4 ) $ reinterpret ( ) ) $ as_data_frame ( ) #> Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 1 4.252873e-230 4.052261e+177 -5.823674e-211 -5.861121e+292 0 #> 2 -3.065433e-207 -1.807369e+221 -5.823674e-211 -5.861121e+292 0","title":"Expr_reinterpret"},{"location":"reference/Expr_reinterpret/#reinterpret-bits","text":"Expr_reinterpret ( signed = TRUE )","title":"reinterpret bits"},{"location":"reference/Expr_reinterpret/#arguments","text":"signed : bool reinterpret into Int64 else UInt64","title":"Arguments"},{"location":"reference/Expr_reinterpret/#returns","text":"Expr Reinterpret the underlying bits as a signed/unsigned integer. This operation is only allowed for 64bit integers. For lower bits integers, you can safely use that cast operation.","title":"Returns"},{"location":"reference/Expr_reinterpret/#examples","text":"df = pl $ DataFrame ( iris ) df $ select ( pl $ all ( ) $ head ( 2 ) $ hash ( 1 , 2 , 3 , 4 ) $ reinterpret ( ) ) $ as_data_frame ( ) #> Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 1 4.252873e-230 4.052261e+177 -5.823674e-211 -5.861121e+292 0 #> 2 -3.065433e-207 -1.807369e+221 -5.823674e-211 -5.861121e+292 0","title":"Examples"},{"location":"reference/Expr_rep/","text":"expression: repeat series Format Method Expr_rep ( n , rechunk = TRUE ) Arguments n : Numeric the number of times to repeat, must be non-negative and finite rechunk : bool default = TRUE, if true memory layout will be rewritten Returns Expr This expression takes input and repeats it n times and append chunk Details if self$len() == 1 , has a special faster implementation, Here rechunk is not necessary, and takes no effect. if self$len() > 1 , then the expression instructs the series to append onto itself n time and rewrite memory Examples pl $ select ( pl $ lit ( \"alice\" ) $ rep ( n = 3 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 literal \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 alice \u2502 #> \u2502 alice \u2502 #> \u2502 alice \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ select ( pl $ lit ( 1 : 3 ) $ rep ( n = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_rep"},{"location":"reference/Expr_rep/#expression-repeat-series","text":"","title":"expression: repeat series"},{"location":"reference/Expr_rep/#format","text":"Method Expr_rep ( n , rechunk = TRUE )","title":"Format"},{"location":"reference/Expr_rep/#arguments","text":"n : Numeric the number of times to repeat, must be non-negative and finite rechunk : bool default = TRUE, if true memory layout will be rewritten","title":"Arguments"},{"location":"reference/Expr_rep/#returns","text":"Expr This expression takes input and repeats it n times and append chunk","title":"Returns"},{"location":"reference/Expr_rep/#details","text":"if self$len() == 1 , has a special faster implementation, Here rechunk is not necessary, and takes no effect. if self$len() > 1 , then the expression instructs the series to append onto itself n time and rewrite memory","title":"Details"},{"location":"reference/Expr_rep/#examples","text":"pl $ select ( pl $ lit ( \"alice\" ) $ rep ( n = 3 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 literal \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 alice \u2502 #> \u2502 alice \u2502 #> \u2502 alice \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ select ( pl $ lit ( 1 : 3 ) $ rep ( n = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_rep_extend/","text":"extend series with repeated series Format Method Expr_rep_extend ( expr , n , rechunk = TRUE , upcast = TRUE ) Arguments expr : Expr or into Expr n : Numeric the number of times to repeat, must be non-negative and finite rechunk : bool default = TRUE, if true memory layout will be rewritten upcast : bool default = TRUE, passed to self$append(), if TRUE non identical types will be casted to common super type if any. If FALSE or no common super type throw error. Returns Expr Extend a series with a repeated series or value. Examples pl $ select ( pl $ lit ( c ( 1 , 2 , 3 ) ) $ rep_extend ( 1 : 3 , n = 5 ) ) #> polars DataFrame: shape: (18, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 3.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 ... \u2502 #> \u2502 3.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 3.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_rep_extend"},{"location":"reference/Expr_rep_extend/#extend-series-with-repeated-series","text":"","title":"extend series with repeated series"},{"location":"reference/Expr_rep_extend/#format","text":"Method Expr_rep_extend ( expr , n , rechunk = TRUE , upcast = TRUE )","title":"Format"},{"location":"reference/Expr_rep_extend/#arguments","text":"expr : Expr or into Expr n : Numeric the number of times to repeat, must be non-negative and finite rechunk : bool default = TRUE, if true memory layout will be rewritten upcast : bool default = TRUE, passed to self$append(), if TRUE non identical types will be casted to common super type if any. If FALSE or no common super type throw error.","title":"Arguments"},{"location":"reference/Expr_rep_extend/#returns","text":"Expr Extend a series with a repeated series or value.","title":"Returns"},{"location":"reference/Expr_rep_extend/#examples","text":"pl $ select ( pl $ lit ( c ( 1 , 2 , 3 ) ) $ rep_extend ( 1 : 3 , n = 5 ) ) #> polars DataFrame: shape: (18, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 3.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 ... \u2502 #> \u2502 3.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 3.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_repeat_by/","text":"Repeat by Expr_repeat_by ( by ) Arguments by : Expr Numeric column that determines how often the values will be repeated. The column will be coerced to UInt32. Give this dtype to make the coercion a no-op. Returns Expr Repeat the elements in this Series as specified in the given expression. The repeated elements are expanded into a List . Examples df = pl $ DataFrame ( list ( a = c ( \"x\" , \"y\" , \"z\" ) , n = c ( 0 : 2 ) ) ) df $ select ( pl $ col ( \"a\" ) $ repeat_by ( \"n\" ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[str] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [] \u2502 #> \u2502 [\"y\"] \u2502 #> \u2502 [\"z\", \"z\"] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_repeat_by"},{"location":"reference/Expr_repeat_by/#repeat-by","text":"Expr_repeat_by ( by )","title":"Repeat by"},{"location":"reference/Expr_repeat_by/#arguments","text":"by : Expr Numeric column that determines how often the values will be repeated. The column will be coerced to UInt32. Give this dtype to make the coercion a no-op.","title":"Arguments"},{"location":"reference/Expr_repeat_by/#returns","text":"Expr Repeat the elements in this Series as specified in the given expression. The repeated elements are expanded into a List .","title":"Returns"},{"location":"reference/Expr_repeat_by/#examples","text":"df = pl $ DataFrame ( list ( a = c ( \"x\" , \"y\" , \"z\" ) , n = c ( 0 : 2 ) ) ) df $ select ( pl $ col ( \"a\" ) $ repeat_by ( \"n\" ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[str] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [] \u2502 #> \u2502 [\"y\"] \u2502 #> \u2502 [\"z\", \"z\"] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_reshape/","text":"Reshape Format Method Expr_reshape ( dims ) Arguments dims : numeric vec of the dimension sizes. If a -1 is used in any of the dimensions, that dimension is inferred. Returns Expr Reshape this Expr to a flat Series or a Series of Lists. Examples pl $ select ( pl $ lit ( 1 : 12 ) $ reshape ( c ( 3 , 4 ) ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [1, 2, ... 4] \u2502 #> \u2502 [5, 6, ... 8] \u2502 #> \u2502 [9, 10, ... 12] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ select ( pl $ lit ( 1 : 12 ) $ reshape ( c ( 3 , - 1 ) ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [1, 2, ... 4] \u2502 #> \u2502 [5, 6, ... 8] \u2502 #> \u2502 [9, 10, ... 12] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_reshape"},{"location":"reference/Expr_reshape/#reshape","text":"","title":"Reshape"},{"location":"reference/Expr_reshape/#format","text":"Method Expr_reshape ( dims )","title":"Format"},{"location":"reference/Expr_reshape/#arguments","text":"dims : numeric vec of the dimension sizes. If a -1 is used in any of the dimensions, that dimension is inferred.","title":"Arguments"},{"location":"reference/Expr_reshape/#returns","text":"Expr Reshape this Expr to a flat Series or a Series of Lists.","title":"Returns"},{"location":"reference/Expr_reshape/#examples","text":"pl $ select ( pl $ lit ( 1 : 12 ) $ reshape ( c ( 3 , 4 ) ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [1, 2, ... 4] \u2502 #> \u2502 [5, 6, ... 8] \u2502 #> \u2502 [9, 10, ... 12] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ select ( pl $ lit ( 1 : 12 ) $ reshape ( c ( 3 , - 1 ) ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [1, 2, ... 4] \u2502 #> \u2502 [5, 6, ... 8] \u2502 #> \u2502 [9, 10, ... 12] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_rolling_max/","text":"Rolling max Expr_rolling_max ( window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" ) Arguments window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not. Returns Expr Apply a rolling max (moving max) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum. Details This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation. Examples pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_max ( window_size = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2502 4 \u2502 #> \u2502 5 \u2502 #> \u2502 6 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_rolling_max"},{"location":"reference/Expr_rolling_max/#rolling-max","text":"Expr_rolling_max ( window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" )","title":"Rolling max"},{"location":"reference/Expr_rolling_max/#arguments","text":"window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.","title":"Arguments"},{"location":"reference/Expr_rolling_max/#returns","text":"Expr Apply a rolling max (moving max) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum.","title":"Returns"},{"location":"reference/Expr_rolling_max/#details","text":"This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation.","title":"Details"},{"location":"reference/Expr_rolling_max/#examples","text":"pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_max ( window_size = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2502 4 \u2502 #> \u2502 5 \u2502 #> \u2502 6 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_rolling_mean/","text":"Rolling mean Expr_rolling_mean ( window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" ) Arguments window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not. Returns Expr Apply a rolling mean (moving mean) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum. Details This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation. Examples pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_mean ( window_size = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 1.5 \u2502 #> \u2502 2.5 \u2502 #> \u2502 3.5 \u2502 #> \u2502 4.5 \u2502 #> \u2502 5.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_rolling_mean"},{"location":"reference/Expr_rolling_mean/#rolling-mean","text":"Expr_rolling_mean ( window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" )","title":"Rolling mean"},{"location":"reference/Expr_rolling_mean/#arguments","text":"window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.","title":"Arguments"},{"location":"reference/Expr_rolling_mean/#returns","text":"Expr Apply a rolling mean (moving mean) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum.","title":"Returns"},{"location":"reference/Expr_rolling_mean/#details","text":"This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation.","title":"Details"},{"location":"reference/Expr_rolling_mean/#examples","text":"pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_mean ( window_size = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 1.5 \u2502 #> \u2502 2.5 \u2502 #> \u2502 3.5 \u2502 #> \u2502 4.5 \u2502 #> \u2502 5.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_rolling_median/","text":"Rolling median Expr_rolling_median ( window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" ) Arguments window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not. Returns Expr Apply a rolling median (moving median) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum. Details This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation. Examples pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_median ( window_size = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 1.5 \u2502 #> \u2502 2.5 \u2502 #> \u2502 3.5 \u2502 #> \u2502 4.5 \u2502 #> \u2502 5.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_rolling_median"},{"location":"reference/Expr_rolling_median/#rolling-median","text":"Expr_rolling_median ( window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" )","title":"Rolling median"},{"location":"reference/Expr_rolling_median/#arguments","text":"window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.","title":"Arguments"},{"location":"reference/Expr_rolling_median/#returns","text":"Expr Apply a rolling median (moving median) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum.","title":"Returns"},{"location":"reference/Expr_rolling_median/#details","text":"This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation.","title":"Details"},{"location":"reference/Expr_rolling_median/#examples","text":"pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_median ( window_size = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 1.5 \u2502 #> \u2502 2.5 \u2502 #> \u2502 3.5 \u2502 #> \u2502 4.5 \u2502 #> \u2502 5.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_rolling_min/","text":"Rolling Min Expr_rolling_min ( window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" ) Arguments window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not. Returns Expr Apply a rolling min (moving min) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum. Details This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation. Examples pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_min ( window_size = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2502 4 \u2502 #> \u2502 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_rolling_min"},{"location":"reference/Expr_rolling_min/#rolling-min","text":"Expr_rolling_min ( window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" )","title":"Rolling Min"},{"location":"reference/Expr_rolling_min/#arguments","text":"window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.","title":"Arguments"},{"location":"reference/Expr_rolling_min/#returns","text":"Expr Apply a rolling min (moving min) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum.","title":"Returns"},{"location":"reference/Expr_rolling_min/#details","text":"This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation.","title":"Details"},{"location":"reference/Expr_rolling_min/#examples","text":"pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_min ( window_size = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2502 4 \u2502 #> \u2502 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_rolling_quantile/","text":"Rolling quantile Expr_rolling_quantile ( quantile , interpolation = \"nearest\" , window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" ) Arguments quantile : Quantile between 0.0 and 1.0. interpolation : choice c('nearest', 'higher', 'lower', 'midpoint', 'linear') window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not. Returns Expr Apply a rolling quantile (moving quantile) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum. Details This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation. Examples pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_quantile ( window_size = 2 , quantile = .5 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 2.0 \u2502 #> \u2502 3.0 \u2502 #> \u2502 4.0 \u2502 #> \u2502 5.0 \u2502 #> \u2502 6.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_rolling_quantile"},{"location":"reference/Expr_rolling_quantile/#rolling-quantile","text":"Expr_rolling_quantile ( quantile , interpolation = \"nearest\" , window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" )","title":"Rolling quantile"},{"location":"reference/Expr_rolling_quantile/#arguments","text":"quantile : Quantile between 0.0 and 1.0. interpolation : choice c('nearest', 'higher', 'lower', 'midpoint', 'linear') window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.","title":"Arguments"},{"location":"reference/Expr_rolling_quantile/#returns","text":"Expr Apply a rolling quantile (moving quantile) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum.","title":"Returns"},{"location":"reference/Expr_rolling_quantile/#details","text":"This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation.","title":"Details"},{"location":"reference/Expr_rolling_quantile/#examples","text":"pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_quantile ( window_size = 2 , quantile = .5 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 2.0 \u2502 #> \u2502 3.0 \u2502 #> \u2502 4.0 \u2502 #> \u2502 5.0 \u2502 #> \u2502 6.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_rolling_skew/","text":"Rolling skew Expr_rolling_skew ( window_size , bias = TRUE ) Arguments window_size : integerish, Size of the rolling window bias : bool default = TRUE, If False, then the calculations are corrected for statistical bias. Returns Expr Compute a rolling skew. Details Extra comments copied from rust-polars_0.25.1 Compute the sample skewness of a data set. For normally distributed data, the skewness should be about zero. For uni-modal continuous distributions, a skewness value greater than zero means that there is more weight in the right tail of the distribution. The function skewtest can be used to determine if the skewness value is close enough to zero, statistically speaking. see: https://github.com/scipy/scipy/blob/47bb6febaa10658c72962b9615d5d5aa2513fa3a/scipy/stats/stats.py#L1024 Examples pl $ DataFrame ( list ( a = iris $ Sepal.Length ) ) $ select ( pl $ col ( \"a\" ) $ rolling_skew ( window_size = 4 ) $ head ( 10 ) ) #> polars DataFrame: shape: (10, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 null \u2502 #> \u2502 null \u2502 #> \u2502 0.278031 \u2502 #> \u2502 ... \u2502 #> \u2502 0.493382 \u2502 #> \u2502 0.0 \u2502 #> \u2502 0.278031 \u2502 #> \u2502 -0.186618 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_rolling_skew"},{"location":"reference/Expr_rolling_skew/#rolling-skew","text":"Expr_rolling_skew ( window_size , bias = TRUE )","title":"Rolling skew"},{"location":"reference/Expr_rolling_skew/#arguments","text":"window_size : integerish, Size of the rolling window bias : bool default = TRUE, If False, then the calculations are corrected for statistical bias.","title":"Arguments"},{"location":"reference/Expr_rolling_skew/#returns","text":"Expr Compute a rolling skew.","title":"Returns"},{"location":"reference/Expr_rolling_skew/#details","text":"Extra comments copied from rust-polars_0.25.1 Compute the sample skewness of a data set. For normally distributed data, the skewness should be about zero. For uni-modal continuous distributions, a skewness value greater than zero means that there is more weight in the right tail of the distribution. The function skewtest can be used to determine if the skewness value is close enough to zero, statistically speaking. see: https://github.com/scipy/scipy/blob/47bb6febaa10658c72962b9615d5d5aa2513fa3a/scipy/stats/stats.py#L1024","title":"Details"},{"location":"reference/Expr_rolling_skew/#examples","text":"pl $ DataFrame ( list ( a = iris $ Sepal.Length ) ) $ select ( pl $ col ( \"a\" ) $ rolling_skew ( window_size = 4 ) $ head ( 10 ) ) #> polars DataFrame: shape: (10, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 null \u2502 #> \u2502 null \u2502 #> \u2502 0.278031 \u2502 #> \u2502 ... \u2502 #> \u2502 0.493382 \u2502 #> \u2502 0.0 \u2502 #> \u2502 0.278031 \u2502 #> \u2502 -0.186618 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_rolling_std/","text":"Rolling std Expr_rolling_std ( window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" ) Arguments window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not. Returns Expr Apply a rolling std (moving std) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum. Details This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation. Examples pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_std ( window_size = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 0.707107 \u2502 #> \u2502 0.707107 \u2502 #> \u2502 0.707107 \u2502 #> \u2502 0.707107 \u2502 #> \u2502 0.707107 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_rolling_std"},{"location":"reference/Expr_rolling_std/#rolling-std","text":"Expr_rolling_std ( window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" )","title":"Rolling std"},{"location":"reference/Expr_rolling_std/#arguments","text":"window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.","title":"Arguments"},{"location":"reference/Expr_rolling_std/#returns","text":"Expr Apply a rolling std (moving std) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum.","title":"Returns"},{"location":"reference/Expr_rolling_std/#details","text":"This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation.","title":"Details"},{"location":"reference/Expr_rolling_std/#examples","text":"pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_std ( window_size = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 0.707107 \u2502 #> \u2502 0.707107 \u2502 #> \u2502 0.707107 \u2502 #> \u2502 0.707107 \u2502 #> \u2502 0.707107 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_rolling_sum/","text":"Rolling sum Expr_rolling_sum ( window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" ) Arguments window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not. Returns Expr Apply a rolling sum (moving sum) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum. Details This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation. Examples pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_sum ( window_size = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 3 \u2502 #> \u2502 5 \u2502 #> \u2502 7 \u2502 #> \u2502 9 \u2502 #> \u2502 11 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_rolling_sum"},{"location":"reference/Expr_rolling_sum/#rolling-sum","text":"Expr_rolling_sum ( window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" )","title":"Rolling sum"},{"location":"reference/Expr_rolling_sum/#arguments","text":"window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.","title":"Arguments"},{"location":"reference/Expr_rolling_sum/#returns","text":"Expr Apply a rolling sum (moving sum) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum.","title":"Returns"},{"location":"reference/Expr_rolling_sum/#details","text":"This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation.","title":"Details"},{"location":"reference/Expr_rolling_sum/#examples","text":"pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_sum ( window_size = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 3 \u2502 #> \u2502 5 \u2502 #> \u2502 7 \u2502 #> \u2502 9 \u2502 #> \u2502 11 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_rolling_var/","text":"Rolling var Expr_rolling_var ( window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" ) Arguments window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not. Returns Expr Apply a rolling var (moving var) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum. Details This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation. Examples pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_var ( window_size = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_rolling_var"},{"location":"reference/Expr_rolling_var/#rolling-var","text":"Expr_rolling_var ( window_size , weights = NULL , min_periods = NULL , center = FALSE , by = NULL , closed = \"left\" )","title":"Rolling var"},{"location":"reference/Expr_rolling_var/#arguments","text":"window_size : The length of the window. Can be a fixed integer size, or a dynamic temporal size indicated by the following string language: 1ns (1 nanosecond) 1us (1 microsecond) 1ms (1 millisecond) 1s (1 second) 1m (1 minute) 1h (1 hour) 1d (1 day) 1w (1 week) 1mo (1 calendar month) 1y (1 calendar year) 1i (1 index count) If the dynamic string language is used, the by and closed arguments must also be set. weights : An optional slice with the same length as the window that will be multiplied elementwise with the values in the window. min_periods : The number of values in the window that should be non-null before computing a result. If None, it will be set equal to window size. center : Set the labels at the center of the window by : If the window_size is temporal for instance \"5h\" or \"3s , you must set the column that will be used to determine the windows. This column must be of dtype {Date, Datetime} closed : : 'left', 'right', 'both', 'none' Define whether the temporal window interval is closed or not.","title":"Arguments"},{"location":"reference/Expr_rolling_var/#returns","text":"Expr Apply a rolling var (moving var) over the values in this array. A window of length window_size will traverse the array. The values that fill this window will (optionally) be multiplied with the weights given by the weight vector. The resulting values will be aggregated to their sum.","title":"Returns"},{"location":"reference/Expr_rolling_var/#details","text":"This functionality is experimental and may change without it being considered a breaking change. Notes: If you want to compute multiple aggregation statistics over the same dynamic window, consider using groupby_rolling this method can cache the window size computation.","title":"Details"},{"location":"reference/Expr_rolling_var/#examples","text":"pl $ DataFrame ( list ( a = 1 : 6 ) ) $ select ( pl $ col ( \"a\" ) $ rolling_var ( window_size = 2 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_round/","text":"round Format a method Expr_round ( decimals ) Arguments decimals : integer Number of decimals to round by. Returns Expr Round underlying floating point data by decimals digits. Examples pl $ DataFrame ( list ( a = c ( 0.33 , 0.5 , 1.02 , 1.5 , NaN , NA , Inf , - Inf ) ) ) $ select ( pl $ col ( \"a\" ) $ round ( 0 ) ) #> polars DataFrame: shape: (8, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 NaN \u2502 #> \u2502 null \u2502 #> \u2502 inf \u2502 #> \u2502 -inf \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_round"},{"location":"reference/Expr_round/#round","text":"","title":"round"},{"location":"reference/Expr_round/#format","text":"a method Expr_round ( decimals )","title":"Format"},{"location":"reference/Expr_round/#arguments","text":"decimals : integer Number of decimals to round by.","title":"Arguments"},{"location":"reference/Expr_round/#returns","text":"Expr Round underlying floating point data by decimals digits.","title":"Returns"},{"location":"reference/Expr_round/#examples","text":"pl $ DataFrame ( list ( a = c ( 0.33 , 0.5 , 1.02 , 1.5 , NaN , NA , Inf , - Inf ) ) ) $ select ( pl $ col ( \"a\" ) $ round ( 0 ) ) #> polars DataFrame: shape: (8, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 2.0 \u2502 #> \u2502 NaN \u2502 #> \u2502 null \u2502 #> \u2502 inf \u2502 #> \u2502 -inf \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_rpow/","text":"Reverse exponentiation %**% (in R ** == ^ ) Expr_rpow ( base ) e1 %**% e2 `%**%.Expr` ( e1 , e2 ) Arguments base : real or Expr, the value of the base, self is the exponent e1 : value where ** operator is defined e2 : value where ** operator is defined Returns Expr Raise a base to the power of the expression as exponent. Details do not use ** , R secretly parses that just as if it was a ^ Examples pl $ DataFrame ( list ( a = - 1 : 3 ) ) $ select ( pl $ lit ( 2 ) $ rpow ( pl $ col ( \"a\" ) ) ) $ get_column ( \"a\" ) $ to_r ( ) == ( - 1 : 3 ) ^ 2 #> [1] TRUE TRUE TRUE TRUE TRUE pl $ DataFrame ( list ( a = - 1 : 3 ) ) $ select ( pl $ lit ( 2 ) %**% ( pl $ col ( \"a\" ) ) ) $ get_column ( \"a\" ) $ to_r ( ) == ( - 1 : 3 ) ^ 2 #> [1] TRUE TRUE TRUE TRUE TRUE","title":"Expr_rpow"},{"location":"reference/Expr_rpow/#reverse-exponentiation-in-r","text":"Expr_rpow ( base ) e1 %**% e2 `%**%.Expr` ( e1 , e2 )","title":"Reverse exponentiation %**%(in R ** == ^)"},{"location":"reference/Expr_rpow/#arguments","text":"base : real or Expr, the value of the base, self is the exponent e1 : value where ** operator is defined e2 : value where ** operator is defined","title":"Arguments"},{"location":"reference/Expr_rpow/#returns","text":"Expr Raise a base to the power of the expression as exponent.","title":"Returns"},{"location":"reference/Expr_rpow/#details","text":"do not use ** , R secretly parses that just as if it was a ^","title":"Details"},{"location":"reference/Expr_rpow/#examples","text":"pl $ DataFrame ( list ( a = - 1 : 3 ) ) $ select ( pl $ lit ( 2 ) $ rpow ( pl $ col ( \"a\" ) ) ) $ get_column ( \"a\" ) $ to_r ( ) == ( - 1 : 3 ) ^ 2 #> [1] TRUE TRUE TRUE TRUE TRUE pl $ DataFrame ( list ( a = - 1 : 3 ) ) $ select ( pl $ lit ( 2 ) %**% ( pl $ col ( \"a\" ) ) ) $ get_column ( \"a\" ) $ to_r ( ) == ( - 1 : 3 ) ^ 2 #> [1] TRUE TRUE TRUE TRUE TRUE","title":"Examples"},{"location":"reference/Expr_sample/","text":"Sample Format Method Expr_sample ( frac = NULL , with_replacement = TRUE , shuffle = FALSE , seed = NULL , n = NULL ) Arguments frac : Fraction of items to return. Cannot be used with n . with_replacement : Allow values to be sampled more than once. shuffle : Shuffle the order of sampled data points. (implicitly TRUE if, with_replacement = TRUE) seed : Seed for the random number generator. If set to None (default), a random seed is used. n : Number of items to return. Cannot be used with frac . Returns Expr ' Sample from this expression. Examples df = pl $ DataFrame ( a = 1 : 3 ) df $ select ( pl $ col ( \"a\" ) $ sample ( frac = 1 ,with_replacement = TRUE ,seed = 1L ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 1 \u2502 #> \u2502 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"a\" ) $ sample ( frac = 2 ,with_replacement = TRUE ,seed = 1L ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 1 \u2502 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"a\" ) $ sample ( n = 2 ,with_replacement = FALSE ,seed = 1L ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_sample"},{"location":"reference/Expr_sample/#sample","text":"","title":"Sample"},{"location":"reference/Expr_sample/#format","text":"Method Expr_sample ( frac = NULL , with_replacement = TRUE , shuffle = FALSE , seed = NULL , n = NULL )","title":"Format"},{"location":"reference/Expr_sample/#arguments","text":"frac : Fraction of items to return. Cannot be used with n . with_replacement : Allow values to be sampled more than once. shuffle : Shuffle the order of sampled data points. (implicitly TRUE if, with_replacement = TRUE) seed : Seed for the random number generator. If set to None (default), a random seed is used. n : Number of items to return. Cannot be used with frac .","title":"Arguments"},{"location":"reference/Expr_sample/#returns","text":"Expr","title":"Returns"},{"location":"reference/Expr_sample/#sample-from-this-expression","text":"","title":"' Sample from this expression."},{"location":"reference/Expr_sample/#examples","text":"df = pl $ DataFrame ( a = 1 : 3 ) df $ select ( pl $ col ( \"a\" ) $ sample ( frac = 1 ,with_replacement = TRUE ,seed = 1L ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 1 \u2502 #> \u2502 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"a\" ) $ sample ( frac = 2 ,with_replacement = TRUE ,seed = 1L ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 1 \u2502 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"a\" ) $ sample ( n = 2 ,with_replacement = FALSE ,seed = 1L ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_search_sorted/","text":"Where to inject element(s) to maintain sorting Format a method Expr_search_sorted ( element ) Arguments element : a R value into literal or an expression of an element Returns Expr Find indices in self where elements should be inserted into to maintain order. Details This function look up where to insert element if to keep self column sorted. It is assumed the self column is already sorted ascending, otherwise wrongs answers. This function is a bit under documented in py-polars. Examples pl $ DataFrame ( list ( a = 0 : 100 ) ) $ select ( pl $ col ( \"a\" ) $ search_sorted ( pl $ lit ( 42L ) ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 42 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_search_sorted"},{"location":"reference/Expr_search_sorted/#where-to-inject-elements-to-maintain-sorting","text":"","title":"Where to inject element(s) to maintain sorting"},{"location":"reference/Expr_search_sorted/#format","text":"a method Expr_search_sorted ( element )","title":"Format"},{"location":"reference/Expr_search_sorted/#arguments","text":"element : a R value into literal or an expression of an element","title":"Arguments"},{"location":"reference/Expr_search_sorted/#returns","text":"Expr Find indices in self where elements should be inserted into to maintain order.","title":"Returns"},{"location":"reference/Expr_search_sorted/#details","text":"This function look up where to insert element if to keep self column sorted. It is assumed the self column is already sorted ascending, otherwise wrongs answers. This function is a bit under documented in py-polars.","title":"Details"},{"location":"reference/Expr_search_sorted/#examples","text":"pl $ DataFrame ( list ( a = 0 : 100 ) ) $ select ( pl $ col ( \"a\" ) $ search_sorted ( pl $ lit ( 42L ) ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 42 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_set_sorted/","text":"Set_sorted Expr_set_sorted ( reverse = FALSE ) Arguments reverse : bool if TRUE Descending else Ascending Returns Expr Flags the expression as 'sorted'. Examples #correct use flag something correctly as ascendingly sorted s = pl $ select ( pl $ lit ( 1 : 4 ) $ set_sorted ( ) $ alias ( \"a\" ) ) $ get_column ( \"a\" ) s $ flags # see flags #> $SORTED_ASC #> [1] TRUE #> #> $SORTED_DESC #> [1] FALSE #> #incorrect use, flag somthing as not sorted ascendingly s2 = pl $ select ( pl $ lit ( c ( 1 , 3 , 2 , 4 ) ) $ set_sorted ( ) $ alias ( \"a\" ) ) $ get_column ( \"a\" ) s2 $ sort ( ) #sorting skipped, although not actually sorted #> polars Series: shape: (4,) #> Series: 'a' [f64] #> [ #> 1.0 #> 3.0 #> 2.0 #> 4.0 #> ]","title":"Expr_set_sorted"},{"location":"reference/Expr_set_sorted/#set_sorted","text":"Expr_set_sorted ( reverse = FALSE )","title":"Set_sorted"},{"location":"reference/Expr_set_sorted/#arguments","text":"reverse : bool if TRUE Descending else Ascending","title":"Arguments"},{"location":"reference/Expr_set_sorted/#returns","text":"Expr Flags the expression as 'sorted'.","title":"Returns"},{"location":"reference/Expr_set_sorted/#examples","text":"#correct use flag something correctly as ascendingly sorted s = pl $ select ( pl $ lit ( 1 : 4 ) $ set_sorted ( ) $ alias ( \"a\" ) ) $ get_column ( \"a\" ) s $ flags # see flags #> $SORTED_ASC #> [1] TRUE #> #> $SORTED_DESC #> [1] FALSE #> #incorrect use, flag somthing as not sorted ascendingly s2 = pl $ select ( pl $ lit ( c ( 1 , 3 , 2 , 4 ) ) $ set_sorted ( ) $ alias ( \"a\" ) ) $ get_column ( \"a\" ) s2 $ sort ( ) #sorting skipped, although not actually sorted #> polars Series: shape: (4,) #> Series: 'a' [f64] #> [ #> 1.0 #> 3.0 #> 2.0 #> 4.0 #> ]","title":"Examples"},{"location":"reference/Expr_shift/","text":"data Shift values Format a method Expr_shift ( periods ) Arguments periods : numeric number of periods to shift, may be negative. Returns Expr Shift values Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ select ( pl $ lit ( 0 : 3 ) $ shift ( - 2 ) $ alias ( \"shift-2\" ) , pl $ lit ( 0 : 3 ) $ shift ( 2 ) $ alias ( \"shift+2\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 shift-2 \u2506 shift+2 \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2 \u2506 null \u2502 #> \u2502 3 \u2506 null \u2502 #> \u2502 null \u2506 0 \u2502 #> \u2502 null \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_shift"},{"location":"reference/Expr_shift/#shift-values","text":"","title":"Shift values"},{"location":"reference/Expr_shift/#format","text":"a method Expr_shift ( periods )","title":"Format"},{"location":"reference/Expr_shift/#arguments","text":"periods : numeric number of periods to shift, may be negative.","title":"Arguments"},{"location":"reference/Expr_shift/#returns","text":"Expr Shift values","title":"Returns"},{"location":"reference/Expr_shift/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_shift/#examples","text":"pl $ select ( pl $ lit ( 0 : 3 ) $ shift ( - 2 ) $ alias ( \"shift-2\" ) , pl $ lit ( 0 : 3 ) $ shift ( 2 ) $ alias ( \"shift+2\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 shift-2 \u2506 shift+2 \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2 \u2506 null \u2502 #> \u2502 3 \u2506 null \u2502 #> \u2502 null \u2506 0 \u2502 #> \u2502 null \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_shift_and_fill/","text":"Shift and fill values Format a method Expr_shift_and_fill ( periods , fill_value ) Arguments periods : numeric number of periods to shift, may be negative. fill_value : Fill None values with the result of this expression. Returns Expr Shift the values by a given period and fill the resulting null values. Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ select ( pl $ lit ( 0 : 3 ) , pl $ lit ( 0 : 3 ) $ shift_and_fill ( - 2 , fill_value = 42 ) $ alias ( \"shift-2\" ) , pl $ lit ( 0 : 3 ) $ shift_and_fill ( 2 , fill_value = pl $ lit ( 42 ) / 2 ) $ alias ( \"shift+2\" ) ) #> polars DataFrame: shape: (4, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2506 shift-2 \u2506 shift+2 \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0 \u2506 2.0 \u2506 21.0 \u2502 #> \u2502 1 \u2506 3.0 \u2506 21.0 \u2502 #> \u2502 2 \u2506 42.0 \u2506 0.0 \u2502 #> \u2502 3 \u2506 42.0 \u2506 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_shift_and_fill"},{"location":"reference/Expr_shift_and_fill/#shift-and-fill-values","text":"","title":"Shift and fill values"},{"location":"reference/Expr_shift_and_fill/#format","text":"a method Expr_shift_and_fill ( periods , fill_value )","title":"Format"},{"location":"reference/Expr_shift_and_fill/#arguments","text":"periods : numeric number of periods to shift, may be negative. fill_value : Fill None values with the result of this expression.","title":"Arguments"},{"location":"reference/Expr_shift_and_fill/#returns","text":"Expr Shift the values by a given period and fill the resulting null values.","title":"Returns"},{"location":"reference/Expr_shift_and_fill/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_shift_and_fill/#examples","text":"pl $ select ( pl $ lit ( 0 : 3 ) , pl $ lit ( 0 : 3 ) $ shift_and_fill ( - 2 , fill_value = 42 ) $ alias ( \"shift-2\" ) , pl $ lit ( 0 : 3 ) $ shift_and_fill ( 2 , fill_value = pl $ lit ( 42 ) / 2 ) $ alias ( \"shift+2\" ) ) #> polars DataFrame: shape: (4, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2506 shift-2 \u2506 shift+2 \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0 \u2506 2.0 \u2506 21.0 \u2502 #> \u2502 1 \u2506 3.0 \u2506 21.0 \u2502 #> \u2502 2 \u2506 42.0 \u2506 0.0 \u2502 #> \u2502 3 \u2506 42.0 \u2506 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_shrink_dtype/","text":"data Wrap column in list Format An object of class character of length 1. Expr_shrink_dtype Returns Expr Shrink numeric columns to the minimal required datatype. Shrink to the dtype needed to fit the extrema of this [Series] . This can be used to reduce memory pressure. Examples pl $ DataFrame ( a = c ( 1L , 2L , 3L ) , b = c ( 1L , 2L , bitwShiftL ( 2L , 29 ) ) , c = c ( - 1L , 2L , bitwShiftL ( 1L , 15 ) ) , d = c ( - 112L , 2L , 112L ) , e = c ( - 112L , 2L , 129L ) , f = c ( \"a\" , \"b\" , \"c\" ) , g = c ( 0.1 , 1.32 , 0.12 ) , h = c ( TRUE , NA , FALSE ) ) $ with_column ( pl $ col ( \"b\" ) $ cast ( pl $ Int64 ) * 32L ) $ select ( pl $ all ( ) $ shrink_dtype ( ) ) #> polars DataFrame: shape: (3, 8) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 d \u2506 e \u2506 f \u2506 g \u2506 h \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i8 \u2506 i64 \u2506 i32 \u2506 i8 \u2506 i16 \u2506 str \u2506 f32 \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 32 \u2506 -1 \u2506 -112 \u2506 -112 \u2506 a \u2506 0.1 \u2506 true \u2502 #> \u2502 2 \u2506 64 \u2506 2 \u2506 2 \u2506 2 \u2506 b \u2506 1.32 \u2506 null \u2502 #> \u2502 3 \u2506 34359738368 \u2506 32768 \u2506 112 \u2506 129 \u2506 c \u2506 0.12 \u2506 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_shrink_dtype"},{"location":"reference/Expr_shrink_dtype/#wrap-column-in-list","text":"","title":"Wrap column in list"},{"location":"reference/Expr_shrink_dtype/#format","text":"An object of class character of length 1. Expr_shrink_dtype","title":"Format"},{"location":"reference/Expr_shrink_dtype/#returns","text":"Expr Shrink numeric columns to the minimal required datatype. Shrink to the dtype needed to fit the extrema of this [Series] . This can be used to reduce memory pressure.","title":"Returns"},{"location":"reference/Expr_shrink_dtype/#examples","text":"pl $ DataFrame ( a = c ( 1L , 2L , 3L ) , b = c ( 1L , 2L , bitwShiftL ( 2L , 29 ) ) , c = c ( - 1L , 2L , bitwShiftL ( 1L , 15 ) ) , d = c ( - 112L , 2L , 112L ) , e = c ( - 112L , 2L , 129L ) , f = c ( \"a\" , \"b\" , \"c\" ) , g = c ( 0.1 , 1.32 , 0.12 ) , h = c ( TRUE , NA , FALSE ) ) $ with_column ( pl $ col ( \"b\" ) $ cast ( pl $ Int64 ) * 32L ) $ select ( pl $ all ( ) $ shrink_dtype ( ) ) #> polars DataFrame: shape: (3, 8) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 d \u2506 e \u2506 f \u2506 g \u2506 h \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i8 \u2506 i64 \u2506 i32 \u2506 i8 \u2506 i16 \u2506 str \u2506 f32 \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 32 \u2506 -1 \u2506 -112 \u2506 -112 \u2506 a \u2506 0.1 \u2506 true \u2502 #> \u2502 2 \u2506 64 \u2506 2 \u2506 2 \u2506 2 \u2506 b \u2506 1.32 \u2506 null \u2502 #> \u2502 3 \u2506 34359738368 \u2506 32768 \u2506 112 \u2506 129 \u2506 c \u2506 0.12 \u2506 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_shuffle/","text":"Shuffle Format Method Expr_shuffle ( seed = NULL ) Arguments seed : numeric value of 0 to 2^52 Seed for the random number generator. If set to Null (default), a random seed value intergish value between 0 and 10000 is picked Returns Expr Shuffle the contents of this expr. Examples pl $ DataFrame ( a = 1 : 3 ) $ select ( pl $ col ( \"a\" ) $ shuffle ( seed = 1 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2 \u2502 #> \u2502 1 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_shuffle"},{"location":"reference/Expr_shuffle/#shuffle","text":"","title":"Shuffle"},{"location":"reference/Expr_shuffle/#format","text":"Method Expr_shuffle ( seed = NULL )","title":"Format"},{"location":"reference/Expr_shuffle/#arguments","text":"seed : numeric value of 0 to 2^52 Seed for the random number generator. If set to Null (default), a random seed value intergish value between 0 and 10000 is picked","title":"Arguments"},{"location":"reference/Expr_shuffle/#returns","text":"Expr Shuffle the contents of this expr.","title":"Returns"},{"location":"reference/Expr_shuffle/#examples","text":"pl $ DataFrame ( a = 1 : 3 ) $ select ( pl $ col ( \"a\" ) $ shuffle ( seed = 1 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2 \u2502 #> \u2502 1 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_sign/","text":"data Sign Format Method Expr_sign Returns Expr Compute the element-wise indication of the sign. Examples pl $ DataFrame ( a = c ( .9 , - 0 , 0 , 4 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ sign ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 0 \u2502 #> \u2502 0 \u2502 #> \u2502 1 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_sign"},{"location":"reference/Expr_sign/#sign","text":"","title":"Sign"},{"location":"reference/Expr_sign/#format","text":"Method Expr_sign","title":"Format"},{"location":"reference/Expr_sign/#returns","text":"Expr Compute the element-wise indication of the sign.","title":"Returns"},{"location":"reference/Expr_sign/#examples","text":"pl $ DataFrame ( a = c ( .9 , - 0 , 0 , 4 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ sign ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 0 \u2502 #> \u2502 0 \u2502 #> \u2502 1 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_sin/","text":"data Sin Format Method Expr_sin Returns Expr Compute the element-wise value for the sine. Details Evaluated Series has dtype Float64 Examples pl $ DataFrame ( a = c ( 0 , pi / 2 , pi , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ sin ( ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 1.2246e-16 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_sin"},{"location":"reference/Expr_sin/#sin","text":"","title":"Sin"},{"location":"reference/Expr_sin/#format","text":"Method Expr_sin","title":"Format"},{"location":"reference/Expr_sin/#returns","text":"Expr Compute the element-wise value for the sine.","title":"Returns"},{"location":"reference/Expr_sin/#details","text":"Evaluated Series has dtype Float64","title":"Details"},{"location":"reference/Expr_sin/#examples","text":"pl $ DataFrame ( a = c ( 0 , pi / 2 , pi , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ sin ( ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 1.2246e-16 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_sinh/","text":"data Sinh Format Method Expr_sinh Returns Expr Compute the element-wise value for the hyperbolic sine. Details Evaluated Series has dtype Float64 Examples pl $ DataFrame ( a = c ( - 1 , asinh ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ sinh ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -1.175201 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.0 \u2502 #> \u2502 1.175201 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_sinh"},{"location":"reference/Expr_sinh/#sinh","text":"","title":"Sinh"},{"location":"reference/Expr_sinh/#format","text":"Method Expr_sinh","title":"Format"},{"location":"reference/Expr_sinh/#returns","text":"Expr Compute the element-wise value for the hyperbolic sine.","title":"Returns"},{"location":"reference/Expr_sinh/#details","text":"Evaluated Series has dtype Float64","title":"Details"},{"location":"reference/Expr_sinh/#examples","text":"pl $ DataFrame ( a = c ( - 1 , asinh ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ sinh ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -1.175201 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.0 \u2502 #> \u2502 1.175201 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_skew/","text":"Skewness Expr_skew ( bias = TRUE ) Arguments bias : If False, then the calculations are corrected for statistical bias. Returns Expr Compute the sample skewness of a data set. Details For normally distributed data, the skewness should be about zero. For unimodal continuous distributions, a skewness value greater than zero means that there is more weight in the right tail of the distribution. The function skewtest can be used to determine if the skewness value is close enough to zero, statistically speaking. See scipy.stats for more information. Examples df = pl $ DataFrame ( list ( a = c ( 1 : 3 , 2 : 1 ) ) ) df $ select ( pl $ col ( \"a\" ) $ skew ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.343622 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_skew"},{"location":"reference/Expr_skew/#skewness","text":"Expr_skew ( bias = TRUE )","title":"Skewness"},{"location":"reference/Expr_skew/#arguments","text":"bias : If False, then the calculations are corrected for statistical bias.","title":"Arguments"},{"location":"reference/Expr_skew/#returns","text":"Expr Compute the sample skewness of a data set.","title":"Returns"},{"location":"reference/Expr_skew/#details","text":"For normally distributed data, the skewness should be about zero. For unimodal continuous distributions, a skewness value greater than zero means that there is more weight in the right tail of the distribution. The function skewtest can be used to determine if the skewness value is close enough to zero, statistically speaking. See scipy.stats for more information.","title":"Details"},{"location":"reference/Expr_skew/#examples","text":"df = pl $ DataFrame ( list ( a = c ( 1 : 3 , 2 : 1 ) ) ) df $ select ( pl $ col ( \"a\" ) $ skew ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.343622 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_slice/","text":"Get a slice of this expression. Format a method Expr_slice ( offset , length = NULL ) Arguments offset : numeric or expression, zero-indexed where to start slice negative value indicate starting (one-indexed) from back length : how many elements should slice contain, default NULL is max length Returns Expr Get a slice of this expression. Examples #as head pl $ DataFrame ( list ( a = 0 : 100 ) ) $ select ( pl $ all ( ) $ slice ( 0 , 6 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0 \u2502 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2502 4 \u2502 #> \u2502 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 #as tail pl $ DataFrame ( list ( a = 0 : 100 ) ) $ select ( pl $ all ( ) $ slice ( - 6 , 6 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 95 \u2502 #> \u2502 96 \u2502 #> \u2502 97 \u2502 #> \u2502 98 \u2502 #> \u2502 99 \u2502 #> \u2502 100 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( list ( a = 0 : 100 ) ) $ select ( pl $ all ( ) $ slice ( 80 ) ) #> polars DataFrame: shape: (21, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 80 \u2502 #> \u2502 81 \u2502 #> \u2502 82 \u2502 #> \u2502 83 \u2502 #> \u2502 ... \u2502 #> \u2502 97 \u2502 #> \u2502 98 \u2502 #> \u2502 99 \u2502 #> \u2502 100 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_slice"},{"location":"reference/Expr_slice/#get-a-slice-of-this-expression","text":"","title":"Get a slice of this expression."},{"location":"reference/Expr_slice/#format","text":"a method Expr_slice ( offset , length = NULL )","title":"Format"},{"location":"reference/Expr_slice/#arguments","text":"offset : numeric or expression, zero-indexed where to start slice negative value indicate starting (one-indexed) from back length : how many elements should slice contain, default NULL is max length","title":"Arguments"},{"location":"reference/Expr_slice/#returns","text":"Expr Get a slice of this expression.","title":"Returns"},{"location":"reference/Expr_slice/#examples","text":"#as head pl $ DataFrame ( list ( a = 0 : 100 ) ) $ select ( pl $ all ( ) $ slice ( 0 , 6 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0 \u2502 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2502 4 \u2502 #> \u2502 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 #as tail pl $ DataFrame ( list ( a = 0 : 100 ) ) $ select ( pl $ all ( ) $ slice ( - 6 , 6 ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 95 \u2502 #> \u2502 96 \u2502 #> \u2502 97 \u2502 #> \u2502 98 \u2502 #> \u2502 99 \u2502 #> \u2502 100 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( list ( a = 0 : 100 ) ) $ select ( pl $ all ( ) $ slice ( 80 ) ) #> polars DataFrame: shape: (21, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 80 \u2502 #> \u2502 81 \u2502 #> \u2502 82 \u2502 #> \u2502 83 \u2502 #> \u2502 ... \u2502 #> \u2502 97 \u2502 #> \u2502 98 \u2502 #> \u2502 99 \u2502 #> \u2502 100 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_sort/","text":"Expr_sort Format a method Expr_sort ( reverse = FALSE , nulls_last = FALSE ) Arguments reverse : bool default FALSE, reverses sort nulls_last : bool, default FALSE, place Nulls last Returns Expr Sort this column. In projection/ selection context the whole column is sorted. If used in a groupby context, the groups are sorted. Details See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( a = c ( 6 , 1 , 0 , NA , Inf , NaN ) ) ) $ select ( pl $ col ( \"a\" ) $ sort ( ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 0.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 6.0 \u2502 #> \u2502 inf \u2502 #> \u2502 NaN \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_sort"},{"location":"reference/Expr_sort/#expr_sort","text":"","title":"Expr_sort"},{"location":"reference/Expr_sort/#format","text":"a method Expr_sort ( reverse = FALSE , nulls_last = FALSE )","title":"Format"},{"location":"reference/Expr_sort/#arguments","text":"reverse : bool default FALSE, reverses sort nulls_last : bool, default FALSE, place Nulls last","title":"Arguments"},{"location":"reference/Expr_sort/#returns","text":"Expr Sort this column. In projection/ selection context the whole column is sorted. If used in a groupby context, the groups are sorted.","title":"Returns"},{"location":"reference/Expr_sort/#details","text":"See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_sort/#examples","text":"pl $ DataFrame ( list ( a = c ( 6 , 1 , 0 , NA , Inf , NaN ) ) ) $ select ( pl $ col ( \"a\" ) $ sort ( ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2502 #> \u2502 0.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 6.0 \u2502 #> \u2502 inf \u2502 #> \u2502 NaN \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_sort_by/","text":"sort column by order of others Format a method Expr_sort_by ( by , reverse = FALSE ) Arguments by : one expression or list expressions and/or strings(interpreted as column names) reverse : single bool to boolean vector, any is_TRUE will give reverse sorting of that column Returns Expr Sort this column by the ordering of another column, or multiple other columns. Details In projection/ selection context the whole column is sorted. If used in a groupby context, the groups are sorted. See Inf,NaN,NULL,Null/NA translations here docs_translations Examples df = pl $ DataFrame ( list ( group = c ( \"a\" , \"a\" , \"a\" , \"b\" , \"b\" , \"b\" ) , value1 = c ( 98 , 1 , 3 , 2 , 99 , 100 ) , value2 = c ( \"d\" , \"f\" , \"b\" , \"e\" , \"c\" , \"a\" ) ) ) # by one column/expression df $ select ( pl $ col ( \"group\" ) $ sort_by ( \"value1\" ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 group \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 a \u2502 #> \u2502 b \u2502 #> \u2502 a \u2502 #> \u2502 a \u2502 #> \u2502 b \u2502 #> \u2502 b \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 # by two columns/expressions df $ select ( pl $ col ( \"group\" ) $ sort_by ( list ( \"value2\" , pl $ col ( \"value1\" ) ) , reverse = c ( TRUE , FALSE ) ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 group \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 a \u2502 #> \u2502 b \u2502 #> \u2502 a \u2502 #> \u2502 b \u2502 #> \u2502 a \u2502 #> \u2502 b \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 # by some expression df $ select ( pl $ col ( \"group\" ) $ sort_by ( pl $ col ( \"value1\" ) $ sort ( reverse = TRUE ) ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 group \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 b \u2502 #> \u2502 b \u2502 #> \u2502 b \u2502 #> \u2502 a \u2502 #> \u2502 a \u2502 #> \u2502 a \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #quite similar usecase as R function `order()` l = list ( ab = c ( rep ( \"a\" , 6 ) , rep ( \"b\" , 6 ) ) , v4 = rep ( 1 : 4 , 3 ) , v3 = rep ( 1 : 3 , 4 ) , v2 = rep ( 1 : 2 , 6 ) , v1 = 1 : 12 ) df = pl $ DataFrame ( l ) #examples of order versus sort_by all.equal ( df $ select ( pl $ col ( \"ab\" ) $ sort_by ( \"v4\" ) $ alias ( \"ab4\" ) , pl $ col ( \"ab\" ) $ sort_by ( \"v3\" ) $ alias ( \"ab3\" ) , pl $ col ( \"ab\" ) $ sort_by ( \"v2\" ) $ alias ( \"ab2\" ) , pl $ col ( \"ab\" ) $ sort_by ( \"v1\" ) $ alias ( \"ab1\" ) , pl $ col ( \"ab\" ) $ sort_by ( list ( \"v3\" , pl $ col ( \"v1\" ) ) ,reverse = c ( FALSE , TRUE ) ) $ alias ( \"ab13FT\" ) , pl $ col ( \"ab\" ) $ sort_by ( list ( \"v3\" , pl $ col ( \"v1\" ) ) ,reverse = TRUE ) $ alias ( \"ab13T\" ) ) $ to_list ( ) , list ( ab4 = l $ ab [ order ( l $ v4 ) ] , ab3 = l $ ab [ order ( l $ v3 ) ] , ab2 = l $ ab [ order ( l $ v2 ) ] , ab1 = l $ ab [ order ( l $ v1 ) ] , ab13FT = l $ ab [ order ( l $ v3 , rev ( l $ v1 ) ) ] , ab13T = l $ ab [ order ( l $ v3 , l $ v1 ,decreasing = TRUE ) ] ) ) #> [1] TRUE","title":"Expr_sort_by"},{"location":"reference/Expr_sort_by/#sort-column-by-order-of-others","text":"","title":"sort column by order of others"},{"location":"reference/Expr_sort_by/#format","text":"a method Expr_sort_by ( by , reverse = FALSE )","title":"Format"},{"location":"reference/Expr_sort_by/#arguments","text":"by : one expression or list expressions and/or strings(interpreted as column names) reverse : single bool to boolean vector, any is_TRUE will give reverse sorting of that column","title":"Arguments"},{"location":"reference/Expr_sort_by/#returns","text":"Expr Sort this column by the ordering of another column, or multiple other columns.","title":"Returns"},{"location":"reference/Expr_sort_by/#details","text":"In projection/ selection context the whole column is sorted. If used in a groupby context, the groups are sorted. See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_sort_by/#examples","text":"df = pl $ DataFrame ( list ( group = c ( \"a\" , \"a\" , \"a\" , \"b\" , \"b\" , \"b\" ) , value1 = c ( 98 , 1 , 3 , 2 , 99 , 100 ) , value2 = c ( \"d\" , \"f\" , \"b\" , \"e\" , \"c\" , \"a\" ) ) ) # by one column/expression df $ select ( pl $ col ( \"group\" ) $ sort_by ( \"value1\" ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 group \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 a \u2502 #> \u2502 b \u2502 #> \u2502 a \u2502 #> \u2502 a \u2502 #> \u2502 b \u2502 #> \u2502 b \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 # by two columns/expressions df $ select ( pl $ col ( \"group\" ) $ sort_by ( list ( \"value2\" , pl $ col ( \"value1\" ) ) , reverse = c ( TRUE , FALSE ) ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 group \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 a \u2502 #> \u2502 b \u2502 #> \u2502 a \u2502 #> \u2502 b \u2502 #> \u2502 a \u2502 #> \u2502 b \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 # by some expression df $ select ( pl $ col ( \"group\" ) $ sort_by ( pl $ col ( \"value1\" ) $ sort ( reverse = TRUE ) ) ) #> polars DataFrame: shape: (6, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 group \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 b \u2502 #> \u2502 b \u2502 #> \u2502 b \u2502 #> \u2502 a \u2502 #> \u2502 a \u2502 #> \u2502 a \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #quite similar usecase as R function `order()` l = list ( ab = c ( rep ( \"a\" , 6 ) , rep ( \"b\" , 6 ) ) , v4 = rep ( 1 : 4 , 3 ) , v3 = rep ( 1 : 3 , 4 ) , v2 = rep ( 1 : 2 , 6 ) , v1 = 1 : 12 ) df = pl $ DataFrame ( l ) #examples of order versus sort_by all.equal ( df $ select ( pl $ col ( \"ab\" ) $ sort_by ( \"v4\" ) $ alias ( \"ab4\" ) , pl $ col ( \"ab\" ) $ sort_by ( \"v3\" ) $ alias ( \"ab3\" ) , pl $ col ( \"ab\" ) $ sort_by ( \"v2\" ) $ alias ( \"ab2\" ) , pl $ col ( \"ab\" ) $ sort_by ( \"v1\" ) $ alias ( \"ab1\" ) , pl $ col ( \"ab\" ) $ sort_by ( list ( \"v3\" , pl $ col ( \"v1\" ) ) ,reverse = c ( FALSE , TRUE ) ) $ alias ( \"ab13FT\" ) , pl $ col ( \"ab\" ) $ sort_by ( list ( \"v3\" , pl $ col ( \"v1\" ) ) ,reverse = TRUE ) $ alias ( \"ab13T\" ) ) $ to_list ( ) , list ( ab4 = l $ ab [ order ( l $ v4 ) ] , ab3 = l $ ab [ order ( l $ v3 ) ] , ab2 = l $ ab [ order ( l $ v2 ) ] , ab1 = l $ ab [ order ( l $ v1 ) ] , ab13FT = l $ ab [ order ( l $ v3 , rev ( l $ v1 ) ) ] , ab13T = l $ ab [ order ( l $ v3 , l $ v1 ,decreasing = TRUE ) ] ) ) #> [1] TRUE","title":"Examples"},{"location":"reference/Expr_sqrt/","text":"Square root Expr_sqrt () Returns Expr Compute the square root of the elements. Examples pl $ DataFrame ( list ( a = - 1 : 3 ) ) $ select ( pl $ col ( \"a\" ) $ sqrt ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 NaN \u2502 #> \u2502 0.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 1.414214 \u2502 #> \u2502 1.732051 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_sqrt"},{"location":"reference/Expr_sqrt/#square-root","text":"Expr_sqrt ()","title":"Square root"},{"location":"reference/Expr_sqrt/#returns","text":"Expr Compute the square root of the elements.","title":"Returns"},{"location":"reference/Expr_sqrt/#examples","text":"pl $ DataFrame ( list ( a = - 1 : 3 ) ) $ select ( pl $ col ( \"a\" ) $ sqrt ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 NaN \u2502 #> \u2502 0.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 1.414214 \u2502 #> \u2502 1.732051 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_std/","text":"Get Standard Deviation Format a method Expr_std ( ddof = 1 ) Arguments ddof : integer in range [0;255] degrees of freedom Returns Expr (f64 scalar) Get Standard Deviation Examples pl $ select ( pl $ lit ( 1 : 5 ) $ std ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.581139 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_std"},{"location":"reference/Expr_std/#get-standard-deviation","text":"","title":"Get Standard Deviation"},{"location":"reference/Expr_std/#format","text":"a method Expr_std ( ddof = 1 )","title":"Format"},{"location":"reference/Expr_std/#arguments","text":"ddof : integer in range [0;255] degrees of freedom","title":"Arguments"},{"location":"reference/Expr_std/#returns","text":"Expr (f64 scalar) Get Standard Deviation","title":"Returns"},{"location":"reference/Expr_std/#examples","text":"pl $ select ( pl $ lit ( 1 : 5 ) $ std ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.581139 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_str/","text":"str: string related methods Expr_str () Returns Expr Create an object namespace of all string related methods. See the individual method pages for full details Examples #missing","title":"Expr_str"},{"location":"reference/Expr_str/#str-string-related-methods","text":"Expr_str ()","title":"str: string related methods"},{"location":"reference/Expr_str/#returns","text":"Expr Create an object namespace of all string related methods. See the individual method pages for full details","title":"Returns"},{"location":"reference/Expr_str/#examples","text":"#missing","title":"Examples"},{"location":"reference/Expr_struct/","text":"struct: related methods Expr_struct () Returns Expr Create an object namespace of all struct related methods. See the individual method pages for full details Examples #missing","title":"Expr_struct"},{"location":"reference/Expr_struct/#struct-related-methods","text":"Expr_struct ()","title":"struct: related methods"},{"location":"reference/Expr_struct/#returns","text":"Expr Create an object namespace of all struct related methods. See the individual method pages for full details","title":"Returns"},{"location":"reference/Expr_struct/#examples","text":"#missing","title":"Examples"},{"location":"reference/Expr_sub/","text":"Sub Expr_sub ( other ) ## S3 method for class 'Expr' e1 - e2 Arguments other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression Returns Exprs Substract Examples #three syntaxes same result pl $ lit ( 5 ) - 10 #> polars Expr: [(5f64) - (10f64)] pl $ lit ( 5 ) - pl $ lit ( 10 ) #> polars Expr: [(5f64) - (10f64)] pl $ lit ( 5 ) $ sub ( pl $ lit ( 10 ) ) #> polars Expr: [(5f64) - (10f64)] - pl $ lit ( 5 ) #> polars Expr: [(0i32) - (5f64)]","title":"Expr_sub"},{"location":"reference/Expr_sub/#sub","text":"Expr_sub ( other ) ## S3 method for class 'Expr' e1 - e2","title":"Sub"},{"location":"reference/Expr_sub/#arguments","text":"other : literal or Robj which can become a literal e1 : lhs Expr e2 : rhs Expr or anything which can become a literal Expression","title":"Arguments"},{"location":"reference/Expr_sub/#returns","text":"Exprs Substract","title":"Returns"},{"location":"reference/Expr_sub/#examples","text":"#three syntaxes same result pl $ lit ( 5 ) - 10 #> polars Expr: [(5f64) - (10f64)] pl $ lit ( 5 ) - pl $ lit ( 10 ) #> polars Expr: [(5f64) - (10f64)] pl $ lit ( 5 ) $ sub ( pl $ lit ( 10 ) ) #> polars Expr: [(5f64) - (10f64)] - pl $ lit ( 5 ) #> polars Expr: [(0i32) - (5f64)]","title":"Examples"},{"location":"reference/Expr_sum/","text":"data sum Format An object of class character of length 1. Expr_sum Returns Expr Get sum value Details Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues. Examples pl $ DataFrame ( list ( x = c ( 1L , NA , 2L ) ) ) $ select ( pl $ col ( \"x\" ) $ sum ( ) ) #is i32 3 (Int32 not casted) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_sum"},{"location":"reference/Expr_sum/#sum","text":"","title":"sum"},{"location":"reference/Expr_sum/#format","text":"An object of class character of length 1. Expr_sum","title":"Format"},{"location":"reference/Expr_sum/#returns","text":"Expr Get sum value","title":"Returns"},{"location":"reference/Expr_sum/#details","text":"Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues.","title":"Details"},{"location":"reference/Expr_sum/#examples","text":"pl $ DataFrame ( list ( x = c ( 1L , NA , 2L ) ) ) $ select ( pl $ col ( \"x\" ) $ sum ( ) ) #is i32 3 (Int32 not casted) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_tail/","text":"Tail Expr_tail ( n = 10 ) Arguments n : numeric number of elements to select from tail Returns Expr Get the tail n elements. Similar to R tail(x) Examples #get 3 last elements pl $ DataFrame ( list ( x = 1 : 11 ) ) $ select ( pl $ col ( \"x\" ) $ tail ( 3 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 9 \u2502 #> \u2502 10 \u2502 #> \u2502 11 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_tail"},{"location":"reference/Expr_tail/#tail","text":"Expr_tail ( n = 10 )","title":"Tail"},{"location":"reference/Expr_tail/#arguments","text":"n : numeric number of elements to select from tail","title":"Arguments"},{"location":"reference/Expr_tail/#returns","text":"Expr Get the tail n elements. Similar to R tail(x)","title":"Returns"},{"location":"reference/Expr_tail/#examples","text":"#get 3 last elements pl $ DataFrame ( list ( x = 1 : 11 ) ) $ select ( pl $ col ( \"x\" ) $ tail ( 3 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 x \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 9 \u2502 #> \u2502 10 \u2502 #> \u2502 11 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_take/","text":"Take values by index. Format a method Expr_take ( indices ) Arguments indices : R scalar/vector or Series, or Expr that leads to a UInt32 dtyped Series. Returns Expr Take values by index. Details similar to R indexing syntax e.g. letters[c(1,3,5)] , however as an expression, not as eager computation exceeding Examples pl $ select ( pl $ lit ( 0 : 10 ) $ take ( c ( 1 , 8 , 0 , 7 ) ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 8 \u2502 #> \u2502 0 \u2502 #> \u2502 7 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_take"},{"location":"reference/Expr_take/#take-values-by-index","text":"","title":"Take values by index."},{"location":"reference/Expr_take/#format","text":"a method Expr_take ( indices )","title":"Format"},{"location":"reference/Expr_take/#arguments","text":"indices : R scalar/vector or Series, or Expr that leads to a UInt32 dtyped Series.","title":"Arguments"},{"location":"reference/Expr_take/#returns","text":"Expr Take values by index.","title":"Returns"},{"location":"reference/Expr_take/#details","text":"similar to R indexing syntax e.g. letters[c(1,3,5)] , however as an expression, not as eager computation exceeding","title":"Details"},{"location":"reference/Expr_take/#examples","text":"pl $ select ( pl $ lit ( 0 : 10 ) $ take ( c ( 1 , 8 , 0 , 7 ) ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 8 \u2502 #> \u2502 0 \u2502 #> \u2502 7 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_take_every/","text":"Take every n'th element Format a method Expr_take_every ( n ) Arguments n : positive integerish value Returns Expr Take every nth value in the Series and return as a new Series. Examples pl $ DataFrame ( list ( a = 0 : 24 ) ) $ select ( pl $ col ( \"a\" ) $ take_every ( 6 ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0 \u2502 #> \u2502 6 \u2502 #> \u2502 12 \u2502 #> \u2502 18 \u2502 #> \u2502 24 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_take_every"},{"location":"reference/Expr_take_every/#take-every-nth-element","text":"","title":"Take every n'th element"},{"location":"reference/Expr_take_every/#format","text":"a method Expr_take_every ( n )","title":"Format"},{"location":"reference/Expr_take_every/#arguments","text":"n : positive integerish value","title":"Arguments"},{"location":"reference/Expr_take_every/#returns","text":"Expr Take every nth value in the Series and return as a new Series.","title":"Returns"},{"location":"reference/Expr_take_every/#examples","text":"pl $ DataFrame ( list ( a = 0 : 24 ) ) $ select ( pl $ col ( \"a\" ) $ take_every ( 6 ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0 \u2502 #> \u2502 6 \u2502 #> \u2502 12 \u2502 #> \u2502 18 \u2502 #> \u2502 24 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_tan/","text":"data Tan Format Method Expr_tan Returns Expr Compute the element-wise value for the tangent. Details Evaluated Series has dtype Float64 Examples pl $ DataFrame ( a = c ( 0 , pi / 2 , pi , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ tan ( ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.0 \u2502 #> \u2502 1.6331e16 \u2502 #> \u2502 -1.2246e-16 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_tan"},{"location":"reference/Expr_tan/#tan","text":"","title":"Tan"},{"location":"reference/Expr_tan/#format","text":"Method Expr_tan","title":"Format"},{"location":"reference/Expr_tan/#returns","text":"Expr Compute the element-wise value for the tangent.","title":"Returns"},{"location":"reference/Expr_tan/#details","text":"Evaluated Series has dtype Float64","title":"Details"},{"location":"reference/Expr_tan/#examples","text":"pl $ DataFrame ( a = c ( 0 , pi / 2 , pi , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ tan ( ) ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0.0 \u2502 #> \u2502 1.6331e16 \u2502 #> \u2502 -1.2246e-16 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_tanh/","text":"data Tanh Format Method Expr_tanh Returns Expr Compute the element-wise value for the hyperbolic tangent. Details Evaluated Series has dtype Float64 Examples pl $ DataFrame ( a = c ( - 1 , atanh ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ tanh ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -0.761594 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.0 \u2502 #> \u2502 0.761594 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_tanh"},{"location":"reference/Expr_tanh/#tanh","text":"","title":"Tanh"},{"location":"reference/Expr_tanh/#format","text":"Method Expr_tanh","title":"Format"},{"location":"reference/Expr_tanh/#returns","text":"Expr Compute the element-wise value for the hyperbolic tangent.","title":"Returns"},{"location":"reference/Expr_tanh/#details","text":"Evaluated Series has dtype Float64","title":"Details"},{"location":"reference/Expr_tanh/#examples","text":"pl $ DataFrame ( a = c ( - 1 , atanh ( 0.5 ) , 0 , 1 , NA_real_ ) ) $ select ( pl $ col ( \"a\" ) $ tanh ( ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -0.761594 \u2502 #> \u2502 0.5 \u2502 #> \u2502 0.0 \u2502 #> \u2502 0.761594 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_to_physical/","text":"data To physical representation Format An object of class character of length 1. Expr_to_physical Returns Expr expression request underlying physical base representation Examples pl $ DataFrame ( list ( vals = c ( \"a\" , \"x\" , NA , \"a\" ) ) ) $ with_columns ( pl $ col ( \"vals\" ) $ cast ( pl $ Categorical ) , pl $ col ( \"vals\" ) $ cast ( pl $ Categorical ) $ to_physical ( ) $ alias ( \"vals_physical\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 vals \u2506 vals_physical \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 cat \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 a \u2506 0 \u2502 #> \u2502 x \u2506 1 \u2502 #> \u2502 null \u2506 null \u2502 #> \u2502 a \u2506 0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_to_physical"},{"location":"reference/Expr_to_physical/#to-physical-representation","text":"","title":"To physical representation"},{"location":"reference/Expr_to_physical/#format","text":"An object of class character of length 1. Expr_to_physical","title":"Format"},{"location":"reference/Expr_to_physical/#returns","text":"Expr expression request underlying physical base representation","title":"Returns"},{"location":"reference/Expr_to_physical/#examples","text":"pl $ DataFrame ( list ( vals = c ( \"a\" , \"x\" , NA , \"a\" ) ) ) $ with_columns ( pl $ col ( \"vals\" ) $ cast ( pl $ Categorical ) , pl $ col ( \"vals\" ) $ cast ( pl $ Categorical ) $ to_physical ( ) $ alias ( \"vals_physical\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 vals \u2506 vals_physical \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 cat \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 a \u2506 0 \u2502 #> \u2502 x \u2506 1 \u2502 #> \u2502 null \u2506 null \u2502 #> \u2502 a \u2506 0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_to_r/","text":"to_r: for debuging an expression Format Method Expr_to_r ( df = NULL , i = 0 ) Arguments df : otherwise a DataFrame to evaluate in, default NULL is an empty DataFrame i : numeric column to extract zero index default first, expression could generate multiple columns Returns R object debug an expression by evaluating in empty DataFrame and return first series to R Examples pl $ lit ( 1 : 3 ) $ to_r ( ) #> [1] 1 2 3 pl $ expr_to_r ( pl $ lit ( 1 : 3 ) ) #> [1] 1 2 3 pl $ expr_to_r ( 1 : 3 ) #> [1] 1 2 3","title":"Expr_to_r"},{"location":"reference/Expr_to_r/#to_r-for-debuging-an-expression","text":"","title":"to_r: for debuging an expression"},{"location":"reference/Expr_to_r/#format","text":"Method Expr_to_r ( df = NULL , i = 0 )","title":"Format"},{"location":"reference/Expr_to_r/#arguments","text":"df : otherwise a DataFrame to evaluate in, default NULL is an empty DataFrame i : numeric column to extract zero index default first, expression could generate multiple columns","title":"Arguments"},{"location":"reference/Expr_to_r/#returns","text":"R object debug an expression by evaluating in empty DataFrame and return first series to R","title":"Returns"},{"location":"reference/Expr_to_r/#examples","text":"pl $ lit ( 1 : 3 ) $ to_r ( ) #> [1] 1 2 3 pl $ expr_to_r ( pl $ lit ( 1 : 3 ) ) #> [1] 1 2 3 pl $ expr_to_r ( 1 : 3 ) #> [1] 1 2 3","title":"Examples"},{"location":"reference/Expr_to_struct/","text":"to_struct Expr_to_struct () Returns Expr pass expr to pl$struct Examples e = pl $ all ( ) $ to_struct ( ) $ alias ( \"my_struct\" ) print ( e ) #> polars Expr: *.as_struct().alias(\"my_struct\") pl $ DataFrame ( iris ) $ select ( e ) #> polars DataFrame: shape: (150, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 my_struct \u2502 #> \u2502 --- \u2502 #> \u2502 struct[5] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {5.1,3.5,1.4,0.2,\"setosa\"} \u2502 #> \u2502 {4.9,3.0,1.4,0.2,\"setosa\"} \u2502 #> \u2502 {4.7,3.2,1.3,0.2,\"setosa\"} \u2502 #> \u2502 {4.6,3.1,1.5,0.2,\"setosa\"} \u2502 #> \u2502 ... \u2502 #> \u2502 {6.3,2.5,5.0,1.9,\"virginica\"} \u2502 #> \u2502 {6.5,3.0,5.2,2.0,\"virginica\"} \u2502 #> \u2502 {6.2,3.4,5.4,2.3,\"virginica\"} \u2502 #> \u2502 {5.9,3.0,5.1,1.8,\"virginica\"} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_to_struct"},{"location":"reference/Expr_to_struct/#to_struct","text":"Expr_to_struct ()","title":"to_struct"},{"location":"reference/Expr_to_struct/#returns","text":"Expr pass expr to pl$struct","title":"Returns"},{"location":"reference/Expr_to_struct/#examples","text":"e = pl $ all ( ) $ to_struct ( ) $ alias ( \"my_struct\" ) print ( e ) #> polars Expr: *.as_struct().alias(\"my_struct\") pl $ DataFrame ( iris ) $ select ( e ) #> polars DataFrame: shape: (150, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 my_struct \u2502 #> \u2502 --- \u2502 #> \u2502 struct[5] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {5.1,3.5,1.4,0.2,\"setosa\"} \u2502 #> \u2502 {4.9,3.0,1.4,0.2,\"setosa\"} \u2502 #> \u2502 {4.7,3.2,1.3,0.2,\"setosa\"} \u2502 #> \u2502 {4.6,3.1,1.5,0.2,\"setosa\"} \u2502 #> \u2502 ... \u2502 #> \u2502 {6.3,2.5,5.0,1.9,\"virginica\"} \u2502 #> \u2502 {6.5,3.0,5.2,2.0,\"virginica\"} \u2502 #> \u2502 {6.2,3.4,5.4,2.3,\"virginica\"} \u2502 #> \u2502 {5.9,3.0,5.1,1.8,\"virginica\"} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_top_k/","text":"Top k values Format a method Expr_top_k ( k , reverse = FALSE ) Arguments k : numeric k top values to get reverse : bool if true then k smallest values Returns Expr Return the k largest elements. If 'reverse=True` the smallest elements will be given. Details This has time complexity: O(n + k \\\\log{}n - \\frac{k}{2}) See Inf,NaN,NULL,Null/NA translations here docs_translations Examples pl $ DataFrame ( list ( a = c ( 6 , 1 , 0 , NA , Inf , NaN ) ) ) $ select ( pl $ col ( \"a\" ) $ top_k ( 5 ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 NaN \u2502 #> \u2502 inf \u2502 #> \u2502 6.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 0.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_top_k"},{"location":"reference/Expr_top_k/#top-k-values","text":"","title":"Top k values"},{"location":"reference/Expr_top_k/#format","text":"a method Expr_top_k ( k , reverse = FALSE )","title":"Format"},{"location":"reference/Expr_top_k/#arguments","text":"k : numeric k top values to get reverse : bool if true then k smallest values","title":"Arguments"},{"location":"reference/Expr_top_k/#returns","text":"Expr Return the k largest elements. If 'reverse=True` the smallest elements will be given.","title":"Returns"},{"location":"reference/Expr_top_k/#details","text":"This has time complexity: O(n + k \\\\log{}n - \\frac{k}{2}) See Inf,NaN,NULL,Null/NA translations here docs_translations","title":"Details"},{"location":"reference/Expr_top_k/#examples","text":"pl $ DataFrame ( list ( a = c ( 6 , 1 , 0 , NA , Inf , NaN ) ) ) $ select ( pl $ col ( \"a\" ) $ top_k ( 5 ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 NaN \u2502 #> \u2502 inf \u2502 #> \u2502 6.0 \u2502 #> \u2502 1.0 \u2502 #> \u2502 0.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_unique/","text":"get unqie values Expr_unique ( maintain_order = FALSE ) Arguments maintain_order : bool, if TRUE guranteed same order, if FALSE maybe Returns Expr Get unique values of this expression. Similar to R unique() Examples pl $ DataFrame ( iris ) $ select ( pl $ col ( \"Species\" ) $ unique ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Species \u2502 #> \u2502 --- \u2502 #> \u2502 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 setosa \u2502 #> \u2502 versicolor \u2502 #> \u2502 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_unique"},{"location":"reference/Expr_unique/#get-unqie-values","text":"Expr_unique ( maintain_order = FALSE )","title":"get unqie values"},{"location":"reference/Expr_unique/#arguments","text":"maintain_order : bool, if TRUE guranteed same order, if FALSE maybe","title":"Arguments"},{"location":"reference/Expr_unique/#returns","text":"Expr Get unique values of this expression. Similar to R unique()","title":"Returns"},{"location":"reference/Expr_unique/#examples","text":"pl $ DataFrame ( iris ) $ select ( pl $ col ( \"Species\" ) $ unique ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Species \u2502 #> \u2502 --- \u2502 #> \u2502 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 setosa \u2502 #> \u2502 versicolor \u2502 #> \u2502 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_unique_counts/","text":"data Value counts Format Method Expr_unique_counts Returns Expr Return a count of the unique values in the order of appearance. This method differs from value_counts in that it does not return the values, only the counts and might be faster Examples pl $ DataFrame ( iris ) $ select ( pl $ col ( \"Species\" ) $ unique_counts ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Species \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 50 \u2502 #> \u2502 50 \u2502 #> \u2502 50 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_unique_counts"},{"location":"reference/Expr_unique_counts/#value-counts","text":"","title":"Value counts"},{"location":"reference/Expr_unique_counts/#format","text":"Method Expr_unique_counts","title":"Format"},{"location":"reference/Expr_unique_counts/#returns","text":"Expr Return a count of the unique values in the order of appearance. This method differs from value_counts in that it does not return the values, only the counts and might be faster","title":"Returns"},{"location":"reference/Expr_unique_counts/#examples","text":"pl $ DataFrame ( iris ) $ select ( pl $ col ( \"Species\" ) $ unique_counts ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Species \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 50 \u2502 #> \u2502 50 \u2502 #> \u2502 50 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_upper_lower_bound/","text":"data Upper bound Format Method Method Expr_upper_bound Expr_lower_bound Returns Expr Calculate the upper/lower bound. Returns a unit Series with the highest value possible for the dtype of this expression. Details Notice lower bound i32 exported to R is NA_integer_ for now Examples pl $ DataFrame ( i32 = 1L ,f64 = 1 ) $ select ( pl $ all ( ) $ upper_bound ( ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 i32 \u2506 f64 \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2147483647 \u2506 inf \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( i32 = 1L ,f64 = 1 ) $ select ( pl $ all ( ) $ lower_bound ( ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 i32 \u2506 f64 \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -2147483648 \u2506 -inf \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_upper_lower_bound"},{"location":"reference/Expr_upper_lower_bound/#upper-bound","text":"","title":"Upper bound"},{"location":"reference/Expr_upper_lower_bound/#format","text":"Method Method Expr_upper_bound Expr_lower_bound","title":"Format"},{"location":"reference/Expr_upper_lower_bound/#returns","text":"Expr Calculate the upper/lower bound. Returns a unit Series with the highest value possible for the dtype of this expression.","title":"Returns"},{"location":"reference/Expr_upper_lower_bound/#details","text":"Notice lower bound i32 exported to R is NA_integer_ for now","title":"Details"},{"location":"reference/Expr_upper_lower_bound/#examples","text":"pl $ DataFrame ( i32 = 1L ,f64 = 1 ) $ select ( pl $ all ( ) $ upper_bound ( ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 i32 \u2506 f64 \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2147483647 \u2506 inf \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( i32 = 1L ,f64 = 1 ) $ select ( pl $ all ( ) $ lower_bound ( ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 i32 \u2506 f64 \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 -2147483648 \u2506 -inf \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_value_counts/","text":"Value counts Format Method Expr_value_counts ( multithreaded = FALSE , sort = FALSE ) Arguments multithreaded : Better to turn this off in the aggregation context, as it can lead to contention. sort : Ensure the output is sorted from most values to least. Returns Expr Count all unique values and create a struct mapping value to count. Examples df = pl $ DataFrame ( iris ) $ select ( pl $ col ( \"Species\" ) $ value_counts ( ) ) df #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Species \u2502 #> \u2502 --- \u2502 #> \u2502 struct[2] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {\"setosa\",50} \u2502 #> \u2502 {\"versicolor\",50} \u2502 #> \u2502 {\"virginica\",50} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ unnest ( ) $ as_data_frame ( ) #recommended to unnest structs before converting to R #> Species counts #> 1 setosa 50 #> 2 versicolor 50 #> 3 virginica 50","title":"Expr_value_counts"},{"location":"reference/Expr_value_counts/#value-counts","text":"","title":"Value counts"},{"location":"reference/Expr_value_counts/#format","text":"Method Expr_value_counts ( multithreaded = FALSE , sort = FALSE )","title":"Format"},{"location":"reference/Expr_value_counts/#arguments","text":"multithreaded : Better to turn this off in the aggregation context, as it can lead to contention. sort : Ensure the output is sorted from most values to least.","title":"Arguments"},{"location":"reference/Expr_value_counts/#returns","text":"Expr Count all unique values and create a struct mapping value to count.","title":"Returns"},{"location":"reference/Expr_value_counts/#examples","text":"df = pl $ DataFrame ( iris ) $ select ( pl $ col ( \"Species\" ) $ value_counts ( ) ) df #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Species \u2502 #> \u2502 --- \u2502 #> \u2502 struct[2] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {\"setosa\",50} \u2502 #> \u2502 {\"versicolor\",50} \u2502 #> \u2502 {\"virginica\",50} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ unnest ( ) $ as_data_frame ( ) #recommended to unnest structs before converting to R #> Species counts #> 1 setosa 50 #> 2 versicolor 50 #> 3 virginica 50","title":"Examples"},{"location":"reference/Expr_var/","text":"Get Variance Format a method Expr_var ( ddof = 1 ) Arguments ddof : integer in range [0;255] degrees of freedom Returns Expr (f64 scalar) Get Variance Examples pl $ select ( pl $ lit ( 1 : 5 ) $ var ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Expr_var"},{"location":"reference/Expr_var/#get-variance","text":"","title":"Get Variance"},{"location":"reference/Expr_var/#format","text":"a method Expr_var ( ddof = 1 )","title":"Format"},{"location":"reference/Expr_var/#arguments","text":"ddof : integer in range [0;255] degrees of freedom","title":"Arguments"},{"location":"reference/Expr_var/#returns","text":"Expr (f64 scalar) Get Variance","title":"Returns"},{"location":"reference/Expr_var/#examples","text":"pl $ select ( pl $ lit ( 1 : 5 ) $ var ( ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Expr_xor/","text":"data Xor Format An object of class character of length 1. Expr_xor ( other ) Arguments other : literal or Robj which can become a literal Returns Expr combine to boolean expresions with XOR Examples pl $ lit ( TRUE ) $ xor ( pl $ lit ( FALSE ) ) #> polars Expr: [(true) ^ (false)]","title":"Expr_xor"},{"location":"reference/Expr_xor/#xor","text":"","title":"Xor"},{"location":"reference/Expr_xor/#format","text":"An object of class character of length 1. Expr_xor ( other )","title":"Format"},{"location":"reference/Expr_xor/#arguments","text":"other : literal or Robj which can become a literal","title":"Arguments"},{"location":"reference/Expr_xor/#returns","text":"Expr combine to boolean expresions with XOR","title":"Returns"},{"location":"reference/Expr_xor/#examples","text":"pl $ lit ( TRUE ) $ xor ( pl $ lit ( FALSE ) ) #> polars Expr: [(true) ^ (false)]","title":"Examples"},{"location":"reference/GroupBy_agg/","text":"GroupBy Aggregate GroupBy_agg ( ... ) Arguments ... : exprs to aggregate Returns aggregated DataFrame Aggregatete a DataFrame over a groupby Examples pl $ DataFrame ( list ( foo = c ( \"one\" , \"two\" , \"two\" , \"one\" , \"two\" ) , bar = c ( 5 , 3 , 2 , 4 , 1 ) ) ) $ groupby ( \"foo\" ) $ agg ( pl $ col ( \"bar\" ) $ sum ( ) $ alias ( \"bar_sum\" ) , pl $ col ( \"bar\" ) $ mean ( ) $ alias ( \"bar_tail_sum\" ) ) #> polars DataFrame: shape: (2, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 bar_sum \u2506 bar_tail_sum \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 two \u2506 6.0 \u2506 2.0 \u2502 #> \u2502 one \u2506 9.0 \u2506 4.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"agg"},{"location":"reference/GroupBy_agg/#groupby-aggregate","text":"GroupBy_agg ( ... )","title":"GroupBy Aggregate"},{"location":"reference/GroupBy_agg/#arguments","text":"... : exprs to aggregate","title":"Arguments"},{"location":"reference/GroupBy_agg/#returns","text":"aggregated DataFrame Aggregatete a DataFrame over a groupby","title":"Returns"},{"location":"reference/GroupBy_agg/#examples","text":"pl $ DataFrame ( list ( foo = c ( \"one\" , \"two\" , \"two\" , \"one\" , \"two\" ) , bar = c ( 5 , 3 , 2 , 4 , 1 ) ) ) $ groupby ( \"foo\" ) $ agg ( pl $ col ( \"bar\" ) $ sum ( ) $ alias ( \"bar_sum\" ) , pl $ col ( \"bar\" ) $ mean ( ) $ alias ( \"bar_tail_sum\" ) ) #> polars DataFrame: shape: (2, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 bar_sum \u2506 bar_tail_sum \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 two \u2506 6.0 \u2506 2.0 \u2502 #> \u2502 one \u2506 9.0 \u2506 4.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/GroupBy_as_data_frame/","text":"convert to data.frame GroupBy_as_data_frame ( ... ) Arguments ... : any opt param passed to R as.data.frame Returns R data.frame convert to data.frame Examples pl $ DataFrame ( iris ) $ as_data_frame ( ) #R-polars back and forth #> Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 1 5.1 3.5 1.4 0.2 setosa #> 2 4.9 3.0 1.4 0.2 setosa #> 3 4.7 3.2 1.3 0.2 setosa #> 4 4.6 3.1 1.5 0.2 setosa #> 5 5.0 3.6 1.4 0.2 setosa #> 6 5.4 3.9 1.7 0.4 setosa #> 7 4.6 3.4 1.4 0.3 setosa #> 8 5.0 3.4 1.5 0.2 setosa #> 9 4.4 2.9 1.4 0.2 setosa #> 10 4.9 3.1 1.5 0.1 setosa #> 11 5.4 3.7 1.5 0.2 setosa #> 12 4.8 3.4 1.6 0.2 setosa #> 13 4.8 3.0 1.4 0.1 setosa #> 14 4.3 3.0 1.1 0.1 setosa #> 15 5.8 4.0 1.2 0.2 setosa #> 16 5.7 4.4 1.5 0.4 setosa #> 17 5.4 3.9 1.3 0.4 setosa #> 18 5.1 3.5 1.4 0.3 setosa #> 19 5.7 3.8 1.7 0.3 setosa #> 20 5.1 3.8 1.5 0.3 setosa #> 21 5.4 3.4 1.7 0.2 setosa #> 22 5.1 3.7 1.5 0.4 setosa #> 23 4.6 3.6 1.0 0.2 setosa #> 24 5.1 3.3 1.7 0.5 setosa #> 25 4.8 3.4 1.9 0.2 setosa #> 26 5.0 3.0 1.6 0.2 setosa #> 27 5.0 3.4 1.6 0.4 setosa #> 28 5.2 3.5 1.5 0.2 setosa #> 29 5.2 3.4 1.4 0.2 setosa #> 30 4.7 3.2 1.6 0.2 setosa #> 31 4.8 3.1 1.6 0.2 setosa #> 32 5.4 3.4 1.5 0.4 setosa #> 33 5.2 4.1 1.5 0.1 setosa #> 34 5.5 4.2 1.4 0.2 setosa #> 35 4.9 3.1 1.5 0.2 setosa #> 36 5.0 3.2 1.2 0.2 setosa #> 37 5.5 3.5 1.3 0.2 setosa #> 38 4.9 3.6 1.4 0.1 setosa #> 39 4.4 3.0 1.3 0.2 setosa #> 40 5.1 3.4 1.5 0.2 setosa #> 41 5.0 3.5 1.3 0.3 setosa #> 42 4.5 2.3 1.3 0.3 setosa #> 43 4.4 3.2 1.3 0.2 setosa #> 44 5.0 3.5 1.6 0.6 setosa #> 45 5.1 3.8 1.9 0.4 setosa #> 46 4.8 3.0 1.4 0.3 setosa #> 47 5.1 3.8 1.6 0.2 setosa #> 48 4.6 3.2 1.4 0.2 setosa #> 49 5.3 3.7 1.5 0.2 setosa #> 50 5.0 3.3 1.4 0.2 setosa #> 51 7.0 3.2 4.7 1.4 versicolor #> 52 6.4 3.2 4.5 1.5 versicolor #> 53 6.9 3.1 4.9 1.5 versicolor #> 54 5.5 2.3 4.0 1.3 versicolor #> 55 6.5 2.8 4.6 1.5 versicolor #> 56 5.7 2.8 4.5 1.3 versicolor #> 57 6.3 3.3 4.7 1.6 versicolor #> 58 4.9 2.4 3.3 1.0 versicolor #> 59 6.6 2.9 4.6 1.3 versicolor #> 60 5.2 2.7 3.9 1.4 versicolor #> 61 5.0 2.0 3.5 1.0 versicolor #> 62 5.9 3.0 4.2 1.5 versicolor #> 63 6.0 2.2 4.0 1.0 versicolor #> 64 6.1 2.9 4.7 1.4 versicolor #> 65 5.6 2.9 3.6 1.3 versicolor #> 66 6.7 3.1 4.4 1.4 versicolor #> 67 5.6 3.0 4.5 1.5 versicolor #> 68 5.8 2.7 4.1 1.0 versicolor #> 69 6.2 2.2 4.5 1.5 versicolor #> 70 5.6 2.5 3.9 1.1 versicolor #> 71 5.9 3.2 4.8 1.8 versicolor #> 72 6.1 2.8 4.0 1.3 versicolor #> 73 6.3 2.5 4.9 1.5 versicolor #> 74 6.1 2.8 4.7 1.2 versicolor #> 75 6.4 2.9 4.3 1.3 versicolor #> 76 6.6 3.0 4.4 1.4 versicolor #> 77 6.8 2.8 4.8 1.4 versicolor #> 78 6.7 3.0 5.0 1.7 versicolor #> 79 6.0 2.9 4.5 1.5 versicolor #> 80 5.7 2.6 3.5 1.0 versicolor #> 81 5.5 2.4 3.8 1.1 versicolor #> 82 5.5 2.4 3.7 1.0 versicolor #> 83 5.8 2.7 3.9 1.2 versicolor #> 84 6.0 2.7 5.1 1.6 versicolor #> 85 5.4 3.0 4.5 1.5 versicolor #> 86 6.0 3.4 4.5 1.6 versicolor #> 87 6.7 3.1 4.7 1.5 versicolor #> 88 6.3 2.3 4.4 1.3 versicolor #> 89 5.6 3.0 4.1 1.3 versicolor #> 90 5.5 2.5 4.0 1.3 versicolor #> 91 5.5 2.6 4.4 1.2 versicolor #> 92 6.1 3.0 4.6 1.4 versicolor #> 93 5.8 2.6 4.0 1.2 versicolor #> 94 5.0 2.3 3.3 1.0 versicolor #> 95 5.6 2.7 4.2 1.3 versicolor #> 96 5.7 3.0 4.2 1.2 versicolor #> 97 5.7 2.9 4.2 1.3 versicolor #> 98 6.2 2.9 4.3 1.3 versicolor #> 99 5.1 2.5 3.0 1.1 versicolor #> 100 5.7 2.8 4.1 1.3 versicolor #> 101 6.3 3.3 6.0 2.5 virginica #> 102 5.8 2.7 5.1 1.9 virginica #> 103 7.1 3.0 5.9 2.1 virginica #> 104 6.3 2.9 5.6 1.8 virginica #> 105 6.5 3.0 5.8 2.2 virginica #> 106 7.6 3.0 6.6 2.1 virginica #> 107 4.9 2.5 4.5 1.7 virginica #> 108 7.3 2.9 6.3 1.8 virginica #> 109 6.7 2.5 5.8 1.8 virginica #> 110 7.2 3.6 6.1 2.5 virginica #> 111 6.5 3.2 5.1 2.0 virginica #> 112 6.4 2.7 5.3 1.9 virginica #> 113 6.8 3.0 5.5 2.1 virginica #> 114 5.7 2.5 5.0 2.0 virginica #> 115 5.8 2.8 5.1 2.4 virginica #> 116 6.4 3.2 5.3 2.3 virginica #> 117 6.5 3.0 5.5 1.8 virginica #> 118 7.7 3.8 6.7 2.2 virginica #> 119 7.7 2.6 6.9 2.3 virginica #> 120 6.0 2.2 5.0 1.5 virginica #> 121 6.9 3.2 5.7 2.3 virginica #> 122 5.6 2.8 4.9 2.0 virginica #> 123 7.7 2.8 6.7 2.0 virginica #> 124 6.3 2.7 4.9 1.8 virginica #> 125 6.7 3.3 5.7 2.1 virginica #> 126 7.2 3.2 6.0 1.8 virginica #> 127 6.2 2.8 4.8 1.8 virginica #> 128 6.1 3.0 4.9 1.8 virginica #> 129 6.4 2.8 5.6 2.1 virginica #> 130 7.2 3.0 5.8 1.6 virginica #> 131 7.4 2.8 6.1 1.9 virginica #> 132 7.9 3.8 6.4 2.0 virginica #> 133 6.4 2.8 5.6 2.2 virginica #> 134 6.3 2.8 5.1 1.5 virginica #> 135 6.1 2.6 5.6 1.4 virginica #> 136 7.7 3.0 6.1 2.3 virginica #> 137 6.3 3.4 5.6 2.4 virginica #> 138 6.4 3.1 5.5 1.8 virginica #> 139 6.0 3.0 4.8 1.8 virginica #> 140 6.9 3.1 5.4 2.1 virginica #> 141 6.7 3.1 5.6 2.4 virginica #> 142 6.9 3.1 5.1 2.3 virginica #> 143 5.8 2.7 5.1 1.9 virginica #> 144 6.8 3.2 5.9 2.3 virginica #> 145 6.7 3.3 5.7 2.5 virginica #> 146 6.7 3.0 5.2 2.3 virginica #> 147 6.3 2.5 5.0 1.9 virginica #> 148 6.5 3.0 5.2 2.0 virginica #> 149 6.2 3.4 5.4 2.3 virginica #> 150 5.9 3.0 5.1 1.8 virginica","title":"as_data_frame"},{"location":"reference/GroupBy_as_data_frame/#convert-to-dataframe","text":"GroupBy_as_data_frame ( ... )","title":"convert to data.frame"},{"location":"reference/GroupBy_as_data_frame/#arguments","text":"... : any opt param passed to R as.data.frame","title":"Arguments"},{"location":"reference/GroupBy_as_data_frame/#returns","text":"R data.frame convert to data.frame","title":"Returns"},{"location":"reference/GroupBy_as_data_frame/#examples","text":"pl $ DataFrame ( iris ) $ as_data_frame ( ) #R-polars back and forth #> Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 1 5.1 3.5 1.4 0.2 setosa #> 2 4.9 3.0 1.4 0.2 setosa #> 3 4.7 3.2 1.3 0.2 setosa #> 4 4.6 3.1 1.5 0.2 setosa #> 5 5.0 3.6 1.4 0.2 setosa #> 6 5.4 3.9 1.7 0.4 setosa #> 7 4.6 3.4 1.4 0.3 setosa #> 8 5.0 3.4 1.5 0.2 setosa #> 9 4.4 2.9 1.4 0.2 setosa #> 10 4.9 3.1 1.5 0.1 setosa #> 11 5.4 3.7 1.5 0.2 setosa #> 12 4.8 3.4 1.6 0.2 setosa #> 13 4.8 3.0 1.4 0.1 setosa #> 14 4.3 3.0 1.1 0.1 setosa #> 15 5.8 4.0 1.2 0.2 setosa #> 16 5.7 4.4 1.5 0.4 setosa #> 17 5.4 3.9 1.3 0.4 setosa #> 18 5.1 3.5 1.4 0.3 setosa #> 19 5.7 3.8 1.7 0.3 setosa #> 20 5.1 3.8 1.5 0.3 setosa #> 21 5.4 3.4 1.7 0.2 setosa #> 22 5.1 3.7 1.5 0.4 setosa #> 23 4.6 3.6 1.0 0.2 setosa #> 24 5.1 3.3 1.7 0.5 setosa #> 25 4.8 3.4 1.9 0.2 setosa #> 26 5.0 3.0 1.6 0.2 setosa #> 27 5.0 3.4 1.6 0.4 setosa #> 28 5.2 3.5 1.5 0.2 setosa #> 29 5.2 3.4 1.4 0.2 setosa #> 30 4.7 3.2 1.6 0.2 setosa #> 31 4.8 3.1 1.6 0.2 setosa #> 32 5.4 3.4 1.5 0.4 setosa #> 33 5.2 4.1 1.5 0.1 setosa #> 34 5.5 4.2 1.4 0.2 setosa #> 35 4.9 3.1 1.5 0.2 setosa #> 36 5.0 3.2 1.2 0.2 setosa #> 37 5.5 3.5 1.3 0.2 setosa #> 38 4.9 3.6 1.4 0.1 setosa #> 39 4.4 3.0 1.3 0.2 setosa #> 40 5.1 3.4 1.5 0.2 setosa #> 41 5.0 3.5 1.3 0.3 setosa #> 42 4.5 2.3 1.3 0.3 setosa #> 43 4.4 3.2 1.3 0.2 setosa #> 44 5.0 3.5 1.6 0.6 setosa #> 45 5.1 3.8 1.9 0.4 setosa #> 46 4.8 3.0 1.4 0.3 setosa #> 47 5.1 3.8 1.6 0.2 setosa #> 48 4.6 3.2 1.4 0.2 setosa #> 49 5.3 3.7 1.5 0.2 setosa #> 50 5.0 3.3 1.4 0.2 setosa #> 51 7.0 3.2 4.7 1.4 versicolor #> 52 6.4 3.2 4.5 1.5 versicolor #> 53 6.9 3.1 4.9 1.5 versicolor #> 54 5.5 2.3 4.0 1.3 versicolor #> 55 6.5 2.8 4.6 1.5 versicolor #> 56 5.7 2.8 4.5 1.3 versicolor #> 57 6.3 3.3 4.7 1.6 versicolor #> 58 4.9 2.4 3.3 1.0 versicolor #> 59 6.6 2.9 4.6 1.3 versicolor #> 60 5.2 2.7 3.9 1.4 versicolor #> 61 5.0 2.0 3.5 1.0 versicolor #> 62 5.9 3.0 4.2 1.5 versicolor #> 63 6.0 2.2 4.0 1.0 versicolor #> 64 6.1 2.9 4.7 1.4 versicolor #> 65 5.6 2.9 3.6 1.3 versicolor #> 66 6.7 3.1 4.4 1.4 versicolor #> 67 5.6 3.0 4.5 1.5 versicolor #> 68 5.8 2.7 4.1 1.0 versicolor #> 69 6.2 2.2 4.5 1.5 versicolor #> 70 5.6 2.5 3.9 1.1 versicolor #> 71 5.9 3.2 4.8 1.8 versicolor #> 72 6.1 2.8 4.0 1.3 versicolor #> 73 6.3 2.5 4.9 1.5 versicolor #> 74 6.1 2.8 4.7 1.2 versicolor #> 75 6.4 2.9 4.3 1.3 versicolor #> 76 6.6 3.0 4.4 1.4 versicolor #> 77 6.8 2.8 4.8 1.4 versicolor #> 78 6.7 3.0 5.0 1.7 versicolor #> 79 6.0 2.9 4.5 1.5 versicolor #> 80 5.7 2.6 3.5 1.0 versicolor #> 81 5.5 2.4 3.8 1.1 versicolor #> 82 5.5 2.4 3.7 1.0 versicolor #> 83 5.8 2.7 3.9 1.2 versicolor #> 84 6.0 2.7 5.1 1.6 versicolor #> 85 5.4 3.0 4.5 1.5 versicolor #> 86 6.0 3.4 4.5 1.6 versicolor #> 87 6.7 3.1 4.7 1.5 versicolor #> 88 6.3 2.3 4.4 1.3 versicolor #> 89 5.6 3.0 4.1 1.3 versicolor #> 90 5.5 2.5 4.0 1.3 versicolor #> 91 5.5 2.6 4.4 1.2 versicolor #> 92 6.1 3.0 4.6 1.4 versicolor #> 93 5.8 2.6 4.0 1.2 versicolor #> 94 5.0 2.3 3.3 1.0 versicolor #> 95 5.6 2.7 4.2 1.3 versicolor #> 96 5.7 3.0 4.2 1.2 versicolor #> 97 5.7 2.9 4.2 1.3 versicolor #> 98 6.2 2.9 4.3 1.3 versicolor #> 99 5.1 2.5 3.0 1.1 versicolor #> 100 5.7 2.8 4.1 1.3 versicolor #> 101 6.3 3.3 6.0 2.5 virginica #> 102 5.8 2.7 5.1 1.9 virginica #> 103 7.1 3.0 5.9 2.1 virginica #> 104 6.3 2.9 5.6 1.8 virginica #> 105 6.5 3.0 5.8 2.2 virginica #> 106 7.6 3.0 6.6 2.1 virginica #> 107 4.9 2.5 4.5 1.7 virginica #> 108 7.3 2.9 6.3 1.8 virginica #> 109 6.7 2.5 5.8 1.8 virginica #> 110 7.2 3.6 6.1 2.5 virginica #> 111 6.5 3.2 5.1 2.0 virginica #> 112 6.4 2.7 5.3 1.9 virginica #> 113 6.8 3.0 5.5 2.1 virginica #> 114 5.7 2.5 5.0 2.0 virginica #> 115 5.8 2.8 5.1 2.4 virginica #> 116 6.4 3.2 5.3 2.3 virginica #> 117 6.5 3.0 5.5 1.8 virginica #> 118 7.7 3.8 6.7 2.2 virginica #> 119 7.7 2.6 6.9 2.3 virginica #> 120 6.0 2.2 5.0 1.5 virginica #> 121 6.9 3.2 5.7 2.3 virginica #> 122 5.6 2.8 4.9 2.0 virginica #> 123 7.7 2.8 6.7 2.0 virginica #> 124 6.3 2.7 4.9 1.8 virginica #> 125 6.7 3.3 5.7 2.1 virginica #> 126 7.2 3.2 6.0 1.8 virginica #> 127 6.2 2.8 4.8 1.8 virginica #> 128 6.1 3.0 4.9 1.8 virginica #> 129 6.4 2.8 5.6 2.1 virginica #> 130 7.2 3.0 5.8 1.6 virginica #> 131 7.4 2.8 6.1 1.9 virginica #> 132 7.9 3.8 6.4 2.0 virginica #> 133 6.4 2.8 5.6 2.2 virginica #> 134 6.3 2.8 5.1 1.5 virginica #> 135 6.1 2.6 5.6 1.4 virginica #> 136 7.7 3.0 6.1 2.3 virginica #> 137 6.3 3.4 5.6 2.4 virginica #> 138 6.4 3.1 5.5 1.8 virginica #> 139 6.0 3.0 4.8 1.8 virginica #> 140 6.9 3.1 5.4 2.1 virginica #> 141 6.7 3.1 5.6 2.4 virginica #> 142 6.9 3.1 5.1 2.3 virginica #> 143 5.8 2.7 5.1 1.9 virginica #> 144 6.8 3.2 5.9 2.3 virginica #> 145 6.7 3.3 5.7 2.5 virginica #> 146 6.7 3.0 5.2 2.3 virginica #> 147 6.3 2.5 5.0 1.9 virginica #> 148 6.5 3.0 5.2 2.0 virginica #> 149 6.2 3.4 5.4 2.3 virginica #> 150 5.9 3.0 5.1 1.8 virginica","title":"Examples"},{"location":"reference/GroupBy_class/","text":"Use groups on a Polars DataFrame Returns A grouped DataFrame Use groups on a Polars DataFrame","title":"Use groups on a Polars DataFrame"},{"location":"reference/GroupBy_class/#use-groups-on-a-polars-dataframe","text":"","title":"Use groups on a Polars DataFrame"},{"location":"reference/GroupBy_class/#returns","text":"A grouped DataFrame Use groups on a Polars DataFrame","title":"Returns"},{"location":"reference/GroupBy_first/","text":"GroupBy First GroupBy_first () Returns aggregated DataFrame Reduce the groups to the first value. Examples df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ first ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 1.0 \u2506 0.5 \u2506 true \u2502 #> \u2502 Orange \u2506 2.0 \u2506 0.5 \u2506 true \u2502 #> \u2502 Banana \u2506 4.0 \u2506 13.0 \u2506 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"first"},{"location":"reference/GroupBy_first/#groupby-first","text":"GroupBy_first ()","title":"GroupBy First"},{"location":"reference/GroupBy_first/#returns","text":"aggregated DataFrame Reduce the groups to the first value.","title":"Returns"},{"location":"reference/GroupBy_first/#examples","text":"df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ first ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 1.0 \u2506 0.5 \u2506 true \u2502 #> \u2502 Orange \u2506 2.0 \u2506 0.5 \u2506 true \u2502 #> \u2502 Banana \u2506 4.0 \u2506 13.0 \u2506 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/GroupBy_last/","text":"GroupBy Last GroupBy_last () Returns aggregated DataFrame Reduce the groups to the last value. Examples df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ last ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 3.0 \u2506 10.0 \u2506 false \u2502 #> \u2502 Orange \u2506 2.0 \u2506 0.5 \u2506 true \u2502 #> \u2502 Banana \u2506 5.0 \u2506 14.0 \u2506 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"last"},{"location":"reference/GroupBy_last/#groupby-last","text":"GroupBy_last ()","title":"GroupBy Last"},{"location":"reference/GroupBy_last/#returns","text":"aggregated DataFrame Reduce the groups to the last value.","title":"Returns"},{"location":"reference/GroupBy_last/#examples","text":"df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ last ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 3.0 \u2506 10.0 \u2506 false \u2502 #> \u2502 Orange \u2506 2.0 \u2506 0.5 \u2506 true \u2502 #> \u2502 Banana \u2506 5.0 \u2506 14.0 \u2506 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/GroupBy_max/","text":"GroupBy Max GroupBy_max () Returns aggregated DataFrame Reduce the groups to the maximum value. Examples df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ max ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 3.0 \u2506 10.0 \u2506 true \u2502 #> \u2502 Orange \u2506 2.0 \u2506 0.5 \u2506 true \u2502 #> \u2502 Banana \u2506 5.0 \u2506 14.0 \u2506 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"max"},{"location":"reference/GroupBy_max/#groupby-max","text":"GroupBy_max ()","title":"GroupBy Max"},{"location":"reference/GroupBy_max/#returns","text":"aggregated DataFrame Reduce the groups to the maximum value.","title":"Returns"},{"location":"reference/GroupBy_max/#examples","text":"df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ max ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 3.0 \u2506 10.0 \u2506 true \u2502 #> \u2502 Orange \u2506 2.0 \u2506 0.5 \u2506 true \u2502 #> \u2502 Banana \u2506 5.0 \u2506 14.0 \u2506 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/GroupBy_mean/","text":"GroupBy Mean GroupBy_mean () Returns aggregated DataFrame Reduce the groups to the mean value. Examples df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ mean ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 2.0 \u2506 4.833333 \u2506 0.666667 \u2502 #> \u2502 Orange \u2506 2.0 \u2506 0.5 \u2506 1.0 \u2502 #> \u2502 Banana \u2506 4.5 \u2506 13.5 \u2506 0.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"mean"},{"location":"reference/GroupBy_mean/#groupby-mean","text":"GroupBy_mean ()","title":"GroupBy Mean"},{"location":"reference/GroupBy_mean/#returns","text":"aggregated DataFrame Reduce the groups to the mean value.","title":"Returns"},{"location":"reference/GroupBy_mean/#examples","text":"df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ mean ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 2.0 \u2506 4.833333 \u2506 0.666667 \u2502 #> \u2502 Orange \u2506 2.0 \u2506 0.5 \u2506 1.0 \u2502 #> \u2502 Banana \u2506 4.5 \u2506 13.5 \u2506 0.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/GroupBy_median/","text":"GroupBy Median GroupBy_median () Returns aggregated DataFrame Reduce the groups to the median value. Examples df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ median ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 2.0 \u2506 4.0 \u2506 null \u2502 #> \u2502 Orange \u2506 2.0 \u2506 0.5 \u2506 null \u2502 #> \u2502 Banana \u2506 4.5 \u2506 13.5 \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"median"},{"location":"reference/GroupBy_median/#groupby-median","text":"GroupBy_median ()","title":"GroupBy Median"},{"location":"reference/GroupBy_median/#returns","text":"aggregated DataFrame Reduce the groups to the median value.","title":"Returns"},{"location":"reference/GroupBy_median/#examples","text":"df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ median ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 2.0 \u2506 4.0 \u2506 null \u2502 #> \u2502 Orange \u2506 2.0 \u2506 0.5 \u2506 null \u2502 #> \u2502 Banana \u2506 4.5 \u2506 13.5 \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/GroupBy_min/","text":"GroupBy Min GroupBy_min () Returns aggregated DataFrame Reduce the groups to the minimum value. Examples df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ min ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 1.0 \u2506 0.5 \u2506 false \u2502 #> \u2502 Orange \u2506 2.0 \u2506 0.5 \u2506 true \u2502 #> \u2502 Banana \u2506 4.0 \u2506 13.0 \u2506 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"min"},{"location":"reference/GroupBy_min/#groupby-min","text":"GroupBy_min ()","title":"GroupBy Min"},{"location":"reference/GroupBy_min/#returns","text":"aggregated DataFrame Reduce the groups to the minimum value.","title":"Returns"},{"location":"reference/GroupBy_min/#examples","text":"df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ min ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 1.0 \u2506 0.5 \u2506 false \u2502 #> \u2502 Orange \u2506 2.0 \u2506 0.5 \u2506 true \u2502 #> \u2502 Banana \u2506 4.0 \u2506 13.0 \u2506 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/GroupBy_null_count/","text":"GroupBy null count GroupBy_null_count () Returns DataFrame Create a new DataFrame that shows the null counts per column. Examples x = mtcars x [ 1 : 10 , 3 : 5 ] = NA pl $ DataFrame ( x ) $ groupby ( \"cyl\" ) $ null_count ( ) #> polars DataFrame: shape: (3, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cyl \u2506 mpg \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 u32 \u2506 u32 \u2506 u32 \u2506 \u2506 u32 \u2506 u32 \u2506 u32 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 4.0 \u2506 0 \u2506 3 \u2506 3 \u2506 ... \u2506 0 \u2506 0 \u2506 0 \u2506 0 \u2502 #> \u2502 6.0 \u2506 0 \u2506 5 \u2506 5 \u2506 ... \u2506 0 \u2506 0 \u2506 0 \u2506 0 \u2502 #> \u2502 8.0 \u2506 0 \u2506 2 \u2506 2 \u2506 ... \u2506 0 \u2506 0 \u2506 0 \u2506 0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"null_count"},{"location":"reference/GroupBy_null_count/#groupby-null-count","text":"GroupBy_null_count ()","title":"GroupBy null count"},{"location":"reference/GroupBy_null_count/#returns","text":"DataFrame Create a new DataFrame that shows the null counts per column.","title":"Returns"},{"location":"reference/GroupBy_null_count/#examples","text":"x = mtcars x [ 1 : 10 , 3 : 5 ] = NA pl $ DataFrame ( x ) $ groupby ( \"cyl\" ) $ null_count ( ) #> polars DataFrame: shape: (3, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 cyl \u2506 mpg \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 u32 \u2506 u32 \u2506 u32 \u2506 \u2506 u32 \u2506 u32 \u2506 u32 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 4.0 \u2506 0 \u2506 3 \u2506 3 \u2506 ... \u2506 0 \u2506 0 \u2506 0 \u2506 0 \u2502 #> \u2502 6.0 \u2506 0 \u2506 5 \u2506 5 \u2506 ... \u2506 0 \u2506 0 \u2506 0 \u2506 0 \u2502 #> \u2502 8.0 \u2506 0 \u2506 2 \u2506 2 \u2506 ... \u2506 0 \u2506 0 \u2506 0 \u2506 0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/GroupBy_std/","text":"GroupBy Std GroupBy_std () Returns aggregated DataFrame Reduce the groups to the standard deviation value. Examples df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ std ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 1.0 \u2506 4.804512 \u2506 0.57735 \u2502 #> \u2502 Orange \u2506 0.0 \u2506 0.0 \u2506 0.0 \u2502 #> \u2502 Banana \u2506 0.707107 \u2506 0.707107 \u2506 0.707107 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"std"},{"location":"reference/GroupBy_std/#groupby-std","text":"GroupBy_std ()","title":"GroupBy Std"},{"location":"reference/GroupBy_std/#returns","text":"aggregated DataFrame Reduce the groups to the standard deviation value.","title":"Returns"},{"location":"reference/GroupBy_std/#examples","text":"df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ std ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 1.0 \u2506 4.804512 \u2506 0.57735 \u2502 #> \u2502 Orange \u2506 0.0 \u2506 0.0 \u2506 0.0 \u2502 #> \u2502 Banana \u2506 0.707107 \u2506 0.707107 \u2506 0.707107 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/GroupBy_sum/","text":"GroupBy Sum GroupBy_sum () Returns aggregated DataFrame Reduce the groups to the sum value. Examples df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ sum ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 6.0 \u2506 14.5 \u2506 2 \u2502 #> \u2502 Orange \u2506 2.0 \u2506 0.5 \u2506 1 \u2502 #> \u2502 Banana \u2506 9.0 \u2506 27.0 \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518","title":"sum"},{"location":"reference/GroupBy_sum/#groupby-sum","text":"GroupBy_sum ()","title":"GroupBy Sum"},{"location":"reference/GroupBy_sum/#returns","text":"aggregated DataFrame Reduce the groups to the sum value.","title":"Returns"},{"location":"reference/GroupBy_sum/#examples","text":"df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ sum ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 6.0 \u2506 14.5 \u2506 2 \u2502 #> \u2502 Orange \u2506 2.0 \u2506 0.5 \u2506 1 \u2502 #> \u2502 Banana \u2506 9.0 \u2506 27.0 \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/GroupBy_var/","text":"GroupBy Var GroupBy_var () Returns aggregated DataFrame Reduce the groups to the variance value. Examples df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ var ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 1.0 \u2506 23.083333 \u2506 0.333333 \u2502 #> \u2502 Orange \u2506 0.0 \u2506 0.0 \u2506 0.0 \u2502 #> \u2502 Banana \u2506 0.5 \u2506 0.5 \u2506 0.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"var"},{"location":"reference/GroupBy_var/#groupby-var","text":"GroupBy_var ()","title":"GroupBy Var"},{"location":"reference/GroupBy_var/#returns","text":"aggregated DataFrame Reduce the groups to the variance value.","title":"Returns"},{"location":"reference/GroupBy_var/#examples","text":"df = pl $ DataFrame ( a = c ( 1 , 2 , 2 , 3 , 4 , 5 ) , b = c ( 0.5 , 0.5 , 4 , 10 , 13 , 14 ) , c = c ( TRUE , TRUE , TRUE , FALSE , FALSE , TRUE ) , d = c ( \"Apple\" , \"Orange\" , \"Apple\" , \"Apple\" , \"Banana\" , \"Banana\" ) ) df $ groupby ( \"d\" , maintain_order = TRUE ) $ var ( ) #> polars DataFrame: shape: (3, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 d \u2506 a \u2506 b \u2506 c \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 str \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 Apple \u2506 1.0 \u2506 23.083333 \u2506 0.333333 \u2502 #> \u2502 Orange \u2506 0.0 \u2506 0.0 \u2506 0.0 \u2502 #> \u2502 Banana \u2506 0.5 \u2506 0.5 \u2506 0.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_class/","text":"Inner workings of the LazyFrame-class The LazyFrame -class is simply two environments of respectively the public and private methods/function calls to the polars rust side. The instanciated LazyFrame -object is an externalptr to a lowlevel rust polars LazyFrame object. The pointer address is the only statefullness of the LazyFrame object on the R side. Any other state resides on the rust side. The S3 method .DollarNames.LazyFrame exposes all public $foobar() -methods which are callable onto the object. Most methods return another LazyFrame -class instance or similar which allows for method chaining. This class system in lack of a better name could be called \"environment classes\" and is the same class system extendr provides, except here there is both a public and private set of methods. For implementation reasons, the private methods are external and must be called from polars:::.pr.$LazyFrame$methodname(), also all private methods must take any self as an argument, thus they are pure functions. Having the private methods as pure functions solved/simplified self-referential complications. DataFrame and LazyFrame can both be said to be a Frame . To convert use DataFrame_object$lazy() -> LazyFrame_object and LazyFrame_object$collect() -> DataFrame_object . This is quite similar to the lazy-collect syntax of the dplyrpackage to interact with database connections such as SQL variants. Most SQL databases would be able to perform the same otimizations as polars such Predicate Pushdown and Projection. However polars can intertact and optimize queries with both SQL DBs and other data sources such parquet files simultanously. (#TODO implement r-polars SQL ;) Details Check out the source code in R/LazyFrame__lazy.R how public methods are derived from private methods. Check out extendr-wrappers.R to see the extendr-auto-generated methods. These are moved to .pr and converted into pure external functions in after-wrappers.R. In zzz.R (named zzz to be last file sourced) the extendr-methods are removed and replaced by any function prefixed LazyFrame_ . Examples #see all exported methods ls ( polars ::: LazyFrame ) #> [1] \"collect\" \"collect_background\" \"describe_optimized_plan\" \"describe_plan\" #> [5] \"filter\" \"first\" \"groupby\" \"join\" #> [9] \"last\" \"limit\" \"max\" \"mean\" #> [13] \"median\" \"min\" \"print\" \"reverse\" #> [17] \"select\" \"slice\" \"std\" \"sum\" #> [21] \"tail\" \"var\" \"with_column\" \"with_columns\" #see all private methods (not intended for regular use) ls ( polars ::: .pr $ LazyFrame ) #> [1] \"collect\" \"collect_background\" \"describe_optimized_plan\" \"describe_plan\" #> [5] \"filter\" \"first\" \"groupby\" \"join\" #> [9] \"last\" \"limit\" \"max\" \"mean\" #> [13] \"median\" \"min\" \"print\" \"reverse\" #> [17] \"select\" \"slice\" \"std\" \"sum\" #> [21] \"tail\" \"var\" \"with_column\" \"with_columns\" ## Practical example ## # First writing R iris dataset to disk, to illustrte a difference temp_filepath = tempfile ( ) write.csv ( iris , temp_filepath ,row.names = FALSE ) # Following example illustrates 2 ways to obtain a LazyFrame # The-Okay-way: convert an in-memory DataFrame to LazyFrame #eager in-mem R data.frame Rdf = read.csv ( temp_filepath ) #eager in-mem polars DataFrame Pdf = pl $ DataFrame ( Rdf ) #lazy frame starting from in-mem DataFrame Ldf_okay = Pdf $ lazy ( ) #The-Best-Way: LazyFrame created directly from a data source is best... Ldf_best = pl $ lazy_csv_reader ( temp_filepath ) # ... as if to e.g. filter the LazyFrame, that filtering also caleld predicate will be # pushed down in the executation stack to the csv_reader, and thereby only bringing into # memory the rows matching to filter. # apply filter: filter_expr = pl $ col ( \"Species\" ) == \"setosa\" #get only rows where Species is setosa Ldf_okay = Ldf_okay $ filter ( filter_expr ) #overwrite LazyFrame with new Ldf_best = Ldf_best $ filter ( filter_expr ) # the non optimized plans are similar, on entire in-mem csv, apply filter Ldf_okay $ describe_plan ( ) #> FILTER [(col(\"Species\")) == (Utf8(setosa))] FROM #> DF [\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"]; PROJECT */5 COLUMNS; SELECTION: \"None\" #> Ldf_best $ describe_plan ( ) #> FILTER [(col(\"Species\")) == (Utf8(setosa))] FROM #> CSV SCAN C:\\Users\\etienne\\AppData\\Local\\Temp\\Rtmpq68bWo\\file1cc475d251ff #> PROJECT */5 COLUMNS #> # NOTE For Ldf_okay, the full time to load csv alrady paid when creating Rdf and Pdf #The optimized plan are quite different, Ldf_best will read csv and perform filter simultanously Ldf_okay $ describe_optimized_plan ( ) #> DF [\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"]; PROJECT */5 COLUMNS; SELECTION: \"[(col(\\\"Species\\\")) == (Utf8(setosa))]\" #> Ldf_best $ describe_optimized_plan ( ) #> CSV SCAN C:\\Users\\etienne\\AppData\\Local\\Temp\\Rtmpq68bWo\\file1cc475d251ff #> PROJECT */5 COLUMNS #> SELECTION: [(col(\"Species\")) == (Utf8(setosa))] #> #To acquire result in-mem use $colelct() Pdf_okay = Ldf_okay $ collect ( ) Pdf_best = Ldf_best $ collect ( ) #verify tables would be the same all.equal ( Pdf_okay $ as_data_frame ( ) , Pdf_best $ as_data_frame ( ) ) #> [1] TRUE #a user might write it as a one-liner like so: Pdf_best2 = pl $ lazy_csv_reader ( temp_filepath ) $ filter ( pl $ col ( \"Species\" ) == \"setosa\" )","title":"Inner workings of the LazyFrame-class"},{"location":"reference/LazyFrame_class/#inner-workings-of-the-lazyframe-class","text":"The LazyFrame -class is simply two environments of respectively the public and private methods/function calls to the polars rust side. The instanciated LazyFrame -object is an externalptr to a lowlevel rust polars LazyFrame object. The pointer address is the only statefullness of the LazyFrame object on the R side. Any other state resides on the rust side. The S3 method .DollarNames.LazyFrame exposes all public $foobar() -methods which are callable onto the object. Most methods return another LazyFrame -class instance or similar which allows for method chaining. This class system in lack of a better name could be called \"environment classes\" and is the same class system extendr provides, except here there is both a public and private set of methods. For implementation reasons, the private methods are external and must be called from polars:::.pr.$LazyFrame$methodname(), also all private methods must take any self as an argument, thus they are pure functions. Having the private methods as pure functions solved/simplified self-referential complications. DataFrame and LazyFrame can both be said to be a Frame . To convert use DataFrame_object$lazy() -> LazyFrame_object and LazyFrame_object$collect() -> DataFrame_object . This is quite similar to the lazy-collect syntax of the dplyrpackage to interact with database connections such as SQL variants. Most SQL databases would be able to perform the same otimizations as polars such Predicate Pushdown and Projection. However polars can intertact and optimize queries with both SQL DBs and other data sources such parquet files simultanously. (#TODO implement r-polars SQL ;)","title":"Inner workings of the LazyFrame-class"},{"location":"reference/LazyFrame_class/#details","text":"Check out the source code in R/LazyFrame__lazy.R how public methods are derived from private methods. Check out extendr-wrappers.R to see the extendr-auto-generated methods. These are moved to .pr and converted into pure external functions in after-wrappers.R. In zzz.R (named zzz to be last file sourced) the extendr-methods are removed and replaced by any function prefixed LazyFrame_ .","title":"Details"},{"location":"reference/LazyFrame_class/#examples","text":"#see all exported methods ls ( polars ::: LazyFrame ) #> [1] \"collect\" \"collect_background\" \"describe_optimized_plan\" \"describe_plan\" #> [5] \"filter\" \"first\" \"groupby\" \"join\" #> [9] \"last\" \"limit\" \"max\" \"mean\" #> [13] \"median\" \"min\" \"print\" \"reverse\" #> [17] \"select\" \"slice\" \"std\" \"sum\" #> [21] \"tail\" \"var\" \"with_column\" \"with_columns\" #see all private methods (not intended for regular use) ls ( polars ::: .pr $ LazyFrame ) #> [1] \"collect\" \"collect_background\" \"describe_optimized_plan\" \"describe_plan\" #> [5] \"filter\" \"first\" \"groupby\" \"join\" #> [9] \"last\" \"limit\" \"max\" \"mean\" #> [13] \"median\" \"min\" \"print\" \"reverse\" #> [17] \"select\" \"slice\" \"std\" \"sum\" #> [21] \"tail\" \"var\" \"with_column\" \"with_columns\" ## Practical example ## # First writing R iris dataset to disk, to illustrte a difference temp_filepath = tempfile ( ) write.csv ( iris , temp_filepath ,row.names = FALSE ) # Following example illustrates 2 ways to obtain a LazyFrame # The-Okay-way: convert an in-memory DataFrame to LazyFrame #eager in-mem R data.frame Rdf = read.csv ( temp_filepath ) #eager in-mem polars DataFrame Pdf = pl $ DataFrame ( Rdf ) #lazy frame starting from in-mem DataFrame Ldf_okay = Pdf $ lazy ( ) #The-Best-Way: LazyFrame created directly from a data source is best... Ldf_best = pl $ lazy_csv_reader ( temp_filepath ) # ... as if to e.g. filter the LazyFrame, that filtering also caleld predicate will be # pushed down in the executation stack to the csv_reader, and thereby only bringing into # memory the rows matching to filter. # apply filter: filter_expr = pl $ col ( \"Species\" ) == \"setosa\" #get only rows where Species is setosa Ldf_okay = Ldf_okay $ filter ( filter_expr ) #overwrite LazyFrame with new Ldf_best = Ldf_best $ filter ( filter_expr ) # the non optimized plans are similar, on entire in-mem csv, apply filter Ldf_okay $ describe_plan ( ) #> FILTER [(col(\"Species\")) == (Utf8(setosa))] FROM #> DF [\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"]; PROJECT */5 COLUMNS; SELECTION: \"None\" #> Ldf_best $ describe_plan ( ) #> FILTER [(col(\"Species\")) == (Utf8(setosa))] FROM #> CSV SCAN C:\\Users\\etienne\\AppData\\Local\\Temp\\Rtmpq68bWo\\file1cc475d251ff #> PROJECT */5 COLUMNS #> # NOTE For Ldf_okay, the full time to load csv alrady paid when creating Rdf and Pdf #The optimized plan are quite different, Ldf_best will read csv and perform filter simultanously Ldf_okay $ describe_optimized_plan ( ) #> DF [\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"]; PROJECT */5 COLUMNS; SELECTION: \"[(col(\\\"Species\\\")) == (Utf8(setosa))]\" #> Ldf_best $ describe_optimized_plan ( ) #> CSV SCAN C:\\Users\\etienne\\AppData\\Local\\Temp\\Rtmpq68bWo\\file1cc475d251ff #> PROJECT */5 COLUMNS #> SELECTION: [(col(\"Species\")) == (Utf8(setosa))] #> #To acquire result in-mem use $colelct() Pdf_okay = Ldf_okay $ collect ( ) Pdf_best = Ldf_best $ collect ( ) #verify tables would be the same all.equal ( Pdf_okay $ as_data_frame ( ) , Pdf_best $ as_data_frame ( ) ) #> [1] TRUE #a user might write it as a one-liner like so: Pdf_best2 = pl $ lazy_csv_reader ( temp_filepath ) $ filter ( pl $ col ( \"Species\" ) == \"setosa\" )","title":"Examples"},{"location":"reference/LazyFrame_collect/","text":"New DataFrame from LazyFrame_object$collect() LazyFrame_collect () Returns collected DataFrame collect DataFrame by lazy query Examples pl $ DataFrame ( iris ) $ lazy ( ) $ filter ( pl $ col ( \"Species\" ) == \"setosa\" ) $ collect ( ) #> polars DataFrame: shape: (50, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 5.1 \u2506 3.8 \u2506 1.6 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.2 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.3 \u2506 3.7 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.0 \u2506 3.3 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"collect"},{"location":"reference/LazyFrame_collect/#new-dataframe-from-lazyframe_objectcollect","text":"LazyFrame_collect ()","title":"New DataFrame from LazyFrame_object$collect()"},{"location":"reference/LazyFrame_collect/#returns","text":"collected DataFrame collect DataFrame by lazy query","title":"Returns"},{"location":"reference/LazyFrame_collect/#examples","text":"pl $ DataFrame ( iris ) $ lazy ( ) $ filter ( pl $ col ( \"Species\" ) == \"setosa\" ) $ collect ( ) #> polars DataFrame: shape: (50, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 5.1 \u2506 3.8 \u2506 1.6 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.2 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.3 \u2506 3.7 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.0 \u2506 3.3 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_collect_background/","text":"New DataFrame from LazyFrame_object$collect() LazyFrame_collect_background () Returns collected DataFrame collect DataFrame by lazy query Examples pl $ DataFrame ( iris ) $ lazy ( ) $ filter ( pl $ col ( \"Species\" ) == \"setosa\" ) $ collect ( ) #> polars DataFrame: shape: (50, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 5.1 \u2506 3.8 \u2506 1.6 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.2 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.3 \u2506 3.7 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.0 \u2506 3.3 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"collect_background"},{"location":"reference/LazyFrame_collect_background/#new-dataframe-from-lazyframe_objectcollect","text":"LazyFrame_collect_background ()","title":"New DataFrame from LazyFrame_object$collect()"},{"location":"reference/LazyFrame_collect_background/#returns","text":"collected DataFrame collect DataFrame by lazy query","title":"Returns"},{"location":"reference/LazyFrame_collect_background/#examples","text":"pl $ DataFrame ( iris ) $ lazy ( ) $ filter ( pl $ col ( \"Species\" ) == \"setosa\" ) $ collect ( ) #> polars DataFrame: shape: (50, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 5.1 \u2506 3.8 \u2506 1.6 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.2 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.3 \u2506 3.7 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.0 \u2506 3.3 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_describe_optimized_plan/","text":"Print the optmized plan of LazyFrame LazyFrame_describe_optimized_plan () select on a LazyFrame","title":"describe_optimized_plan"},{"location":"reference/LazyFrame_describe_optimized_plan/#print-the-optmized-plan-of-lazyframe","text":"LazyFrame_describe_optimized_plan () select on a LazyFrame","title":"Print the optmized plan of LazyFrame"},{"location":"reference/LazyFrame_describe_plan/","text":"data Print the non-optimized plan plan of LazyFrame Format An object of class character of length 1. LazyFrame_describe_plan select on a LazyFrame","title":"describe_plan"},{"location":"reference/LazyFrame_describe_plan/#print-the-non-optimized-plan-plan-of-lazyframe","text":"","title":"Print the non-optimized plan plan of LazyFrame"},{"location":"reference/LazyFrame_describe_plan/#format","text":"An object of class character of length 1. LazyFrame_describe_plan select on a LazyFrame","title":"Format"},{"location":"reference/LazyFrame_filter/","text":"data Apply filter to LazyFrame Format An object of class character of length 1. LazyFrame_filter ( expr ) Arguments expr : one Expr or string naming a column Returns A new LazyFrame object with add/modified column. Filter rows with an Expression definining a boolean column Examples pl $ DataFrame ( iris ) $ lazy ( ) $ filter ( pl $ col ( \"Species\" ) == \"setosa\" ) $ collect ( ) #> polars DataFrame: shape: (50, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 5.1 \u2506 3.8 \u2506 1.6 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.2 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.3 \u2506 3.7 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.0 \u2506 3.3 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"filter"},{"location":"reference/LazyFrame_filter/#apply-filter-to-lazyframe","text":"","title":"Apply filter to LazyFrame"},{"location":"reference/LazyFrame_filter/#format","text":"An object of class character of length 1. LazyFrame_filter ( expr )","title":"Format"},{"location":"reference/LazyFrame_filter/#arguments","text":"expr : one Expr or string naming a column","title":"Arguments"},{"location":"reference/LazyFrame_filter/#returns","text":"A new LazyFrame object with add/modified column. Filter rows with an Expression definining a boolean column","title":"Returns"},{"location":"reference/LazyFrame_filter/#examples","text":"pl $ DataFrame ( iris ) $ lazy ( ) $ filter ( pl $ col ( \"Species\" ) == \"setosa\" ) $ collect ( ) #> polars DataFrame: shape: (50, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 5.1 \u2506 3.8 \u2506 1.6 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.2 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.3 \u2506 3.7 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.0 \u2506 3.3 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_first/","text":"First Format function LazyFrame_first Returns A new DataFrame object with applied filter. Get the first row of the DataFrame. Examples pl $ DataFrame ( mtcars ) $ lazy ( ) $ first ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"first"},{"location":"reference/LazyFrame_first/#first","text":"","title":"First"},{"location":"reference/LazyFrame_first/#format","text":"function LazyFrame_first","title":"Format"},{"location":"reference/LazyFrame_first/#returns","text":"A new DataFrame object with applied filter. Get the first row of the DataFrame.","title":"Returns"},{"location":"reference/LazyFrame_first/#examples","text":"pl $ DataFrame ( mtcars ) $ lazy ( ) $ first ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_groupby/","text":"Lazy_groupby LazyFrame_groupby ( ... , maintain_order = FALSE ) Arguments ... : any single Expr or string naming a column maintain_order : bool should an aggregate of groupby retain order of groups or FALSE = random, slightly faster? Returns A new LazyGroupBy object with applied groups. apply groupby on LazyFrame, return LazyGroupBy","title":"groupby"},{"location":"reference/LazyFrame_groupby/#lazy_groupby","text":"LazyFrame_groupby ( ... , maintain_order = FALSE )","title":"Lazy_groupby"},{"location":"reference/LazyFrame_groupby/#arguments","text":"... : any single Expr or string naming a column maintain_order : bool should an aggregate of groupby retain order of groups or FALSE = random, slightly faster?","title":"Arguments"},{"location":"reference/LazyFrame_groupby/#returns","text":"A new LazyGroupBy object with applied groups. apply groupby on LazyFrame, return LazyGroupBy","title":"Returns"},{"location":"reference/LazyFrame_join/","text":"LazyFrame join LazyFrame_join ( other , left_on = NULL , right_on = NULL , on = NULL , how = c ( \"inner\" , \"left\" , \"outer\" , \"semi\" , \"anti\" , \"cross\" ), suffix = \"_right\" , allow_parallel = TRUE , force_parallel = FALSE ) Arguments other : LazyFrame left_on : names of columns in self LazyFrame, order should match. Type, see on param. right_on : names of columns in other LazyFrame, order should match. Type, see on param. on : named columns as char vector of named columns, or list of expressions and/or strings. how : a string selecting one of the following methods: inner, left, outer, semi, anti, cross suffix : name to added right table allow_parallel : bool force_parallel : bool Returns A new LazyFrame object with applied join. join a LazyFrame","title":"join"},{"location":"reference/LazyFrame_join/#lazyframe-join","text":"LazyFrame_join ( other , left_on = NULL , right_on = NULL , on = NULL , how = c ( \"inner\" , \"left\" , \"outer\" , \"semi\" , \"anti\" , \"cross\" ), suffix = \"_right\" , allow_parallel = TRUE , force_parallel = FALSE )","title":"LazyFrame join"},{"location":"reference/LazyFrame_join/#arguments","text":"other : LazyFrame left_on : names of columns in self LazyFrame, order should match. Type, see on param. right_on : names of columns in other LazyFrame, order should match. Type, see on param. on : named columns as char vector of named columns, or list of expressions and/or strings. how : a string selecting one of the following methods: inner, left, outer, semi, anti, cross suffix : name to added right table allow_parallel : bool force_parallel : bool","title":"Arguments"},{"location":"reference/LazyFrame_join/#returns","text":"A new LazyFrame object with applied join. join a LazyFrame","title":"Returns"},{"location":"reference/LazyFrame_last/","text":"Last Format function LazyFrame_last Returns A new LazyFrame object with applied aggregation. Aggregate the columns in the DataFrame to their maximum value. Examples pl $ DataFrame ( mtcars ) $ lazy ( ) $ last ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"last"},{"location":"reference/LazyFrame_last/#last","text":"","title":"Last"},{"location":"reference/LazyFrame_last/#format","text":"function LazyFrame_last","title":"Format"},{"location":"reference/LazyFrame_last/#returns","text":"A new LazyFrame object with applied aggregation. Aggregate the columns in the DataFrame to their maximum value.","title":"Returns"},{"location":"reference/LazyFrame_last/#examples","text":"pl $ DataFrame ( mtcars ) $ lazy ( ) $ last ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_limit/","text":"Limits LazyFrame_limit ( n ) Arguments n : positive numeric or integer number not larger than 2^32 Returns A new LazyFrame object with applied filter. take limit of n rows of query Details any number will converted to u32. Negative raises error Examples pl $ DataFrame ( mtcars ) $ lazy ( ) $ limit ( 4 ) $ collect ( ) #> polars DataFrame: shape: (4, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"limit"},{"location":"reference/LazyFrame_limit/#limits","text":"LazyFrame_limit ( n )","title":"Limits"},{"location":"reference/LazyFrame_limit/#arguments","text":"n : positive numeric or integer number not larger than 2^32","title":"Arguments"},{"location":"reference/LazyFrame_limit/#returns","text":"A new LazyFrame object with applied filter. take limit of n rows of query","title":"Returns"},{"location":"reference/LazyFrame_limit/#details","text":"any number will converted to u32. Negative raises error","title":"Details"},{"location":"reference/LazyFrame_limit/#examples","text":"pl $ DataFrame ( mtcars ) $ lazy ( ) $ limit ( 4 ) $ collect ( ) #> polars DataFrame: shape: (4, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_max/","text":"Max Format function LazyFrame_max Returns A new LazyFrame object with applied aggregation. Aggregate the columns in the DataFrame to their maximum value. Examples pl $ DataFrame ( mtcars ) $ lazy ( ) $ max ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 33.9 \u2506 8.0 \u2506 472.0 \u2506 335.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"max"},{"location":"reference/LazyFrame_max/#max","text":"","title":"Max"},{"location":"reference/LazyFrame_max/#format","text":"function LazyFrame_max","title":"Format"},{"location":"reference/LazyFrame_max/#returns","text":"A new LazyFrame object with applied aggregation. Aggregate the columns in the DataFrame to their maximum value.","title":"Returns"},{"location":"reference/LazyFrame_max/#examples","text":"pl $ DataFrame ( mtcars ) $ lazy ( ) $ max ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 33.9 \u2506 8.0 \u2506 472.0 \u2506 335.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_mean/","text":"Mean Format function LazyFrame_mean Returns A new LazyFrame object with applied aggregation. Aggregate the columns in the DataFrame to their mean value. Examples pl $ DataFrame ( mtcars ) $ lazy ( ) $ mean ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 20.090625 \u2506 6.1875 \u2506 230.721875 \u2506 146.6875 \u2506 ... \u2506 0.4375 \u2506 0.40625 \u2506 3.6875 \u2506 2.8125 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"mean"},{"location":"reference/LazyFrame_mean/#mean","text":"","title":"Mean"},{"location":"reference/LazyFrame_mean/#format","text":"function LazyFrame_mean","title":"Format"},{"location":"reference/LazyFrame_mean/#returns","text":"A new LazyFrame object with applied aggregation. Aggregate the columns in the DataFrame to their mean value.","title":"Returns"},{"location":"reference/LazyFrame_mean/#examples","text":"pl $ DataFrame ( mtcars ) $ lazy ( ) $ mean ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 20.090625 \u2506 6.1875 \u2506 230.721875 \u2506 146.6875 \u2506 ... \u2506 0.4375 \u2506 0.40625 \u2506 3.6875 \u2506 2.8125 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_median/","text":"Median Format function LazyFrame_median Returns A new LazyFrame object with applied aggregation. Aggregate the columns in the DataFrame to their median value. Examples pl $ DataFrame ( mtcars ) $ lazy ( ) $ median ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 19.2 \u2506 6.0 \u2506 196.3 \u2506 123.0 \u2506 ... \u2506 0.0 \u2506 0.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"median"},{"location":"reference/LazyFrame_median/#median","text":"","title":"Median"},{"location":"reference/LazyFrame_median/#format","text":"function LazyFrame_median","title":"Format"},{"location":"reference/LazyFrame_median/#returns","text":"A new LazyFrame object with applied aggregation. Aggregate the columns in the DataFrame to their median value.","title":"Returns"},{"location":"reference/LazyFrame_median/#examples","text":"pl $ DataFrame ( mtcars ) $ lazy ( ) $ median ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 19.2 \u2506 6.0 \u2506 196.3 \u2506 123.0 \u2506 ... \u2506 0.0 \u2506 0.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_min/","text":"Min Format function LazyFrame_min Returns A new LazyFrame object with applied aggregation. Aggregate the columns in the DataFrame to their minimum value. Examples pl $ DataFrame ( mtcars ) $ lazy ( ) $ min ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 10.4 \u2506 4.0 \u2506 71.1 \u2506 52.0 \u2506 ... \u2506 0.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"min"},{"location":"reference/LazyFrame_min/#min","text":"","title":"Min"},{"location":"reference/LazyFrame_min/#format","text":"function LazyFrame_min","title":"Format"},{"location":"reference/LazyFrame_min/#returns","text":"A new LazyFrame object with applied aggregation. Aggregate the columns in the DataFrame to their minimum value.","title":"Returns"},{"location":"reference/LazyFrame_min/#examples","text":"pl $ DataFrame ( mtcars ) $ lazy ( ) $ min ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 10.4 \u2506 4.0 \u2506 71.1 \u2506 52.0 \u2506 ... \u2506 0.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_print/","text":"data print LazyFrame internal method Format An object of class character of length 1. LazyFrame_print ( x ) Arguments x : LazyFrame Returns self can be used i the middle of a method chain Examples pl $ DataFrame ( iris ) $ lazy ( ) $ print ( ) #> DF [\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"]; PROJECT */5 COLUMNS; SELECTION: \"None\" #> #> [1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\" #> DF [\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"]; PROJECT */5 COLUMNS; SELECTION: \"None\" #>","title":"print"},{"location":"reference/LazyFrame_print/#print-lazyframe-internal-method","text":"","title":"print LazyFrame internal method"},{"location":"reference/LazyFrame_print/#format","text":"An object of class character of length 1. LazyFrame_print ( x )","title":"Format"},{"location":"reference/LazyFrame_print/#arguments","text":"x : LazyFrame","title":"Arguments"},{"location":"reference/LazyFrame_print/#returns","text":"self can be used i the middle of a method chain","title":"Returns"},{"location":"reference/LazyFrame_print/#examples","text":"pl $ DataFrame ( iris ) $ lazy ( ) $ print ( ) #> DF [\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"]; PROJECT */5 COLUMNS; SELECTION: \"None\" #> #> [1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\" #> DF [\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"]; PROJECT */5 COLUMNS; SELECTION: \"None\" #>","title":"Examples"},{"location":"reference/LazyFrame_reverse/","text":"data Reverse Format An object of class character of length 1. LazyFrame_reverse Returns LazyFrame Reverse the DataFrame. Examples pl $ DataFrame ( mtcars ) $ lazy ( ) $ reverse ( ) $ collect ( ) #> polars DataFrame: shape: (32, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 6.0 \u2502 #> \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 4.0 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"reverse"},{"location":"reference/LazyFrame_reverse/#reverse","text":"","title":"Reverse"},{"location":"reference/LazyFrame_reverse/#format","text":"An object of class character of length 1. LazyFrame_reverse","title":"Format"},{"location":"reference/LazyFrame_reverse/#returns","text":"LazyFrame Reverse the DataFrame.","title":"Returns"},{"location":"reference/LazyFrame_reverse/#examples","text":"pl $ DataFrame ( mtcars ) $ lazy ( ) $ reverse ( ) $ collect ( ) #> polars DataFrame: shape: (32, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 6.0 \u2502 #> \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 4.0 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_select/","text":"Lazy_select LazyFrame_select ( ... ) Arguments ... : any single Expr or string naming a column Returns A new LazyFrame object with applied filter. select on a LazyFrame","title":"select"},{"location":"reference/LazyFrame_select/#lazy_select","text":"LazyFrame_select ( ... )","title":"Lazy_select"},{"location":"reference/LazyFrame_select/#arguments","text":"... : any single Expr or string naming a column","title":"Arguments"},{"location":"reference/LazyFrame_select/#returns","text":"A new LazyFrame object with applied filter. select on a LazyFrame","title":"Returns"},{"location":"reference/LazyFrame_slice/","text":"Slice LazyFrame_slice ( offset , length = NULL ) Arguments offset : integer length : integer or NULL Returns DataFrame Get a slice of this DataFrame. Examples pl $ DataFrame ( mtcars ) $ lazy ( ) $ slice ( 2 , 4 ) $ collect ( ) #> polars DataFrame: shape: (4, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 18.7 \u2506 8.0 \u2506 360.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 0.0 \u2506 3.0 \u2506 2.0 \u2502 #> \u2502 18.1 \u2506 6.0 \u2506 225.0 \u2506 105.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( mtcars ) $ lazy ( ) $ slice ( 30 ) $ collect ( ) #> polars DataFrame: shape: (2, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 mtcars [ 2 : 6 , ] #> mpg cyl disp hp drat wt qsec vs am gear carb #> Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 #> Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 #> Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 #> Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 #> Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1","title":"slice"},{"location":"reference/LazyFrame_slice/#slice","text":"LazyFrame_slice ( offset , length = NULL )","title":"Slice"},{"location":"reference/LazyFrame_slice/#arguments","text":"offset : integer length : integer or NULL","title":"Arguments"},{"location":"reference/LazyFrame_slice/#returns","text":"DataFrame Get a slice of this DataFrame.","title":"Returns"},{"location":"reference/LazyFrame_slice/#examples","text":"pl $ DataFrame ( mtcars ) $ lazy ( ) $ slice ( 2 , 4 ) $ collect ( ) #> polars DataFrame: shape: (4, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2502 18.7 \u2506 8.0 \u2506 360.0 \u2506 175.0 \u2506 ... \u2506 0.0 \u2506 0.0 \u2506 3.0 \u2506 2.0 \u2502 #> \u2502 18.1 \u2506 6.0 \u2506 225.0 \u2506 105.0 \u2506 ... \u2506 1.0 \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( mtcars ) $ lazy ( ) $ slice ( 30 ) $ collect ( ) #> polars DataFrame: shape: (2, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 mtcars [ 2 : 6 , ] #> mpg cyl disp hp drat wt qsec vs am gear carb #> Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 #> Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 #> Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 #> Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 #> Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1","title":"Examples"},{"location":"reference/LazyFrame_std/","text":"Std LazyFrame_std ( ddof = 1 ) Arguments ddof : integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1. Returns A new LazyFrame object with applied aggregation. Aggregate the columns of this LazyFrame to their standard deviation values. Examples pl $ DataFrame ( mtcars ) $ lazy ( ) $ std ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6.026948 \u2506 1.785922 \u2506 123.938694 \u2506 68.562868 \u2506 ... \u2506 0.504016 \u2506 0.498991 \u2506 0.737804 \u2506 1.6152 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"std"},{"location":"reference/LazyFrame_std/#std","text":"LazyFrame_std ( ddof = 1 )","title":"Std"},{"location":"reference/LazyFrame_std/#arguments","text":"ddof : integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1.","title":"Arguments"},{"location":"reference/LazyFrame_std/#returns","text":"A new LazyFrame object with applied aggregation. Aggregate the columns of this LazyFrame to their standard deviation values.","title":"Returns"},{"location":"reference/LazyFrame_std/#examples","text":"pl $ DataFrame ( mtcars ) $ lazy ( ) $ std ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 6.026948 \u2506 1.785922 \u2506 123.938694 \u2506 68.562868 \u2506 ... \u2506 0.504016 \u2506 0.498991 \u2506 0.737804 \u2506 1.6152 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_sum/","text":"Sum Format function LazyFrame_sum Returns LazyFrame Aggregate the columns of this DataFrame to their sum values. Examples pl $ DataFrame ( mtcars ) $ lazy ( ) $ sum ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 642.9 \u2506 198.0 \u2506 7383.1 \u2506 4694.0 \u2506 ... \u2506 14.0 \u2506 13.0 \u2506 118.0 \u2506 90.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"sum"},{"location":"reference/LazyFrame_sum/#sum","text":"","title":"Sum"},{"location":"reference/LazyFrame_sum/#format","text":"function LazyFrame_sum","title":"Format"},{"location":"reference/LazyFrame_sum/#returns","text":"LazyFrame Aggregate the columns of this DataFrame to their sum values.","title":"Returns"},{"location":"reference/LazyFrame_sum/#examples","text":"pl $ DataFrame ( mtcars ) $ lazy ( ) $ sum ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 642.9 \u2506 198.0 \u2506 7383.1 \u2506 4694.0 \u2506 ... \u2506 14.0 \u2506 13.0 \u2506 118.0 \u2506 90.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_tail/","text":"Tail LazyFrame_tail ( n ) Arguments n : positive numeric or integer number not larger than 2^32 Returns A new LazyFrame object with applied filter. take last n rows of query Details any number will converted to u32. Negative raises error Examples pl $ DataFrame ( mtcars ) $ lazy ( ) $ tail ( 2 ) $ collect ( ) #> polars DataFrame: shape: (2, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"tail"},{"location":"reference/LazyFrame_tail/#tail","text":"LazyFrame_tail ( n )","title":"Tail"},{"location":"reference/LazyFrame_tail/#arguments","text":"n : positive numeric or integer number not larger than 2^32","title":"Arguments"},{"location":"reference/LazyFrame_tail/#returns","text":"A new LazyFrame object with applied filter. take last n rows of query","title":"Returns"},{"location":"reference/LazyFrame_tail/#details","text":"any number will converted to u32. Negative raises error","title":"Details"},{"location":"reference/LazyFrame_tail/#examples","text":"pl $ DataFrame ( mtcars ) $ lazy ( ) $ tail ( 2 ) $ collect ( ) #> polars DataFrame: shape: (2, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 0.0 \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2502 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_var/","text":"Var LazyFrame_var ( ddof = 1 ) Arguments ddof : integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1. Returns A new LazyFrame object with applied aggregation. Aggregate the columns of this LazyFrame to their variance values. Examples pl $ DataFrame ( mtcars ) $ lazy ( ) $ var ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 36.324103 \u2506 3.189516 \u2506 15360.7998 \u2506 4700.86693 \u2506 ... \u2506 0.254032 \u2506 0.248992 \u2506 0.544355 \u2506 2.608871 \u2502 #> \u2502 \u2506 \u2506 29 \u2506 5 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"var"},{"location":"reference/LazyFrame_var/#var","text":"LazyFrame_var ( ddof = 1 )","title":"Var"},{"location":"reference/LazyFrame_var/#arguments","text":"ddof : integer Delta Degrees of Freedom: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1.","title":"Arguments"},{"location":"reference/LazyFrame_var/#returns","text":"A new LazyFrame object with applied aggregation. Aggregate the columns of this LazyFrame to their variance values.","title":"Returns"},{"location":"reference/LazyFrame_var/#examples","text":"pl $ DataFrame ( mtcars ) $ lazy ( ) $ var ( ) $ collect ( ) #> polars DataFrame: shape: (1, 11) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 vs \u2506 am \u2506 gear \u2506 carb \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 36.324103 \u2506 3.189516 \u2506 15360.7998 \u2506 4700.86693 \u2506 ... \u2506 0.254032 \u2506 0.248992 \u2506 0.544355 \u2506 2.608871 \u2502 #> \u2502 \u2506 \u2506 29 \u2506 5 \u2506 \u2506 \u2506 \u2506 \u2506 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/LazyFrame_with_column/","text":"data Lazy with column Format An object of class character of length 1. LazyFrame_with_column ( expr ) Arguments expr : one Expr or string naming a column Returns A new LazyFrame object with add/modified column. add or replace columns of LazyFrame","title":"with_column"},{"location":"reference/LazyFrame_with_column/#lazy-with-column","text":"","title":"Lazy with column"},{"location":"reference/LazyFrame_with_column/#format","text":"An object of class character of length 1. LazyFrame_with_column ( expr )","title":"Format"},{"location":"reference/LazyFrame_with_column/#arguments","text":"expr : one Expr or string naming a column","title":"Arguments"},{"location":"reference/LazyFrame_with_column/#returns","text":"A new LazyFrame object with add/modified column. add or replace columns of LazyFrame","title":"Returns"},{"location":"reference/LazyFrame_with_columns/","text":"Lazy with columns LazyFrame_with_columns ( ... ) Arguments ... : any single Expr or string naming a column Returns A new LazyFrame object with added/modified columns. add or replace columns of LazyFrame","title":"with_columns"},{"location":"reference/LazyFrame_with_columns/#lazy-with-columns","text":"LazyFrame_with_columns ( ... )","title":"Lazy with columns"},{"location":"reference/LazyFrame_with_columns/#arguments","text":"... : any single Expr or string naming a column","title":"Arguments"},{"location":"reference/LazyFrame_with_columns/#returns","text":"A new LazyFrame object with added/modified columns. add or replace columns of LazyFrame","title":"Returns"},{"location":"reference/LazyGroupBy_agg/","text":"LazyGroupBy_agg LazyGroupBy_agg ( ... ) Arguments ... : any Expr or string Returns A new LazyFrame object. aggregate a polar_lazy_groupby","title":"agg"},{"location":"reference/LazyGroupBy_agg/#lazygroupby_agg","text":"LazyGroupBy_agg ( ... )","title":"LazyGroupBy_agg"},{"location":"reference/LazyGroupBy_agg/#arguments","text":"... : any Expr or string","title":"Arguments"},{"location":"reference/LazyGroupBy_agg/#returns","text":"A new LazyFrame object. aggregate a polar_lazy_groupby","title":"Returns"},{"location":"reference/LazyGroupBy_apply/","text":"LazyGroupBy_apply LazyGroupBy_apply ( f ) Arguments f : R function to apply Returns A new LazyFrame object. one day this will apply","title":"apply"},{"location":"reference/LazyGroupBy_apply/#lazygroupby_apply","text":"LazyGroupBy_apply ( f )","title":"LazyGroupBy_apply"},{"location":"reference/LazyGroupBy_apply/#arguments","text":"f : R function to apply","title":"Arguments"},{"location":"reference/LazyGroupBy_apply/#returns","text":"A new LazyFrame object. one day this will apply","title":"Returns"},{"location":"reference/LazyGroupBy_class/","text":"Use groups on a Polars lazy DataFrame Returns A lazy grouped DataFrame Use groups on a Polars lazy DataFrame","title":"Use groups on a Polars lazy DataFrame"},{"location":"reference/LazyGroupBy_class/#use-groups-on-a-polars-lazy-dataframe","text":"","title":"Use groups on a Polars lazy DataFrame"},{"location":"reference/LazyGroupBy_class/#returns","text":"A lazy grouped DataFrame Use groups on a Polars lazy DataFrame","title":"Returns"},{"location":"reference/LazyGroupBy_head/","text":"LazyGroupBy_head LazyGroupBy_head ( n = 1L ) Arguments n : integer number of rows to get Returns A new LazyFrame object. get n rows of head of group","title":"head"},{"location":"reference/LazyGroupBy_head/#lazygroupby_head","text":"LazyGroupBy_head ( n = 1L )","title":"LazyGroupBy_head"},{"location":"reference/LazyGroupBy_head/#arguments","text":"n : integer number of rows to get","title":"Arguments"},{"location":"reference/LazyGroupBy_head/#returns","text":"A new LazyFrame object. get n rows of head of group","title":"Returns"},{"location":"reference/LazyGroupBy_print/","text":"LazyGroupBy_print LazyGroupBy_print () prints opague groupby, not much to show","title":"print"},{"location":"reference/LazyGroupBy_print/#lazygroupby_print","text":"LazyGroupBy_print () prints opague groupby, not much to show","title":"LazyGroupBy_print"},{"location":"reference/LazyGroupBy_tail/","text":"LazyGroupBy_tail LazyGroupBy_tail ( n = 1L ) Arguments n : integer number of rows to get Returns A new LazyFrame object. get n tail rows of group","title":"tail"},{"location":"reference/LazyGroupBy_tail/#lazygroupby_tail","text":"LazyGroupBy_tail ( n = 1L )","title":"LazyGroupBy_tail"},{"location":"reference/LazyGroupBy_tail/#arguments","text":"n : integer number of rows to get","title":"Arguments"},{"location":"reference/LazyGroupBy_tail/#returns","text":"A new LazyFrame object. get n tail rows of group","title":"Returns"},{"location":"reference/Ok/","text":"Wrap in Ok Ok ( x ) Arguments x : any R object Returns same R object wrapped in a Ok-result Wrap in Ok","title":"Ok"},{"location":"reference/Ok/#wrap-in-ok","text":"Ok ( x )","title":"Wrap in Ok"},{"location":"reference/Ok/#arguments","text":"x : any R object","title":"Arguments"},{"location":"reference/Ok/#returns","text":"same R object wrapped in a Ok-result Wrap in Ok","title":"Returns"},{"location":"reference/PolarsBackgroundHandle_is_exhausted/","text":"PolarsBackgroundHandle PolarsBackgroundHandle_is_exhausted () Returns Bool PolarsBackgroundHandle Examples lazy_df = pl $ DataFrame ( iris [ , 1 : 3 ] ) $ lazy ( ) $ select ( pl $ all ( ) $ first ( ) ) handle = lazy_df $ collect_background ( ) handle $ is_exhausted ( ) #> [1] FALSE df = handle $ join ( ) handle $ is_exhausted ( ) #> [1] TRUE","title":"PolarsBackgroundHandle_is_exhausted"},{"location":"reference/PolarsBackgroundHandle_is_exhausted/#polarsbackgroundhandle","text":"PolarsBackgroundHandle_is_exhausted ()","title":"PolarsBackgroundHandle"},{"location":"reference/PolarsBackgroundHandle_is_exhausted/#returns","text":"Bool PolarsBackgroundHandle","title":"Returns"},{"location":"reference/PolarsBackgroundHandle_is_exhausted/#examples","text":"lazy_df = pl $ DataFrame ( iris [ , 1 : 3 ] ) $ lazy ( ) $ select ( pl $ all ( ) $ first ( ) ) handle = lazy_df $ collect_background ( ) handle $ is_exhausted ( ) #> [1] FALSE df = handle $ join ( ) handle $ is_exhausted ( ) #> [1] TRUE","title":"Examples"},{"location":"reference/PolarsBackgroundHandle_join/","text":"PolarsBackgroundHandle PolarsBackgroundHandle_join () Returns DataFrame PolarsBackgroundHandle Examples lazy_df = pl $ DataFrame ( iris [ , 1 : 3 ] ) $ lazy ( ) $ select ( pl $ all ( ) $ first ( ) ) handle = lazy_df $ collect_background ( ) df = handle $ join ( )","title":"PolarsBackgroundHandle_join"},{"location":"reference/PolarsBackgroundHandle_join/#polarsbackgroundhandle","text":"PolarsBackgroundHandle_join ()","title":"PolarsBackgroundHandle"},{"location":"reference/PolarsBackgroundHandle_join/#returns","text":"DataFrame PolarsBackgroundHandle","title":"Returns"},{"location":"reference/PolarsBackgroundHandle_join/#examples","text":"lazy_df = pl $ DataFrame ( iris [ , 1 : 3 ] ) $ lazy ( ) $ select ( pl $ all ( ) $ first ( ) ) handle = lazy_df $ collect_background ( ) df = handle $ join ( )","title":"Examples"},{"location":"reference/RField_name/","text":"get/set Field name RField_name () Returns name get/set Field name Examples field = pl $ Field ( \"Cities\" , pl $ Utf8 ) #get name / datatype field $ name #> [1] \"Cities\" field $ datatype #> DataType: Utf8 #set + get values field $ name = \"CityPoPulations\" #<- is fine too field $ datatype = pl $ UInt32 print ( field ) #> Field { #> name: \"CityPoPulations\", #> dtype: UInt32, #> }","title":"RField_name"},{"location":"reference/RField_name/#getset-field-name","text":"RField_name ()","title":"get/set Field name"},{"location":"reference/RField_name/#returns","text":"name get/set Field name","title":"Returns"},{"location":"reference/RField_name/#examples","text":"field = pl $ Field ( \"Cities\" , pl $ Utf8 ) #get name / datatype field $ name #> [1] \"Cities\" field $ datatype #> DataType: Utf8 #set + get values field $ name = \"CityPoPulations\" #<- is fine too field $ datatype = pl $ UInt32 print ( field ) #> Field { #> name: \"CityPoPulations\", #> dtype: UInt32, #> }","title":"Examples"},{"location":"reference/RField_print/","text":"Print a polars Field RField_print () Returns self Print a polars Field Examples print ( pl $ Field ( \"foo\" , pl $ List ( pl $ UInt64 ) ) ) #> Field { #> name: \"foo\", #> dtype: List( #> UInt64, #> ), #> }","title":"RField_print"},{"location":"reference/RField_print/#print-a-polars-field","text":"RField_print ()","title":"Print a polars Field"},{"location":"reference/RField_print/#returns","text":"self Print a polars Field","title":"Returns"},{"location":"reference/RField_print/#examples","text":"print ( pl $ Field ( \"foo\" , pl $ List ( pl $ UInt64 ) ) ) #> Field { #> name: \"foo\", #> dtype: List( #> UInt64, #> ), #> }","title":"Examples"},{"location":"reference/Series/","text":"Create new Series Arguments x : any vector name : string Returns Series found in api as pl$Series named Series_constructor internally Examples { pl $ Series ( 1 : 4 ) } #> polars Series: shape: (4,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> 4 #> ]","title":"Series"},{"location":"reference/Series/#create-new-series","text":"","title":"Create new Series"},{"location":"reference/Series/#arguments","text":"x : any vector name : string","title":"Arguments"},{"location":"reference/Series/#returns","text":"Series found in api as pl$Series named Series_constructor internally","title":"Returns"},{"location":"reference/Series/#examples","text":"{ pl $ Series ( 1 : 4 ) } #> polars Series: shape: (4,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> 4 #> ]","title":"Examples"},{"location":"reference/Series_abs/","text":"Take absolute value of Series Series_abs () Returns Series Take absolute value of Series Examples pl $ Series ( - 2 : 2 ) $ abs ( ) #> polars Series: shape: (5,) #> Series: '' [i32] #> [ #> 2 #> 1 #> 0 #> 1 #> 2 #> ]","title":"abs"},{"location":"reference/Series_abs/#take-absolute-value-of-series","text":"Series_abs ()","title":"Take absolute value of Series"},{"location":"reference/Series_abs/#returns","text":"Series Take absolute value of Series","title":"Returns"},{"location":"reference/Series_abs/#examples","text":"pl $ Series ( - 2 : 2 ) $ abs ( ) #> polars Series: shape: (5,) #> Series: '' [i32] #> [ #> 2 #> 1 #> 0 #> 1 #> 2 #> ]","title":"Examples"},{"location":"reference/Series_add/","text":"add Series Series_add ( other ) ## S3 method for class 'Series' s1 + s2 Arguments other : Series or into Series s1 : lhs Series s2 : rhs Series or any into Series Returns Series Series arithmetics Examples pl $ Series ( 1 : 3 ) $ add ( 11 : 13 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 12 #> 14 #> 16 #> ] pl $ Series ( 1 : 3 ) $ add ( pl $ Series ( 11 : 13 ) ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 12 #> 14 #> 16 #> ] pl $ Series ( 1 : 3 ) $ add ( 1L ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 2 #> 3 #> 4 #> ] 1L + pl $ Series ( 1 : 3 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 2 #> 3 #> 4 #> ] pl $ Series ( 1 : 3 ) + 1L #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 2 #> 3 #> 4 #> ]","title":"add"},{"location":"reference/Series_add/#add-series","text":"Series_add ( other ) ## S3 method for class 'Series' s1 + s2","title":"add Series"},{"location":"reference/Series_add/#arguments","text":"other : Series or into Series s1 : lhs Series s2 : rhs Series or any into Series","title":"Arguments"},{"location":"reference/Series_add/#returns","text":"Series Series arithmetics","title":"Returns"},{"location":"reference/Series_add/#examples","text":"pl $ Series ( 1 : 3 ) $ add ( 11 : 13 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 12 #> 14 #> 16 #> ] pl $ Series ( 1 : 3 ) $ add ( pl $ Series ( 11 : 13 ) ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 12 #> 14 #> 16 #> ] pl $ Series ( 1 : 3 ) $ add ( 1L ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 2 #> 3 #> 4 #> ] 1L + pl $ Series ( 1 : 3 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 2 #> 3 #> 4 #> ] pl $ Series ( 1 : 3 ) + 1L #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 2 #> 3 #> 4 #> ]","title":"Examples"},{"location":"reference/Series_alias/","text":"data Alias Format An object of class character of length 1. Series_alias ( name ) Arguments name : a String as the new name Returns Series Change name of Series Examples pl $ Series ( 1 : 3 ,name = \"alice\" ) $ alias ( \"bob\" ) #> polars Series: shape: (3,) #> Series: 'bob' [i32] #> [ #> 1 #> 2 #> 3 #> ]","title":"alias"},{"location":"reference/Series_alias/#alias","text":"","title":"Alias"},{"location":"reference/Series_alias/#format","text":"An object of class character of length 1. Series_alias ( name )","title":"Format"},{"location":"reference/Series_alias/#arguments","text":"name : a String as the new name","title":"Arguments"},{"location":"reference/Series_alias/#returns","text":"Series Change name of Series","title":"Returns"},{"location":"reference/Series_alias/#examples","text":"pl $ Series ( 1 : 3 ,name = \"alice\" ) $ alias ( \"bob\" ) #> polars Series: shape: (3,) #> Series: 'bob' [i32] #> [ #> 1 #> 2 #> 3 #> ]","title":"Examples"},{"location":"reference/Series_all/","text":"Reduce Boolean Series with ALL Series_all () Returns bool Reduce Boolean Series with ALL Examples pl $ Series ( c ( TRUE , TRUE , NA ) ) $ all ( ) #> [1] FALSE","title":"all"},{"location":"reference/Series_all/#reduce-boolean-series-with-all","text":"Series_all ()","title":"Reduce Boolean Series with ALL"},{"location":"reference/Series_all/#returns","text":"bool Reduce Boolean Series with ALL","title":"Returns"},{"location":"reference/Series_all/#examples","text":"pl $ Series ( c ( TRUE , TRUE , NA ) ) $ all ( ) #> [1] FALSE","title":"Examples"},{"location":"reference/Series_any/","text":"Reduce Boolean Series with ANY Series_any () Returns bool Reduce Boolean Series with ANY Examples pl $ Series ( c ( TRUE , FALSE , NA ) ) $ any ( ) #> [1] TRUE","title":"any"},{"location":"reference/Series_any/#reduce-boolean-series-with-any","text":"Series_any ()","title":"Reduce Boolean Series with ANY"},{"location":"reference/Series_any/#returns","text":"bool Reduce Boolean Series with ANY","title":"Returns"},{"location":"reference/Series_any/#examples","text":"pl $ Series ( c ( TRUE , FALSE , NA ) ) $ any ( ) #> [1] TRUE","title":"Examples"},{"location":"reference/Series_append/","text":"append (default immutable) Series_append ( other , immutable = TRUE ) Arguments other : Series to append immutable : bool should append be immutable, default TRUE as mutable operations should be avoided in plain R API's. Returns Series append two Series, see details for mutability Details if immutable = FLASE, the Series object will not behave as immutable. This mean appending to this Series will affect any variable pointing to this memory location. This will break normal scoping rules of R. Polars-clones are cheap. Mutable operations are likely never needed in any sense. Examples #default immutable behaviour, s_imut and s_imut_copy stay the same s_imut = pl $ Series ( 1 : 3 ) s_imut_copy = s_imut s_new = s_imut $ append ( pl $ Series ( 1 : 3 ) ) identical ( s_imut $ to_r_vector ( ) , s_imut_copy $ to_r_vector ( ) ) #> [1] TRUE #pypolars-like mutable behaviour,s_mut_copy become the same as s_new s_mut = pl $ Series ( 1 : 3 ) s_mut_copy = s_mut #must deactivate this to allow to use immutable=FALSE pl $ set_polars_options ( strictly_immutable = FALSE ) #> $strictly_immutable #> [1] TRUE #> s_new = s_mut $ append ( pl $ Series ( 1 : 3 ) ,immutable = FALSE ) identical ( s_new $ to_r_vector ( ) , s_mut_copy $ to_r_vector ( ) ) #> [1] TRUE","title":"append"},{"location":"reference/Series_append/#append-default-immutable","text":"Series_append ( other , immutable = TRUE )","title":"append (default immutable)"},{"location":"reference/Series_append/#arguments","text":"other : Series to append immutable : bool should append be immutable, default TRUE as mutable operations should be avoided in plain R API's.","title":"Arguments"},{"location":"reference/Series_append/#returns","text":"Series append two Series, see details for mutability","title":"Returns"},{"location":"reference/Series_append/#details","text":"if immutable = FLASE, the Series object will not behave as immutable. This mean appending to this Series will affect any variable pointing to this memory location. This will break normal scoping rules of R. Polars-clones are cheap. Mutable operations are likely never needed in any sense.","title":"Details"},{"location":"reference/Series_append/#examples","text":"#default immutable behaviour, s_imut and s_imut_copy stay the same s_imut = pl $ Series ( 1 : 3 ) s_imut_copy = s_imut s_new = s_imut $ append ( pl $ Series ( 1 : 3 ) ) identical ( s_imut $ to_r_vector ( ) , s_imut_copy $ to_r_vector ( ) ) #> [1] TRUE #pypolars-like mutable behaviour,s_mut_copy become the same as s_new s_mut = pl $ Series ( 1 : 3 ) s_mut_copy = s_mut #must deactivate this to allow to use immutable=FALSE pl $ set_polars_options ( strictly_immutable = FALSE ) #> $strictly_immutable #> [1] TRUE #> s_new = s_mut $ append ( pl $ Series ( 1 : 3 ) ,immutable = FALSE ) identical ( s_new $ to_r_vector ( ) , s_mut_copy $ to_r_vector ( ) ) #> [1] TRUE","title":"Examples"},{"location":"reference/Series_apply/","text":"Apply every value with an R fun Series_apply ( fun , datatype = NULL , strict_return_type = TRUE , allow_fail_eval = FALSE ) Arguments fun : r function, should take a scalar value as input and return one. datatype : DataType of return value. Default NULL means same as input. strict_return_type : bool, default TRUE: fail on wrong return type, FALSE: convert to polars Null allow_fail_eval : bool, default FALSE: raise R fun error, TRUE: convert to polars Null Returns Series About as slow as regular non-vectorized R. Similar to using R sapply on a vector. Examples s = pl $ Series ( letters [ 1 : 5 ] , \"ltrs\" ) f = \\ ( x ) paste ( x , \":\" , as.integer ( charToRaw ( x ) ) ) s $ apply ( f , pl $ Utf8 ) #> polars Series: shape: (5,) #> Series: 'ltrs_apply' [str] #> [ #> \"a : 97\" #> \"b : 98\" #> \"c : 99\" #> \"d : 100\" #> \"e : 101\" #> ] #same as pl $ Series ( sapply ( s $ to_r ( ) , f ) , s $ name ) #> polars Series: shape: (5,) #> Series: 'ltrs' [str] #> [ #> \"a : 97\" #> \"b : 98\" #> \"c : 99\" #> \"d : 100\" #> \"e : 101\" #> ]","title":"apply"},{"location":"reference/Series_apply/#apply-every-value-with-an-r-fun","text":"Series_apply ( fun , datatype = NULL , strict_return_type = TRUE , allow_fail_eval = FALSE )","title":"Apply every value with an R fun"},{"location":"reference/Series_apply/#arguments","text":"fun : r function, should take a scalar value as input and return one. datatype : DataType of return value. Default NULL means same as input. strict_return_type : bool, default TRUE: fail on wrong return type, FALSE: convert to polars Null allow_fail_eval : bool, default FALSE: raise R fun error, TRUE: convert to polars Null","title":"Arguments"},{"location":"reference/Series_apply/#returns","text":"Series About as slow as regular non-vectorized R. Similar to using R sapply on a vector.","title":"Returns"},{"location":"reference/Series_apply/#examples","text":"s = pl $ Series ( letters [ 1 : 5 ] , \"ltrs\" ) f = \\ ( x ) paste ( x , \":\" , as.integer ( charToRaw ( x ) ) ) s $ apply ( f , pl $ Utf8 ) #> polars Series: shape: (5,) #> Series: 'ltrs_apply' [str] #> [ #> \"a : 97\" #> \"b : 98\" #> \"c : 99\" #> \"d : 100\" #> \"e : 101\" #> ] #same as pl $ Series ( sapply ( s $ to_r ( ) , f ) , s $ name ) #> polars Series: shape: (5,) #> Series: 'ltrs' [str] #> [ #> \"a : 97\" #> \"b : 98\" #> \"c : 99\" #> \"d : 100\" #> \"e : 101\" #> ]","title":"Examples"},{"location":"reference/Series_arg_max/","text":"data idx to max value Format An object of class character of length 1. Series_arg_max Returns bool idx to max value Examples pl $ Series ( c ( 5 , 1 ) ) $ arg_max ( ) #> [1] 0","title":"arg_max"},{"location":"reference/Series_arg_max/#idx-to-max-value","text":"","title":"idx to max value"},{"location":"reference/Series_arg_max/#format","text":"An object of class character of length 1. Series_arg_max","title":"Format"},{"location":"reference/Series_arg_max/#returns","text":"bool idx to max value","title":"Returns"},{"location":"reference/Series_arg_max/#examples","text":"pl $ Series ( c ( 5 , 1 ) ) $ arg_max ( ) #> [1] 0","title":"Examples"},{"location":"reference/Series_arg_min/","text":"data idx to min value Format An object of class character of length 1. Series_arg_min Returns bool idx to min value Examples pl $ Series ( c ( 5 , 1 ) ) $ arg_min ( ) #> [1] 1","title":"arg_min"},{"location":"reference/Series_arg_min/#idx-to-min-value","text":"","title":"idx to min value"},{"location":"reference/Series_arg_min/#format","text":"An object of class character of length 1. Series_arg_min","title":"Format"},{"location":"reference/Series_arg_min/#returns","text":"bool idx to min value","title":"Returns"},{"location":"reference/Series_arg_min/#examples","text":"pl $ Series ( c ( 5 , 1 ) ) $ arg_min ( ) #> [1] 1","title":"Examples"},{"location":"reference/Series_arr/","text":"arr: list related methods on Series of dtype List Series_arr () Returns Expr Create an object namespace of all list related methods. See the individual method pages for full details Examples s = pl $ Series ( list ( 1 : 3 , 1 : 2 , NULL ) ) s #> polars Series: shape: (3,) #> Series: '' [list[i32]] #> [ #> [1, 2, 3] #> [1, 2] #> [] #> ] s $ arr $ first ( ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 1 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr"},{"location":"reference/Series_arr/#arr-list-related-methods-on-series-of-dtype-list","text":"Series_arr ()","title":"arr: list related methods on Series of dtype List"},{"location":"reference/Series_arr/#returns","text":"Expr Create an object namespace of all list related methods. See the individual method pages for full details","title":"Returns"},{"location":"reference/Series_arr/#examples","text":"s = pl $ Series ( list ( 1 : 3 , 1 : 2 , NULL ) ) s #> polars Series: shape: (3,) #> Series: '' [list[i32]] #> [ #> [1, 2, 3] #> [1, 2] #> [] #> ] s $ arr $ first ( ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 1 \u2502 #> \u2502 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Series_ceil/","text":"Series_ceil Series_ceil () Returns bool Ceil of this Series Examples pl $ Series ( c ( .5 , 1.999 ) ) $ ceil ( ) #> polars Series: shape: (2,) #> Series: '' [f64] #> [ #> 1.0 #> 2.0 #> ]","title":"ceil"},{"location":"reference/Series_ceil/#series_ceil","text":"Series_ceil ()","title":"Series_ceil"},{"location":"reference/Series_ceil/#returns","text":"bool Ceil of this Series","title":"Returns"},{"location":"reference/Series_ceil/#examples","text":"pl $ Series ( c ( .5 , 1.999 ) ) $ ceil ( ) #> polars Series: shape: (2,) #> Series: '' [f64] #> [ #> 1.0 #> 2.0 #> ]","title":"Examples"},{"location":"reference/Series_chunk_lengths/","text":"data Lengths of Series memory chunks Format An object of class character of length 1. Series_chunk_lengths Returns numeric vector. Length is number of chunks. Sum of lengths is equal to size of Series. Get the Lengths of Series memory chunks as vector. Examples chunked_series = c ( pl $ Series ( 1 : 3 ) , pl $ Series ( 1 : 10 ) ) chunked_series $ chunk_lengths ( ) #> [1] 3 10","title":"chunk_lengths"},{"location":"reference/Series_chunk_lengths/#lengths-of-series-memory-chunks","text":"","title":"Lengths of Series memory chunks"},{"location":"reference/Series_chunk_lengths/#format","text":"An object of class character of length 1. Series_chunk_lengths","title":"Format"},{"location":"reference/Series_chunk_lengths/#returns","text":"numeric vector. Length is number of chunks. Sum of lengths is equal to size of Series. Get the Lengths of Series memory chunks as vector.","title":"Returns"},{"location":"reference/Series_chunk_lengths/#examples","text":"chunked_series = c ( pl $ Series ( 1 : 3 ) , pl $ Series ( 1 : 10 ) ) chunked_series $ chunk_lengths ( ) #> [1] 3 10","title":"Examples"},{"location":"reference/Series_class/","text":"Inner workings of the Series-class The Series -class is simply two environments of respectively the public and private methods/function calls to the polars rust side. The instanciated Series -object is an externalptr to a lowlevel rust polars Series object. The pointer address is the only statefullness of the Series object on the R side. Any other state resides on the rust side. The S3 method .DollarNames.Series exposes all public $foobar() -methods which are callable onto the object. Most methods return another Series -class instance or similar which allows for method chaining. This class system in lack of a better name could be called \"environment classes\" and is the same class system extendr provides, except here there is both a public and private set of methods. For implementation reasons, the private methods are external and must be called from polars:::.pr.$Series$methodname(), also all private methods must take any self as an argument, thus they are pure functions. Having the private methods as pure functions solved/simplified self-referential complications. Details Check out the source code in R/Series_frame.R how public methods are derived from private methods. Check out extendr-wrappers.R to see the extendr-auto-generated methods. These are moved to .pr and converted into pure external functions in after-wrappers.R. In zzz.R (named zzz to be last file sourced) the extendr-methods are removed and replaced by any function prefixed Series_ . Examples #see all exported methods ls ( polars ::: Series ) #> [1] \"abs\" \"add\" \"alias\" \"all\" \"any\" \"append\" \"apply\" #> [8] \"arg_max\" \"arg_min\" \"arr\" \"ceil\" \"chunk_lengths\" \"clone\" \"compare\" #> [15] \"cumsum\" \"div\" \"dtype\" \"expr\" \"flags\" \"floor\" \"is_numeric\" #> [22] \"is_sorted\" \"len\" \"max\" \"min\" \"mul\" \"name\" \"print\" #> [29] \"rem\" \"rename\" \"rep\" \"series_equal\" \"set_sorted\" \"shape\" \"sort\" #> [36] \"std\" \"sub\" \"sum\" \"to_frame\" \"to_lit\" \"to_r\" \"to_r_list\" #> [43] \"to_r_vector\" \"value_counts\" \"var\" #see all private methods (not intended for regular use) ls ( polars ::: .pr $ Series ) #> [1] \"abs\" \"add\" \"alias\" \"all\" #> [5] \"any\" \"append_mut\" \"apply\" \"arg_max\" #> [9] \"arg_min\" \"ceil\" \"chunk_lengths\" \"clone\" #> [13] \"compare\" \"cumsum\" \"div\" \"dtype\" #> [17] \"floor\" \"from_arrow\" \"is_sorted\" \"is_sorted_flag\" #> [21] \"is_sorted_reverse_flag\" \"len\" \"max\" \"min\" #> [25] \"mul\" \"name\" \"new\" \"panic\" #> [29] \"print\" \"rem\" \"rename_mut\" \"rep\" #> [33] \"series_equal\" \"set_sorted_mut\" \"shape\" \"sleep\" #> [37] \"sort_mut\" \"sub\" \"sum\" \"to_frame\" #> [41] \"to_r\" \"value_counts\" #make an object s = pl $ Series ( 1 : 3 ) #use a public method/property s $ shape #> [1] 3 1 #use a private method (mutable append not allowed in public api) s_copy = s .pr $ Series $ append_mut ( s , pl $ Series ( 5 : 1 ) ) #> $ok #> NULL #> #> $err #> NULL #> #> attr(,\"class\") #> [1] \"extendr_result\" identical ( s_copy $ to_r ( ) , s $ to_r ( ) ) # s_copy was modified when s was modified #> [1] TRUE","title":"Inner workings of the Series-class"},{"location":"reference/Series_class/#inner-workings-of-the-series-class","text":"The Series -class is simply two environments of respectively the public and private methods/function calls to the polars rust side. The instanciated Series -object is an externalptr to a lowlevel rust polars Series object. The pointer address is the only statefullness of the Series object on the R side. Any other state resides on the rust side. The S3 method .DollarNames.Series exposes all public $foobar() -methods which are callable onto the object. Most methods return another Series -class instance or similar which allows for method chaining. This class system in lack of a better name could be called \"environment classes\" and is the same class system extendr provides, except here there is both a public and private set of methods. For implementation reasons, the private methods are external and must be called from polars:::.pr.$Series$methodname(), also all private methods must take any self as an argument, thus they are pure functions. Having the private methods as pure functions solved/simplified self-referential complications.","title":"Inner workings of the Series-class"},{"location":"reference/Series_class/#details","text":"Check out the source code in R/Series_frame.R how public methods are derived from private methods. Check out extendr-wrappers.R to see the extendr-auto-generated methods. These are moved to .pr and converted into pure external functions in after-wrappers.R. In zzz.R (named zzz to be last file sourced) the extendr-methods are removed and replaced by any function prefixed Series_ .","title":"Details"},{"location":"reference/Series_class/#examples","text":"#see all exported methods ls ( polars ::: Series ) #> [1] \"abs\" \"add\" \"alias\" \"all\" \"any\" \"append\" \"apply\" #> [8] \"arg_max\" \"arg_min\" \"arr\" \"ceil\" \"chunk_lengths\" \"clone\" \"compare\" #> [15] \"cumsum\" \"div\" \"dtype\" \"expr\" \"flags\" \"floor\" \"is_numeric\" #> [22] \"is_sorted\" \"len\" \"max\" \"min\" \"mul\" \"name\" \"print\" #> [29] \"rem\" \"rename\" \"rep\" \"series_equal\" \"set_sorted\" \"shape\" \"sort\" #> [36] \"std\" \"sub\" \"sum\" \"to_frame\" \"to_lit\" \"to_r\" \"to_r_list\" #> [43] \"to_r_vector\" \"value_counts\" \"var\" #see all private methods (not intended for regular use) ls ( polars ::: .pr $ Series ) #> [1] \"abs\" \"add\" \"alias\" \"all\" #> [5] \"any\" \"append_mut\" \"apply\" \"arg_max\" #> [9] \"arg_min\" \"ceil\" \"chunk_lengths\" \"clone\" #> [13] \"compare\" \"cumsum\" \"div\" \"dtype\" #> [17] \"floor\" \"from_arrow\" \"is_sorted\" \"is_sorted_flag\" #> [21] \"is_sorted_reverse_flag\" \"len\" \"max\" \"min\" #> [25] \"mul\" \"name\" \"new\" \"panic\" #> [29] \"print\" \"rem\" \"rename_mut\" \"rep\" #> [33] \"series_equal\" \"set_sorted_mut\" \"shape\" \"sleep\" #> [37] \"sort_mut\" \"sub\" \"sum\" \"to_frame\" #> [41] \"to_r\" \"value_counts\" #make an object s = pl $ Series ( 1 : 3 ) #use a public method/property s $ shape #> [1] 3 1 #use a private method (mutable append not allowed in public api) s_copy = s .pr $ Series $ append_mut ( s , pl $ Series ( 5 : 1 ) ) #> $ok #> NULL #> #> $err #> NULL #> #> attr(,\"class\") #> [1] \"extendr_result\" identical ( s_copy $ to_r ( ) , s $ to_r ( ) ) # s_copy was modified when s was modified #> [1] TRUE","title":"Examples"},{"location":"reference/Series_clone/","text":"data Clone a Series Format An object of class character of length 1. Series_clone Returns Series Rarely useful as Series are nearly 100% immutable Any modification of a Series should lead to a clone anyways. Examples s1 = pl $ Series ( 1 : 3 ) ; s2 = s1 $ clone ( ) ; s3 = s1 pl $ mem_address ( s1 ) != pl $ mem_address ( s2 ) #> [1] TRUE pl $ mem_address ( s1 ) == pl $ mem_address ( s3 ) #> [1] TRUE","title":"clone"},{"location":"reference/Series_clone/#clone-a-series","text":"","title":"Clone a Series"},{"location":"reference/Series_clone/#format","text":"An object of class character of length 1. Series_clone","title":"Format"},{"location":"reference/Series_clone/#returns","text":"Series Rarely useful as Series are nearly 100% immutable Any modification of a Series should lead to a clone anyways.","title":"Returns"},{"location":"reference/Series_clone/#examples","text":"s1 = pl $ Series ( 1 : 3 ) ; s2 = s1 $ clone ( ) ; s3 = s1 pl $ mem_address ( s1 ) != pl $ mem_address ( s2 ) #> [1] TRUE pl $ mem_address ( s1 ) == pl $ mem_address ( s3 ) #> [1] TRUE","title":"Examples"},{"location":"reference/Series_compare/","text":"Compare Series Series_compare ( other , op ) ## S3 method for class 'Series' s1 == s2 ## S3 method for class 'Series' s1 != s2 ## S3 method for class 'Series' s1 < s2 ## S3 method for class 'Series' s1 > s2 ## S3 method for class 'Series' s1 <= s2 ## S3 method for class 'Series' s1 >= s2 Arguments other : A Series or something a Series can be created from op : the chosen operator a String either: 'equal', 'not_equal', 'lt', 'gt', 'lt_eq' or 'gt_eq' s1 : lhs Series s2 : rhs Series or any into Series Returns Series compare two Series Examples pl $ Series ( 1 : 5 ) == pl $ Series ( c ( 1 : 3 , NA_integer_ , 10L ) ) #> polars Series: shape: (5,) #> Series: '' [bool] #> [ #> true #> true #> true #> false #> false #> ]","title":"compare"},{"location":"reference/Series_compare/#compare-series","text":"Series_compare ( other , op ) ## S3 method for class 'Series' s1 == s2 ## S3 method for class 'Series' s1 != s2 ## S3 method for class 'Series' s1 < s2 ## S3 method for class 'Series' s1 > s2 ## S3 method for class 'Series' s1 <= s2 ## S3 method for class 'Series' s1 >= s2","title":"Compare Series"},{"location":"reference/Series_compare/#arguments","text":"other : A Series or something a Series can be created from op : the chosen operator a String either: 'equal', 'not_equal', 'lt', 'gt', 'lt_eq' or 'gt_eq' s1 : lhs Series s2 : rhs Series or any into Series","title":"Arguments"},{"location":"reference/Series_compare/#returns","text":"Series compare two Series","title":"Returns"},{"location":"reference/Series_compare/#examples","text":"pl $ Series ( 1 : 5 ) == pl $ Series ( c ( 1 : 3 , NA_integer_ , 10L ) ) #> polars Series: shape: (5,) #> Series: '' [bool] #> [ #> true #> true #> true #> false #> false #> ]","title":"Examples"},{"location":"reference/Series_cumsum/","text":"Cumulative sum Series_cumsum ( reverse = FALSE ) Arguments reverse : bool, default FALSE, if true roll over vector from back to forth Returns Series Get an array with the cumulative sum computed at every element. Details Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues. Examples pl $ Series ( c ( 1 : 2 , NA , 3 , NaN , 4 , Inf ) ) $ cumsum ( ) #> polars Series: shape: (7,) #> Series: '' [f64] #> [ #> 1.0 #> 3.0 #> null #> 6.0 #> NaN #> NaN #> NaN #> ] pl $ Series ( c ( 1 : 2 , NA , 3 , Inf , 4 , - Inf , 5 ) ) $ cumsum ( ) #> polars Series: shape: (8,) #> Series: '' [f64] #> [ #> 1.0 #> 3.0 #> null #> 6.0 #> inf #> inf #> NaN #> NaN #> ]","title":"cumsum"},{"location":"reference/Series_cumsum/#cumulative-sum","text":"Series_cumsum ( reverse = FALSE )","title":"Cumulative sum"},{"location":"reference/Series_cumsum/#arguments","text":"reverse : bool, default FALSE, if true roll over vector from back to forth","title":"Arguments"},{"location":"reference/Series_cumsum/#returns","text":"Series Get an array with the cumulative sum computed at every element.","title":"Returns"},{"location":"reference/Series_cumsum/#details","text":"Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues.","title":"Details"},{"location":"reference/Series_cumsum/#examples","text":"pl $ Series ( c ( 1 : 2 , NA , 3 , NaN , 4 , Inf ) ) $ cumsum ( ) #> polars Series: shape: (7,) #> Series: '' [f64] #> [ #> 1.0 #> 3.0 #> null #> 6.0 #> NaN #> NaN #> NaN #> ] pl $ Series ( c ( 1 : 2 , NA , 3 , Inf , 4 , - Inf , 5 ) ) $ cumsum ( ) #> polars Series: shape: (8,) #> Series: '' [f64] #> [ #> 1.0 #> 3.0 #> null #> 6.0 #> inf #> inf #> NaN #> NaN #> ]","title":"Examples"},{"location":"reference/Series_div/","text":"div Series Series_div ( other ) ## S3 method for class 'Series' s1 / s2 Arguments other : Series or into Series s1 : lhs Series s2 : rhs Series or any into Series Returns Series Series arithmetics Examples pl $ Series ( 1 : 3 ) $ div ( 11 : 13 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 0 #> 0 #> 0 #> ] pl $ Series ( 1 : 3 ) $ div ( pl $ Series ( 11 : 13 ) ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 0 #> 0 #> 0 #> ] pl $ Series ( 1 : 3 ) $ div ( 1L ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> ] 2L / pl $ Series ( 1 : 3 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 2 #> 1 #> 0 #> ] pl $ Series ( 1 : 3 ) / 2L #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 0 #> 1 #> 1 #> ]","title":"div"},{"location":"reference/Series_div/#div-series","text":"Series_div ( other ) ## S3 method for class 'Series' s1 / s2","title":"div Series"},{"location":"reference/Series_div/#arguments","text":"other : Series or into Series s1 : lhs Series s2 : rhs Series or any into Series","title":"Arguments"},{"location":"reference/Series_div/#returns","text":"Series Series arithmetics","title":"Returns"},{"location":"reference/Series_div/#examples","text":"pl $ Series ( 1 : 3 ) $ div ( 11 : 13 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 0 #> 0 #> 0 #> ] pl $ Series ( 1 : 3 ) $ div ( pl $ Series ( 11 : 13 ) ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 0 #> 0 #> 0 #> ] pl $ Series ( 1 : 3 ) $ div ( 1L ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> ] 2L / pl $ Series ( 1 : 3 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 2 #> 1 #> 0 #> ] pl $ Series ( 1 : 3 ) / 2L #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 0 #> 1 #> 1 #> ]","title":"Examples"},{"location":"reference/Series_dtype/","text":"Get data type of Series Series_dtype () Series_flags () Returns DataType DataType Get data type of Series Get data type of Series Details property sorted flags are not settable, use set_sorted Examples pl $ Series ( 1 : 4 ) $ dtype #> DataType: Int32 pl $ Series ( c ( 1 , 2 ) ) $ dtype #> DataType: Float64 pl $ Series ( letters ) $ dtype #> DataType: Utf8 pl $ Series ( 1 : 4 ) $ sort ( ) $ flags #> $SORTED_ASC #> [1] TRUE #> #> $SORTED_DESC #> [1] FALSE #>","title":"dtype"},{"location":"reference/Series_dtype/#get-data-type-of-series","text":"Series_dtype () Series_flags ()","title":"Get data type of Series"},{"location":"reference/Series_dtype/#returns","text":"DataType DataType Get data type of Series Get data type of Series","title":"Returns"},{"location":"reference/Series_dtype/#details","text":"property sorted flags are not settable, use set_sorted","title":"Details"},{"location":"reference/Series_dtype/#examples","text":"pl $ Series ( 1 : 4 ) $ dtype #> DataType: Int32 pl $ Series ( c ( 1 , 2 ) ) $ dtype #> DataType: Float64 pl $ Series ( letters ) $ dtype #> DataType: Utf8 pl $ Series ( 1 : 4 ) $ sort ( ) $ flags #> $SORTED_ASC #> [1] TRUE #> #> $SORTED_DESC #> [1] FALSE #>","title":"Examples"},{"location":"reference/Series_expr/","text":"Any expr method on a Series Series_expr () Returns Expr Call an expression on a Series See the individual Expr method pages for full details Details This is a shorthand of writing something like pl$DataFrame(s)$select(pl$col(\"sname\")$expr)$to_series(0) This subnamespace is experimental. Submit an issue if anything unexpected happend. Examples s = pl $ Series ( list ( 1 : 3 , 1 : 2 , NULL ) ) s $ expr $ first ( ) #> polars Series: shape: (1,) #> Series: '' [list[i32]] #> [ #> [1, 2, 3] #> ] s $ expr $ alias ( \"alice\" ) #> polars Series: shape: (3,) #> Series: 'alice' [list[i32]] #> [ #> [1, 2, 3] #> [1, 2] #> [] #> ]","title":"expr"},{"location":"reference/Series_expr/#any-expr-method-on-a-series","text":"Series_expr ()","title":"Any expr method on a Series"},{"location":"reference/Series_expr/#returns","text":"Expr Call an expression on a Series See the individual Expr method pages for full details","title":"Returns"},{"location":"reference/Series_expr/#details","text":"This is a shorthand of writing something like pl$DataFrame(s)$select(pl$col(\"sname\")$expr)$to_series(0) This subnamespace is experimental. Submit an issue if anything unexpected happend.","title":"Details"},{"location":"reference/Series_expr/#examples","text":"s = pl $ Series ( list ( 1 : 3 , 1 : 2 , NULL ) ) s $ expr $ first ( ) #> polars Series: shape: (1,) #> Series: '' [list[i32]] #> [ #> [1, 2, 3] #> ] s $ expr $ alias ( \"alice\" ) #> polars Series: shape: (3,) #> Series: 'alice' [list[i32]] #> [ #> [1, 2, 3] #> [1, 2] #> [] #> ]","title":"Examples"},{"location":"reference/Series_floor/","text":"Series_floor Series_floor () Returns numeric Floor of this Series Examples pl $ Series ( c ( .5 , 1.999 ) ) $ floor ( ) #> polars Series: shape: (2,) #> Series: '' [f64] #> [ #> 0.0 #> 1.0 #> ]","title":"floor"},{"location":"reference/Series_floor/#series_floor","text":"Series_floor ()","title":"Series_floor"},{"location":"reference/Series_floor/#returns","text":"numeric Floor of this Series","title":"Returns"},{"location":"reference/Series_floor/#examples","text":"pl $ Series ( c ( .5 , 1.999 ) ) $ floor ( ) #> polars Series: shape: (2,) #> Series: '' [f64] #> [ #> 0.0 #> 1.0 #> ]","title":"Examples"},{"location":"reference/Series_is_numeric/","text":"is_numeric Format method Series_is_numeric () Returns bool return bool whether series is numeric Details true of series dtype is member of pl$numeric_dtypes Examples pl $ Series ( 1 : 4 ) $ is_numeric ( ) #> [1] TRUE pl $ Series ( c ( \"a\" , \"b\" , \"c\" ) ) $ is_numeric ( ) #> [1] FALSE pl $ numeric_dtypes #> $Int8 #> DataType: Int8 #> #> $Int16 #> DataType: Int16 #> #> $Int32 #> DataType: Int32 #> #> $Int64 #> DataType: Int64 #> #> $Float32 #> DataType: Float32 #> #> $Float64 #> DataType: Float64 #>","title":"is_numeric"},{"location":"reference/Series_is_numeric/#is_numeric","text":"","title":"is_numeric"},{"location":"reference/Series_is_numeric/#format","text":"method Series_is_numeric ()","title":"Format"},{"location":"reference/Series_is_numeric/#returns","text":"bool return bool whether series is numeric","title":"Returns"},{"location":"reference/Series_is_numeric/#details","text":"true of series dtype is member of pl$numeric_dtypes","title":"Details"},{"location":"reference/Series_is_numeric/#examples","text":"pl $ Series ( 1 : 4 ) $ is_numeric ( ) #> [1] TRUE pl $ Series ( c ( \"a\" , \"b\" , \"c\" ) ) $ is_numeric ( ) #> [1] FALSE pl $ numeric_dtypes #> $Int8 #> DataType: Int8 #> #> $Int16 #> DataType: Int16 #> #> $Int32 #> DataType: Int32 #> #> $Int64 #> DataType: Int64 #> #> $Float32 #> DataType: Float32 #> #> $Float64 #> DataType: Float64 #>","title":"Examples"},{"location":"reference/Series_is_sorted/","text":"is_sorted Series_is_sorted ( reverse = FALSE , nulls_last = NULL ) Arguments reverse : order sorted nulls_last : bool where to keep nulls, default same as reverse Returns DataType is_sorted Details property sorted flags are not settable, use set_sorted Examples pl $ Series ( 1 : 4 ) $ sort ( ) $ is_sorted ( ) #> [1] TRUE","title":"is_sorted"},{"location":"reference/Series_is_sorted/#is_sorted","text":"Series_is_sorted ( reverse = FALSE , nulls_last = NULL )","title":"is_sorted"},{"location":"reference/Series_is_sorted/#arguments","text":"reverse : order sorted nulls_last : bool where to keep nulls, default same as reverse","title":"Arguments"},{"location":"reference/Series_is_sorted/#returns","text":"DataType is_sorted","title":"Returns"},{"location":"reference/Series_is_sorted/#details","text":"property sorted flags are not settable, use set_sorted","title":"Details"},{"location":"reference/Series_is_sorted/#examples","text":"pl $ Series ( 1 : 4 ) $ sort ( ) $ is_sorted ( ) #> [1] TRUE","title":"Examples"},{"location":"reference/Series_len/","text":"data Series_len Format An object of class character of length 1. Series_len Returns numeric Length of this Series. Examples pl $ Series ( 1 : 10 ) $ len ( ) #> [1] 10","title":"len"},{"location":"reference/Series_len/#series_len","text":"","title":"Series_len"},{"location":"reference/Series_len/#format","text":"An object of class character of length 1. Series_len","title":"Format"},{"location":"reference/Series_len/#returns","text":"numeric Length of this Series.","title":"Returns"},{"location":"reference/Series_len/#examples","text":"pl $ Series ( 1 : 10 ) $ len ( ) #> [1] 10","title":"Examples"},{"location":"reference/Series_max/","text":"data max Format An object of class character of length 1. Series_max Returns Series Reduce Series with max Details Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before maxming to prevent overflow issues. Examples pl $ Series ( c ( 1 : 2 , NA , 3 , 5 ) ) $ max ( ) # a NA is dropped always #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> 5.0 #> ] pl $ Series ( c ( 1 : 2 , NA , 3 , NaN , 4 , Inf ) ) $ max ( ) # NaN carries / poisons #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> inf #> ] pl $ Series ( c ( 1 : 2 , 3 , Inf , 4 , - Inf , 5 ) ) $ max ( ) # Inf-Inf is NaN #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> inf #> ]","title":"max"},{"location":"reference/Series_max/#max","text":"","title":"max"},{"location":"reference/Series_max/#format","text":"An object of class character of length 1. Series_max","title":"Format"},{"location":"reference/Series_max/#returns","text":"Series Reduce Series with max","title":"Returns"},{"location":"reference/Series_max/#details","text":"Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before maxming to prevent overflow issues.","title":"Details"},{"location":"reference/Series_max/#examples","text":"pl $ Series ( c ( 1 : 2 , NA , 3 , 5 ) ) $ max ( ) # a NA is dropped always #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> 5.0 #> ] pl $ Series ( c ( 1 : 2 , NA , 3 , NaN , 4 , Inf ) ) $ max ( ) # NaN carries / poisons #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> inf #> ] pl $ Series ( c ( 1 : 2 , 3 , Inf , 4 , - Inf , 5 ) ) $ max ( ) # Inf-Inf is NaN #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> inf #> ]","title":"Examples"},{"location":"reference/Series_min/","text":"data min Format An object of class character of length 1. Series_min Returns Series Reduce Series with min Details Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before minming to prevent overflow issues. Examples pl $ Series ( c ( 1 : 2 , NA , 3 , 5 ) ) $ min ( ) # a NA is dropped always #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> 1.0 #> ] pl $ Series ( c ( 1 : 2 , NA , 3 , NaN , 4 , Inf ) ) $ min ( ) # NaN carries / poisons #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> 1.0 #> ] pl $ Series ( c ( 1 : 2 , 3 , Inf , 4 , - Inf , 5 ) ) $ min ( ) # Inf-Inf is NaN #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> -inf #> ]","title":"min"},{"location":"reference/Series_min/#min","text":"","title":"min"},{"location":"reference/Series_min/#format","text":"An object of class character of length 1. Series_min","title":"Format"},{"location":"reference/Series_min/#returns","text":"Series Reduce Series with min","title":"Returns"},{"location":"reference/Series_min/#details","text":"Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before minming to prevent overflow issues.","title":"Details"},{"location":"reference/Series_min/#examples","text":"pl $ Series ( c ( 1 : 2 , NA , 3 , 5 ) ) $ min ( ) # a NA is dropped always #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> 1.0 #> ] pl $ Series ( c ( 1 : 2 , NA , 3 , NaN , 4 , Inf ) ) $ min ( ) # NaN carries / poisons #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> 1.0 #> ] pl $ Series ( c ( 1 : 2 , 3 , Inf , 4 , - Inf , 5 ) ) $ min ( ) # Inf-Inf is NaN #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> -inf #> ]","title":"Examples"},{"location":"reference/Series_mul/","text":"mul Series Series_mul ( other ) ## S3 method for class 'Series' s1 * s2 Arguments other : Series or into Series s1 : lhs Series s2 : rhs Series or any into Series Returns Series Series arithmetics Examples pl $ Series ( 1 : 3 ) $ mul ( 11 : 13 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 11 #> 24 #> 39 #> ] pl $ Series ( 1 : 3 ) $ mul ( pl $ Series ( 11 : 13 ) ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 11 #> 24 #> 39 #> ] pl $ Series ( 1 : 3 ) $ mul ( 1L ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> ] 2L * pl $ Series ( 1 : 3 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 2 #> 4 #> 6 #> ] pl $ Series ( 1 : 3 ) * 2L #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 2 #> 4 #> 6 #> ]","title":"mul"},{"location":"reference/Series_mul/#mul-series","text":"Series_mul ( other ) ## S3 method for class 'Series' s1 * s2","title":"mul Series"},{"location":"reference/Series_mul/#arguments","text":"other : Series or into Series s1 : lhs Series s2 : rhs Series or any into Series","title":"Arguments"},{"location":"reference/Series_mul/#returns","text":"Series Series arithmetics","title":"Returns"},{"location":"reference/Series_mul/#examples","text":"pl $ Series ( 1 : 3 ) $ mul ( 11 : 13 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 11 #> 24 #> 39 #> ] pl $ Series ( 1 : 3 ) $ mul ( pl $ Series ( 11 : 13 ) ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 11 #> 24 #> 39 #> ] pl $ Series ( 1 : 3 ) $ mul ( 1L ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> ] 2L * pl $ Series ( 1 : 3 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 2 #> 4 #> 6 #> ] pl $ Series ( 1 : 3 ) * 2L #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 2 #> 4 #> 6 #> ]","title":"Examples"},{"location":"reference/Series_name/","text":"Property: Name Series_name () Returns String the name Get name of Series Examples pl $ Series ( 1 : 3 ,name = \"alice\" ) $ name #> [1] \"alice\"","title":"name"},{"location":"reference/Series_name/#property-name","text":"Series_name ()","title":"Property: Name"},{"location":"reference/Series_name/#returns","text":"String the name Get name of Series","title":"Returns"},{"location":"reference/Series_name/#examples","text":"pl $ Series ( 1 : 3 ,name = \"alice\" ) $ name #> [1] \"alice\"","title":"Examples"},{"location":"reference/Series_print/","text":"Print Series ## S3 method for class 'Series' print ( x , ... ) Series_print () Arguments x : Series ... : not used Returns invisible(self) self Print Series Print Series Examples print ( pl $ Series ( 1 : 3 ) ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> ] pl $ Series ( 1 : 3 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> ]","title":"print"},{"location":"reference/Series_print/#print-series","text":"## S3 method for class 'Series' print ( x , ... ) Series_print ()","title":"Print Series"},{"location":"reference/Series_print/#arguments","text":"x : Series ... : not used","title":"Arguments"},{"location":"reference/Series_print/#returns","text":"invisible(self) self Print Series Print Series","title":"Returns"},{"location":"reference/Series_print/#examples","text":"print ( pl $ Series ( 1 : 3 ) ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> ] pl $ Series ( 1 : 3 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> ]","title":"Examples"},{"location":"reference/Series_rem/","text":"rem Series Series_rem ( other ) Arguments other : Series or into Series Returns Series Series arithmetics, remainder Examples pl $ Series ( 1 : 4 ) $ rem ( 2L ) #> polars Series: shape: (4,) #> Series: '' [i32] #> [ #> 1 #> 0 #> 1 #> 0 #> ] pl $ Series ( 1 : 3 ) $ rem ( pl $ Series ( 11 : 13 ) ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> ] pl $ Series ( 1 : 3 ) $ rem ( 1L ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 0 #> 0 #> 0 #> ]","title":"rem"},{"location":"reference/Series_rem/#rem-series","text":"Series_rem ( other )","title":"rem Series"},{"location":"reference/Series_rem/#arguments","text":"other : Series or into Series","title":"Arguments"},{"location":"reference/Series_rem/#returns","text":"Series Series arithmetics, remainder","title":"Returns"},{"location":"reference/Series_rem/#examples","text":"pl $ Series ( 1 : 4 ) $ rem ( 2L ) #> polars Series: shape: (4,) #> Series: '' [i32] #> [ #> 1 #> 0 #> 1 #> 0 #> ] pl $ Series ( 1 : 3 ) $ rem ( pl $ Series ( 11 : 13 ) ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 1 #> 2 #> 3 #> ] pl $ Series ( 1 : 3 ) $ rem ( 1L ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 0 #> 0 #> 0 #> ]","title":"Examples"},{"location":"reference/Series_rename/","text":"Rename a series Format method Series_rename ( name , in_place = FALSE ) Arguments name : string the new name in_place : bool rename in-place, breaks immutability If true will throw an error unless this option has been set: pl$set_polars_options(strictly_immutable = FALSE) Returns bool Rename a series Examples pl $ Series ( 1 : 4 , \"bob\" ) $ rename ( \"alice\" ) #> polars Series: shape: (4,) #> Series: 'alice' [i32] #> [ #> 1 #> 2 #> 3 #> 4 #> ]","title":"rename"},{"location":"reference/Series_rename/#rename-a-series","text":"","title":"Rename a series"},{"location":"reference/Series_rename/#format","text":"method Series_rename ( name , in_place = FALSE )","title":"Format"},{"location":"reference/Series_rename/#arguments","text":"name : string the new name in_place : bool rename in-place, breaks immutability If true will throw an error unless this option has been set: pl$set_polars_options(strictly_immutable = FALSE)","title":"Arguments"},{"location":"reference/Series_rename/#returns","text":"bool Rename a series","title":"Returns"},{"location":"reference/Series_rename/#examples","text":"pl $ Series ( 1 : 4 , \"bob\" ) $ rename ( \"alice\" ) #> polars Series: shape: (4,) #> Series: 'alice' [i32] #> [ #> 1 #> 2 #> 3 #> 4 #> ]","title":"Examples"},{"location":"reference/Series_rep/","text":"duplicate and concatenate a series Format method Series_rep ( n , rechunk = TRUE ) Arguments n : number of times to repeat rechunk : bool default true, reallocate object in memory. If FALSE the Series will take up less space, If TRUE calculations might be faster. Returns bool duplicate and concatenate a series Details This function in not implemented in pypolars Examples pl $ Series ( 1 : 2 , \"bob\" ) $ rep ( 3 ) #> polars Series: shape: (6,) #> Series: 'bob' [i32] #> [ #> 1 #> 2 #> 1 #> 2 #> 1 #> 2 #> ]","title":"rep"},{"location":"reference/Series_rep/#duplicate-and-concatenate-a-series","text":"","title":"duplicate and concatenate a series"},{"location":"reference/Series_rep/#format","text":"method Series_rep ( n , rechunk = TRUE )","title":"Format"},{"location":"reference/Series_rep/#arguments","text":"n : number of times to repeat rechunk : bool default true, reallocate object in memory. If FALSE the Series will take up less space, If TRUE calculations might be faster.","title":"Arguments"},{"location":"reference/Series_rep/#returns","text":"bool duplicate and concatenate a series","title":"Returns"},{"location":"reference/Series_rep/#details","text":"This function in not implemented in pypolars","title":"Details"},{"location":"reference/Series_rep/#examples","text":"pl $ Series ( 1 : 2 , \"bob\" ) $ rep ( 3 ) #> polars Series: shape: (6,) #> Series: 'bob' [i32] #> [ #> 1 #> 2 #> 1 #> 2 #> 1 #> 2 #> ]","title":"Examples"},{"location":"reference/Series_series_equal/","text":"Are Series's equal? Format method Series_series_equal ( other , null_equal = FALSE , strict = FALSE ) Arguments other : Series to compare with null_equal : bool if TRUE, (Null==Null) is true and not Null/NA. Overridden by strict. strict : bool if TRUE, do not allow similar DataType comparison. Overrides null_equal. Returns bool Check if series is equal with another Series. Examples pl $ Series ( 1 : 4 , \"bob\" ) $ series_equal ( pl $ Series ( 1 : 4 ) ) #> [1] FALSE","title":"series_equal"},{"location":"reference/Series_series_equal/#are-seriess-equal","text":"","title":"Are Series's equal?"},{"location":"reference/Series_series_equal/#format","text":"method Series_series_equal ( other , null_equal = FALSE , strict = FALSE )","title":"Format"},{"location":"reference/Series_series_equal/#arguments","text":"other : Series to compare with null_equal : bool if TRUE, (Null==Null) is true and not Null/NA. Overridden by strict. strict : bool if TRUE, do not allow similar DataType comparison. Overrides null_equal.","title":"Arguments"},{"location":"reference/Series_series_equal/#returns","text":"bool Check if series is equal with another Series.","title":"Returns"},{"location":"reference/Series_series_equal/#examples","text":"pl $ Series ( 1 : 4 , \"bob\" ) $ series_equal ( pl $ Series ( 1 : 4 ) ) #> [1] FALSE","title":"Examples"},{"location":"reference/Series_set_sorted/","text":"Set sorted Series_set_sorted ( reverse = FALSE , in_place = FALSE ) Arguments reverse : bool if TRUE, signals series is Descendingly sorted, otherwise Ascendingly. in_place : if TRUE, will set flag mutably and return NULL. Remember to use pl$set_polars_options(strictly_immutable = FALSE) otherwise an error will be thrown. If FALSE will return a cloned Series with set_flag which in the very most cases should be just fine. Returns Series invisible Set sorted Examples s = pl $ Series ( 1 : 4 ) $ set_sorted ( ) s $ flags #> $SORTED_ASC #> [1] TRUE #> #> $SORTED_DESC #> [1] FALSE #>","title":"set_sorted"},{"location":"reference/Series_set_sorted/#set-sorted","text":"Series_set_sorted ( reverse = FALSE , in_place = FALSE )","title":"Set sorted"},{"location":"reference/Series_set_sorted/#arguments","text":"reverse : bool if TRUE, signals series is Descendingly sorted, otherwise Ascendingly. in_place : if TRUE, will set flag mutably and return NULL. Remember to use pl$set_polars_options(strictly_immutable = FALSE) otherwise an error will be thrown. If FALSE will return a cloned Series with set_flag which in the very most cases should be just fine.","title":"Arguments"},{"location":"reference/Series_set_sorted/#returns","text":"Series invisible Set sorted","title":"Returns"},{"location":"reference/Series_set_sorted/#examples","text":"s = pl $ Series ( 1 : 4 ) $ set_sorted ( ) s $ flags #> $SORTED_ASC #> [1] TRUE #> #> $SORTED_DESC #> [1] FALSE #>","title":"Examples"},{"location":"reference/Series_shape/","text":"Shape of series Series_shape () Returns dimension vector of Series Shape of series Examples identical ( pl $ Series ( 1 : 2 ) $ shape , 2 : 1 ) #> [1] FALSE","title":"shape"},{"location":"reference/Series_shape/#shape-of-series","text":"Series_shape ()","title":"Shape of series"},{"location":"reference/Series_shape/#returns","text":"dimension vector of Series Shape of series","title":"Returns"},{"location":"reference/Series_shape/#examples","text":"identical ( pl $ Series ( 1 : 2 ) $ shape , 2 : 1 ) #> [1] FALSE","title":"Examples"},{"location":"reference/Series_sort/","text":"Sort this Series Series_sort ( reverse = FALSE , in_place = FALSE ) Arguments reverse : bool reverse(descending) sort in_place : bool sort mutable in-place, breaks immutability If true will throw an error unless this option has been set: pl$set_polars_options(strictly_immutable = FALSE) Returns Series Sort this Series Examples pl $ Series ( c ( 1 , NA , NaN , Inf , - Inf ) ) $ sort ( ) #> polars Series: shape: (5,) #> Series: '' [f64] #> [ #> null #> -inf #> 1.0 #> inf #> NaN #> ]","title":"sort"},{"location":"reference/Series_sort/#sort-this-series","text":"Series_sort ( reverse = FALSE , in_place = FALSE )","title":"Sort this Series"},{"location":"reference/Series_sort/#arguments","text":"reverse : bool reverse(descending) sort in_place : bool sort mutable in-place, breaks immutability If true will throw an error unless this option has been set: pl$set_polars_options(strictly_immutable = FALSE)","title":"Arguments"},{"location":"reference/Series_sort/#returns","text":"Series Sort this Series","title":"Returns"},{"location":"reference/Series_sort/#examples","text":"pl $ Series ( c ( 1 , NA , NaN , Inf , - Inf ) ) $ sort ( ) #> polars Series: shape: (5,) #> Series: '' [f64] #> [ #> null #> -inf #> 1.0 #> inf #> NaN #> ]","title":"Examples"},{"location":"reference/Series_std/","text":"Get the standard deviation of this Series. Format method Series_std ( ddof = 1 ) Arguments ddof : \u201cDelta Degrees of Freedom\u201d: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1. Returns bool Get the standard deviation of this Series. Examples pl $ Series ( 1 : 4 , \"bob\" ) $ std ( ) #> [1] 1.290994","title":"std"},{"location":"reference/Series_std/#get-the-standard-deviation-of-this-series","text":"","title":"Get the standard deviation of this Series."},{"location":"reference/Series_std/#format","text":"method Series_std ( ddof = 1 )","title":"Format"},{"location":"reference/Series_std/#arguments","text":"ddof : \u201cDelta Degrees of Freedom\u201d: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1.","title":"Arguments"},{"location":"reference/Series_std/#returns","text":"bool Get the standard deviation of this Series.","title":"Returns"},{"location":"reference/Series_std/#examples","text":"pl $ Series ( 1 : 4 , \"bob\" ) $ std ( ) #> [1] 1.290994","title":"Examples"},{"location":"reference/Series_sub/","text":"sub Series Series_sub ( other ) ## S3 method for class 'Series' s1 - s2 Arguments other : Series or into Series s1 : lhs Series s2 : rhs Series or any into Series Returns Series Series arithmetics Examples pl $ Series ( 1 : 3 ) $ sub ( 11 : 13 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> -10 #> -10 #> -10 #> ] pl $ Series ( 1 : 3 ) $ sub ( pl $ Series ( 11 : 13 ) ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> -10 #> -10 #> -10 #> ] pl $ Series ( 1 : 3 ) $ sub ( 1L ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 0 #> 1 #> 2 #> ] 1L - pl $ Series ( 1 : 3 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 0 #> -1 #> -2 #> ] pl $ Series ( 1 : 3 ) - 1L #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 0 #> 1 #> 2 #> ]","title":"sub"},{"location":"reference/Series_sub/#sub-series","text":"Series_sub ( other ) ## S3 method for class 'Series' s1 - s2","title":"sub Series"},{"location":"reference/Series_sub/#arguments","text":"other : Series or into Series s1 : lhs Series s2 : rhs Series or any into Series","title":"Arguments"},{"location":"reference/Series_sub/#returns","text":"Series Series arithmetics","title":"Returns"},{"location":"reference/Series_sub/#examples","text":"pl $ Series ( 1 : 3 ) $ sub ( 11 : 13 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> -10 #> -10 #> -10 #> ] pl $ Series ( 1 : 3 ) $ sub ( pl $ Series ( 11 : 13 ) ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> -10 #> -10 #> -10 #> ] pl $ Series ( 1 : 3 ) $ sub ( 1L ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 0 #> 1 #> 2 #> ] 1L - pl $ Series ( 1 : 3 ) #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 0 #> -1 #> -2 #> ] pl $ Series ( 1 : 3 ) - 1L #> polars Series: shape: (3,) #> Series: '' [i32] #> [ #> 0 #> 1 #> 2 #> ]","title":"Examples"},{"location":"reference/Series_sum/","text":"data Sum Format An object of class character of length 1. Series_sum Returns Series Reduce Series with sum Details Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues. Examples pl $ Series ( c ( 1 : 2 , NA , 3 , 5 ) ) $ sum ( ) # a NA is dropped always #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> 11.0 #> ] pl $ Series ( c ( 1 : 2 , NA , 3 , NaN , 4 , Inf ) ) $ sum ( ) # NaN carries / poisons #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> NaN #> ] pl $ Series ( c ( 1 : 2 , 3 , Inf , 4 , - Inf , 5 ) ) $ sum ( ) # Inf-Inf is NaN #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> NaN #> ]","title":"sum"},{"location":"reference/Series_sum/#sum","text":"","title":"Sum"},{"location":"reference/Series_sum/#format","text":"An object of class character of length 1. Series_sum","title":"Format"},{"location":"reference/Series_sum/#returns","text":"Series Reduce Series with sum","title":"Returns"},{"location":"reference/Series_sum/#details","text":"Dtypes in Int8, UInt8, Int16, UInt16 are cast to Int64 before summing to prevent overflow issues.","title":"Details"},{"location":"reference/Series_sum/#examples","text":"pl $ Series ( c ( 1 : 2 , NA , 3 , 5 ) ) $ sum ( ) # a NA is dropped always #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> 11.0 #> ] pl $ Series ( c ( 1 : 2 , NA , 3 , NaN , 4 , Inf ) ) $ sum ( ) # NaN carries / poisons #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> NaN #> ] pl $ Series ( c ( 1 : 2 , 3 , Inf , 4 , - Inf , 5 ) ) $ sum ( ) # Inf-Inf is NaN #> polars Series: shape: (1,) #> Series: '' [f64] #> [ #> NaN #> ]","title":"Examples"},{"location":"reference/Series_to_frames/","text":"Series to DataFrame Format method Series_to_frame () Returns Series Series to DataFrame Examples pl $ Series ( 1 : 4 , \"bob\" ) $ to_frame ( ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 bob \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2502 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"to_frames"},{"location":"reference/Series_to_frames/#series-to-dataframe","text":"","title":"Series to DataFrame"},{"location":"reference/Series_to_frames/#format","text":"method Series_to_frame ()","title":"Format"},{"location":"reference/Series_to_frames/#returns","text":"Series Series to DataFrame","title":"Returns"},{"location":"reference/Series_to_frames/#examples","text":"pl $ Series ( 1 : 4 , \"bob\" ) $ to_frame ( ) #> polars DataFrame: shape: (4, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 bob \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2502 3 \u2502 #> \u2502 4 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Series_to_lit/","text":"Series to Literal Series_to_lit () Returns Expr convert Series to literal to perform modification and return Examples ( pl $ Series ( list ( 1 : 1 , 1 : 2 , 1 : 3 , 1 : 4 ) ) $ print ( ) $ to_lit ( ) $ arr $ lengths ( ) $ sum ( ) $ cast ( pl $ dtypes $ Int8 ) $ lit_to_s ( ) ) #> shape: (4,) #> Series: '' [list[i32]] #> [ #> [1] #> [1, 2] #> [1, 2, 3] #> [1, 2, ... 4] #> ] #> polars Series: shape: (1,) #> Series: '' [i8] #> [ #> 10 #> ]","title":"to_lit"},{"location":"reference/Series_to_lit/#series-to-literal","text":"Series_to_lit ()","title":"Series to Literal"},{"location":"reference/Series_to_lit/#returns","text":"Expr convert Series to literal to perform modification and return","title":"Returns"},{"location":"reference/Series_to_lit/#examples","text":"( pl $ Series ( list ( 1 : 1 , 1 : 2 , 1 : 3 , 1 : 4 ) ) $ print ( ) $ to_lit ( ) $ arr $ lengths ( ) $ sum ( ) $ cast ( pl $ dtypes $ Int8 ) $ lit_to_s ( ) ) #> shape: (4,) #> Series: '' [list[i32]] #> [ #> [1] #> [1, 2] #> [1, 2, 3] #> [1, 2, ... 4] #> ] #> polars Series: shape: (1,) #> Series: '' [i8] #> [ #> 10 #> ]","title":"Examples"},{"location":"reference/Series_to_r/","text":"Get r vector/list Series_to_r () Series_to_r_vector () Series_to_r_list () Returns R list or vector R vector R list return R list (if polars Series is list) or vector (any other polars Series type) return R vector (implicit unlist) return R list (implicit as.list) Details Fun fact: Nested polars Series list must have same inner type, e.g. List(List(Int32)) Thus every leaf(non list type) will be placed on the same depth of the tree, and be the same type. Examples #make polars Series_Utf8 series_vec = pl $ Series ( letters [ 1 : 3 ] ) #Series_non_list series_vec $ to_r ( ) #as vector because Series DataType is not list (is Utf8) #> [1] \"a\" \"b\" \"c\" series_vec $ to_r_list ( ) #implicit call as.list(), convert to list #> [[1]] #> [1] \"a\" #> #> [[2]] #> [1] \"b\" #> #> [[3]] #> [1] \"c\" #> series_vec $ to_r_vector ( ) #implicit call unlist(), same as to_r() as already vector #> [1] \"a\" \"b\" \"c\" #make nested Series_list of Series_list of Series_Int32 #using Expr syntax because currently more complete translated series_list = pl $ DataFrame ( list ( a = c ( 1 : 5 , NA_integer_ ) ) ) $ select ( pl $ col ( \"a\" ) $ list ( ) $ list ( ) $ append ( ( pl $ col ( \"a\" ) $ head ( 2 ) $ list ( ) $ append ( pl $ col ( \"a\" ) $ tail ( 1 ) $ list ( ) ) ) $ list ( ) ) ) $ get_column ( \"a\" ) # get series from DataFrame #Series_list series_list $ to_r ( ) #as list because Series DataType is list #> [[1]] #> [[1]][[1]] #> [1] 1 2 3 4 5 NA #> #> #> [[2]] #> [[2]][[1]] #> [1] 1 2 #> #> [[2]][[2]] #> [1] NA #> #> series_list $ to_r_list ( ) #implicit call as.list(), same as to_r() as already list #> [[1]] #> [[1]][[1]] #> [1] 1 2 3 4 5 NA #> #> #> [[2]] #> [[2]][[1]] #> [1] 1 2 #> #> [[2]][[2]] #> [1] NA #> #> series_list $ to_r_vector ( ) #implicit call unlist(), append into a vector #> [1] 1 2 3 4 5 NA 1 2 NA # #","title":"to_r"},{"location":"reference/Series_to_r/#get-r-vectorlist","text":"Series_to_r () Series_to_r_vector () Series_to_r_list ()","title":"Get r vector/list"},{"location":"reference/Series_to_r/#returns","text":"R list or vector R vector R list return R list (if polars Series is list) or vector (any other polars Series type) return R vector (implicit unlist) return R list (implicit as.list)","title":"Returns"},{"location":"reference/Series_to_r/#details","text":"Fun fact: Nested polars Series list must have same inner type, e.g. List(List(Int32)) Thus every leaf(non list type) will be placed on the same depth of the tree, and be the same type.","title":"Details"},{"location":"reference/Series_to_r/#examples","text":"#make polars Series_Utf8 series_vec = pl $ Series ( letters [ 1 : 3 ] ) #Series_non_list series_vec $ to_r ( ) #as vector because Series DataType is not list (is Utf8) #> [1] \"a\" \"b\" \"c\" series_vec $ to_r_list ( ) #implicit call as.list(), convert to list #> [[1]] #> [1] \"a\" #> #> [[2]] #> [1] \"b\" #> #> [[3]] #> [1] \"c\" #> series_vec $ to_r_vector ( ) #implicit call unlist(), same as to_r() as already vector #> [1] \"a\" \"b\" \"c\" #make nested Series_list of Series_list of Series_Int32 #using Expr syntax because currently more complete translated series_list = pl $ DataFrame ( list ( a = c ( 1 : 5 , NA_integer_ ) ) ) $ select ( pl $ col ( \"a\" ) $ list ( ) $ list ( ) $ append ( ( pl $ col ( \"a\" ) $ head ( 2 ) $ list ( ) $ append ( pl $ col ( \"a\" ) $ tail ( 1 ) $ list ( ) ) ) $ list ( ) ) ) $ get_column ( \"a\" ) # get series from DataFrame #Series_list series_list $ to_r ( ) #as list because Series DataType is list #> [[1]] #> [[1]][[1]] #> [1] 1 2 3 4 5 NA #> #> #> [[2]] #> [[2]][[1]] #> [1] 1 2 #> #> [[2]][[2]] #> [1] NA #> #> series_list $ to_r_list ( ) #implicit call as.list(), same as to_r() as already list #> [[1]] #> [[1]][[1]] #> [1] 1 2 3 4 5 NA #> #> #> [[2]] #> [[2]][[1]] #> [1] 1 2 #> #> [[2]][[2]] #> [1] NA #> #> series_list $ to_r_vector ( ) #implicit call unlist(), append into a vector #> [1] 1 2 3 4 5 NA 1 2 NA # #","title":"Examples"},{"location":"reference/Series_value_count/","text":"Value Counts as DataFrame Series_value_counts ( sorted = TRUE , multithreaded = FALSE ) Arguments sorted : bool, default TRUE: sort table by value; FALSE: random multithreaded : bool, default FALSE, process multithreaded. Likely faster to have TRUE for a big Series. If called within an already multithreaded context such calling apply on a GroupBy with many groups, then likely slightly faster to leave FALSE. Returns DataFrame Value Counts as DataFrame Examples pl $ Series ( iris $ Species , \"flower species\" ) $ value_counts ( ) #> polars DataFrame: shape: (3, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 flower species \u2506 counts \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 cat \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 setosa \u2506 50 \u2502 #> \u2502 versicolor \u2506 50 \u2502 #> \u2502 virginica \u2506 50 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"value_count"},{"location":"reference/Series_value_count/#value-counts-as-dataframe","text":"Series_value_counts ( sorted = TRUE , multithreaded = FALSE )","title":"Value Counts as DataFrame"},{"location":"reference/Series_value_count/#arguments","text":"sorted : bool, default TRUE: sort table by value; FALSE: random multithreaded : bool, default FALSE, process multithreaded. Likely faster to have TRUE for a big Series. If called within an already multithreaded context such calling apply on a GroupBy with many groups, then likely slightly faster to leave FALSE.","title":"Arguments"},{"location":"reference/Series_value_count/#returns","text":"DataFrame Value Counts as DataFrame","title":"Returns"},{"location":"reference/Series_value_count/#examples","text":"pl $ Series ( iris $ Species , \"flower species\" ) $ value_counts ( ) #> polars DataFrame: shape: (3, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 flower species \u2506 counts \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 cat \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 setosa \u2506 50 \u2502 #> \u2502 versicolor \u2506 50 \u2502 #> \u2502 virginica \u2506 50 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/Series_var/","text":"Get the standard deviation of this Series. Format method Series_var ( ddof = 1 ) Arguments ddof : \u201cDelta Degrees of Freedom\u201d: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1. Returns bool Get the standard deviation of this Series. Examples pl $ Series ( 1 : 4 , \"bob\" ) $ var ( ) #> [1] 1.666667","title":"var"},{"location":"reference/Series_var/#get-the-standard-deviation-of-this-series","text":"","title":"Get the standard deviation of this Series."},{"location":"reference/Series_var/#format","text":"method Series_var ( ddof = 1 )","title":"Format"},{"location":"reference/Series_var/#arguments","text":"ddof : \u201cDelta Degrees of Freedom\u201d: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1.","title":"Arguments"},{"location":"reference/Series_var/#returns","text":"bool Get the standard deviation of this Series.","title":"Returns"},{"location":"reference/Series_var/#examples","text":"pl $ Series ( 1 : 4 , \"bob\" ) $ var ( ) #> [1] 1.666667","title":"Examples"},{"location":"reference/all/","text":"New Expr referring to all columns Returns Boolean literal Not to mix up with Expr_object$all() which is a 'reduce Boolean columns by AND' method. Details last all() in example is this Expr method, the first pl$all() refers to \"all-columns\" and is an expression constructor Examples pl $ DataFrame ( list ( all = c ( TRUE , TRUE ) ,some = c ( TRUE , FALSE ) ) ) $ select ( pl $ all ( ) $ all ( ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 all \u2506 some \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 bool \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2506 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"all"},{"location":"reference/all/#new-expr-referring-to-all-columns","text":"","title":"New Expr referring to all columns"},{"location":"reference/all/#returns","text":"Boolean literal Not to mix up with Expr_object$all() which is a 'reduce Boolean columns by AND' method.","title":"Returns"},{"location":"reference/all/#details","text":"last all() in example is this Expr method, the first pl$all() refers to \"all-columns\" and is an expression constructor","title":"Details"},{"location":"reference/all/#examples","text":"pl $ DataFrame ( list ( all = c ( TRUE , TRUE ) ,some = c ( TRUE , FALSE ) ) ) $ select ( pl $ all ( ) $ all ( ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 all \u2506 some \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 bool \u2506 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2506 false \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/and_then/","text":"map an ok-value or pass on an err-value and_then ( x , f ) Arguments x : any R object f : a closure that takes the ok part as input Returns same R object wrapped in a Err-result map an ok-value or pass on an err-value","title":"and_then"},{"location":"reference/and_then/#map-an-ok-value-or-pass-on-an-err-value","text":"and_then ( x , f )","title":"map an ok-value or pass on an err-value"},{"location":"reference/and_then/#arguments","text":"x : any R object f : a closure that takes the ok part as input","title":"Arguments"},{"location":"reference/and_then/#returns","text":"same R object wrapped in a Err-result map an ok-value or pass on an err-value","title":"Returns"},{"location":"reference/arr_arg_max/","text":"Arg max sublists Format function Returns Expr Retrieve the index of the maximum value in every sublist. Examples df = pl $ DataFrame ( list ( s = list ( 1 : 2 , 2 : 1 ) ) ) df $ select ( pl $ col ( \"s\" ) $ arr $ arg_max ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_arg_max"},{"location":"reference/arr_arg_max/#arg-max-sublists","text":"","title":"Arg max sublists"},{"location":"reference/arr_arg_max/#format","text":"function","title":"Format"},{"location":"reference/arr_arg_max/#returns","text":"Expr Retrieve the index of the maximum value in every sublist.","title":"Returns"},{"location":"reference/arr_arg_max/#examples","text":"df = pl $ DataFrame ( list ( s = list ( 1 : 2 , 2 : 1 ) ) ) df $ select ( pl $ col ( \"s\" ) $ arr $ arg_max ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_arg_min/","text":"Arg min sublists Format function Returns Expr Retrieve the index of the minimal value in every sublist. Examples df = pl $ DataFrame ( list ( s = list ( 1 : 2 , 2 : 1 ) ) ) df $ select ( pl $ col ( \"s\" ) $ arr $ arg_min ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0 \u2502 #> \u2502 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_arg_min"},{"location":"reference/arr_arg_min/#arg-min-sublists","text":"","title":"Arg min sublists"},{"location":"reference/arr_arg_min/#format","text":"function","title":"Format"},{"location":"reference/arr_arg_min/#returns","text":"Expr Retrieve the index of the minimal value in every sublist.","title":"Returns"},{"location":"reference/arr_arg_min/#examples","text":"df = pl $ DataFrame ( list ( s = list ( 1 : 2 , 2 : 1 ) ) ) df $ select ( pl $ col ( \"s\" ) $ arr $ arg_min ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 0 \u2502 #> \u2502 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_concat/","text":"concat another list Format function Arguments other : Rlist, Expr or column of same tyoe as self. Returns Expr Concat the arrays in a Series dtype List in linear time. Examples df = pl $ DataFrame ( a = list ( \"a\" , \"x\" ) , b = list ( c ( \"b\" , \"c\" ) , c ( \"y\" , \"z\" ) ) ) df $ select ( pl $ col ( \"a\" ) $ arr $ concat ( pl $ col ( \"b\" ) ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[str] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [\"a\", \"b\", \"c\"] \u2502 #> \u2502 [\"x\", \"y\", \"z\"] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"a\" ) $ arr $ concat ( \"hello from R\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[str] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [\"a\", \"hello from R\"] \u2502 #> \u2502 [\"x\", \"hello from R\"] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"a\" ) $ arr $ concat ( list ( \"hello\" , c ( \"hello\" , \"world\" ) ) ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[str] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [\"a\", \"hello\"] \u2502 #> \u2502 [\"x\", \"hello\", \"world\"] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_concat"},{"location":"reference/arr_concat/#concat-another-list","text":"","title":"concat another list"},{"location":"reference/arr_concat/#format","text":"function","title":"Format"},{"location":"reference/arr_concat/#arguments","text":"other : Rlist, Expr or column of same tyoe as self.","title":"Arguments"},{"location":"reference/arr_concat/#returns","text":"Expr Concat the arrays in a Series dtype List in linear time.","title":"Returns"},{"location":"reference/arr_concat/#examples","text":"df = pl $ DataFrame ( a = list ( \"a\" , \"x\" ) , b = list ( c ( \"b\" , \"c\" ) , c ( \"y\" , \"z\" ) ) ) df $ select ( pl $ col ( \"a\" ) $ arr $ concat ( pl $ col ( \"b\" ) ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[str] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [\"a\", \"b\", \"c\"] \u2502 #> \u2502 [\"x\", \"y\", \"z\"] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"a\" ) $ arr $ concat ( \"hello from R\" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[str] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [\"a\", \"hello from R\"] \u2502 #> \u2502 [\"x\", \"hello from R\"] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"a\" ) $ arr $ concat ( list ( \"hello\" , c ( \"hello\" , \"world\" ) ) ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[str] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [\"a\", \"hello\"] \u2502 #> \u2502 [\"x\", \"hello\", \"world\"] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_contains/","text":"Sublists contains Format function Arguments item : any into Expr/literal Returns Expr of a boolean mask Check if sublists contain the given item. Examples df = pl $ DataFrame ( list ( a = list ( 3 : 1 , NULL , 1 : 2 ) ) ) #NULL or integer() or list() df $ select ( pl $ col ( \"a\" ) $ arr $ contains ( 1L ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_contains"},{"location":"reference/arr_contains/#sublists-contains","text":"","title":"Sublists contains"},{"location":"reference/arr_contains/#format","text":"function","title":"Format"},{"location":"reference/arr_contains/#arguments","text":"item : any into Expr/literal","title":"Arguments"},{"location":"reference/arr_contains/#returns","text":"Expr of a boolean mask Check if sublists contain the given item.","title":"Returns"},{"location":"reference/arr_contains/#examples","text":"df = pl $ DataFrame ( list ( a = list ( 3 : 1 , NULL , 1 : 2 ) ) ) #NULL or integer() or list() df $ select ( pl $ col ( \"a\" ) $ arr $ contains ( 1L ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 bool \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 true \u2502 #> \u2502 false \u2502 #> \u2502 true \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_diff/","text":"Diff sublists Format function Arguments n : Number of slots to shift null_behavior : choice \"ignore\"(default) \"drop\" Returns Expr Calculate the n-th discrete difference of every sublist. Examples df = pl $ DataFrame ( list ( s = list ( 1 : 4 , c ( 10L , 2L , 1L ) ) ) ) df $ select ( pl $ col ( \"s\" ) $ arr $ diff ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [null, 1, ... 1] \u2502 #> \u2502 [null, -8, -1] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_diff"},{"location":"reference/arr_diff/#diff-sublists","text":"","title":"Diff sublists"},{"location":"reference/arr_diff/#format","text":"function","title":"Format"},{"location":"reference/arr_diff/#arguments","text":"n : Number of slots to shift null_behavior : choice \"ignore\"(default) \"drop\"","title":"Arguments"},{"location":"reference/arr_diff/#returns","text":"Expr Calculate the n-th discrete difference of every sublist.","title":"Returns"},{"location":"reference/arr_diff/#examples","text":"df = pl $ DataFrame ( list ( s = list ( 1 : 4 , c ( 10L , 2L , 1L ) ) ) ) df $ select ( pl $ col ( \"s\" ) $ arr $ diff ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [null, 1, ... 1] \u2502 #> \u2502 [null, -8, -1] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_eval/","text":"eval sublists (kinda like lapply) Format function Arguments Expr : Expression to run. Note that you can select an element with pl$first() , or pl$col() parallel : bool Run all expression parallel. Don't activate this blindly. Parallelism is worth it if there is enough work to do per thread. This likely should not be use in the groupby context, because we already parallel execution per group Returns Expr Run any polars expression against the lists' elements. Examples df = pl $ DataFrame ( a = list ( c ( 1 , 8 , 3 ) , b = c ( 4 , 5 , 2 ) ) ) df $ select ( pl $ all ( ) $ cast ( pl $ dtypes $ Int64 ) ) $ with_column ( pl $ concat_list ( c ( \"a\" , \"b\" ) ) $ arr $ eval ( pl $ element ( ) $ rank ( ) ) $ alias ( \"rank\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 new_column \u2506 b \u2506 rank \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i64 \u2506 i64 \u2506 list[f32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 4 \u2506 [1.0, 2.0] \u2502 #> \u2502 8 \u2506 5 \u2506 [1.0, 2.0] \u2502 #> \u2502 3 \u2506 2 \u2506 [1.0, 2.0] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_eval"},{"location":"reference/arr_eval/#eval-sublists-kinda-like-lapply","text":"","title":"eval sublists (kinda like lapply)"},{"location":"reference/arr_eval/#format","text":"function","title":"Format"},{"location":"reference/arr_eval/#arguments","text":"Expr : Expression to run. Note that you can select an element with pl$first() , or pl$col() parallel : bool Run all expression parallel. Don't activate this blindly. Parallelism is worth it if there is enough work to do per thread. This likely should not be use in the groupby context, because we already parallel execution per group","title":"Arguments"},{"location":"reference/arr_eval/#returns","text":"Expr Run any polars expression against the lists' elements.","title":"Returns"},{"location":"reference/arr_eval/#examples","text":"df = pl $ DataFrame ( a = list ( c ( 1 , 8 , 3 ) , b = c ( 4 , 5 , 2 ) ) ) df $ select ( pl $ all ( ) $ cast ( pl $ dtypes $ Int64 ) ) $ with_column ( pl $ concat_list ( c ( \"a\" , \"b\" ) ) $ arr $ eval ( pl $ element ( ) $ rank ( ) ) $ alias ( \"rank\" ) ) #> polars DataFrame: shape: (3, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 new_column \u2506 b \u2506 rank \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i64 \u2506 i64 \u2506 list[f32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 4 \u2506 [1.0, 2.0] \u2502 #> \u2502 8 \u2506 5 \u2506 [1.0, 2.0] \u2502 #> \u2502 3 \u2506 2 \u2506 [1.0, 2.0] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_first/","text":"First in sublists Format function Returns Expr Get the first value of the sublists. Examples df = pl $ DataFrame ( list ( a = list ( 3 : 1 , NULL , 1 : 2 ) ) ) #NULL or integer() or list() df $ select ( pl $ col ( \"a\" ) $ arr $ first ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 null \u2502 #> \u2502 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_first"},{"location":"reference/arr_first/#first-in-sublists","text":"","title":"First in sublists"},{"location":"reference/arr_first/#format","text":"function","title":"Format"},{"location":"reference/arr_first/#returns","text":"Expr Get the first value of the sublists.","title":"Returns"},{"location":"reference/arr_first/#examples","text":"df = pl $ DataFrame ( list ( a = list ( 3 : 1 , NULL , 1 : 2 ) ) ) #NULL or integer() or list() df $ select ( pl $ col ( \"a\" ) $ arr $ first ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 null \u2502 #> \u2502 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_get/","text":"Get list Format function ## S3 method for class 'ExprArrNameSpace' x [ index ] Arguments x : ExprArrNameSpace index : value to get Returns Expr Get the value by index in the sublists. Details [.ExprArrNameSpace used as e.g. pl$col(\"a\")$arr[0] same as pl$col(\"a\")$get(0) Examples df = pl $ DataFrame ( list ( a = list ( 3 : 1 , NULL , 1 : 2 ) ) ) #NULL or integer() or list() df $ select ( pl $ col ( \"a\" ) $ arr $ get ( 0 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 null \u2502 #> \u2502 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"a\" ) $ arr $ get ( c ( 2 , 0 , - 1 ) ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 null \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df = pl $ DataFrame ( list ( a = list ( 3 : 1 , NULL , 1 : 2 ) ) ) #NULL or integer() or list() df $ select ( pl $ col ( \"a\" ) $ arr [ 0 ] ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 null \u2502 #> \u2502 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"a\" ) $ arr [ c ( 2 , 0 , - 1 ) ] ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 null \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_get"},{"location":"reference/arr_get/#get-list","text":"","title":"Get list"},{"location":"reference/arr_get/#format","text":"function ## S3 method for class 'ExprArrNameSpace' x [ index ]","title":"Format"},{"location":"reference/arr_get/#arguments","text":"x : ExprArrNameSpace index : value to get","title":"Arguments"},{"location":"reference/arr_get/#returns","text":"Expr Get the value by index in the sublists.","title":"Returns"},{"location":"reference/arr_get/#details","text":"[.ExprArrNameSpace used as e.g. pl$col(\"a\")$arr[0] same as pl$col(\"a\")$get(0)","title":"Details"},{"location":"reference/arr_get/#examples","text":"df = pl $ DataFrame ( list ( a = list ( 3 : 1 , NULL , 1 : 2 ) ) ) #NULL or integer() or list() df $ select ( pl $ col ( \"a\" ) $ arr $ get ( 0 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 null \u2502 #> \u2502 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"a\" ) $ arr $ get ( c ( 2 , 0 , - 1 ) ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 null \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df = pl $ DataFrame ( list ( a = list ( 3 : 1 , NULL , 1 : 2 ) ) ) #NULL or integer() or list() df $ select ( pl $ col ( \"a\" ) $ arr [ 0 ] ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 null \u2502 #> \u2502 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"a\" ) $ arr [ c ( 2 , 0 , - 1 ) ] ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 null \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_head/","text":"Heads of sublists Format function Arguments n : Numeric or Expr, number of values to return for each sublist. Returns Expr head the first n values of every sublist. Examples df = pl $ DataFrame ( list ( a = list ( 1 : 4 , c ( 10L , 2L , 1L ) ) ) ) df $ select ( pl $ col ( \"a\" ) $ arr $ head ( 2 ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [1, 2] \u2502 #> \u2502 [10, 2] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_head"},{"location":"reference/arr_head/#heads-of-sublists","text":"","title":"Heads of sublists"},{"location":"reference/arr_head/#format","text":"function","title":"Format"},{"location":"reference/arr_head/#arguments","text":"n : Numeric or Expr, number of values to return for each sublist.","title":"Arguments"},{"location":"reference/arr_head/#returns","text":"Expr head the first n values of every sublist.","title":"Returns"},{"location":"reference/arr_head/#examples","text":"df = pl $ DataFrame ( list ( a = list ( 1 : 4 , c ( 10L , 2L , 1L ) ) ) ) df $ select ( pl $ col ( \"a\" ) $ arr $ head ( 2 ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [1, 2] \u2502 #> \u2502 [10, 2] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_join/","text":"Join sublists Format function Arguments separator : string to separate the items with Returns Series of dtype Utf8 Join all string items in a sublist and place a separator between them. This errors if inner type of list != Utf8 . Examples df = pl $ DataFrame ( list ( s = list ( c ( \"a\" , \"b\" , \"c\" ) , c ( \"x\" , \"y\" ) ) ) ) df $ select ( pl $ col ( \"s\" ) $ arr $ join ( \" \" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 a b c \u2502 #> \u2502 x y \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_join"},{"location":"reference/arr_join/#join-sublists","text":"","title":"Join sublists"},{"location":"reference/arr_join/#format","text":"function","title":"Format"},{"location":"reference/arr_join/#arguments","text":"separator : string to separate the items with","title":"Arguments"},{"location":"reference/arr_join/#returns","text":"Series of dtype Utf8 Join all string items in a sublist and place a separator between them. This errors if inner type of list != Utf8 .","title":"Returns"},{"location":"reference/arr_join/#examples","text":"df = pl $ DataFrame ( list ( s = list ( c ( \"a\" , \"b\" , \"c\" ) , c ( \"x\" , \"y\" ) ) ) ) df $ select ( pl $ col ( \"s\" ) $ arr $ join ( \" \" ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 a b c \u2502 #> \u2502 x y \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_last/","text":"Last in sublists Format function Returns Expr Get the last value of the sublists. Examples df = pl $ DataFrame ( list ( a = list ( 3 : 1 , NULL , 1 : 2 ) ) ) #NULL or integer() or list() df $ select ( pl $ col ( \"a\" ) $ arr $ last ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 null \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_last"},{"location":"reference/arr_last/#last-in-sublists","text":"","title":"Last in sublists"},{"location":"reference/arr_last/#format","text":"function","title":"Format"},{"location":"reference/arr_last/#returns","text":"Expr Get the last value of the sublists.","title":"Returns"},{"location":"reference/arr_last/#examples","text":"df = pl $ DataFrame ( list ( a = list ( 3 : 1 , NULL , 1 : 2 ) ) ) #NULL or integer() or list() df $ select ( pl $ col ( \"a\" ) $ arr $ last ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 null \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_lengths/","text":"Lengths arrays in list Format function Returns Expr Get the length of the arrays as UInt32 Examples df = pl $ DataFrame ( list_of_strs = pl $ Series ( list ( c ( \"a\" , \"b\" ) , \"c\" ) ) ) df $ with_column ( pl $ col ( \"list_of_strs\" ) $ arr $ lengths ( ) $ alias ( \"list_of_strs_lengths\" ) ) #> polars DataFrame: shape: (2, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 list_of_strs \u2506 list_of_strs_lengths \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 list[str] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [\"a\", \"b\"] \u2506 2 \u2502 #> \u2502 [\"c\"] \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_lengths"},{"location":"reference/arr_lengths/#lengths-arrays-in-list","text":"","title":"Lengths arrays in list"},{"location":"reference/arr_lengths/#format","text":"function","title":"Format"},{"location":"reference/arr_lengths/#returns","text":"Expr Get the length of the arrays as UInt32","title":"Returns"},{"location":"reference/arr_lengths/#examples","text":"df = pl $ DataFrame ( list_of_strs = pl $ Series ( list ( c ( \"a\" , \"b\" ) , \"c\" ) ) ) df $ with_column ( pl $ col ( \"list_of_strs\" ) $ arr $ lengths ( ) $ alias ( \"list_of_strs_lengths\" ) ) #> polars DataFrame: shape: (2, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 list_of_strs \u2506 list_of_strs_lengths \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 list[str] \u2506 u32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [\"a\", \"b\"] \u2506 2 \u2502 #> \u2502 [\"c\"] \u2506 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_max/","text":"Max lists Format function Returns Expr Compute the max value of the lists in the array. Examples df = pl $ DataFrame ( values = pl $ Series ( list ( 1L , 2 : 3 ) ) ) df $ select ( pl $ col ( \"values\" ) $ arr $ max ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 values \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_max"},{"location":"reference/arr_max/#max-lists","text":"","title":"Max lists"},{"location":"reference/arr_max/#format","text":"function","title":"Format"},{"location":"reference/arr_max/#returns","text":"Expr Compute the max value of the lists in the array.","title":"Returns"},{"location":"reference/arr_max/#examples","text":"df = pl $ DataFrame ( values = pl $ Series ( list ( 1L , 2 : 3 ) ) ) df $ select ( pl $ col ( \"values\" ) $ arr $ max ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 values \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_mean/","text":"Mean of lists Format function Returns Expr Compute the mean value of the lists in the array. Examples df = pl $ DataFrame ( values = pl $ Series ( list ( 1L , 2 : 3 ) ) ) df $ select ( pl $ col ( \"values\" ) $ arr $ mean ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 values \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 2.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_mean"},{"location":"reference/arr_mean/#mean-of-lists","text":"","title":"Mean of lists"},{"location":"reference/arr_mean/#format","text":"function","title":"Format"},{"location":"reference/arr_mean/#returns","text":"Expr Compute the mean value of the lists in the array.","title":"Returns"},{"location":"reference/arr_mean/#examples","text":"df = pl $ DataFrame ( values = pl $ Series ( list ( 1L , 2 : 3 ) ) ) df $ select ( pl $ col ( \"values\" ) $ arr $ mean ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 values \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2502 2.5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_min/","text":"#' Min lists Format function Returns Expr Compute the min value of the lists in the array. Examples df = pl $ DataFrame ( values = pl $ Series ( list ( 1L , 2 : 3 ) ) ) df $ select ( pl $ col ( \"values\" ) $ arr $ min ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 values \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_min"},{"location":"reference/arr_min/#min-lists","text":"","title":"#' Min lists"},{"location":"reference/arr_min/#format","text":"function","title":"Format"},{"location":"reference/arr_min/#returns","text":"Expr Compute the min value of the lists in the array.","title":"Returns"},{"location":"reference/arr_min/#examples","text":"df = pl $ DataFrame ( values = pl $ Series ( list ( 1L , 2 : 3 ) ) ) df $ select ( pl $ col ( \"values\" ) $ arr $ min ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 values \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_reverse/","text":"Reverse list Format function Returns Expr Reverse the arrays in the list. Examples df = pl $ DataFrame ( list ( values = list ( 3 : 1 , c ( 9L , 1 : 2 ) ) ) ) df $ select ( pl $ col ( \"values\" ) $ arr $ reverse ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 values \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [1, 2, 3] \u2502 #> \u2502 [2, 1, 9] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_reverse"},{"location":"reference/arr_reverse/#reverse-list","text":"","title":"Reverse list"},{"location":"reference/arr_reverse/#format","text":"function","title":"Format"},{"location":"reference/arr_reverse/#returns","text":"Expr Reverse the arrays in the list.","title":"Returns"},{"location":"reference/arr_reverse/#examples","text":"df = pl $ DataFrame ( list ( values = list ( 3 : 1 , c ( 9L , 1 : 2 ) ) ) ) df $ select ( pl $ col ( \"values\" ) $ arr $ reverse ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 values \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [1, 2, 3] \u2502 #> \u2502 [2, 1, 9] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_shift/","text":"Shift sublists Format function Arguments periods : Value. Number of places to shift (may be negative). Returns Expr Shift values by the given period. Examples df = pl $ DataFrame ( list ( s = list ( 1 : 4 , c ( 10L , 2L , 1L ) ) ) ) df $ select ( pl $ col ( \"s\" ) $ arr $ shift ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [null, 1, ... 3] \u2502 #> \u2502 [null, 10, 2] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_shift"},{"location":"reference/arr_shift/#shift-sublists","text":"","title":"Shift sublists"},{"location":"reference/arr_shift/#format","text":"function","title":"Format"},{"location":"reference/arr_shift/#arguments","text":"periods : Value. Number of places to shift (may be negative).","title":"Arguments"},{"location":"reference/arr_shift/#returns","text":"Expr Shift values by the given period.","title":"Returns"},{"location":"reference/arr_shift/#examples","text":"df = pl $ DataFrame ( list ( s = list ( 1 : 4 , c ( 10L , 2L , 1L ) ) ) ) df $ select ( pl $ col ( \"s\" ) $ arr $ shift ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [null, 1, ... 3] \u2502 #> \u2502 [null, 10, 2] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_slice/","text":"Slice sublists Format function Arguments offset : value or Expr. Start index. Negative indexing is supported. length : value or Expr. Length of the slice. If set to None (default), the slice is taken to the end of the list. Returns Expr Slice every sublist. Examples df = pl $ DataFrame ( list ( s = list ( 1 : 4 , c ( 10L , 2L , 1L ) ) ) ) df $ select ( pl $ col ( \"s\" ) $ arr $ slice ( 2 ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [3, 4] \u2502 #> \u2502 [1] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_slice"},{"location":"reference/arr_slice/#slice-sublists","text":"","title":"Slice sublists"},{"location":"reference/arr_slice/#format","text":"function","title":"Format"},{"location":"reference/arr_slice/#arguments","text":"offset : value or Expr. Start index. Negative indexing is supported. length : value or Expr. Length of the slice. If set to None (default), the slice is taken to the end of the list.","title":"Arguments"},{"location":"reference/arr_slice/#returns","text":"Expr Slice every sublist.","title":"Returns"},{"location":"reference/arr_slice/#examples","text":"df = pl $ DataFrame ( list ( s = list ( 1 : 4 , c ( 10L , 2L , 1L ) ) ) ) df $ select ( pl $ col ( \"s\" ) $ arr $ slice ( 2 ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 s \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [3, 4] \u2502 #> \u2502 [1] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_sort/","text":"Get list Format function Arguments index : numeric vector or Expr of length 1 or same length of Series. if length 1 pick same value from each sublist, if length as Series/column, pick by individual index across sublists. So index 0 would return the first item of every sublist and index -1 would return the last item of every sublist if an index is out of bounds, it will return a None . Returns Expr Get the value by index in the sublists. Examples df = pl $ DataFrame ( list ( a = list ( 3 : 1 , NULL , 1 : 2 ) ) ) #NULL or integer() or list() df $ select ( pl $ col ( \"a\" ) $ arr $ get ( 0 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 null \u2502 #> \u2502 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"a\" ) $ arr $ get ( c ( 2 , 0 , - 1 ) ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 null \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_sort"},{"location":"reference/arr_sort/#get-list","text":"","title":"Get list"},{"location":"reference/arr_sort/#format","text":"function","title":"Format"},{"location":"reference/arr_sort/#arguments","text":"index : numeric vector or Expr of length 1 or same length of Series. if length 1 pick same value from each sublist, if length as Series/column, pick by individual index across sublists. So index 0 would return the first item of every sublist and index -1 would return the last item of every sublist if an index is out of bounds, it will return a None .","title":"Arguments"},{"location":"reference/arr_sort/#returns","text":"Expr Get the value by index in the sublists.","title":"Returns"},{"location":"reference/arr_sort/#examples","text":"df = pl $ DataFrame ( list ( a = list ( 3 : 1 , NULL , 1 : 2 ) ) ) #NULL or integer() or list() df $ select ( pl $ col ( \"a\" ) $ arr $ get ( 0 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 3 \u2502 #> \u2502 null \u2502 #> \u2502 1 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ col ( \"a\" ) $ arr $ get ( c ( 2 , 0 , - 1 ) ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 null \u2502 #> \u2502 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_sum/","text":"Sum lists Format function Returns Expr Sum all the lists in the array. Examples df = pl $ DataFrame ( values = pl $ Series ( list ( 1L , 2 : 3 ) ) ) df $ select ( pl $ col ( \"values\" ) $ arr $ sum ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 values \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_sum"},{"location":"reference/arr_sum/#sum-lists","text":"","title":"Sum lists"},{"location":"reference/arr_sum/#format","text":"function","title":"Format"},{"location":"reference/arr_sum/#returns","text":"Expr Sum all the lists in the array.","title":"Returns"},{"location":"reference/arr_sum/#examples","text":"df = pl $ DataFrame ( values = pl $ Series ( list ( 1L , 2 : 3 ) ) ) df $ select ( pl $ col ( \"values\" ) $ arr $ sum ( ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 values \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2502 #> \u2502 5 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_tail/","text":"Tails of sublists Format function Arguments n : Numeric or Expr, number of values to return for each sublist. Returns Expr tail the first n values of every sublist. Examples df = pl $ DataFrame ( list ( a = list ( 1 : 4 , c ( 10L , 2L , 1L ) ) ) ) df $ select ( pl $ col ( \"a\" ) $ arr $ tail ( 2 ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [3, 4] \u2502 #> \u2502 [2, 1] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_tail"},{"location":"reference/arr_tail/#tails-of-sublists","text":"","title":"Tails of sublists"},{"location":"reference/arr_tail/#format","text":"function","title":"Format"},{"location":"reference/arr_tail/#arguments","text":"n : Numeric or Expr, number of values to return for each sublist.","title":"Arguments"},{"location":"reference/arr_tail/#returns","text":"Expr tail the first n values of every sublist.","title":"Returns"},{"location":"reference/arr_tail/#examples","text":"df = pl $ DataFrame ( list ( a = list ( 1 : 4 , c ( 10L , 2L , 1L ) ) ) ) df $ select ( pl $ col ( \"a\" ) $ arr $ tail ( 2 ) ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [3, 4] \u2502 #> \u2502 [2, 1] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_take/","text":"take in sublists Format function Returns Expr Get the take value of the sublists. Examples df = pl $ DataFrame ( list ( a = list ( 3 : 1 , NULL , 1 : 2 ) ) ) #NULL or integer() or list() idx = pl $ Series ( list ( 0 : 1 , 1L , 1L ) ) df $ select ( pl $ col ( \"a\" ) $ arr $ take ( 99 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [null] \u2502 #> \u2502 [null] \u2502 #> \u2502 [null] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_take"},{"location":"reference/arr_take/#take-in-sublists","text":"","title":"take in sublists"},{"location":"reference/arr_take/#format","text":"function","title":"Format"},{"location":"reference/arr_take/#returns","text":"Expr Get the take value of the sublists.","title":"Returns"},{"location":"reference/arr_take/#examples","text":"df = pl $ DataFrame ( list ( a = list ( 3 : 1 , NULL , 1 : 2 ) ) ) #NULL or integer() or list() idx = pl $ Series ( list ( 0 : 1 , 1L , 1L ) ) df $ select ( pl $ col ( \"a\" ) $ arr $ take ( 99 ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[i32] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [null] \u2502 #> \u2502 [null] \u2502 #> \u2502 [null] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/arr_to_struct/","text":"List to Struct Format function Arguments n_field_strategy : Strategy to determine the number of fields of the struct. default = 'first_non_null' else 'max_width' name_generator : an R function that takes a scalar column number and outputs a string value. The default NULL is equivalent to the R function \\(idx) paste0(\"field_\",idx) upper_bound : upper_bound numeric A polars LazyFrame needs to know the schema at all time. The caller therefore must provide an upper_bound of struct fields that will be set. If this is incorrectly downstream operation may fail. For instance an all().sum() expression will look in the current schema to determine which columns to select. It is adviced to set this value in a lazy query. Returns Expr List to Struct Examples df = pl $ DataFrame ( list ( a = list ( 1 : 3 , 1 : 2 ) ) ) df2 = df $ select ( pl $ col ( \"a\" ) $ arr $ to_struct ( name_generator = \\ ( idx ) paste0 ( \"hello_you_\" , idx ) ) ) df2 $ unnest ( ) #> polars DataFrame: shape: (2, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 hello_you_0 \u2506 hello_you_1 \u2506 hello_you_2 \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 2 \u2506 3 \u2502 #> \u2502 1 \u2506 2 \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df2 $ to_list ( ) #> $a #> $a$hello_you_0 #> [1] 1 1 #> #> $a$hello_you_1 #> [1] 2 2 #> #> $a$hello_you_2 #> [1] 3 NA #> #>","title":"arr_to_struct"},{"location":"reference/arr_to_struct/#list-to-struct","text":"","title":"List to Struct"},{"location":"reference/arr_to_struct/#format","text":"function","title":"Format"},{"location":"reference/arr_to_struct/#arguments","text":"n_field_strategy : Strategy to determine the number of fields of the struct. default = 'first_non_null' else 'max_width' name_generator : an R function that takes a scalar column number and outputs a string value. The default NULL is equivalent to the R function \\(idx) paste0(\"field_\",idx) upper_bound : upper_bound numeric A polars LazyFrame needs to know the schema at all time. The caller therefore must provide an upper_bound of struct fields that will be set. If this is incorrectly downstream operation may fail. For instance an all().sum() expression will look in the current schema to determine which columns to select. It is adviced to set this value in a lazy query.","title":"Arguments"},{"location":"reference/arr_to_struct/#returns","text":"Expr List to Struct","title":"Returns"},{"location":"reference/arr_to_struct/#examples","text":"df = pl $ DataFrame ( list ( a = list ( 1 : 3 , 1 : 2 ) ) ) df2 = df $ select ( pl $ col ( \"a\" ) $ arr $ to_struct ( name_generator = \\ ( idx ) paste0 ( \"hello_you_\" , idx ) ) ) df2 $ unnest ( ) #> polars DataFrame: shape: (2, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 hello_you_0 \u2506 hello_you_1 \u2506 hello_you_2 \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 2 \u2506 3 \u2502 #> \u2502 1 \u2506 2 \u2506 null \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df2 $ to_list ( ) #> $a #> $a$hello_you_0 #> [1] 1 1 #> #> $a$hello_you_1 #> [1] 2 2 #> #> $a$hello_you_2 #> [1] 3 NA #> #>","title":"Examples"},{"location":"reference/arr_unique/","text":"Unique list Format function Returns Expr Get the unique/distinct values in the list. Examples df = pl $ DataFrame ( list ( a = list ( 1 , 1 , 2 ) ) ) df $ select ( pl $ col ( \"a\" ) $ arr $ unique ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[f64] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [1.0] \u2502 #> \u2502 [1.0] \u2502 #> \u2502 [2.0] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"arr_unique"},{"location":"reference/arr_unique/#unique-list","text":"","title":"Unique list"},{"location":"reference/arr_unique/#format","text":"function","title":"Format"},{"location":"reference/arr_unique/#returns","text":"Expr Get the unique/distinct values in the list.","title":"Returns"},{"location":"reference/arr_unique/#examples","text":"df = pl $ DataFrame ( list ( a = list ( 1 , 1 , 2 ) ) ) df $ select ( pl $ col ( \"a\" ) $ arr $ unique ( ) ) #> polars DataFrame: shape: (3, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2502 #> \u2502 --- \u2502 #> \u2502 list[f64] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [1.0] \u2502 #> \u2502 [1.0] \u2502 #> \u2502 [2.0] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/c.Series/","text":"Immutable combine series ## S3 method for class 'Series' c ( x , ... ) Arguments x : a Series ... : Series(s) or any object into Series meaning pl$Series(object) returns a series Returns a combined Series Immutable combine series Details append datatypes has to match. Combine does not rechunk. Read more about R vectors, Series and chunks in docs_translations : Examples s = c ( pl $ Series ( 1 : 5 ) , 3 : 1 , NA_integer_ ) s $ chunk_lengths ( ) #the series contain three unmerged chunks #> [1] 5 3 1","title":"c.Series"},{"location":"reference/c.Series/#immutable-combine-series","text":"## S3 method for class 'Series' c ( x , ... )","title":"Immutable combine series"},{"location":"reference/c.Series/#arguments","text":"x : a Series ... : Series(s) or any object into Series meaning pl$Series(object) returns a series","title":"Arguments"},{"location":"reference/c.Series/#returns","text":"a combined Series Immutable combine series","title":"Returns"},{"location":"reference/c.Series/#details","text":"append datatypes has to match. Combine does not rechunk. Read more about R vectors, Series and chunks in docs_translations :","title":"Details"},{"location":"reference/c.Series/#examples","text":"s = c ( pl $ Series ( 1 : 5 ) , 3 : 1 , NA_integer_ ) s $ chunk_lengths ( ) #the series contain three unmerged chunks #> [1] 5 3 1","title":"Examples"},{"location":"reference/check_no_missing_args/","text":"check_no_missing_args check_no_missing_args ( fun , args , warn = TRUE ) Arguments fun : target function to check incomming arguments for args : list of args to check warn : bool if TRUE throw warning when check fails Returns true if args are correct lifecycle: DEPRECATE","title":"check_no_missing_args"},{"location":"reference/check_no_missing_args/#check_no_missing_args","text":"check_no_missing_args ( fun , args , warn = TRUE )","title":"check_no_missing_args"},{"location":"reference/check_no_missing_args/#arguments","text":"fun : target function to check incomming arguments for args : list of args to check warn : bool if TRUE throw warning when check fails","title":"Arguments"},{"location":"reference/check_no_missing_args/#returns","text":"true if args are correct lifecycle: DEPRECATE","title":"Returns"},{"location":"reference/check_tz_to_result/","text":"Verify correct time zone check_tz_to_result ( tz , allow_null = TRUE ) Arguments tz : time zone string or NULL allow_null : bool, if TRUE accept NULL Returns a result object, with either a valid string or an Err Verify correct time zone Examples check_tz_to_result = polars ::: check_tz_to_result # expose internal #return Ok check_tz_to_result ( \"GMT\" ) #> $ok #> [1] \"GMT\" #> #> $err #> NULL #> #> attr(,\"class\") #> [1] \"extendr_result\" check_tz_to_result ( NULL ) #> $ok #> NULL #> #> $err #> NULL #> #> attr(,\"class\") #> [1] \"extendr_result\" #return Err check_tz_to_result ( \"Alice\" ) #> $ok #> NULL #> #> $err #> [1] \"pre-check tz: the tz 'Alice' is not a valid string from base::OlsonNames() or NULL\" #> #> attr(,\"class\") #> [1] \"extendr_result\" check_tz_to_result ( 42 ) #> $ok #> NULL #> #> $err #> [1] \"pre-check tz: the tz '42' is not a valid string from base::OlsonNames() or NULL\" #> #> attr(,\"class\") #> [1] \"extendr_result\" check_tz_to_result ( NULL , allow_null = FALSE ) #> $ok #> NULL #> #> $err #> [1] \"pre-check tz: here NULL tz is not allowed\" #> #> attr(,\"class\") #> [1] \"extendr_result\"","title":"check_tz_to_result"},{"location":"reference/check_tz_to_result/#verify-correct-time-zone","text":"check_tz_to_result ( tz , allow_null = TRUE )","title":"Verify correct time zone"},{"location":"reference/check_tz_to_result/#arguments","text":"tz : time zone string or NULL allow_null : bool, if TRUE accept NULL","title":"Arguments"},{"location":"reference/check_tz_to_result/#returns","text":"a result object, with either a valid string or an Err Verify correct time zone","title":"Returns"},{"location":"reference/check_tz_to_result/#examples","text":"check_tz_to_result = polars ::: check_tz_to_result # expose internal #return Ok check_tz_to_result ( \"GMT\" ) #> $ok #> [1] \"GMT\" #> #> $err #> NULL #> #> attr(,\"class\") #> [1] \"extendr_result\" check_tz_to_result ( NULL ) #> $ok #> NULL #> #> $err #> NULL #> #> attr(,\"class\") #> [1] \"extendr_result\" #return Err check_tz_to_result ( \"Alice\" ) #> $ok #> NULL #> #> $err #> [1] \"pre-check tz: the tz 'Alice' is not a valid string from base::OlsonNames() or NULL\" #> #> attr(,\"class\") #> [1] \"extendr_result\" check_tz_to_result ( 42 ) #> $ok #> NULL #> #> $err #> [1] \"pre-check tz: the tz '42' is not a valid string from base::OlsonNames() or NULL\" #> #> attr(,\"class\") #> [1] \"extendr_result\" check_tz_to_result ( NULL , allow_null = FALSE ) #> $ok #> NULL #> #> $err #> [1] \"pre-check tz: here NULL tz is not allowed\" #> #> attr(,\"class\") #> [1] \"extendr_result\"","title":"Examples"},{"location":"reference/clone_env_one_level_deep/","text":"Clone env on level deep. clone_env_one_level_deep ( env ) Arguments env : an R environment. Returns shallow clone of R environment Clone env on level deep. Details Sometimes used in polars to produce different hashmaps(environments) containing some of the same, but not all elements. environments are used for collections of methods and types. This function can be used to make a parallel collection pointing to some of the same types. Simply copying an environment, does apparently not spawn a new hashmap, and therefore the collections stay identical. Examples fruit_env = new.env ( parent = emptyenv ( ) ) fruit_env $ banana = TRUE fruit_env $ apple = FALSE env_1 = new.env ( parent = emptyenv ( ) ) env_1 $ fruit_env = fruit_env env_naive_copy = env_1 env_shallow_clone = polars ::: clone_env_one_level_deep ( env_1 ) #modifying env_! env_1 $ minerals = new.env ( parent = emptyenv ( ) ) env_1 $ fruit_env $ apple = 42L #naive copy is fully identical to env_1, so copying it not much useful ls ( env_naive_copy ) #> [1] \"fruit_env\" \"minerals\" #shallow copy env does not have minerals ls ( env_shallow_clone ) #> [1] \"fruit_env\" #however shallow clone does subscribe to changes to fruits as they were there # at time of cloning env_shallow_clone $ fruit_env $ apple #> [1] 42","title":"clone_env_one_level_deep"},{"location":"reference/clone_env_one_level_deep/#clone-env-on-level-deep","text":"clone_env_one_level_deep ( env )","title":"Clone env on level deep."},{"location":"reference/clone_env_one_level_deep/#arguments","text":"env : an R environment.","title":"Arguments"},{"location":"reference/clone_env_one_level_deep/#returns","text":"shallow clone of R environment Clone env on level deep.","title":"Returns"},{"location":"reference/clone_env_one_level_deep/#details","text":"Sometimes used in polars to produce different hashmaps(environments) containing some of the same, but not all elements. environments are used for collections of methods and types. This function can be used to make a parallel collection pointing to some of the same types. Simply copying an environment, does apparently not spawn a new hashmap, and therefore the collections stay identical.","title":"Details"},{"location":"reference/clone_env_one_level_deep/#examples","text":"fruit_env = new.env ( parent = emptyenv ( ) ) fruit_env $ banana = TRUE fruit_env $ apple = FALSE env_1 = new.env ( parent = emptyenv ( ) ) env_1 $ fruit_env = fruit_env env_naive_copy = env_1 env_shallow_clone = polars ::: clone_env_one_level_deep ( env_1 ) #modifying env_! env_1 $ minerals = new.env ( parent = emptyenv ( ) ) env_1 $ fruit_env $ apple = 42L #naive copy is fully identical to env_1, so copying it not much useful ls ( env_naive_copy ) #> [1] \"fruit_env\" \"minerals\" #shallow copy env does not have minerals ls ( env_shallow_clone ) #> [1] \"fruit_env\" #however shallow clone does subscribe to changes to fruits as they were there # at time of cloning env_shallow_clone $ fruit_env $ apple #> [1] 42","title":"Examples"},{"location":"reference/coalesce/","text":"Coalesce Arguments ... : is a: If one arg: Series or Expr, same as column$sum() string, same as pl$col(column)$sum() numeric, same as pl$lit(column)$sum() list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ... If several args, then wrapped in a list and handled as above. - exprs : list of Expr or Series or strings or a mix, or a char vector Returns Expr Expr Folds the expressions from left to right, keeping the first non-null value. Folds the expressions from left to right, keeping the first non-null value. Examples df = pl $ DataFrame ( a = NA_real_ , b = c ( 1 : 2 , NA_real_ , NA_real_ ) , c = c ( 1 : 3 , NA_real_ ) ) #use coalesce to get first non Null value for each row, otherwise insert 99.9 df $ with_column ( pl $ coalesce ( \"a\" , \"b\" , \"c\" , 99.9 ) $ alias ( \"d\" ) ) #> polars DataFrame: shape: (4, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 d \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2506 1.0 \u2506 1.0 \u2506 1.0 \u2502 #> \u2502 null \u2506 2.0 \u2506 2.0 \u2506 2.0 \u2502 #> \u2502 null \u2506 null \u2506 3.0 \u2506 3.0 \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 99.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #Create lagged columns and collect them into a list. This mimics a rolling window. df = pl $ DataFrame ( A = c ( 1 , 2 , 9 , 2 , 13 ) ) df $ with_columns ( lapply ( 0 : 2 , \\ ( i ) pl $ col ( \"A\" ) $ shift ( i ) $ alias ( paste0 ( \"A_lag_\" , i ) ) ) ) $ select ( pl $ concat_list ( lapply ( 2 : 0 ,\\ ( i ) pl $ col ( paste0 ( \"A_lag_\" , i ) ) ) ) $ alias ( \"A_rolling\" ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 A_rolling \u2502 #> \u2502 --- \u2502 #> \u2502 list[f64] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [null, null, 1.0] \u2502 #> \u2502 [null, 1.0, 2.0] \u2502 #> \u2502 [1.0, 2.0, 9.0] \u2502 #> \u2502 [2.0, 9.0, 2.0] \u2502 #> \u2502 [9.0, 2.0, 13.0] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #concat Expr a Series and an R obejct pl $ concat_list ( list ( pl $ lit ( 1 : 5 ) , pl $ Series ( 5 : 1 ) , rep ( 0L , 5 ) ) ) $ alias ( \"alice\" ) $ lit_to_s ( ) #> polars Series: shape: (5,) #> Series: 'alice' [list[i32]] #> [ #> [1, 5, 0] #> [2, 4, 0] #> [3, 3, 0] #> [4, 2, 0] #> [5, 1, 0] #> ]","title":"coalesce"},{"location":"reference/coalesce/#coalesce","text":"","title":"Coalesce"},{"location":"reference/coalesce/#arguments","text":"... : is a: If one arg: Series or Expr, same as column$sum() string, same as pl$col(column)$sum() numeric, same as pl$lit(column)$sum() list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ... If several args, then wrapped in a list and handled as above. - exprs : list of Expr or Series or strings or a mix, or a char vector","title":"Arguments"},{"location":"reference/coalesce/#returns","text":"Expr Expr Folds the expressions from left to right, keeping the first non-null value. Folds the expressions from left to right, keeping the first non-null value.","title":"Returns"},{"location":"reference/coalesce/#examples","text":"df = pl $ DataFrame ( a = NA_real_ , b = c ( 1 : 2 , NA_real_ , NA_real_ ) , c = c ( 1 : 3 , NA_real_ ) ) #use coalesce to get first non Null value for each row, otherwise insert 99.9 df $ with_column ( pl $ coalesce ( \"a\" , \"b\" , \"c\" , 99.9 ) $ alias ( \"d\" ) ) #> polars DataFrame: shape: (4, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 d \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2506 1.0 \u2506 1.0 \u2506 1.0 \u2502 #> \u2502 null \u2506 2.0 \u2506 2.0 \u2506 2.0 \u2502 #> \u2502 null \u2506 null \u2506 3.0 \u2506 3.0 \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 99.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #Create lagged columns and collect them into a list. This mimics a rolling window. df = pl $ DataFrame ( A = c ( 1 , 2 , 9 , 2 , 13 ) ) df $ with_columns ( lapply ( 0 : 2 , \\ ( i ) pl $ col ( \"A\" ) $ shift ( i ) $ alias ( paste0 ( \"A_lag_\" , i ) ) ) ) $ select ( pl $ concat_list ( lapply ( 2 : 0 ,\\ ( i ) pl $ col ( paste0 ( \"A_lag_\" , i ) ) ) ) $ alias ( \"A_rolling\" ) ) #> polars DataFrame: shape: (5, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 A_rolling \u2502 #> \u2502 --- \u2502 #> \u2502 list[f64] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 [null, null, 1.0] \u2502 #> \u2502 [null, 1.0, 2.0] \u2502 #> \u2502 [1.0, 2.0, 9.0] \u2502 #> \u2502 [2.0, 9.0, 2.0] \u2502 #> \u2502 [9.0, 2.0, 13.0] \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #concat Expr a Series and an R obejct pl $ concat_list ( list ( pl $ lit ( 1 : 5 ) , pl $ Series ( 5 : 1 ) , rep ( 0L , 5 ) ) ) $ alias ( \"alice\" ) $ lit_to_s ( ) #> polars Series: shape: (5,) #> Series: 'alice' [list[i32]] #> [ #> [1, 5, 0] #> [2, 4, 0] #> [3, 3, 0] #> [4, 2, 0] #> [5, 1, 0] #> ]","title":"Examples"},{"location":"reference/col/","text":"Start Expression with a column Arguments name : * a single column by a string all columns by using a wildcard \"*\" multiple columns as vector of strings column by regular expression if the regex starts with ^ and ends with $ e.g. pl$DataFrame(iris)$select(pl$col(c(\"^Sepal.*$\"))) * a single DataType or an R list of DataTypes, select any column of any such DataType * Series of utf8 strings abiding to above options Returns Column Exprression Return an expression representing a column in a DataFrame. Examples df = pl $ DataFrame ( list ( foo = 1 , bar = 2L ,foobar = \"3\" ) ) #a single column by a string df $ select ( pl $ col ( \"foo\" ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 #all columns by wildcard df $ select ( pl $ col ( \"*\" ) ) #> polars DataFrame: shape: (1, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 bar \u2506 foobar \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 2 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ all ( ) ) #> polars DataFrame: shape: (1, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 bar \u2506 foobar \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 2 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #multiple columns as vector of strings df $ select ( pl $ col ( c ( \"foo\" , \"bar\" ) ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 bar \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 #column by regular expression if the regex starts with `^` and ends with `$` df $ select ( pl $ col ( \"^foo.*$\" ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 foobar \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #a single DataType df $ select ( pl $ col ( pl $ dtypes $ Float64 ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 # ... or an R list of DataTypes, select any column of any such DataType df $ select ( pl $ col ( list ( pl $ dtypes $ Float64 , pl $ dtypes $ Utf8 ) ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 foobar \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 # from Series of names df $ select ( pl $ col ( pl $ Series ( c ( \"bar\" , \"foobar\" ) ) ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 bar \u2506 foobar \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"col"},{"location":"reference/col/#start-expression-with-a-column","text":"","title":"Start Expression with a column"},{"location":"reference/col/#arguments","text":"name : * a single column by a string all columns by using a wildcard \"*\" multiple columns as vector of strings column by regular expression if the regex starts with ^ and ends with $ e.g. pl$DataFrame(iris)$select(pl$col(c(\"^Sepal.*$\"))) * a single DataType or an R list of DataTypes, select any column of any such DataType * Series of utf8 strings abiding to above options","title":"Arguments"},{"location":"reference/col/#returns","text":"Column Exprression Return an expression representing a column in a DataFrame.","title":"Returns"},{"location":"reference/col/#examples","text":"df = pl $ DataFrame ( list ( foo = 1 , bar = 2L ,foobar = \"3\" ) ) #a single column by a string df $ select ( pl $ col ( \"foo\" ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 #all columns by wildcard df $ select ( pl $ col ( \"*\" ) ) #> polars DataFrame: shape: (1, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 bar \u2506 foobar \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 2 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( pl $ all ( ) ) #> polars DataFrame: shape: (1, 3) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 bar \u2506 foobar \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 2 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #multiple columns as vector of strings df $ select ( pl $ col ( c ( \"foo\" , \"bar\" ) ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 bar \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 2 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 #column by regular expression if the regex starts with `^` and ends with `$` df $ select ( pl $ col ( \"^foo.*$\" ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 foobar \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #a single DataType df $ select ( pl $ col ( pl $ dtypes $ Float64 ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 # ... or an R list of DataTypes, select any column of any such DataType df $ select ( pl $ col ( list ( pl $ dtypes $ Float64 , pl $ dtypes $ Utf8 ) ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 foo \u2506 foobar \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1.0 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 # from Series of names df $ select ( pl $ col ( pl $ Series ( c ( \"bar\" , \"foobar\" ) ) ) ) #> polars DataFrame: shape: (1, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 bar \u2506 foobar \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 2 \u2506 3 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/construct_DataTypeVector/","text":"construct data type vector construct_DataTypeVector ( l ) Arguments l : list of Expr or string Returns extptr to rust vector of RPolarsDataType's lifecycle: Deprecate, move to rust side","title":"construct_DataTypeVector"},{"location":"reference/construct_DataTypeVector/#construct-data-type-vector","text":"construct_DataTypeVector ( l )","title":"construct data type vector"},{"location":"reference/construct_DataTypeVector/#arguments","text":"l : list of Expr or string","title":"Arguments"},{"location":"reference/construct_DataTypeVector/#returns","text":"extptr to rust vector of RPolarsDataType's lifecycle: Deprecate, move to rust side","title":"Returns"},{"location":"reference/construct_ProtoExprArray/","text":"construct proto Expr array from args construct_ProtoExprArray ( ... ) Arguments ... : any Expr or string Returns ProtoExprArray object construct proto Expr array from args Examples polars ::: construct_ProtoExprArray ( pl $ col ( \"Species\" ) , \"Sepal.Width\" ) #> <pointer: 0x000003e7c81217a0> #> attr(,\"class\") #> [1] \"ProtoExprArray\"","title":"construct_ProtoExprArray"},{"location":"reference/construct_ProtoExprArray/#construct-proto-expr-array-from-args","text":"construct_ProtoExprArray ( ... )","title":"construct proto Expr array from args"},{"location":"reference/construct_ProtoExprArray/#arguments","text":"... : any Expr or string","title":"Arguments"},{"location":"reference/construct_ProtoExprArray/#returns","text":"ProtoExprArray object construct proto Expr array from args","title":"Returns"},{"location":"reference/construct_ProtoExprArray/#examples","text":"polars ::: construct_ProtoExprArray ( pl $ col ( \"Species\" ) , \"Sepal.Width\" ) #> <pointer: 0x000003e7c81217a0> #> attr(,\"class\") #> [1] \"ProtoExprArray\"","title":"Examples"},{"location":"reference/docs_translations/","text":"Translation definitions across python, R and polars. Format info Comments for how the R and python world translates into polars: R and python are both high-level glue languages great for Data Science. Rust is a pedantic low-level language with similar use cases as C and C++. Polars is written in ~100k lines of rust and has a rust API. Py-polars the python API for polars, is implemented as an interface with the rust API. r-polars is very parallel to py-polars except it interfaces with R. The performance and behavior are unexpectedly quite similar as the 'engine' is the exact same rust code and data structures. Translation details","title":"docs_translations"},{"location":"reference/docs_translations/#translation-definitions-across-python-r-and-polars","text":"","title":"Translation definitions across python, R and polars."},{"location":"reference/docs_translations/#format","text":"info","title":"Format"},{"location":"reference/docs_translations/#comments-for-how-the-r-and-python-world-translates-into-polars","text":"R and python are both high-level glue languages great for Data Science. Rust is a pedantic low-level language with similar use cases as C and C++. Polars is written in ~100k lines of rust and has a rust API. Py-polars the python API for polars, is implemented as an interface with the rust API. r-polars is very parallel to py-polars except it interfaces with R. The performance and behavior are unexpectedly quite similar as the 'engine' is the exact same rust code and data structures.","title":"Comments for how the R and python world translates into polars:"},{"location":"reference/docs_translations/#translation-details","text":"","title":"Translation details"},{"location":"reference/dot-DollarNames.DataFrame/","text":"auto complete $-access into a polars object ## S3 method for class 'DataFrame' .DollarNames ( x , pattern = \"\" ) Arguments x : DataFrame pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"dot-DollarNames.DataFrame"},{"location":"reference/dot-DollarNames.DataFrame/#auto-complete-access-into-a-polars-object","text":"## S3 method for class 'DataFrame' .DollarNames ( x , pattern = \"\" )","title":"auto complete $-access into a polars object"},{"location":"reference/dot-DollarNames.DataFrame/#arguments","text":"x : DataFrame pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"Arguments"},{"location":"reference/dot-DollarNames.Expr/","text":"auto complete $-access into a polars object ## S3 method for class 'Expr' .DollarNames ( x , pattern = \"\" ) Arguments x : Expr pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"dot-DollarNames.Expr"},{"location":"reference/dot-DollarNames.Expr/#auto-complete-access-into-a-polars-object","text":"## S3 method for class 'Expr' .DollarNames ( x , pattern = \"\" )","title":"auto complete $-access into a polars object"},{"location":"reference/dot-DollarNames.Expr/#arguments","text":"x : Expr pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"Arguments"},{"location":"reference/dot-DollarNames.GroupBy/","text":"auto complete $-access into a polars object ## S3 method for class 'GroupBy' .DollarNames ( x , pattern = \"\" ) Arguments x : GroupBy pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"dot-DollarNames.GroupBy"},{"location":"reference/dot-DollarNames.GroupBy/#auto-complete-access-into-a-polars-object","text":"## S3 method for class 'GroupBy' .DollarNames ( x , pattern = \"\" )","title":"auto complete $-access into a polars object"},{"location":"reference/dot-DollarNames.GroupBy/#arguments","text":"x : GroupBy pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"Arguments"},{"location":"reference/dot-DollarNames.LazyFrame/","text":"auto complete $-access into a polars object ## S3 method for class 'LazyFrame' .DollarNames ( x , pattern = \"\" ) Arguments x : LazyFrame pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"dot-DollarNames.LazyFrame"},{"location":"reference/dot-DollarNames.LazyFrame/#auto-complete-access-into-a-polars-object","text":"## S3 method for class 'LazyFrame' .DollarNames ( x , pattern = \"\" )","title":"auto complete $-access into a polars object"},{"location":"reference/dot-DollarNames.LazyFrame/#arguments","text":"x : LazyFrame pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"Arguments"},{"location":"reference/dot-DollarNames.PolarsBackgroundHandle/","text":"auto complete $-access into a polars object ## S3 method for class 'PolarsBackgroundHandle' .DollarNames ( x , pattern = \"\" ) Arguments x : LazyFrame pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"dot-DollarNames.PolarsBackgroundHandle"},{"location":"reference/dot-DollarNames.PolarsBackgroundHandle/#auto-complete-access-into-a-polars-object","text":"## S3 method for class 'PolarsBackgroundHandle' .DollarNames ( x , pattern = \"\" )","title":"auto complete $-access into a polars object"},{"location":"reference/dot-DollarNames.PolarsBackgroundHandle/#arguments","text":"x : LazyFrame pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"Arguments"},{"location":"reference/dot-DollarNames.Series/","text":"auto complete $-access into a polars object ## S3 method for class 'Series' .DollarNames ( x , pattern = \"\" ) Arguments x : Series pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"dot-DollarNames.Series"},{"location":"reference/dot-DollarNames.Series/#auto-complete-access-into-a-polars-object","text":"## S3 method for class 'Series' .DollarNames ( x , pattern = \"\" )","title":"auto complete $-access into a polars object"},{"location":"reference/dot-DollarNames.Series/#arguments","text":"x : Series pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"Arguments"},{"location":"reference/dot-DollarNames.VecDataFrame/","text":"auto complete $-access into a polars object ## S3 method for class 'VecDataFrame' .DollarNames ( x , pattern = \"\" ) Arguments x : VecDataFrame pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"dot-DollarNames.VecDataFrame"},{"location":"reference/dot-DollarNames.VecDataFrame/#auto-complete-access-into-a-polars-object","text":"## S3 method for class 'VecDataFrame' .DollarNames ( x , pattern = \"\" )","title":"auto complete $-access into a polars object"},{"location":"reference/dot-DollarNames.VecDataFrame/#arguments","text":"x : VecDataFrame pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"Arguments"},{"location":"reference/dot-DollarNames.When/","text":"auto complete $-access into a polars object ## S3 method for class 'When' .DollarNames ( x , pattern = \"\" ) Arguments x : When pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"dot-DollarNames.When"},{"location":"reference/dot-DollarNames.When/#auto-complete-access-into-a-polars-object","text":"## S3 method for class 'When' .DollarNames ( x , pattern = \"\" )","title":"auto complete $-access into a polars object"},{"location":"reference/dot-DollarNames.When/#arguments","text":"x : When pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"Arguments"},{"location":"reference/dot-DollarNames.WhenThen/","text":"auto complete $-access into a polars object ## S3 method for class 'WhenThen' .DollarNames ( x , pattern = \"\" ) Arguments x : WhenThen pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"dot-DollarNames.WhenThen"},{"location":"reference/dot-DollarNames.WhenThen/#auto-complete-access-into-a-polars-object","text":"## S3 method for class 'WhenThen' .DollarNames ( x , pattern = \"\" )","title":"auto complete $-access into a polars object"},{"location":"reference/dot-DollarNames.WhenThen/#arguments","text":"x : WhenThen pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"Arguments"},{"location":"reference/dot-DollarNames.WhenThenThen/","text":"auto complete $-access into a polars object ## S3 method for class 'WhenThenThen' .DollarNames ( x , pattern = \"\" ) Arguments x : WhenThenThen pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"dot-DollarNames.WhenThenThen"},{"location":"reference/dot-DollarNames.WhenThenThen/#auto-complete-access-into-a-polars-object","text":"## S3 method for class 'WhenThenThen' .DollarNames ( x , pattern = \"\" )","title":"auto complete $-access into a polars object"},{"location":"reference/dot-DollarNames.WhenThenThen/#arguments","text":"x : WhenThenThen pattern : code-stump as string to auto-complete called by the interactive R session internally","title":"Arguments"},{"location":"reference/dot-pr/","text":"data polars-API: private calls to rust-polars Format An object of class environment of length 16. .pr .pr Original extendr bindings converted into pure functions Examples #.pr$DataFrame$print() is an external function where self is passed as arg polars ::: .pr $ DataFrame $ print ( self = pl $ DataFrame ( iris ) ) #> shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #> polars DataFrame: shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 polars ::: print_env ( .pr , \".pr the collection of private method calls to rust-polars\" ) #> #> #> .pr the collection of private method calls to rust-polars ( environment ): #> #> DataFrame ( environment ): #> [ by_agg ; function ] #> [ clone_see_me_macro ; function ] #> [ columns ; function ] #> [ dtypes ; function ] #> [ estimated_size ; function ] #> [ export_stream ; function ] #> [ from_arrow_record_batches ; function ] #> [ get_column ; function ] #> [ get_columns ; function ] #> [ lazy ; function ] #> [ new ; function ] #> [ new_par_from_list ; function ] #> [ new_with_capacity ; function ] #> [ null_count ; function ] #> [ print ; function ] #> [ schema ; function ] #> [ select ; function ] #> [ select_at_idx ; function ] #> [ set_column_from_robj ; function ] #> [ set_column_from_series ; function ] #> [ set_column_names_mut ; function ] #> [ shape ; function ] #> [ to_list ; function ] #> [ to_list_tag_structs ; function ] #> [ to_list_unwind ; function ] #> [ to_struct ; function ] #> [ unnest ; function ] #> #> #> DataType ( environment ): #> [ eq ; function ] #> [ get_all_simple_type_names ; function ] #> [ get_insides ; function ] #> [ is_temporal ; function ] #> [ ne ; function ] #> [ new ; function ] #> [ new_datetime ; function ] #> [ new_duration ; function ] #> [ new_list ; function ] #> [ new_object ; function ] #> [ new_struct ; function ] #> [ print ; function ] #> [ same_outer_datatype ; function ] #> #> #> DataTypeVector ( environment ): #> [ from_rlist ; function ] #> [ new ; function ] #> [ print ; function ] #> [ push ; function ] #> #> #> Expr ( environment ): #> [ abs ; function ] #> [ add ; function ] #> [ agg_groups ; function ] #> [ alias ; function ] #> [ all ; function ] #> [ and ; function ] #> [ any ; function ] #> [ append ; function ] #> [ arccos ; function ] #> [ arccosh ; function ] #> [ arcsin ; function ] #> [ arcsinh ; function ] #> [ arctan ; function ] #> [ arctanh ; function ] #> [ arg_max ; function ] #> [ arg_min ; function ] #> [ arg_sort ; function ] #> [ arg_unique ; function ] #> [ arr_contains ; function ] #> [ arr_lengths ; function ] #> [ backward_fill ; function ] #> [ bin_contains ; function ] #> [ bin_decode_base64 ; function ] #> [ bin_decode_hex ; function ] #> [ bin_encode_base64 ; function ] #> [ bin_encode_hex ; function ] #> [ bin_ends_with ; function ] #> [ bin_starts_with ; function ] #> [ cast ; function ] #> [ cat_set_ordering ; function ] #> [ ceil ; function ] #> [ clip ; function ] #> [ clip_max ; function ] #> [ clip_min ; function ] #> [ col ; function ] #> [ cols ; function ] #> [ cos ; function ] #> [ cosh ; function ] #> [ count ; function ] #> [ cumcount ; function ] #> [ cummax ; function ] #> [ cummin ; function ] #> [ cumprod ; function ] #> [ cumsum ; function ] #> [ cumulative_eval ; function ] #> [ diff ; function ] #> [ div ; function ] #> [ dot ; function ] #> [ drop_nans ; function ] #> [ drop_nulls ; function ] #> [ dt_cast_time_unit ; function ] #> [ dt_combine ; function ] #> [ dt_convert_time_zone ; function ] #> [ dt_day ; function ] #> [ dt_epoch_seconds ; function ] #> [ dt_hour ; function ] #> [ dt_iso_year ; function ] #> [ dt_microsecond ; function ] #> [ dt_millisecond ; function ] #> [ dt_minute ; function ] #> [ dt_month ; function ] #> [ dt_nanosecond ; function ] #> [ dt_offset_by ; function ] #> [ dt_ordinal_day ; function ] #> [ dt_quarter ; function ] #> [ dt_replace_time_zone ; function ] #> [ dt_round ; function ] #> [ dt_second ; function ] #> [ dt_strftime ; function ] #> [ dt_truncate ; function ] #> [ dt_tz_localize ; function ] #> [ dt_week ; function ] #> [ dt_weekday ; function ] #> [ dt_with_time_unit ; function ] #> [ dt_year ; function ] #> [ dtype_cols ; function ] #> [ duration_days ; function ] #> [ duration_hours ; function ] #> [ duration_microseconds ; function ] #> [ duration_milliseconds ; function ] #> [ duration_minutes ; function ] #> [ duration_nanoseconds ; function ] #> [ duration_seconds ; function ] #> [ entropy ; function ] #> [ eq ; function ] #> [ ewm_mean ; function ] #> [ ewm_std ; function ] #> [ ewm_var ; function ] #> [ exclude ; function ] #> [ exclude_dtype ; function ] #> [ exp ; function ] #> [ explode ; function ] #> [ extend_constant ; function ] #> [ extend_expr ; function ] #> [ fill_nan ; function ] #> [ fill_null ; function ] #> [ fill_null_with_strategy ; function ] #> [ filter ; function ] #> [ first ; function ] #> [ flatten ; function ] #> [ floor ; function ] #> [ forward_fill ; function ] #> [ gt ; function ] #> [ gt_eq ; function ] #> [ hash ; function ] #> [ head ; function ] #> [ interpolate ; function ] #> [ is_duplicated ; function ] #> [ is_finite ; function ] #> [ is_first ; function ] #> [ is_in ; function ] #> [ is_infinite ; function ] #> [ is_nan ; function ] #> [ is_not ; function ] #> [ is_not_nan ; function ] #> [ is_not_null ; function ] #> [ is_null ; function ] #> [ is_unique ; function ] #> [ keep_name ; function ] #> [ kurtosis ; function ] #> [ last ; function ] #> [ len ; function ] #> [ list ; function ] #> [ lit ; function ] #> [ log ; function ] #> [ log10 ; function ] #> [ lower_bound ; function ] #> [ lst_arg_max ; function ] #> [ lst_arg_min ; function ] #> [ lst_diff ; function ] #> [ lst_eval ; function ] #> [ lst_get ; function ] #> [ lst_join ; function ] #> [ lst_max ; function ] #> [ lst_mean ; function ] #> [ lst_min ; function ] #> [ lst_reverse ; function ] #> [ lst_shift ; function ] #> [ lst_slice ; function ] #> [ lst_sort ; function ] #> [ lst_sum ; function ] #> [ lst_take ; function ] #> [ lst_to_struct ; function ] #> [ lst_unique ; function ] #> [ lt ; function ] #> [ lt_eq ; function ] #> [ map ; function ] #> [ map_alias ; function ] #> [ max ; function ] #> [ mean ; function ] #> [ median ; function ] #> [ meta_eq ; function ] #> [ meta_has_multiple_outputs ; function ] #> [ meta_is_regex_projection ; function ] #> [ meta_output_name ; function ] #> [ meta_pop ; function ] #> [ meta_roots ; function ] #> [ meta_undo_aliases ; function ] #> [ min ; function ] #> [ mode ; function ] #> [ mul ; function ] #> [ n_unique ; function ] #> [ nan_max ; function ] #> [ nan_min ; function ] #> [ neq ; function ] #> [ null_count ; function ] #> [ or ; function ] #> [ over ; function ] #> [ pct_change ; function ] #> [ pow ; function ] #> [ prefix ; function ] #> [ print ; function ] #> [ product ; function ] #> [ quantile ; function ] #> [ rank ; function ] #> [ rechunk ; function ] #> [ reinterpret ; function ] #> [ rep ; function ] #> [ repeat_by ; function ] #> [ reshape ; function ] #> [ reverse ; function ] #> [ rolling_max ; function ] #> [ rolling_mean ; function ] #> [ rolling_median ; function ] #> [ rolling_min ; function ] #> [ rolling_quantile ; function ] #> [ rolling_skew ; function ] #> [ rolling_std ; function ] #> [ rolling_sum ; function ] #> [ rolling_var ; function ] #> [ round ; function ] #> [ sample_frac ; function ] #> [ sample_n ; function ] #> [ search_sorted ; function ] #> [ shift ; function ] #> [ shift_and_fill ; function ] #> [ shrink_dtype ; function ] #> [ shuffle ; function ] #> [ sign ; function ] #> [ sin ; function ] #> [ sinh ; function ] #> [ skew ; function ] #> [ slice ; function ] #> [ sort ; function ] #> [ sort_by ; function ] #> [ std ; function ] #> [ str_base64_decode ; function ] #> [ str_base64_encode ; function ] #> [ str_concat ; function ] #> [ str_contains ; function ] #> [ str_count_match ; function ] #> [ str_ends_with ; function ] #> [ str_extract ; function ] #> [ str_extract_all ; function ] #> [ str_hex_decode ; function ] #> [ str_hex_encode ; function ] #> [ str_json_extract ; function ] #> [ str_json_path_match ; function ] #> [ str_lengths ; function ] #> [ str_ljust ; function ] #> [ str_lstrip ; function ] #> [ str_n_chars ; function ] #> [ str_parse_date ; function ] #> [ str_parse_datetime ; function ] #> [ str_parse_int ; function ] #> [ str_parse_time ; function ] #> [ str_replace ; function ] #> [ str_replace_all ; function ] #> [ str_rjust ; function ] #> [ str_rstrip ; function ] #> [ str_slice ; function ] #> [ str_split ; function ] #> [ str_split_exact ; function ] #> [ str_splitn ; function ] #> [ str_starts_with ; function ] #> [ str_strip ; function ] #> [ str_to_lowercase ; function ] #> [ str_to_uppercase ; function ] #> [ str_zfill ; function ] #> [ struct_field_by_name ; function ] #> [ struct_rename_fields ; function ] #> [ sub ; function ] #> [ suffix ; function ] #> [ sum ; function ] #> [ tail ; function ] #> [ take ; function ] #> [ take_every ; function ] #> [ tan ; function ] #> [ tanh ; function ] #> [ timestamp ; function ] #> [ to_physical ; function ] #> [ top_k ; function ] #> [ unique ; function ] #> [ unique_counts ; function ] #> [ unique_stable ; function ] #> [ upper_bound ; function ] #> [ value_counts ; function ] #> [ var ; function ] #> [ xor ; function ] #> #> [ GroupBy ; NULL ] #> #> LazyFrame ( environment ): #> [ collect ; function ] #> [ collect_background ; function ] #> [ describe_optimized_plan ; function ] #> [ describe_plan ; function ] #> [ filter ; function ] #> [ first ; function ] #> [ groupby ; function ] #> [ join ; function ] #> [ last ; function ] #> [ limit ; function ] #> [ max ; function ] #> [ mean ; function ] #> [ median ; function ] #> [ min ; function ] #> [ print ; function ] #> [ reverse ; function ] #> [ select ; function ] #> [ slice ; function ] #> [ std ; function ] #> [ sum ; function ] #> [ tail ; function ] #> [ var ; function ] #> [ with_column ; function ] #> [ with_columns ; function ] #> #> #> LazyGroupBy ( environment ): #> [ agg ; function ] #> [ head ; function ] #> [ print ; function ] #> [ tail ; function ] #> #> #> PolarsBackgroundHandle ( environment ): #> [ is_exhausted ; function ] #> [ join ; function ] #> [ new ; function ] #> #> #> ProtoExprArray ( environment ): #> [ new ; function ] #> [ print ; function ] #> [ push_back_rexpr ; function ] #> [ push_back_str ; function ] #> #> #> RField ( environment ): #> [ clone ; function ] #> [ get_datatype ; function ] #> [ get_name ; function ] #> [ new ; function ] #> [ print ; function ] #> [ set_datatype_mut ; function ] #> [ set_name_mut ; function ] #> #> #> RNullValues ( environment ): #> [ new_all_columns ; function ] #> [ new_columns ; function ] #> [ new_named ; function ] #> #> #> Series ( environment ): #> [ abs ; function ] #> [ add ; function ] #> [ alias ; function ] #> [ all ; function ] #> [ any ; function ] #> [ append_mut ; function ] #> [ apply ; function ] #> [ arg_max ; function ] #> [ arg_min ; function ] #> [ ceil ; function ] #> [ chunk_lengths ; function ] #> [ clone ; function ] #> [ compare ; function ] #> [ cumsum ; function ] #> [ div ; function ] #> [ dtype ; function ] #> [ floor ; function ] #> [ from_arrow ; function ] #> [ is_sorted ; function ] #> [ is_sorted_flag ; function ] #> [ is_sorted_reverse_flag ; function ] #> [ len ; function ] #> [ max ; function ] #> [ min ; function ] #> [ mul ; function ] #> [ name ; function ] #> [ new ; function ] #> [ panic ; function ] #> [ print ; function ] #> [ rem ; function ] #> [ rename_mut ; function ] #> [ rep ; function ] #> [ series_equal ; function ] #> [ set_sorted_mut ; function ] #> [ shape ; function ] #> [ sleep ; function ] #> [ sort_mut ; function ] #> [ sub ; function ] #> [ sum ; function ] #> [ to_frame ; function ] #> [ to_r ; function ] #> [ value_counts ; function ] #> #> #> VecDataFrame ( environment ): #> [ new ; function ] #> [ print ; function ] #> [ push ; function ] #> [ with_capacity ; function ] #> #> #> When ( environment ): #> [ print ; function ] #> [ then ; function ] #> [ when ; function ] #> #> #> WhenThen ( environment ): #> [ otherwise ; function ] #> [ print ; function ] #> [ when ; function ] #> #> #> WhenThenThen ( environment ): #> [ otherwise ; function ] #> [ print ; function ] #> [ then ; function ] #> [ when ; function ] #>","title":"dot-pr"},{"location":"reference/dot-pr/#polars-api-private-calls-to-rust-polars","text":"","title":"polars-API: private calls to rust-polars"},{"location":"reference/dot-pr/#format","text":"An object of class environment of length 16. .pr .pr Original extendr bindings converted into pure functions","title":"Format"},{"location":"reference/dot-pr/#examples","text":"#.pr$DataFrame$print() is an external function where self is passed as arg polars ::: .pr $ DataFrame $ print ( self = pl $ DataFrame ( iris ) ) #> shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #> polars DataFrame: shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 polars ::: print_env ( .pr , \".pr the collection of private method calls to rust-polars\" ) #> #> #> .pr the collection of private method calls to rust-polars ( environment ): #> #> DataFrame ( environment ): #> [ by_agg ; function ] #> [ clone_see_me_macro ; function ] #> [ columns ; function ] #> [ dtypes ; function ] #> [ estimated_size ; function ] #> [ export_stream ; function ] #> [ from_arrow_record_batches ; function ] #> [ get_column ; function ] #> [ get_columns ; function ] #> [ lazy ; function ] #> [ new ; function ] #> [ new_par_from_list ; function ] #> [ new_with_capacity ; function ] #> [ null_count ; function ] #> [ print ; function ] #> [ schema ; function ] #> [ select ; function ] #> [ select_at_idx ; function ] #> [ set_column_from_robj ; function ] #> [ set_column_from_series ; function ] #> [ set_column_names_mut ; function ] #> [ shape ; function ] #> [ to_list ; function ] #> [ to_list_tag_structs ; function ] #> [ to_list_unwind ; function ] #> [ to_struct ; function ] #> [ unnest ; function ] #> #> #> DataType ( environment ): #> [ eq ; function ] #> [ get_all_simple_type_names ; function ] #> [ get_insides ; function ] #> [ is_temporal ; function ] #> [ ne ; function ] #> [ new ; function ] #> [ new_datetime ; function ] #> [ new_duration ; function ] #> [ new_list ; function ] #> [ new_object ; function ] #> [ new_struct ; function ] #> [ print ; function ] #> [ same_outer_datatype ; function ] #> #> #> DataTypeVector ( environment ): #> [ from_rlist ; function ] #> [ new ; function ] #> [ print ; function ] #> [ push ; function ] #> #> #> Expr ( environment ): #> [ abs ; function ] #> [ add ; function ] #> [ agg_groups ; function ] #> [ alias ; function ] #> [ all ; function ] #> [ and ; function ] #> [ any ; function ] #> [ append ; function ] #> [ arccos ; function ] #> [ arccosh ; function ] #> [ arcsin ; function ] #> [ arcsinh ; function ] #> [ arctan ; function ] #> [ arctanh ; function ] #> [ arg_max ; function ] #> [ arg_min ; function ] #> [ arg_sort ; function ] #> [ arg_unique ; function ] #> [ arr_contains ; function ] #> [ arr_lengths ; function ] #> [ backward_fill ; function ] #> [ bin_contains ; function ] #> [ bin_decode_base64 ; function ] #> [ bin_decode_hex ; function ] #> [ bin_encode_base64 ; function ] #> [ bin_encode_hex ; function ] #> [ bin_ends_with ; function ] #> [ bin_starts_with ; function ] #> [ cast ; function ] #> [ cat_set_ordering ; function ] #> [ ceil ; function ] #> [ clip ; function ] #> [ clip_max ; function ] #> [ clip_min ; function ] #> [ col ; function ] #> [ cols ; function ] #> [ cos ; function ] #> [ cosh ; function ] #> [ count ; function ] #> [ cumcount ; function ] #> [ cummax ; function ] #> [ cummin ; function ] #> [ cumprod ; function ] #> [ cumsum ; function ] #> [ cumulative_eval ; function ] #> [ diff ; function ] #> [ div ; function ] #> [ dot ; function ] #> [ drop_nans ; function ] #> [ drop_nulls ; function ] #> [ dt_cast_time_unit ; function ] #> [ dt_combine ; function ] #> [ dt_convert_time_zone ; function ] #> [ dt_day ; function ] #> [ dt_epoch_seconds ; function ] #> [ dt_hour ; function ] #> [ dt_iso_year ; function ] #> [ dt_microsecond ; function ] #> [ dt_millisecond ; function ] #> [ dt_minute ; function ] #> [ dt_month ; function ] #> [ dt_nanosecond ; function ] #> [ dt_offset_by ; function ] #> [ dt_ordinal_day ; function ] #> [ dt_quarter ; function ] #> [ dt_replace_time_zone ; function ] #> [ dt_round ; function ] #> [ dt_second ; function ] #> [ dt_strftime ; function ] #> [ dt_truncate ; function ] #> [ dt_tz_localize ; function ] #> [ dt_week ; function ] #> [ dt_weekday ; function ] #> [ dt_with_time_unit ; function ] #> [ dt_year ; function ] #> [ dtype_cols ; function ] #> [ duration_days ; function ] #> [ duration_hours ; function ] #> [ duration_microseconds ; function ] #> [ duration_milliseconds ; function ] #> [ duration_minutes ; function ] #> [ duration_nanoseconds ; function ] #> [ duration_seconds ; function ] #> [ entropy ; function ] #> [ eq ; function ] #> [ ewm_mean ; function ] #> [ ewm_std ; function ] #> [ ewm_var ; function ] #> [ exclude ; function ] #> [ exclude_dtype ; function ] #> [ exp ; function ] #> [ explode ; function ] #> [ extend_constant ; function ] #> [ extend_expr ; function ] #> [ fill_nan ; function ] #> [ fill_null ; function ] #> [ fill_null_with_strategy ; function ] #> [ filter ; function ] #> [ first ; function ] #> [ flatten ; function ] #> [ floor ; function ] #> [ forward_fill ; function ] #> [ gt ; function ] #> [ gt_eq ; function ] #> [ hash ; function ] #> [ head ; function ] #> [ interpolate ; function ] #> [ is_duplicated ; function ] #> [ is_finite ; function ] #> [ is_first ; function ] #> [ is_in ; function ] #> [ is_infinite ; function ] #> [ is_nan ; function ] #> [ is_not ; function ] #> [ is_not_nan ; function ] #> [ is_not_null ; function ] #> [ is_null ; function ] #> [ is_unique ; function ] #> [ keep_name ; function ] #> [ kurtosis ; function ] #> [ last ; function ] #> [ len ; function ] #> [ list ; function ] #> [ lit ; function ] #> [ log ; function ] #> [ log10 ; function ] #> [ lower_bound ; function ] #> [ lst_arg_max ; function ] #> [ lst_arg_min ; function ] #> [ lst_diff ; function ] #> [ lst_eval ; function ] #> [ lst_get ; function ] #> [ lst_join ; function ] #> [ lst_max ; function ] #> [ lst_mean ; function ] #> [ lst_min ; function ] #> [ lst_reverse ; function ] #> [ lst_shift ; function ] #> [ lst_slice ; function ] #> [ lst_sort ; function ] #> [ lst_sum ; function ] #> [ lst_take ; function ] #> [ lst_to_struct ; function ] #> [ lst_unique ; function ] #> [ lt ; function ] #> [ lt_eq ; function ] #> [ map ; function ] #> [ map_alias ; function ] #> [ max ; function ] #> [ mean ; function ] #> [ median ; function ] #> [ meta_eq ; function ] #> [ meta_has_multiple_outputs ; function ] #> [ meta_is_regex_projection ; function ] #> [ meta_output_name ; function ] #> [ meta_pop ; function ] #> [ meta_roots ; function ] #> [ meta_undo_aliases ; function ] #> [ min ; function ] #> [ mode ; function ] #> [ mul ; function ] #> [ n_unique ; function ] #> [ nan_max ; function ] #> [ nan_min ; function ] #> [ neq ; function ] #> [ null_count ; function ] #> [ or ; function ] #> [ over ; function ] #> [ pct_change ; function ] #> [ pow ; function ] #> [ prefix ; function ] #> [ print ; function ] #> [ product ; function ] #> [ quantile ; function ] #> [ rank ; function ] #> [ rechunk ; function ] #> [ reinterpret ; function ] #> [ rep ; function ] #> [ repeat_by ; function ] #> [ reshape ; function ] #> [ reverse ; function ] #> [ rolling_max ; function ] #> [ rolling_mean ; function ] #> [ rolling_median ; function ] #> [ rolling_min ; function ] #> [ rolling_quantile ; function ] #> [ rolling_skew ; function ] #> [ rolling_std ; function ] #> [ rolling_sum ; function ] #> [ rolling_var ; function ] #> [ round ; function ] #> [ sample_frac ; function ] #> [ sample_n ; function ] #> [ search_sorted ; function ] #> [ shift ; function ] #> [ shift_and_fill ; function ] #> [ shrink_dtype ; function ] #> [ shuffle ; function ] #> [ sign ; function ] #> [ sin ; function ] #> [ sinh ; function ] #> [ skew ; function ] #> [ slice ; function ] #> [ sort ; function ] #> [ sort_by ; function ] #> [ std ; function ] #> [ str_base64_decode ; function ] #> [ str_base64_encode ; function ] #> [ str_concat ; function ] #> [ str_contains ; function ] #> [ str_count_match ; function ] #> [ str_ends_with ; function ] #> [ str_extract ; function ] #> [ str_extract_all ; function ] #> [ str_hex_decode ; function ] #> [ str_hex_encode ; function ] #> [ str_json_extract ; function ] #> [ str_json_path_match ; function ] #> [ str_lengths ; function ] #> [ str_ljust ; function ] #> [ str_lstrip ; function ] #> [ str_n_chars ; function ] #> [ str_parse_date ; function ] #> [ str_parse_datetime ; function ] #> [ str_parse_int ; function ] #> [ str_parse_time ; function ] #> [ str_replace ; function ] #> [ str_replace_all ; function ] #> [ str_rjust ; function ] #> [ str_rstrip ; function ] #> [ str_slice ; function ] #> [ str_split ; function ] #> [ str_split_exact ; function ] #> [ str_splitn ; function ] #> [ str_starts_with ; function ] #> [ str_strip ; function ] #> [ str_to_lowercase ; function ] #> [ str_to_uppercase ; function ] #> [ str_zfill ; function ] #> [ struct_field_by_name ; function ] #> [ struct_rename_fields ; function ] #> [ sub ; function ] #> [ suffix ; function ] #> [ sum ; function ] #> [ tail ; function ] #> [ take ; function ] #> [ take_every ; function ] #> [ tan ; function ] #> [ tanh ; function ] #> [ timestamp ; function ] #> [ to_physical ; function ] #> [ top_k ; function ] #> [ unique ; function ] #> [ unique_counts ; function ] #> [ unique_stable ; function ] #> [ upper_bound ; function ] #> [ value_counts ; function ] #> [ var ; function ] #> [ xor ; function ] #> #> [ GroupBy ; NULL ] #> #> LazyFrame ( environment ): #> [ collect ; function ] #> [ collect_background ; function ] #> [ describe_optimized_plan ; function ] #> [ describe_plan ; function ] #> [ filter ; function ] #> [ first ; function ] #> [ groupby ; function ] #> [ join ; function ] #> [ last ; function ] #> [ limit ; function ] #> [ max ; function ] #> [ mean ; function ] #> [ median ; function ] #> [ min ; function ] #> [ print ; function ] #> [ reverse ; function ] #> [ select ; function ] #> [ slice ; function ] #> [ std ; function ] #> [ sum ; function ] #> [ tail ; function ] #> [ var ; function ] #> [ with_column ; function ] #> [ with_columns ; function ] #> #> #> LazyGroupBy ( environment ): #> [ agg ; function ] #> [ head ; function ] #> [ print ; function ] #> [ tail ; function ] #> #> #> PolarsBackgroundHandle ( environment ): #> [ is_exhausted ; function ] #> [ join ; function ] #> [ new ; function ] #> #> #> ProtoExprArray ( environment ): #> [ new ; function ] #> [ print ; function ] #> [ push_back_rexpr ; function ] #> [ push_back_str ; function ] #> #> #> RField ( environment ): #> [ clone ; function ] #> [ get_datatype ; function ] #> [ get_name ; function ] #> [ new ; function ] #> [ print ; function ] #> [ set_datatype_mut ; function ] #> [ set_name_mut ; function ] #> #> #> RNullValues ( environment ): #> [ new_all_columns ; function ] #> [ new_columns ; function ] #> [ new_named ; function ] #> #> #> Series ( environment ): #> [ abs ; function ] #> [ add ; function ] #> [ alias ; function ] #> [ all ; function ] #> [ any ; function ] #> [ append_mut ; function ] #> [ apply ; function ] #> [ arg_max ; function ] #> [ arg_min ; function ] #> [ ceil ; function ] #> [ chunk_lengths ; function ] #> [ clone ; function ] #> [ compare ; function ] #> [ cumsum ; function ] #> [ div ; function ] #> [ dtype ; function ] #> [ floor ; function ] #> [ from_arrow ; function ] #> [ is_sorted ; function ] #> [ is_sorted_flag ; function ] #> [ is_sorted_reverse_flag ; function ] #> [ len ; function ] #> [ max ; function ] #> [ min ; function ] #> [ mul ; function ] #> [ name ; function ] #> [ new ; function ] #> [ panic ; function ] #> [ print ; function ] #> [ rem ; function ] #> [ rename_mut ; function ] #> [ rep ; function ] #> [ series_equal ; function ] #> [ set_sorted_mut ; function ] #> [ shape ; function ] #> [ sleep ; function ] #> [ sort_mut ; function ] #> [ sub ; function ] #> [ sum ; function ] #> [ to_frame ; function ] #> [ to_r ; function ] #> [ value_counts ; function ] #> #> #> VecDataFrame ( environment ): #> [ new ; function ] #> [ print ; function ] #> [ push ; function ] #> [ with_capacity ; function ] #> #> #> When ( environment ): #> [ print ; function ] #> [ then ; function ] #> [ when ; function ] #> #> #> WhenThen ( environment ): #> [ otherwise ; function ] #> [ print ; function ] #> [ when ; function ] #> #> #> WhenThenThen ( environment ): #> [ otherwise ; function ] #> [ print ; function ] #> [ then ; function ] #> [ when ; function ] #>","title":"Examples"},{"location":"reference/element/","text":"an element in 'eval'-expr Returns Expr Alias for an element in evaluated in an eval expression. Examples pl $ lit ( 1 : 5 ) $ cumulative_eval ( pl $ element ( ) $ first ( ) - pl $ element ( ) $ last ( ) ** 2 ) $ to_r ( ) #> [1] 0 -3 -8 -15 -24","title":"element"},{"location":"reference/element/#an-element-in-eval-expr","text":"","title":"an element in 'eval'-expr"},{"location":"reference/element/#returns","text":"Expr Alias for an element in evaluated in an eval expression.","title":"Returns"},{"location":"reference/element/#examples","text":"pl $ lit ( 1 : 5 ) $ cumulative_eval ( pl $ element ( ) $ first ( ) - pl $ element ( ) $ last ( ) ** 2 ) $ to_r ( ) #> [1] 0 -3 -8 -15 -24","title":"Examples"},{"location":"reference/extendr_method_to_pure_functions/","text":"extendr methods into pure functions extendr_method_to_pure_functions ( env ) Arguments env : environment object output from extendr-wrappers.R classes Returns env of pure function calls to rust self is a global of extendr wrapper methods this function copies the function into a new environment and modify formals to have a self argument","title":"extendr_method_to_pure_functions"},{"location":"reference/extendr_method_to_pure_functions/#extendr-methods-into-pure-functions","text":"extendr_method_to_pure_functions ( env )","title":"extendr methods into pure functions"},{"location":"reference/extendr_method_to_pure_functions/#arguments","text":"env : environment object output from extendr-wrappers.R classes","title":"Arguments"},{"location":"reference/extendr_method_to_pure_functions/#returns","text":"env of pure function calls to rust self is a global of extendr wrapper methods this function copies the function into a new environment and modify formals to have a self argument","title":"Returns"},{"location":"reference/extra_auto_completion/","text":"Extra polars auto completion Arguments activate : bool default TRUE, enable chained auto-completion Extra polars auto completion Details polars always supports auto completetion via .DollarNames. However chained methods like x$a()$b()$? are not supported vi .DollarNames. This feature experimental and not perfect. Any feedback is appreciated. Currently does not play that nice with Rstudio, as Rstudio backtick quotes any custom suggestions. Examples #auto completion via .DollarNames method e = pl $ lit ( 42 ) # to autocomplete pl$lit(42) save to variable # then write `e$` and press tab to see available methods # polars has experimental auto completetion for chain of methods if all on the same line pl $ extra_auto_completion ( ) #first activate feature (this will 'annoy' the Rstudio auto-completer) pl $ lit ( 42 ) $ lit_to_s ( ) # add a $ and press tab 1-3 times #> polars Series: shape: (1,) #> Series: 'literal' [f64] #> [ #> 42.0 #> ] pl $ extra_auto_completion ( activate = FALSE ) #deactivate","title":"extra_auto_completion"},{"location":"reference/extra_auto_completion/#extra-polars-auto-completion","text":"","title":"Extra polars auto completion"},{"location":"reference/extra_auto_completion/#arguments","text":"activate : bool default TRUE, enable chained auto-completion Extra polars auto completion","title":"Arguments"},{"location":"reference/extra_auto_completion/#details","text":"polars always supports auto completetion via .DollarNames. However chained methods like x$a()$b()$? are not supported vi .DollarNames. This feature experimental and not perfect. Any feedback is appreciated. Currently does not play that nice with Rstudio, as Rstudio backtick quotes any custom suggestions.","title":"Details"},{"location":"reference/extra_auto_completion/#examples","text":"#auto completion via .DollarNames method e = pl $ lit ( 42 ) # to autocomplete pl$lit(42) save to variable # then write `e$` and press tab to see available methods # polars has experimental auto completetion for chain of methods if all on the same line pl $ extra_auto_completion ( ) #first activate feature (this will 'annoy' the Rstudio auto-completer) pl $ lit ( 42 ) $ lit_to_s ( ) # add a $ and press tab 1-3 times #> polars Series: shape: (1,) #> Series: 'literal' [f64] #> [ #> 42.0 #> ] pl $ extra_auto_completion ( activate = FALSE ) #deactivate","title":"Examples"},{"location":"reference/filter-open-paren-close-paren/","text":"filter DataFrame DataFrame_filter ( bool_expr ) Arguments bool_expr : Polars expression which will evaluate to a bool pl$Series Returns filtered DataFrame DataFrame$filter(bool_expr) Examples pl $ DataFrame ( iris ) $ lazy ( ) $ filter ( pl $ col ( \"Sepal.Length\" ) > 5 ) $ collect ( ) #> polars DataFrame: shape: (118, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.4 \u2506 3.9 \u2506 1.7 \u2506 0.4 \u2506 setosa \u2502 #> \u2502 5.4 \u2506 3.7 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.8 \u2506 4.0 \u2506 1.2 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"filter-open-paren-close-paren"},{"location":"reference/filter-open-paren-close-paren/#filter-dataframe","text":"DataFrame_filter ( bool_expr )","title":"filter DataFrame"},{"location":"reference/filter-open-paren-close-paren/#arguments","text":"bool_expr : Polars expression which will evaluate to a bool pl$Series","title":"Arguments"},{"location":"reference/filter-open-paren-close-paren/#returns","text":"filtered DataFrame DataFrame$filter(bool_expr)","title":"Returns"},{"location":"reference/filter-open-paren-close-paren/#examples","text":"pl $ DataFrame ( iris ) $ lazy ( ) $ filter ( pl $ col ( \"Sepal.Length\" ) > 5 ) $ collect ( ) #> polars DataFrame: shape: (118, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.4 \u2506 3.9 \u2506 1.7 \u2506 0.4 \u2506 setosa \u2502 #> \u2502 5.4 \u2506 3.7 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 5.8 \u2506 4.0 \u2506 1.2 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/get_method_usages/","text":"Generate autocompletion suggestions for object get_method_usages ( env , pattern = \"\" ) Arguments env : environment to extract usages from pattern : string passed to ls(pattern) to subset methods by pattern Returns method usages Generate autocompletion suggestions for object Details used internally for auto completion in .DollarNames methods Examples polars ::: get_method_usages ( polars ::: DataFrame , pattern = \"col\" ) #> [1] \"columns\" \"columns<-\" \"get_column()\" \"get_columns()\" \"with_column()\" \"with_columns()\"","title":"get_method_usages"},{"location":"reference/get_method_usages/#generate-autocompletion-suggestions-for-object","text":"get_method_usages ( env , pattern = \"\" )","title":"Generate autocompletion suggestions for object"},{"location":"reference/get_method_usages/#arguments","text":"env : environment to extract usages from pattern : string passed to ls(pattern) to subset methods by pattern","title":"Arguments"},{"location":"reference/get_method_usages/#returns","text":"method usages Generate autocompletion suggestions for object","title":"Returns"},{"location":"reference/get_method_usages/#details","text":"used internally for auto completion in .DollarNames methods","title":"Details"},{"location":"reference/get_method_usages/#examples","text":"polars ::: get_method_usages ( polars ::: DataFrame , pattern = \"col\" ) #> [1] \"columns\" \"columns<-\" \"get_column()\" \"get_columns()\" \"with_column()\" \"with_columns()\"","title":"Examples"},{"location":"reference/is_DataFrame_data_input/","text":"Validate data input for create Dataframe with pl$DataFrame is_DataFrame_data_input ( x ) Arguments x : any R object to test if suitable as input to DataFrame Returns bool The Dataframe constructors accepts data.frame inheritors or list of vectors and/or Series. Examples polars ::: is_DataFrame_data_input ( iris ) #> [1] TRUE polars ::: is_DataFrame_data_input ( list ( 1 : 5 , pl $ Series ( 1 : 5 ) , letters [ 1 : 5 ] ) ) #> [1] TRUE","title":"is_DataFrame_data_input"},{"location":"reference/is_DataFrame_data_input/#validate-data-input-for-create-dataframe-with-pldataframe","text":"is_DataFrame_data_input ( x )","title":"Validate data input for create Dataframe with pl$DataFrame"},{"location":"reference/is_DataFrame_data_input/#arguments","text":"x : any R object to test if suitable as input to DataFrame","title":"Arguments"},{"location":"reference/is_DataFrame_data_input/#returns","text":"bool The Dataframe constructors accepts data.frame inheritors or list of vectors and/or Series.","title":"Returns"},{"location":"reference/is_DataFrame_data_input/#examples","text":"polars ::: is_DataFrame_data_input ( iris ) #> [1] TRUE polars ::: is_DataFrame_data_input ( list ( 1 : 5 , pl $ Series ( 1 : 5 ) , letters [ 1 : 5 ] ) ) #> [1] TRUE","title":"Examples"},{"location":"reference/is_err/","text":"check if x ss a result and an err is_err ( x ) Arguments x : R object which could be a rust-like result of a list with two elements, ok and err Returns bool if is a result object which is an err check if x ss a result and an err","title":"is_err"},{"location":"reference/is_err/#check-if-x-ss-a-result-and-an-err","text":"is_err ( x )","title":"check if x ss a result and an err"},{"location":"reference/is_err/#arguments","text":"x : R object which could be a rust-like result of a list with two elements, ok and err","title":"Arguments"},{"location":"reference/is_err/#returns","text":"bool if is a result object which is an err check if x ss a result and an err","title":"Returns"},{"location":"reference/is_ok/","text":"check if x ss a result and an ok is_ok ( x ) Arguments x : R object which could be a rust-like result of a list with two elements, ok and err Returns bool if is a result object which is an ok check if x ss a result and an ok","title":"is_ok"},{"location":"reference/is_ok/#check-if-x-ss-a-result-and-an-ok","text":"is_ok ( x )","title":"check if x ss a result and an ok"},{"location":"reference/is_ok/#arguments","text":"x : R object which could be a rust-like result of a list with two elements, ok and err","title":"Arguments"},{"location":"reference/is_ok/#returns","text":"bool if is a result object which is an ok check if x ss a result and an ok","title":"Returns"},{"location":"reference/is_polars_dtype/","text":"chek if x is a valid RPolarsDataType is_polars_dtype ( x , include_unknown = FALSE ) Arguments x : a candidate Returns a list DataType with an inner DataType chek if x is a valid RPolarsDataType Examples polars ::: is_polars_dtype ( pl $ Int64 ) #> [1] TRUE","title":"is_polars_dtype"},{"location":"reference/is_polars_dtype/#chek-if-x-is-a-valid-rpolarsdatatype","text":"is_polars_dtype ( x , include_unknown = FALSE )","title":"chek if x is a valid RPolarsDataType"},{"location":"reference/is_polars_dtype/#arguments","text":"x : a candidate","title":"Arguments"},{"location":"reference/is_polars_dtype/#returns","text":"a list DataType with an inner DataType chek if x is a valid RPolarsDataType","title":"Returns"},{"location":"reference/is_polars_dtype/#examples","text":"polars ::: is_polars_dtype ( pl $ Int64 ) #> [1] TRUE","title":"Examples"},{"location":"reference/is_result/","text":"check if z is a result is_result ( x ) Arguments x : R object which could be a rust-like result of a list with two elements, ok and err Returns bool if is a result object check if z is a result Details both ok and err being NULL encodes ok-value NULL. No way to encode an err-value NULL If both ok and err has value then this is an invalid result","title":"is_result"},{"location":"reference/is_result/#check-if-z-is-a-result","text":"is_result ( x )","title":"check if z is a result"},{"location":"reference/is_result/#arguments","text":"x : R object which could be a rust-like result of a list with two elements, ok and err","title":"Arguments"},{"location":"reference/is_result/#returns","text":"bool if is a result object check if z is a result","title":"Returns"},{"location":"reference/is_result/#details","text":"both ok and err being NULL encodes ok-value NULL. No way to encode an err-value NULL If both ok and err has value then this is an invalid result","title":"Details"},{"location":"reference/is_schema/","text":"check if schema Format function is_schema ( x ) Arguments x : objet to test if schema Returns bool check if schema Examples polars ::: is_schema ( pl $ DataFrame ( iris ) $ schema ) #> [1] TRUE pl $ is_schema ( pl $ DataFrame ( iris ) $ schema ) #> [1] TRUE polars ::: is_schema ( list ( \"alice\" , \"bob\" ) ) #> [1] FALSE","title":"is_schema"},{"location":"reference/is_schema/#check-if-schema","text":"","title":"check if schema"},{"location":"reference/is_schema/#format","text":"function is_schema ( x )","title":"Format"},{"location":"reference/is_schema/#arguments","text":"x : objet to test if schema","title":"Arguments"},{"location":"reference/is_schema/#returns","text":"bool check if schema","title":"Returns"},{"location":"reference/is_schema/#examples","text":"polars ::: is_schema ( pl $ DataFrame ( iris ) $ schema ) #> [1] TRUE pl $ is_schema ( pl $ DataFrame ( iris ) $ schema ) #> [1] TRUE polars ::: is_schema ( list ( \"alice\" , \"bob\" ) ) #> [1] FALSE","title":"Examples"},{"location":"reference/l_to_vdf/","text":"DataFrame-list to rust vector of DataFrame l_to_vdf ( l ) Arguments l : list of DataFrame Returns VecDataFrame lifecycle: DEPRECATE, imple on rust side as a function","title":"l_to_vdf"},{"location":"reference/l_to_vdf/#dataframe-list-to-rust-vector-of-dataframe","text":"l_to_vdf ( l )","title":"DataFrame-list to rust vector of DataFrame"},{"location":"reference/l_to_vdf/#arguments","text":"l : list of DataFrame","title":"Arguments"},{"location":"reference/l_to_vdf/#returns","text":"VecDataFrame lifecycle: DEPRECATE, imple on rust side as a function","title":"Returns"},{"location":"reference/lazy_csv_reader/","text":"new LazyFrame from csv lazy_csv_reader ( path , sep = \",\" , has_header = TRUE , ignore_errors = FALSE , skip_rows = 0 , n_rows = NULL , cache = FALSE , overwrite_dtype = NULL , low_memory = FALSE , comment_char = NULL , quote_char = \"\\\"\" , null_values = NULL , infer_schema_length = 100 , skip_rows_after_header = 0 , encoding = \"utf8\" , row_count_name = NULL , row_count_offset = 0 , parse_dates = FALSE ) csv_reader ( ... ) Arguments path : string, Path to a file sep : Single char to use as delimiter in the file. has_header : bool, indicate if the first row of dataset is a header or not. If set to False, column names will be autogenerated in the following format: column_x, with x being an enumeration over every column in the dataset starting at 1. ignore_errors : bool, try to keep reading lines if some lines yield errors. First try infer_schema_length=0 to read all columns as pl.Utf8 to check which values might cause an issue. skip_rows : integer, Start reading after skip_rows lines. The header will be parsed at this offset. n_rows : int (NULL is disable),Stop reading from CSV file after reading n_rows. cache : bool, cache the result after reading. overwrite_dtype : (NULL is disable) named list of dtypes OR dtype-names, where name points to a column. Can overwrite dtypes during inference. Supported types so far are: name | alias | polars side dtype \"Boolean\" | \"logical\" => DataType::Boolean, \"Float32\" | \"double\" => DataType::Float32, \"Float64\" | \"float64\" => DataType::Float64, \"Int32\" | \"integer\" => DataType::Int32, \"Int64\" | \"integer64\" => DataType::Int64, \"Utf8\" | \"character\" => DataType::Utf8, low_memory : bool, reduce memory usage in expense of performance comment_char : (NULL is disable) Single byte character that indicates the start of a comment line, for instance #. quote_char : (NULL is disable) Single byte character used for csv quoting, default = \". Set to None to turn off special handling and escaping of quotes. null_values : (NULL is disable) Values to interpret as null values. You can provide a String : All values equal to this string will be null. Unnamed char vector: A null value per column. Named char vector. A mapping from (names)column to a null value string(values). infer_schema_length : Maximum number of rows to read to infer the column types. If set to 0, all columns will be read as UTF-8. If NULL , a full table scan will be done (slow). skip_rows_after_header : bool Skip this number of rows when the header is parsed. encoding : either \"utf8\" or \"utf8-lossy\". Lossy means that invalid utf8 values are replaced with \"?\" characters. row_count_name : String(NULL is disable), name of a added row count column row_count_offset : integer, Offset to start the row_count column (only used if the name is set). parse_dates : bool Try to automatically parse dates. If this does not succeed, the column remains of data type pl.Utf8. ... : any argument passed to lazy_csv_reader Returns lazyframe DataFrame will scan the csv when collect(), not now Details Read a file from path into a polars lazy frame. Not yet supporting eol_char and with_column_names Examples my_file = tempfile ( ) write.csv ( iris , my_file ) lazy_frame = polars ::: lazy_csv_reader ( path = my_file ) lazy_frame $ collect ( ) #> polars DataFrame: shape: (150, 6) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2506 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 2 \u2506 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 3 \u2506 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4 \u2506 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 147 \u2506 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 148 \u2506 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 149 \u2506 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 150 \u2506 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 unlink ( my_file )","title":"lazy_csv_reader"},{"location":"reference/lazy_csv_reader/#new-lazyframe-from-csv","text":"lazy_csv_reader ( path , sep = \",\" , has_header = TRUE , ignore_errors = FALSE , skip_rows = 0 , n_rows = NULL , cache = FALSE , overwrite_dtype = NULL , low_memory = FALSE , comment_char = NULL , quote_char = \"\\\"\" , null_values = NULL , infer_schema_length = 100 , skip_rows_after_header = 0 , encoding = \"utf8\" , row_count_name = NULL , row_count_offset = 0 , parse_dates = FALSE ) csv_reader ( ... )","title":"new LazyFrame from csv"},{"location":"reference/lazy_csv_reader/#arguments","text":"path : string, Path to a file sep : Single char to use as delimiter in the file. has_header : bool, indicate if the first row of dataset is a header or not. If set to False, column names will be autogenerated in the following format: column_x, with x being an enumeration over every column in the dataset starting at 1. ignore_errors : bool, try to keep reading lines if some lines yield errors. First try infer_schema_length=0 to read all columns as pl.Utf8 to check which values might cause an issue. skip_rows : integer, Start reading after skip_rows lines. The header will be parsed at this offset. n_rows : int (NULL is disable),Stop reading from CSV file after reading n_rows. cache : bool, cache the result after reading. overwrite_dtype : (NULL is disable) named list of dtypes OR dtype-names, where name points to a column. Can overwrite dtypes during inference. Supported types so far are: name | alias | polars side dtype \"Boolean\" | \"logical\" => DataType::Boolean, \"Float32\" | \"double\" => DataType::Float32, \"Float64\" | \"float64\" => DataType::Float64, \"Int32\" | \"integer\" => DataType::Int32, \"Int64\" | \"integer64\" => DataType::Int64, \"Utf8\" | \"character\" => DataType::Utf8, low_memory : bool, reduce memory usage in expense of performance comment_char : (NULL is disable) Single byte character that indicates the start of a comment line, for instance #. quote_char : (NULL is disable) Single byte character used for csv quoting, default = \". Set to None to turn off special handling and escaping of quotes. null_values : (NULL is disable) Values to interpret as null values. You can provide a String : All values equal to this string will be null. Unnamed char vector: A null value per column. Named char vector. A mapping from (names)column to a null value string(values). infer_schema_length : Maximum number of rows to read to infer the column types. If set to 0, all columns will be read as UTF-8. If NULL , a full table scan will be done (slow). skip_rows_after_header : bool Skip this number of rows when the header is parsed. encoding : either \"utf8\" or \"utf8-lossy\". Lossy means that invalid utf8 values are replaced with \"?\" characters. row_count_name : String(NULL is disable), name of a added row count column row_count_offset : integer, Offset to start the row_count column (only used if the name is set). parse_dates : bool Try to automatically parse dates. If this does not succeed, the column remains of data type pl.Utf8. ... : any argument passed to lazy_csv_reader","title":"Arguments"},{"location":"reference/lazy_csv_reader/#returns","text":"lazyframe DataFrame will scan the csv when collect(), not now","title":"Returns"},{"location":"reference/lazy_csv_reader/#details","text":"Read a file from path into a polars lazy frame. Not yet supporting eol_char and with_column_names","title":"Details"},{"location":"reference/lazy_csv_reader/#examples","text":"my_file = tempfile ( ) write.csv ( iris , my_file ) lazy_frame = polars ::: lazy_csv_reader ( path = my_file ) lazy_frame $ collect ( ) #> polars DataFrame: shape: (150, 6) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2506 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 2 \u2506 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 3 \u2506 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4 \u2506 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 147 \u2506 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 148 \u2506 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 149 \u2506 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 150 \u2506 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 unlink ( my_file )","title":"Examples"},{"location":"reference/length.Series/","text":"Length of series ## S3 method for class 'Series' length ( x ) Arguments x : a Series Returns the length as a double Length of series","title":"length.Series"},{"location":"reference/length.Series/#length-of-series","text":"## S3 method for class 'Series' length ( x )","title":"Length of series"},{"location":"reference/length.Series/#arguments","text":"x : a Series","title":"Arguments"},{"location":"reference/length.Series/#returns","text":"the length as a double Length of series","title":"Returns"},{"location":"reference/macro_add_syntax_check_to/","text":"add syntax verification to class macro_add_syntax_check_to_class ( Class_name ) Arguments Class_name : string name of env class Returns dollarsign method with syntax verification add syntax verification to class Details this function overrides dollarclass method of a extendr env_class to run first verify_method_call() to check for syntax error and return more user friendly error if issues All R functions coined 'macro'-functions use eval(parse()) but only at package build time to solve some tricky self-referential problem. If possible to deprecate a macro in a clean way , go ahead. see zzz.R for usage examples See Also verify_method_call","title":"macro_add_syntax_check_to"},{"location":"reference/macro_add_syntax_check_to/#add-syntax-verification-to-class","text":"macro_add_syntax_check_to_class ( Class_name )","title":"add syntax verification to class"},{"location":"reference/macro_add_syntax_check_to/#arguments","text":"Class_name : string name of env class","title":"Arguments"},{"location":"reference/macro_add_syntax_check_to/#returns","text":"dollarsign method with syntax verification add syntax verification to class","title":"Returns"},{"location":"reference/macro_add_syntax_check_to/#details","text":"this function overrides dollarclass method of a extendr env_class to run first verify_method_call() to check for syntax error and return more user friendly error if issues All R functions coined 'macro'-functions use eval(parse()) but only at package build time to solve some tricky self-referential problem. If possible to deprecate a macro in a clean way , go ahead. see zzz.R for usage examples","title":"Details"},{"location":"reference/macro_add_syntax_check_to/#see-also","text":"verify_method_call","title":"See Also"},{"location":"reference/macro_new_subnamespace/","text":"Macro - New subnamespace macro_new_subnamespace ( class_pattern , subclass_env = NULL , remove_f = TRUE ) Arguments class_pattern : regex to select functions subclass_env : optional subclass of remove_f : drop sourced functions from package ns after bundling into sub ns Returns A function which returns a subclass environment of bundled class functions. Bundle class methods into an environment (subname space) Details This function is used to emulate py-polars subnamespace-methods All R functions coined 'macro_'-functions use eval(parse()) but only at package build time to solve some tricky self-referential problem. If possible to deprecate a macro in a clean way , go ahead. Examples #macro_new_subnamespace() is not exported, export for this toy example #macro_new_subnamespace = polars:::macro_new_subnamespace ##define some new methods prefixed 'MyClass_' #MyClass_add2 = function() self + 2 #MyClass_mul2 = function() self * 2 ##grab any sourced function prefixed 'MyClass_' #my_class_sub_ns = macro_new_subnamespace(\"^MyClass_\", \"myclass_sub_ns\") #here adding sub-namespace as a expr-class property/method during session-time, #which only is for this demo. #instead sourced method like Expr_arr() at package build time instead #env = polars:::Expr #get env of the Expr Class #env$my_sub_ns = method_as_property(function() { #add a property/method # my_class_sub_ns(self) #}) #rm(env) #optional clean up #add user defined S3 method the subclass 'myclass_sub_ns' #print.myclass_sub_ns = function(x, ...) { #add ... even if not used # print(\"hello world, I'm myclass_sub_ns\") # print(\"methods in sub namespace are:\") # print(ls(x)) # } #test # e = pl$lit(1:5) #make an Expr #print(e$my_sub_ns) #inspect #e$my_sub_ns$add2() #use the sub namespace #e$my_sub_ns$mul2()","title":"macro_new_subnamespace"},{"location":"reference/macro_new_subnamespace/#macro-new-subnamespace","text":"macro_new_subnamespace ( class_pattern , subclass_env = NULL , remove_f = TRUE )","title":"Macro - New subnamespace"},{"location":"reference/macro_new_subnamespace/#arguments","text":"class_pattern : regex to select functions subclass_env : optional subclass of remove_f : drop sourced functions from package ns after bundling into sub ns","title":"Arguments"},{"location":"reference/macro_new_subnamespace/#returns","text":"A function which returns a subclass environment of bundled class functions. Bundle class methods into an environment (subname space)","title":"Returns"},{"location":"reference/macro_new_subnamespace/#details","text":"This function is used to emulate py-polars subnamespace-methods All R functions coined 'macro_'-functions use eval(parse()) but only at package build time to solve some tricky self-referential problem. If possible to deprecate a macro in a clean way , go ahead.","title":"Details"},{"location":"reference/macro_new_subnamespace/#examples","text":"#macro_new_subnamespace() is not exported, export for this toy example #macro_new_subnamespace = polars:::macro_new_subnamespace ##define some new methods prefixed 'MyClass_' #MyClass_add2 = function() self + 2 #MyClass_mul2 = function() self * 2 ##grab any sourced function prefixed 'MyClass_' #my_class_sub_ns = macro_new_subnamespace(\"^MyClass_\", \"myclass_sub_ns\") #here adding sub-namespace as a expr-class property/method during session-time, #which only is for this demo. #instead sourced method like Expr_arr() at package build time instead #env = polars:::Expr #get env of the Expr Class #env$my_sub_ns = method_as_property(function() { #add a property/method # my_class_sub_ns(self) #}) #rm(env) #optional clean up #add user defined S3 method the subclass 'myclass_sub_ns' #print.myclass_sub_ns = function(x, ...) { #add ... even if not used # print(\"hello world, I'm myclass_sub_ns\") # print(\"methods in sub namespace are:\") # print(ls(x)) # } #test # e = pl$lit(1:5) #make an Expr #print(e$my_sub_ns) #inspect #e$my_sub_ns$add2() #use the sub namespace #e$my_sub_ns$mul2()","title":"Examples"},{"location":"reference/map/","text":"map an Err part of Result map ( x , f ) Arguments x : any R object f : a closure that takes the ok part as input Returns same R object wrapped in a Err-result map an Err part of Result","title":"map"},{"location":"reference/map/#map-an-err-part-of-result","text":"map ( x , f )","title":"map an Err part of Result"},{"location":"reference/map/#arguments","text":"x : any R object f : a closure that takes the ok part as input","title":"Arguments"},{"location":"reference/map/#returns","text":"same R object wrapped in a Err-result map an Err part of Result","title":"Returns"},{"location":"reference/map_err/","text":"map an Err part of Result map_err ( x , f ) Arguments x : any R object f : a closure that takes the err part as input Returns same R object wrapped in a Err-result map an Err part of Result","title":"map_err"},{"location":"reference/map_err/#map-an-err-part-of-result","text":"map_err ( x , f )","title":"map an Err part of Result"},{"location":"reference/map_err/#arguments","text":"x : any R object f : a closure that takes the err part as input","title":"Arguments"},{"location":"reference/map_err/#returns","text":"same R object wrapped in a Err-result map an Err part of Result","title":"Returns"},{"location":"reference/max/","text":"max across expressions / literals / Series Arguments ... : is a: If one arg: Series or Expr, same as column$sum() string, same as pl$col(column)$sum() numeric, same as pl$lit(column)$sum() list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ... If several args, then wrapped in a list and handled as above. Returns Expr Folds the expressions from left to right, keeping the first non-null value. Examples df = pl $ DataFrame ( a = NA_real_ , b = c ( 1 : 2 , NA_real_ , NA_real_ ) , c = c ( 1 : 3 , NA_real_ ) ) #use coalesce to get first non Null value for each row, otherwise insert 99.9 df $ with_column ( pl $ coalesce ( \"a\" , \"b\" , \"c\" , 99.9 ) $ alias ( \"d\" ) ) #> polars DataFrame: shape: (4, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 d \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2506 1.0 \u2506 1.0 \u2506 1.0 \u2502 #> \u2502 null \u2506 2.0 \u2506 2.0 \u2506 2.0 \u2502 #> \u2502 null \u2506 null \u2506 3.0 \u2506 3.0 \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 99.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"max"},{"location":"reference/max/#max-across-expressions-literals-series","text":"","title":"max across expressions / literals / Series"},{"location":"reference/max/#arguments","text":"... : is a: If one arg: Series or Expr, same as column$sum() string, same as pl$col(column)$sum() numeric, same as pl$lit(column)$sum() list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ... If several args, then wrapped in a list and handled as above.","title":"Arguments"},{"location":"reference/max/#returns","text":"Expr Folds the expressions from left to right, keeping the first non-null value.","title":"Returns"},{"location":"reference/max/#examples","text":"df = pl $ DataFrame ( a = NA_real_ , b = c ( 1 : 2 , NA_real_ , NA_real_ ) , c = c ( 1 : 3 , NA_real_ ) ) #use coalesce to get first non Null value for each row, otherwise insert 99.9 df $ with_column ( pl $ coalesce ( \"a\" , \"b\" , \"c\" , 99.9 ) $ alias ( \"d\" ) ) #> polars DataFrame: shape: (4, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 d \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2506 1.0 \u2506 1.0 \u2506 1.0 \u2502 #> \u2502 null \u2506 2.0 \u2506 2.0 \u2506 2.0 \u2502 #> \u2502 null \u2506 null \u2506 3.0 \u2506 3.0 \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 99.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/mem_address/","text":"Get Memory Address Arguments robj : an R object Returns String of mem address mimics pl$mem_address Examples pl $ mem_address ( pl $ Series ( 1 : 3 ) ) #> [1] \"0x3e7ca130580\"","title":"mem_address"},{"location":"reference/mem_address/#get-memory-address","text":"","title":"Get Memory Address"},{"location":"reference/mem_address/#arguments","text":"robj : an R object","title":"Arguments"},{"location":"reference/mem_address/#returns","text":"String of mem address mimics pl$mem_address","title":"Returns"},{"location":"reference/mem_address/#examples","text":"pl $ mem_address ( pl $ Series ( 1 : 3 ) ) #> [1] \"0x3e7ca130580\"","title":"Examples"},{"location":"reference/method_as_property/","text":"Give a class method property behavior method_as_property ( f , setter = FALSE ) Arguments f : a function setter : bool, if true a property method can be modified by user Returns function subclassed into c(\"property\",\"function\") or c(\"setter\",\"property\",\"function\") Internal function, see use in source","title":"method_as_property"},{"location":"reference/method_as_property/#give-a-class-method-property-behavior","text":"method_as_property ( f , setter = FALSE )","title":"Give a class method property behavior"},{"location":"reference/method_as_property/#arguments","text":"f : a function setter : bool, if true a property method can be modified by user","title":"Arguments"},{"location":"reference/method_as_property/#returns","text":"function subclassed into c(\"property\",\"function\") or c(\"setter\",\"property\",\"function\") Internal function, see use in source","title":"Returns"},{"location":"reference/min/","text":"min across expressions / literals / Series Arguments ... : is a: If one arg: Series or Expr, same as column$sum() string, same as pl$col(column)$sum() numeric, same as pl$lit(column)$sum() list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ... If several args, then wrapped in a list and handled as above. Returns Expr Folds the expressions from left to right, keeping the first non-null value. Examples df = pl $ DataFrame ( a = NA_real_ , b = c ( 2 : 1 , NA_real_ , NA_real_ ) , c = c ( 1 : 3 , NA_real_ ) , d = c ( 1 : 2 , NA_real_ , - Inf ) ) #use min to get first non Null value for each row, otherwise insert 99.9 df $ with_column ( pl $ min ( \"a\" , \"b\" , \"c\" , 99.9 ) $ alias ( \"d\" ) ) #> polars DataFrame: shape: (4, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 d \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2506 2.0 \u2506 1.0 \u2506 1.0 \u2502 #> \u2502 null \u2506 1.0 \u2506 2.0 \u2506 1.0 \u2502 #> \u2502 null \u2506 null \u2506 3.0 \u2506 3.0 \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 99.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"min"},{"location":"reference/min/#min-across-expressions-literals-series","text":"","title":"min across expressions / literals / Series"},{"location":"reference/min/#arguments","text":"... : is a: If one arg: Series or Expr, same as column$sum() string, same as pl$col(column)$sum() numeric, same as pl$lit(column)$sum() list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ... If several args, then wrapped in a list and handled as above.","title":"Arguments"},{"location":"reference/min/#returns","text":"Expr Folds the expressions from left to right, keeping the first non-null value.","title":"Returns"},{"location":"reference/min/#examples","text":"df = pl $ DataFrame ( a = NA_real_ , b = c ( 2 : 1 , NA_real_ , NA_real_ ) , c = c ( 1 : 3 , NA_real_ ) , d = c ( 1 : 2 , NA_real_ , - Inf ) ) #use min to get first non Null value for each row, otherwise insert 99.9 df $ with_column ( pl $ min ( \"a\" , \"b\" , \"c\" , 99.9 ) $ alias ( \"d\" ) ) #> polars DataFrame: shape: (4, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 d \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 null \u2506 2.0 \u2506 1.0 \u2506 1.0 \u2502 #> \u2502 null \u2506 1.0 \u2506 2.0 \u2506 1.0 \u2502 #> \u2502 null \u2506 null \u2506 3.0 \u2506 3.0 \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 99.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/move_env_elements/","text":"Move environment elements from one env to another move_env_elements ( from_env , to_env , element_names , remove = TRUE ) Arguments from_env : env from to_env : env to element_names : names of elements to move, if named names, then name of name is to_env name remove : bool, actually remove element in from_env Move environment elements from one env to another","title":"move_env_elements"},{"location":"reference/move_env_elements/#move-environment-elements-from-one-env-to-another","text":"move_env_elements ( from_env , to_env , element_names , remove = TRUE )","title":"Move environment elements from one env to another"},{"location":"reference/move_env_elements/#arguments","text":"from_env : env from to_env : env to element_names : names of elements to move, if named names, then name of name is to_env name remove : bool, actually remove element in from_env Move environment elements from one env to another","title":"Arguments"},{"location":"reference/nanoarrow/","text":"polars to nanoarrow and arrow as_nanoarrow_array_stream.DataFrame ( x , ... , schema = NULL ) infer_nanoarrow_schema.DataFrame ( x , ... ) as_arrow_table.DataFrame ( x , ... ) as_record_batch_reader.DataFrame ( x , ... , schema = NULL ) Arguments x : a polars DataFrame ... : not used right now schema : must stay at default value NULL Returns a nanoarrow array stream a nanoarrow array schema an arrow table an arrow record batch reader Conversion via native apache arrow array stream (fast), THIS REQUIRES \u00b4nanoarrow\u00b4 Details The following functions enable conversion to nanoarrow and arrow . Conversion kindly provided by \"paleolimbot / Dewey Dunnington\" Author of nanoarrow . Currently these conversions are the fastest way to convert from polars to R. Examples library ( nanoarrow ) df = pl $ DataFrame ( mtcars ) nanoarrow_array_stream = as_nanoarrow_array_stream ( df ) rdf = as.data.frame ( nanoarrow_array_stream ) print ( head ( rdf ) ) #> mpg cyl disp hp drat wt qsec vs am gear carb #> 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 #> 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 #> 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 #> 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 #> 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 #> 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 nanoarrow_array_schema = infer_nanoarrow_schema ( df ) print ( nanoarrow_array_schema ) #> <nanoarrow_schema struct> #> $ format : chr \"+s\" #> $ name : chr \"\" #> $ metadata : list() #> $ flags : int 0 #> $ children :List of 11 #> ..$ mpg :<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"mpg\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ cyl :<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"cyl\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ disp:<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"disp\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ hp :<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"hp\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ drat:<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"drat\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ wt :<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"wt\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ qsec:<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"qsec\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ vs :<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"vs\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ am :<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"am\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ gear:<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"gear\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ carb:<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"carb\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> $ dictionary: NULL library ( arrow ) #> #> Attaching package: \u2018arrow\u2019 #> The following object is masked from \u2018package:testthat\u2019: #> #> matches #> The following object is masked from \u2018package:magrittr\u2019: #> #> is_in #> The following object is masked from \u2018package:utils\u2019: #> #> timestamp arrow_table = as_arrow_table ( df ) print ( arrow_table ) #> Table #> 32 rows x 11 columns #> $mpg <double> #> $cyl <double> #> $disp <double> #> $hp <double> #> $drat <double> #> $wt <double> #> $qsec <double> #> $vs <double> #> $am <double> #> $gear <double> #> $carb <double> arrow_record_batch_reader = as_record_batch_reader ( df ) #requires arrow print ( arrow_record_batch_reader ) #> RecordBatchReader #> mpg: double #> cyl: double #> disp: double #> hp: double #> drat: double #> wt: double #> qsec: double #> vs: double #> am: double #> gear: double #> carb: double","title":"nanoarrow"},{"location":"reference/nanoarrow/#polars-to-nanoarrow-and-arrow","text":"as_nanoarrow_array_stream.DataFrame ( x , ... , schema = NULL ) infer_nanoarrow_schema.DataFrame ( x , ... ) as_arrow_table.DataFrame ( x , ... ) as_record_batch_reader.DataFrame ( x , ... , schema = NULL )","title":"polars to nanoarrow and arrow"},{"location":"reference/nanoarrow/#arguments","text":"x : a polars DataFrame ... : not used right now schema : must stay at default value NULL","title":"Arguments"},{"location":"reference/nanoarrow/#returns","text":"a nanoarrow array stream a nanoarrow array schema an arrow table an arrow record batch reader Conversion via native apache arrow array stream (fast), THIS REQUIRES \u00b4nanoarrow\u00b4","title":"Returns"},{"location":"reference/nanoarrow/#details","text":"The following functions enable conversion to nanoarrow and arrow . Conversion kindly provided by \"paleolimbot / Dewey Dunnington\" Author of nanoarrow . Currently these conversions are the fastest way to convert from polars to R.","title":"Details"},{"location":"reference/nanoarrow/#examples","text":"library ( nanoarrow ) df = pl $ DataFrame ( mtcars ) nanoarrow_array_stream = as_nanoarrow_array_stream ( df ) rdf = as.data.frame ( nanoarrow_array_stream ) print ( head ( rdf ) ) #> mpg cyl disp hp drat wt qsec vs am gear carb #> 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 #> 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 #> 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 #> 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 #> 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 #> 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 nanoarrow_array_schema = infer_nanoarrow_schema ( df ) print ( nanoarrow_array_schema ) #> <nanoarrow_schema struct> #> $ format : chr \"+s\" #> $ name : chr \"\" #> $ metadata : list() #> $ flags : int 0 #> $ children :List of 11 #> ..$ mpg :<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"mpg\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ cyl :<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"cyl\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ disp:<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"disp\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ hp :<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"hp\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ drat:<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"drat\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ wt :<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"wt\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ qsec:<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"qsec\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ vs :<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"vs\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ am :<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"am\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ gear:<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"gear\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> ..$ carb:<nanoarrow_schema double> #> .. ..$ format : chr \"g\" #> .. ..$ name : chr \"carb\" #> .. ..$ metadata : list() #> .. ..$ flags : int 2 #> .. ..$ children : list() #> .. ..$ dictionary: NULL #> $ dictionary: NULL library ( arrow ) #> #> Attaching package: \u2018arrow\u2019 #> The following object is masked from \u2018package:testthat\u2019: #> #> matches #> The following object is masked from \u2018package:magrittr\u2019: #> #> is_in #> The following object is masked from \u2018package:utils\u2019: #> #> timestamp arrow_table = as_arrow_table ( df ) print ( arrow_table ) #> Table #> 32 rows x 11 columns #> $mpg <double> #> $cyl <double> #> $disp <double> #> $hp <double> #> $drat <double> #> $wt <double> #> $qsec <double> #> $vs <double> #> $am <double> #> $gear <double> #> $carb <double> arrow_record_batch_reader = as_record_batch_reader ( df ) #requires arrow print ( arrow_record_batch_reader ) #> RecordBatchReader #> mpg: double #> cyl: double #> disp: double #> hp: double #> drat: double #> wt: double #> qsec: double #> vs: double #> am: double #> gear: double #> carb: double","title":"Examples"},{"location":"reference/ncol.DataFrame/","text":"The Number of Columns of a DataFrame ncol.DataFrame ( x ) Arguments x : DataFrame Returns Integer The Number of Columns of a DataFrame","title":"ncol.DataFrame"},{"location":"reference/ncol.DataFrame/#the-number-of-columns-of-a-dataframe","text":"ncol.DataFrame ( x )","title":"The Number of Columns of a DataFrame"},{"location":"reference/ncol.DataFrame/#arguments","text":"x : DataFrame","title":"Arguments"},{"location":"reference/ncol.DataFrame/#returns","text":"Integer The Number of Columns of a DataFrame","title":"Returns"},{"location":"reference/ncol.LazyFrame/","text":"The Number of Columns of a LazyFrame ncol.LazyFrame ( x ) Arguments x : LazyFrame Returns Integer The Number of Columns of a LazyFrame","title":"ncol.LazyFrame"},{"location":"reference/ncol.LazyFrame/#the-number-of-columns-of-a-lazyframe","text":"ncol.LazyFrame ( x )","title":"The Number of Columns of a LazyFrame"},{"location":"reference/ncol.LazyFrame/#arguments","text":"x : LazyFrame","title":"Arguments"},{"location":"reference/ncol.LazyFrame/#returns","text":"Integer The Number of Columns of a LazyFrame","title":"Returns"},{"location":"reference/nrow.DataFrame/","text":"The Number of Rows of a DataFrame nrow.DataFrame ( x ) Arguments x : DataFrame Returns Integer The Number of Rows of a DataFrame","title":"nrow.DataFrame"},{"location":"reference/nrow.DataFrame/#the-number-of-rows-of-a-dataframe","text":"nrow.DataFrame ( x )","title":"The Number of Rows of a DataFrame"},{"location":"reference/nrow.DataFrame/#arguments","text":"x : DataFrame","title":"Arguments"},{"location":"reference/nrow.DataFrame/#returns","text":"Integer The Number of Rows of a DataFrame","title":"Returns"},{"location":"reference/nrow.LazyFrame/","text":"The Number of Rows of a LazyFrame nrow.LazyFrame ( x ) Arguments x : LazyFrame Returns Integer The Number of Rows of a LazyFrame","title":"nrow.LazyFrame"},{"location":"reference/nrow.LazyFrame/#the-number-of-rows-of-a-lazyframe","text":"nrow.LazyFrame ( x )","title":"The Number of Rows of a LazyFrame"},{"location":"reference/nrow.LazyFrame/#arguments","text":"x : LazyFrame","title":"Arguments"},{"location":"reference/nrow.LazyFrame/#returns","text":"Integer The Number of Rows of a LazyFrame","title":"Returns"},{"location":"reference/object/","text":"data Any polars class object is made of this Format An object of class character of length 1. object One SEXP of Rtype: \"externalptr\" + a class attribute Details object$method() calls are facilitated by a $.ClassName - s3method see 'R/after-wrappers.R' Code completion is facilitted by .DollarNames.ClassName -s3method see e.g. 'R/dataframe__frame.R' Implementation of property-methods as DataFrame_columns() and syntax checking is an extension to $.ClassName See function macro_add_syntax_check_to_class(). Examples #all a polars object is made of: some_polars_object = pl $ DataFrame ( iris ) str ( some_polars_object ) #External Pointer tagged with a class attribute. #> Class 'DataFrame' <externalptr>","title":"object"},{"location":"reference/object/#any-polars-class-object-is-made-of-this","text":"","title":"Any polars class object is made of this"},{"location":"reference/object/#format","text":"An object of class character of length 1. object One SEXP of Rtype: \"externalptr\" + a class attribute","title":"Format"},{"location":"reference/object/#details","text":"object$method() calls are facilitated by a $.ClassName - s3method see 'R/after-wrappers.R' Code completion is facilitted by .DollarNames.ClassName -s3method see e.g. 'R/dataframe__frame.R' Implementation of property-methods as DataFrame_columns() and syntax checking is an extension to $.ClassName See function macro_add_syntax_check_to_class().","title":"Details"},{"location":"reference/object/#examples","text":"#all a polars object is made of: some_polars_object = pl $ DataFrame ( iris ) str ( some_polars_object ) #External Pointer tagged with a class attribute. #> Class 'DataFrame' <externalptr>","title":"Examples"},{"location":"reference/or_else/","text":"map an Err part of Result or_else ( x , f ) Arguments x : any R object f : a closure that takes the ok part as input, must return a result itself Returns same R object wrapped in a Err-result map an Err part of Result","title":"or_else"},{"location":"reference/or_else/#map-an-err-part-of-result","text":"or_else ( x , f )","title":"map an Err part of Result"},{"location":"reference/or_else/#arguments","text":"x : any R object f : a closure that takes the ok part as input, must return a result itself","title":"Arguments"},{"location":"reference/or_else/#returns","text":"same R object wrapped in a Err-result map an Err part of Result","title":"Returns"},{"location":"reference/pcase/","text":"Simple SQL CASE WHEN implementation for R pcase ( ... , or_else = NULL ) Arguments ... : odd arugments are bool statements, a next even argument is returned if prior bool statement is the first true or_else : return this if no bool statements were true Returns any return given first true bool statement otherwise value of or_else Inspired by data.table::fcase + dplyr::case_when. Used instead of base::switch internally. Details Lifecycle: perhaps replace with something written in rust to speed up a bit Examples n = 7 polars ::: pcase ( n < 5 , \"nope\" , n > 6 , \"yeah\" , or_else = stopf ( \"failed to have a case for n=%s\" , n ) ) #> [1] \"yeah\"","title":"pcase"},{"location":"reference/pcase/#simple-sql-case-when-implementation-for-r","text":"pcase ( ... , or_else = NULL )","title":"Simple SQL CASE WHEN implementation for R"},{"location":"reference/pcase/#arguments","text":"... : odd arugments are bool statements, a next even argument is returned if prior bool statement is the first true or_else : return this if no bool statements were true","title":"Arguments"},{"location":"reference/pcase/#returns","text":"any return given first true bool statement otherwise value of or_else Inspired by data.table::fcase + dplyr::case_when. Used instead of base::switch internally.","title":"Returns"},{"location":"reference/pcase/#details","text":"Lifecycle: perhaps replace with something written in rust to speed up a bit","title":"Details"},{"location":"reference/pcase/#examples","text":"n = 7 polars ::: pcase ( n < 5 , \"nope\" , n > 6 , \"yeah\" , or_else = stopf ( \"failed to have a case for n=%s\" , n ) ) #> [1] \"yeah\"","title":"Examples"},{"location":"reference/pl-cash-from_arrow/","text":"pl$from_arrow Arguments data : arrow Table or Array or ChunkedArray rechunk : bool rewrite in one array per column, Implemented for ChunkedArray Array is already contiguous. Not implemented for Table. C schema : named list of DataTypes or char vec of names. Same length as arrow table. If schema names or types do not match arrow table, the columns will be renamed/recasted. NULL default is to import columns as is. Takes no effect for Array or ChunkedArray schema_overrides : named list of DataTypes. Name some columns to recast by the DataType. Takes not effect for Array or ChunkedArray Returns DataFrame or Series import Arrow Table or Array Examples pl $ from_arrow ( data = arrow :: arrow_table ( iris ) , schema_overrides = list ( Sepal.Length = pl $ Float32 , Species = pl $ Utf8 ) ) #> polars DataFrame: shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f32 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 char_schema = names ( iris ) char_schema [ 1 ] = \"Alice\" pl $ from_arrow ( data = arrow :: arrow_table ( iris ) , schema = char_schema ) #> polars DataFrame: shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Alice \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"pl-cash-from_arrow"},{"location":"reference/pl-cash-from_arrow/#plfrom_arrow","text":"","title":"pl$from_arrow"},{"location":"reference/pl-cash-from_arrow/#arguments","text":"data : arrow Table or Array or ChunkedArray rechunk : bool rewrite in one array per column, Implemented for ChunkedArray Array is already contiguous. Not implemented for Table. C schema : named list of DataTypes or char vec of names. Same length as arrow table. If schema names or types do not match arrow table, the columns will be renamed/recasted. NULL default is to import columns as is. Takes no effect for Array or ChunkedArray schema_overrides : named list of DataTypes. Name some columns to recast by the DataType. Takes not effect for Array or ChunkedArray","title":"Arguments"},{"location":"reference/pl-cash-from_arrow/#returns","text":"DataFrame or Series import Arrow Table or Array","title":"Returns"},{"location":"reference/pl-cash-from_arrow/#examples","text":"pl $ from_arrow ( data = arrow :: arrow_table ( iris ) , schema_overrides = list ( Sepal.Length = pl $ Float32 , Species = pl $ Utf8 ) ) #> polars DataFrame: shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f32 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 char_schema = names ( iris ) char_schema [ 1 ] = \"Alice\" pl $ from_arrow ( data = arrow :: arrow_table ( iris ) , schema = char_schema ) #> polars DataFrame: shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Alice \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/pl_Datetime/","text":"Create Datetime DataType Format function Arguments tu : string option either \"ms\", \"us\" or \"ns\" tz : string the Time Zone, see details Returns Datetime DataType Datetime DataType constructor Details all allowed TimeZone designations can be found in base::OlsonNames() Examples pl $ Datetime ( \"ns\" , \"Pacific/Samoa\" ) #> DataType: Datetime( #> Nanoseconds, #> Some( #> \"Pacific/Samoa\", #> ), #> )","title":"Datetime"},{"location":"reference/pl_Datetime/#create-datetime-datatype","text":"","title":"Create Datetime DataType"},{"location":"reference/pl_Datetime/#format","text":"function","title":"Format"},{"location":"reference/pl_Datetime/#arguments","text":"tu : string option either \"ms\", \"us\" or \"ns\" tz : string the Time Zone, see details","title":"Arguments"},{"location":"reference/pl_Datetime/#returns","text":"Datetime DataType Datetime DataType constructor","title":"Returns"},{"location":"reference/pl_Datetime/#details","text":"all allowed TimeZone designations can be found in base::OlsonNames()","title":"Details"},{"location":"reference/pl_Datetime/#examples","text":"pl $ Datetime ( \"ns\" , \"Pacific/Samoa\" ) #> DataType: Datetime( #> Nanoseconds, #> Some( #> \"Pacific/Samoa\", #> ), #> )","title":"Examples"},{"location":"reference/pl_Field/","text":"Create Field Arguments name : string name datatype : DataType Returns a list DataType with an inner DataType Create Field Details A Field is not a DataType but a name + DataType Fields are used in Structs-datatypes and Schemas to represent everything of the Series/Column except the raw values. Examples #make a struct pl $ Field ( \"city_names\" , pl $ Utf8 ) #> Field { #> name: \"city_names\", #> dtype: Utf8, #> } # find any DataType bundled pl$dtypes print ( pl $ dtypes ) #> $Boolean #> DataType: Boolean #> #> $UInt8 #> DataType: UInt8 #> #> $UInt16 #> DataType: UInt16 #> #> $UInt32 #> DataType: UInt32 #> #> $UInt64 #> DataType: UInt64 #> #> $Int8 #> DataType: Int8 #> #> $Int16 #> DataType: Int16 #> #> $Int32 #> DataType: Int32 #> #> $Int64 #> DataType: Int64 #> #> $Float32 #> DataType: Float32 #> #> $Float64 #> DataType: Float64 #> #> $Utf8 #> DataType: Utf8 #> #> $Binary #> DataType: Binary #> #> $Date #> DataType: Date #> #> $Time #> DataType: Time #> #> $Null #> DataType: Null #> #> $Categorical #> DataType: Categorical( #> None, #> ) #> #> $Unknown #> DataType: Unknown #> #> $Datetime #> function(tu=\"us\", tz = NULL) { #> if (!is.null(tz) && (!is_string(tz) || !tz %in% base::OlsonNames())) { #> stopf(\"Datetime: the tz '%s' is not a valid timezone string, see base::OlsonNames()\",tz) #> } #> unwrap(.pr$DataType$new_datetime(tu,tz)) #> } #> <environment: namespace:polars> #> #> $List #> function(datatype) { #> if(is.character(datatype) && length(datatype)==1 ) { #> datatype = .pr$DataType$new(datatype) #> } #> if(!inherits(datatype,\"RPolarsDataType\")) { #> stopf(paste( #> \"input for generating a list DataType must be another DataType\", #> \"or an interpretable name thereof.\" #> )) #> } #> .pr$DataType$new_list(datatype) #> } #> <environment: namespace:polars> #> #> $Struct #> function(...) { #> result({ #> largs = list2(...) #> if (is.list(largs[[1]])) { #> largs = largs[[1]] #> element_name = \"list element\" #> } else { #> element_name = \"positional argument\" #> } #> mapply( #> names(largs) %||% character(length(largs)), #> largs, #> seq_along(largs), #> FUN = \\(name, arg, i) { #> if(inherits(arg,\"RPolarsDataType\")) return(pl$Field(name, arg)) #> if(inherits(arg,\"RField\")) return(arg) #> stopf( #> \"%s [%s] {name:'%s', value:%s} must either be a Field (pl$Field) or a named %s\", #> element_name, i, name, arg,\"DataType see (pl$dtypes), see examples for pl$Struct()\" #> ) #> },SIMPLIFY = FALSE #> ) #> }) |> #> and_then(DataType$new_struct) |> #> unwrap(\"in pl$Struct:\") #> } #> <bytecode: 0x00000185e0364468> #> <environment: namespace:polars> #>","title":"Field"},{"location":"reference/pl_Field/#create-field","text":"","title":"Create Field"},{"location":"reference/pl_Field/#arguments","text":"name : string name datatype : DataType","title":"Arguments"},{"location":"reference/pl_Field/#returns","text":"a list DataType with an inner DataType Create Field","title":"Returns"},{"location":"reference/pl_Field/#details","text":"A Field is not a DataType but a name + DataType Fields are used in Structs-datatypes and Schemas to represent everything of the Series/Column except the raw values.","title":"Details"},{"location":"reference/pl_Field/#examples","text":"#make a struct pl $ Field ( \"city_names\" , pl $ Utf8 ) #> Field { #> name: \"city_names\", #> dtype: Utf8, #> } # find any DataType bundled pl$dtypes print ( pl $ dtypes ) #> $Boolean #> DataType: Boolean #> #> $UInt8 #> DataType: UInt8 #> #> $UInt16 #> DataType: UInt16 #> #> $UInt32 #> DataType: UInt32 #> #> $UInt64 #> DataType: UInt64 #> #> $Int8 #> DataType: Int8 #> #> $Int16 #> DataType: Int16 #> #> $Int32 #> DataType: Int32 #> #> $Int64 #> DataType: Int64 #> #> $Float32 #> DataType: Float32 #> #> $Float64 #> DataType: Float64 #> #> $Utf8 #> DataType: Utf8 #> #> $Binary #> DataType: Binary #> #> $Date #> DataType: Date #> #> $Time #> DataType: Time #> #> $Null #> DataType: Null #> #> $Categorical #> DataType: Categorical( #> None, #> ) #> #> $Unknown #> DataType: Unknown #> #> $Datetime #> function(tu=\"us\", tz = NULL) { #> if (!is.null(tz) && (!is_string(tz) || !tz %in% base::OlsonNames())) { #> stopf(\"Datetime: the tz '%s' is not a valid timezone string, see base::OlsonNames()\",tz) #> } #> unwrap(.pr$DataType$new_datetime(tu,tz)) #> } #> <environment: namespace:polars> #> #> $List #> function(datatype) { #> if(is.character(datatype) && length(datatype)==1 ) { #> datatype = .pr$DataType$new(datatype) #> } #> if(!inherits(datatype,\"RPolarsDataType\")) { #> stopf(paste( #> \"input for generating a list DataType must be another DataType\", #> \"or an interpretable name thereof.\" #> )) #> } #> .pr$DataType$new_list(datatype) #> } #> <environment: namespace:polars> #> #> $Struct #> function(...) { #> result({ #> largs = list2(...) #> if (is.list(largs[[1]])) { #> largs = largs[[1]] #> element_name = \"list element\" #> } else { #> element_name = \"positional argument\" #> } #> mapply( #> names(largs) %||% character(length(largs)), #> largs, #> seq_along(largs), #> FUN = \\(name, arg, i) { #> if(inherits(arg,\"RPolarsDataType\")) return(pl$Field(name, arg)) #> if(inherits(arg,\"RField\")) return(arg) #> stopf( #> \"%s [%s] {name:'%s', value:%s} must either be a Field (pl$Field) or a named %s\", #> element_name, i, name, arg,\"DataType see (pl$dtypes), see examples for pl$Struct()\" #> ) #> },SIMPLIFY = FALSE #> ) #> }) |> #> and_then(DataType$new_struct) |> #> unwrap(\"in pl$Struct:\") #> } #> <bytecode: 0x00000185e0364468> #> <environment: namespace:polars> #>","title":"Examples"},{"location":"reference/pl_List/","text":"Create List DataType Format function Arguments datatype : an inner DataType Returns a list DataType with an inner DataType Create List DataType Examples pl $ List ( pl $ List ( pl $ Boolean ) ) #> DataType: List( #> List( #> Boolean, #> ), #> )","title":"List"},{"location":"reference/pl_List/#create-list-datatype","text":"","title":"Create List DataType"},{"location":"reference/pl_List/#format","text":"function","title":"Format"},{"location":"reference/pl_List/#arguments","text":"datatype : an inner DataType","title":"Arguments"},{"location":"reference/pl_List/#returns","text":"a list DataType with an inner DataType Create List DataType","title":"Returns"},{"location":"reference/pl_List/#examples","text":"pl $ List ( pl $ List ( pl $ Boolean ) ) #> DataType: List( #> List( #> Boolean, #> ), #> )","title":"Examples"},{"location":"reference/pl_PTime/","text":"Store Time in R Arguments x : an integer or double vector of n epochs since midnight OR a char vector of char times passed to as.POSIXct converted to seconds. tu : timeunit either \"s\",\"ms\",\"us\",\"ns\" fmt : a format string passed to as.POSIXct format via ... Returns a PTime vector either double or integer, with class \"PTime\" and attribute \"tu\" being either \"s\",\"ms\",\"us\" or \"ns\" Store Time in R Details PTime should probably be replaced with package nanotime or similar. base R is missing encoding of Time since midnight \"s\" \"ms\", \"us\" and \"ns\". The latter \"ns\" is the standard for the polars Time type. Use PTime to convert R doubles and integers and use as input to polars functions which needs a time. Loosely inspired by data.table::ITime which is i32 only. PTime must support polars native timeunit is nanoseconds. The R double(float64) can imitate a i64 ns with full precision within the full range of 24 hours. PTime does not have a time zone and always prints the time as is no matter local machine time zone. An essential difference between R and polars is R prints POSIXct/lt without a timezone in local time. Polars prints Datetime without a timezone label as is (GMT). For POSIXct/lt taged with a timexone(tzone) and Datetime with a timezone(tz) the behavior is the same conversion is intuitive. It appears behavior of R timezones is subject to change a bit in R 4.3.0, see polars unit test test-expr_datetime.R/\"pl$date_range Date lazy/eager\". Examples #make PTime in all time units pl $ PTime ( runif ( 5 ) * 3600 * 24 * 1E0 , tu = \"s\" ) #> PTime [ double ]: number of epochs [ s ] since midnight #> [1] \"15:33:05 val: 55985\" \"00:01:10 val: 70\" \"20:05:31 val: 72331\" \"04:48:10 val: 17290\" \"04:54:24 val: 17664\" pl $ PTime ( runif ( 5 ) * 3600 * 24 * 1E3 , tu = \"ms\" ) #> PTime [ double ]: number of epochs [ ms ] since midnight #> [1] \"02:05:17:738ms val: 7517738\" \"11:28:33:197ms val: 41313197\" \"10:25:47:991ms val: 37547991\" #> [4] \"17:49:40:318ms val: 64180318\" \"17:25:24:491ms val: 62724491\" pl $ PTime ( runif ( 5 ) * 3600 * 24 * 1E6 , tu = \"us\" ) #> PTime [ double ]: number of epochs [ us ] since midnight #> [1] \"17:33:31:997_227us val: 63211997227\" \"18:47:28:183_022us val: 67648183022\" \"11:43:51:610_804us val: 42231610804\" #> [4] \"20:24:44:574_399us val: 73484574399\" \"01:39:31:990_983us val: 5971990983\" pl $ PTime ( runif ( 5 ) * 3600 * 24 * 1E9 , tu = \"ns\" ) #> PTime [ double ]: number of epochs [ ns ] since midnight #> [1] \"19:39:54:338_377_565ns val: 70794338377565\" \"21:04:11:798_473_298ns val: 75851798473298\" #> [3] \"16:14:51:179_843_991ns val: 58491179843991\" \"18:35:02:355_766_296ns val: 66902355766296\" #> [5] \"12:48:53:771_131_932ns val: 46133771131932\" pl $ PTime ( \"23:59:59\" ) #> PTime [ double ]: number of epochs [ s ] since midnight #> [1] \"23:59:59 val: 86399\" pl $ Series ( pl $ PTime ( runif ( 5 ) * 3600 * 24 * 1E0 , tu = \"s\" ) ) #> polars Series: shape: (5,) #> Series: '' [time] #> [ #> 18:11:19 #> 08:16:05 #> 23:30:04 #> 13:07:38 #> 09:21:58 #> ] pl $ lit ( pl $ PTime ( \"23:59:59\" ) ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: '' [time] #> [ #> 23:59:59 #> ] pl $ lit ( pl $ PTime ( \"23:59:59\" ) ) $ to_r ( ) #> PTime [ double ]: number of epochs [ ns ] since midnight #> [1] \"23:59:59:000_000_000ns val: 8.6399e+13\"","title":"PTime"},{"location":"reference/pl_PTime/#store-time-in-r","text":"","title":"Store Time in R"},{"location":"reference/pl_PTime/#arguments","text":"x : an integer or double vector of n epochs since midnight OR a char vector of char times passed to as.POSIXct converted to seconds. tu : timeunit either \"s\",\"ms\",\"us\",\"ns\" fmt : a format string passed to as.POSIXct format via ...","title":"Arguments"},{"location":"reference/pl_PTime/#returns","text":"a PTime vector either double or integer, with class \"PTime\" and attribute \"tu\" being either \"s\",\"ms\",\"us\" or \"ns\" Store Time in R","title":"Returns"},{"location":"reference/pl_PTime/#details","text":"PTime should probably be replaced with package nanotime or similar. base R is missing encoding of Time since midnight \"s\" \"ms\", \"us\" and \"ns\". The latter \"ns\" is the standard for the polars Time type. Use PTime to convert R doubles and integers and use as input to polars functions which needs a time. Loosely inspired by data.table::ITime which is i32 only. PTime must support polars native timeunit is nanoseconds. The R double(float64) can imitate a i64 ns with full precision within the full range of 24 hours. PTime does not have a time zone and always prints the time as is no matter local machine time zone. An essential difference between R and polars is R prints POSIXct/lt without a timezone in local time. Polars prints Datetime without a timezone label as is (GMT). For POSIXct/lt taged with a timexone(tzone) and Datetime with a timezone(tz) the behavior is the same conversion is intuitive. It appears behavior of R timezones is subject to change a bit in R 4.3.0, see polars unit test test-expr_datetime.R/\"pl$date_range Date lazy/eager\".","title":"Details"},{"location":"reference/pl_PTime/#examples","text":"#make PTime in all time units pl $ PTime ( runif ( 5 ) * 3600 * 24 * 1E0 , tu = \"s\" ) #> PTime [ double ]: number of epochs [ s ] since midnight #> [1] \"15:33:05 val: 55985\" \"00:01:10 val: 70\" \"20:05:31 val: 72331\" \"04:48:10 val: 17290\" \"04:54:24 val: 17664\" pl $ PTime ( runif ( 5 ) * 3600 * 24 * 1E3 , tu = \"ms\" ) #> PTime [ double ]: number of epochs [ ms ] since midnight #> [1] \"02:05:17:738ms val: 7517738\" \"11:28:33:197ms val: 41313197\" \"10:25:47:991ms val: 37547991\" #> [4] \"17:49:40:318ms val: 64180318\" \"17:25:24:491ms val: 62724491\" pl $ PTime ( runif ( 5 ) * 3600 * 24 * 1E6 , tu = \"us\" ) #> PTime [ double ]: number of epochs [ us ] since midnight #> [1] \"17:33:31:997_227us val: 63211997227\" \"18:47:28:183_022us val: 67648183022\" \"11:43:51:610_804us val: 42231610804\" #> [4] \"20:24:44:574_399us val: 73484574399\" \"01:39:31:990_983us val: 5971990983\" pl $ PTime ( runif ( 5 ) * 3600 * 24 * 1E9 , tu = \"ns\" ) #> PTime [ double ]: number of epochs [ ns ] since midnight #> [1] \"19:39:54:338_377_565ns val: 70794338377565\" \"21:04:11:798_473_298ns val: 75851798473298\" #> [3] \"16:14:51:179_843_991ns val: 58491179843991\" \"18:35:02:355_766_296ns val: 66902355766296\" #> [5] \"12:48:53:771_131_932ns val: 46133771131932\" pl $ PTime ( \"23:59:59\" ) #> PTime [ double ]: number of epochs [ s ] since midnight #> [1] \"23:59:59 val: 86399\" pl $ Series ( pl $ PTime ( runif ( 5 ) * 3600 * 24 * 1E0 , tu = \"s\" ) ) #> polars Series: shape: (5,) #> Series: '' [time] #> [ #> 18:11:19 #> 08:16:05 #> 23:30:04 #> 13:07:38 #> 09:21:58 #> ] pl $ lit ( pl $ PTime ( \"23:59:59\" ) ) $ lit_to_s ( ) #> polars Series: shape: (1,) #> Series: '' [time] #> [ #> 23:59:59 #> ] pl $ lit ( pl $ PTime ( \"23:59:59\" ) ) $ to_r ( ) #> PTime [ double ]: number of epochs [ ns ] since midnight #> [1] \"23:59:59:000_000_000ns val: 8.6399e+13\"","title":"Examples"},{"location":"reference/pl_Struct/","text":"Create Struct DataType Format function Arguments datatype : an inner DataType Returns a list DataType with an inner DataType Struct DataType Constructor Examples # create a Struct-DataType pl $ List ( pl $ List ( pl $ Boolean ) ) #> DataType: List( #> List( #> Boolean, #> ), #> ) # Find any DataType via pl$dtypes print ( pl $ dtypes ) #> $Boolean #> DataType: Boolean #> #> $UInt8 #> DataType: UInt8 #> #> $UInt16 #> DataType: UInt16 #> #> $UInt32 #> DataType: UInt32 #> #> $UInt64 #> DataType: UInt64 #> #> $Int8 #> DataType: Int8 #> #> $Int16 #> DataType: Int16 #> #> $Int32 #> DataType: Int32 #> #> $Int64 #> DataType: Int64 #> #> $Float32 #> DataType: Float32 #> #> $Float64 #> DataType: Float64 #> #> $Utf8 #> DataType: Utf8 #> #> $Binary #> DataType: Binary #> #> $Date #> DataType: Date #> #> $Time #> DataType: Time #> #> $Null #> DataType: Null #> #> $Categorical #> DataType: Categorical( #> None, #> ) #> #> $Unknown #> DataType: Unknown #> #> $Datetime #> function(tu=\"us\", tz = NULL) { #> if (!is.null(tz) && (!is_string(tz) || !tz %in% base::OlsonNames())) { #> stopf(\"Datetime: the tz '%s' is not a valid timezone string, see base::OlsonNames()\",tz) #> } #> unwrap(.pr$DataType$new_datetime(tu,tz)) #> } #> <environment: namespace:polars> #> #> $List #> function(datatype) { #> if(is.character(datatype) && length(datatype)==1 ) { #> datatype = .pr$DataType$new(datatype) #> } #> if(!inherits(datatype,\"RPolarsDataType\")) { #> stopf(paste( #> \"input for generating a list DataType must be another DataType\", #> \"or an interpretable name thereof.\" #> )) #> } #> .pr$DataType$new_list(datatype) #> } #> <environment: namespace:polars> #> #> $Struct #> function(...) { #> result({ #> largs = list2(...) #> if (is.list(largs[[1]])) { #> largs = largs[[1]] #> element_name = \"list element\" #> } else { #> element_name = \"positional argument\" #> } #> mapply( #> names(largs) %||% character(length(largs)), #> largs, #> seq_along(largs), #> FUN = \\(name, arg, i) { #> if(inherits(arg,\"RPolarsDataType\")) return(pl$Field(name, arg)) #> if(inherits(arg,\"RField\")) return(arg) #> stopf( #> \"%s [%s] {name:'%s', value:%s} must either be a Field (pl$Field) or a named %s\", #> element_name, i, name, arg,\"DataType see (pl$dtypes), see examples for pl$Struct()\" #> ) #> },SIMPLIFY = FALSE #> ) #> }) |> #> and_then(DataType$new_struct) |> #> unwrap(\"in pl$Struct:\") #> } #> <bytecode: 0x00000185e0364468> #> <environment: namespace:polars> #>","title":"Struct"},{"location":"reference/pl_Struct/#create-struct-datatype","text":"","title":"Create Struct DataType"},{"location":"reference/pl_Struct/#format","text":"function","title":"Format"},{"location":"reference/pl_Struct/#arguments","text":"datatype : an inner DataType","title":"Arguments"},{"location":"reference/pl_Struct/#returns","text":"a list DataType with an inner DataType Struct DataType Constructor","title":"Returns"},{"location":"reference/pl_Struct/#examples","text":"# create a Struct-DataType pl $ List ( pl $ List ( pl $ Boolean ) ) #> DataType: List( #> List( #> Boolean, #> ), #> ) # Find any DataType via pl$dtypes print ( pl $ dtypes ) #> $Boolean #> DataType: Boolean #> #> $UInt8 #> DataType: UInt8 #> #> $UInt16 #> DataType: UInt16 #> #> $UInt32 #> DataType: UInt32 #> #> $UInt64 #> DataType: UInt64 #> #> $Int8 #> DataType: Int8 #> #> $Int16 #> DataType: Int16 #> #> $Int32 #> DataType: Int32 #> #> $Int64 #> DataType: Int64 #> #> $Float32 #> DataType: Float32 #> #> $Float64 #> DataType: Float64 #> #> $Utf8 #> DataType: Utf8 #> #> $Binary #> DataType: Binary #> #> $Date #> DataType: Date #> #> $Time #> DataType: Time #> #> $Null #> DataType: Null #> #> $Categorical #> DataType: Categorical( #> None, #> ) #> #> $Unknown #> DataType: Unknown #> #> $Datetime #> function(tu=\"us\", tz = NULL) { #> if (!is.null(tz) && (!is_string(tz) || !tz %in% base::OlsonNames())) { #> stopf(\"Datetime: the tz '%s' is not a valid timezone string, see base::OlsonNames()\",tz) #> } #> unwrap(.pr$DataType$new_datetime(tu,tz)) #> } #> <environment: namespace:polars> #> #> $List #> function(datatype) { #> if(is.character(datatype) && length(datatype)==1 ) { #> datatype = .pr$DataType$new(datatype) #> } #> if(!inherits(datatype,\"RPolarsDataType\")) { #> stopf(paste( #> \"input for generating a list DataType must be another DataType\", #> \"or an interpretable name thereof.\" #> )) #> } #> .pr$DataType$new_list(datatype) #> } #> <environment: namespace:polars> #> #> $Struct #> function(...) { #> result({ #> largs = list2(...) #> if (is.list(largs[[1]])) { #> largs = largs[[1]] #> element_name = \"list element\" #> } else { #> element_name = \"positional argument\" #> } #> mapply( #> names(largs) %||% character(length(largs)), #> largs, #> seq_along(largs), #> FUN = \\(name, arg, i) { #> if(inherits(arg,\"RPolarsDataType\")) return(pl$Field(name, arg)) #> if(inherits(arg,\"RField\")) return(arg) #> stopf( #> \"%s [%s] {name:'%s', value:%s} must either be a Field (pl$Field) or a named %s\", #> element_name, i, name, arg,\"DataType see (pl$dtypes), see examples for pl$Struct()\" #> ) #> },SIMPLIFY = FALSE #> ) #> }) |> #> and_then(DataType$new_struct) |> #> unwrap(\"in pl$Struct:\") #> } #> <bytecode: 0x00000185e0364468> #> <environment: namespace:polars> #>","title":"Examples"},{"location":"reference/pl_class/","text":"data The complete polars public API. Format An object of class environment of length 57. pl pl -object is a environment of all public functions and class constructors. Public functions are not exported as a normal package as it would be huge namespace collision with base:: and other functions. All object-methods are accessed with object$method() via the new class functions. Having all functions in an namespace is similar to the rust- and python- polars api. Details If someone do not particularly like the letter combination pl , they are free to bind the environment to another variable name as simon_says = pl or even do attach(pl) Examples #how to use polars via `pl` pl $ col ( \"colname\" ) $ sum ( ) / pl $ lit ( 42L ) #expression ~ chain-method / literal-expression #> polars Expr: [(col(\"colname\").sum()) / (42i32)] #pl inventory polars ::: print_env ( pl , \"polars public functions\" ) #> #> #> polars public functions ( environment ): #> [ all ; function ] #> [ Binary ; RPolarsDataType ] #> [ Boolean ; RPolarsDataType ] #> [ Categorical ; RPolarsDataType ] #> [ coalesce ; function ] #> [ col ; function ] #> [ concat ; function ] #> [ concat_list ; function ] #> [ csv_reader ; function ] #> [ DataFrame ; function ] #> [ Date ; RPolarsDataType ] #> [ date_range ; function ] #> [ Datetime ; function ] #> #> dtypes ( list ): #> [ Binary ; RPolarsDataType ] #> [ Boolean ; RPolarsDataType ] #> [ Categorical ; RPolarsDataType ] #> [ Date ; RPolarsDataType ] #> [ Datetime ; function ] #> [ Float32 ; RPolarsDataType ] #> [ Float64 ; RPolarsDataType ] #> [ Int16 ; RPolarsDataType ] #> [ Int32 ; RPolarsDataType ] #> [ Int64 ; RPolarsDataType ] #> [ Int8 ; RPolarsDataType ] #> [ List ; function ] #> [ Null ; RPolarsDataType ] #> [ Struct ; function ] #> [ Time ; RPolarsDataType ] #> [ UInt16 ; RPolarsDataType ] #> [ UInt32 ; RPolarsDataType ] #> [ UInt64 ; RPolarsDataType ] #> [ UInt8 ; RPolarsDataType ] #> [ Unknown ; RPolarsDataType ] #> [ Utf8 ; RPolarsDataType ] #> #> [ element ; function ] #> [ expr_to_r ; function ] #> [ extra_auto_completion ; function ] #> [ Field ; function ] #> [ Float32 ; RPolarsDataType ] #> [ Float64 ; RPolarsDataType ] #> [ from_arrow ; function ] #> [ get_polars_opt_requirements ; function ] #> [ get_polars_options ; function ] #> [ Int16 ; RPolarsDataType ] #> [ Int32 ; RPolarsDataType ] #> [ Int64 ; RPolarsDataType ] #> [ Int8 ; RPolarsDataType ] #> [ is_schema ; function ] #> [ lazy_csv_reader ; function ] #> [ List ; function ] #> [ lit ; function ] #> [ max ; function ] #> [ mem_address ; function ] #> [ min ; function ] #> [ Null ; RPolarsDataType ] #> #> numeric_dtypes ( list ): #> [ Float32 ; RPolarsDataType ] #> [ Float64 ; RPolarsDataType ] #> [ Int16 ; RPolarsDataType ] #> [ Int32 ; RPolarsDataType ] #> [ Int64 ; RPolarsDataType ] #> [ Int8 ; RPolarsDataType ] #> #> [ PTime ; function ] #> [ read_csv ; function ] #> [ reset_polars_options ; function ] #> [ same_outer_dt ; function ] #> [ scan_arrow_ipc ; function ] #> [ select ; function ] #> [ Series ; function ] #> [ set_polars_options ; function ] #> [ std ; function ] #> [ struct ; function ] #> [ Struct ; function ] #> [ sum ; function ] #> [ Time ; RPolarsDataType ] #> [ UInt16 ; RPolarsDataType ] #> [ UInt32 ; RPolarsDataType ] #> [ UInt64 ; RPolarsDataType ] #> [ UInt8 ; RPolarsDataType ] #> [ Unknown ; RPolarsDataType ] #> [ Utf8 ; RPolarsDataType ] #> [ var ; function ] #> [ when ; function ] #all accessible classes and their public methods polars ::: print_env ( polars ::: pl_pub_class_env , \"polars public class methods, access via object$method()\" ) #> #> #> polars public class methods, access via object$method() ( environment ): #> #> DataFrame ( environment ): #> [ as_data_frame ; function ] #> [ clone ; function ] #> [ columns ; setter property function ] #> [ dtypes ; property function ] #> [ estimated_size ; function ] #> [ filter ; function ] #> [ first ; function ] #> [ get_column ; function ] #> [ get_columns ; function ] #> [ groupby ; function ] #> [ height ; property function ] #> [ join ; function ] #> [ last ; function ] #> [ lazy ; function ] #> [ limit ; function ] #> [ max ; function ] #> [ mean ; function ] #> [ median ; function ] #> [ min ; function ] #> [ null_count ; function ] #> [ print ; function ] #> [ reverse ; function ] #> [ schema ; property function ] #> [ select ; function ] #> [ shape ; property function ] #> [ slice ; function ] #> [ std ; function ] #> [ sum ; function ] #> [ tail ; function ] #> [ to_list ; function ] #> [ to_series ; function ] #> [ to_struct ; function ] #> [ unnest ; function ] #> [ var ; function ] #> [ width ; property function ] #> [ with_column ; function ] #> [ with_columns ; function ] #> #> #> DataType ( environment ): #> [ eq ; function ] #> [ get_all_simple_type_names ; function ] #> [ get_insides ; function ] #> [ is_temporal ; function ] #> [ ne ; function ] #> [ new ; function ] #> [ new_datetime ; function ] #> [ new_duration ; function ] #> [ new_list ; function ] #> [ new_object ; function ] #> [ new_struct ; function ] #> [ print ; function ] #> [ same_outer_datatype ; function ] #> #> #> Expr ( environment ): #> [ abs ; function ] #> [ add ; function ] #> [ agg_groups ; function ] #> [ alias ; function ] #> [ all ; function ] #> [ and ; function ] #> [ any ; function ] #> [ append ; function ] #> [ apply ; function ] #> [ arccos ; function ] #> [ arccosh ; function ] #> [ arcsin ; function ] #> [ arcsinh ; function ] #> [ arctan ; function ] #> [ arctanh ; function ] #> [ arg_max ; function ] #> [ arg_min ; function ] #> [ arg_sort ; function ] #> [ arg_unique ; function ] #> [ argsort ; function ] #> [ arr ; property function ] #> [ backward_fill ; function ] #> [ bin ; property function ] #> [ cast ; function ] #> [ cat ; property function ] #> [ ceil ; function ] #> [ clip ; function ] #> [ clip_max ; function ] #> [ clip_min ; function ] #> [ cos ; function ] #> [ cosh ; function ] #> [ count ; function ] #> [ cumcount ; function ] #> [ cummax ; function ] #> [ cummin ; function ] #> [ cumprod ; function ] #> [ cumsum ; function ] #> [ cumulative_eval ; function ] #> [ diff ; function ] #> [ div ; function ] #> [ dot ; function ] #> [ drop_nans ; function ] #> [ drop_nulls ; function ] #> [ dt ; property function ] #> [ entropy ; function ] #> [ eq ; function ] #> [ ewm_mean ; function ] #> [ ewm_std ; function ] #> [ ewm_var ; function ] #> [ exclude ; function ] #> [ exp ; function ] #> [ explode ; function ] #> [ extend_constant ; function ] #> [ extend_expr ; function ] #> [ fill_nan ; function ] #> [ fill_null ; function ] #> [ filter ; function ] #> [ first ; function ] #> [ flatten ; function ] #> [ floor ; function ] #> [ forward_fill ; function ] #> [ gt ; function ] #> [ gt_eq ; function ] #> [ hash ; function ] #> [ head ; function ] #> [ inspect ; function ] #> [ interpolate ; function ] #> [ is_between ; function ] #> [ is_duplicated ; function ] #> [ is_finite ; function ] #> [ is_first ; function ] #> [ is_in ; function ] #> [ is_infinite ; function ] #> [ is_nan ; function ] #> [ is_not ; function ] #> [ is_not_nan ; function ] #> [ is_not_null ; function ] #> [ is_null ; function ] #> [ is_unique ; function ] #> [ keep_name ; function ] #> [ kurtosis ; function ] #> [ last ; function ] #> [ len ; function ] #> [ limit ; function ] #> [ list ; function ] #> [ lit ; function ] #> [ lit_to_df ; function ] #> [ lit_to_s ; function ] #> [ log ; function ] #> [ log10 ; function ] #> [ lower_bound ; function ] #> [ lt ; function ] #> [ lt_eq ; function ] #> [ map ; function ] #> [ map_alias ; function ] #> [ max ; function ] #> [ mean ; function ] #> [ median ; function ] #> [ meta ; property function ] #> [ min ; function ] #> [ mode ; function ] #> [ mul ; function ] #> [ n_unique ; function ] #> [ nan_max ; function ] #> [ nan_min ; function ] #> [ neq ; function ] #> [ null_count ; function ] #> [ or ; function ] #> [ over ; function ] #> [ pct_change ; function ] #> [ pow ; function ] #> [ prefix ; function ] #> [ print ; function ] #> [ product ; function ] #> [ quantile ; function ] #> [ rank ; function ] #> [ rechunk ; function ] #> [ reinterpret ; function ] #> [ rep ; function ] #> [ rep_extend ; function ] #> [ repeat_by ; function ] #> [ reshape ; function ] #> [ reverse ; function ] #> [ rolling_max ; function ] #> [ rolling_mean ; function ] #> [ rolling_median ; function ] #> [ rolling_min ; function ] #> [ rolling_quantile ; function ] #> [ rolling_skew ; function ] #> [ rolling_std ; function ] #> [ rolling_sum ; function ] #> [ rolling_var ; function ] #> [ round ; function ] #> [ rpow ; function ] #> [ sample ; function ] #> [ search_sorted ; function ] #> [ set_sorted ; function ] #> [ shift ; function ] #> [ shift_and_fill ; function ] #> [ shrink_dtype ; function ] #> [ shuffle ; function ] #> [ sign ; function ] #> [ sin ; function ] #> [ sinh ; function ] #> [ skew ; function ] #> [ slice ; function ] #> [ sort ; function ] #> [ sort_by ; function ] #> [ sqrt ; function ] #> [ std ; function ] #> [ str ; property function ] #> [ struct ; property function ] #> [ sub ; function ] #> [ suffix ; function ] #> [ sum ; function ] #> [ tail ; function ] #> [ take ; function ] #> [ take_every ; function ] #> [ tan ; function ] #> [ tanh ; function ] #> [ to_physical ; function ] #> [ to_r ; function ] #> [ to_struct ; function ] #> [ top_k ; function ] #> [ unique ; function ] #> [ unique_counts ; function ] #> [ upper_bound ; function ] #> [ value_counts ; function ] #> [ var ; function ] #> [ where ; function ] #> [ xor ; function ] #> #> #> LazyFrame ( environment ): #> [ collect ; function ] #> [ collect_background ; function ] #> [ describe_optimized_plan ; function ] #> [ describe_plan ; function ] #> [ filter ; function ] #> [ first ; function ] #> [ groupby ; function ] #> [ join ; function ] #> [ last ; function ] #> [ limit ; function ] #> [ max ; function ] #> [ mean ; function ] #> [ median ; function ] #> [ min ; function ] #> [ print ; function ] #> [ reverse ; function ] #> [ select ; function ] #> [ slice ; function ] #> [ std ; function ] #> [ sum ; function ] #> [ tail ; function ] #> [ var ; function ] #> [ with_column ; function ] #> [ with_columns ; function ] #> #> #> LazyGroupBy ( environment ): #> [ agg ; function ] #> [ apply ; function ] #> [ head ; function ] #> [ print ; function ] #> [ tail ; function ] #> #> #> PolarsBackgroundHandle ( environment ): #> [ is_exhausted ; function ] #> [ join ; function ] #> #> #> Series ( environment ): #> [ abs ; function ] #> [ add ; function ] #> [ alias ; function ] #> [ all ; function ] #> [ any ; function ] #> [ append ; function ] #> [ apply ; function ] #> [ arg_max ; function ] #> [ arg_min ; function ] #> [ arr ; property function ] #> [ ceil ; function ] #> [ chunk_lengths ; function ] #> [ clone ; function ] #> [ compare ; function ] #> [ cumsum ; function ] #> [ div ; function ] #> [ dtype ; property function ] #> [ expr ; property function ] #> [ flags ; property function ] #> [ floor ; function ] #> [ is_numeric ; function ] #> [ is_sorted ; function ] #> [ len ; function ] #> [ max ; function ] #> [ min ; function ] #> [ mul ; function ] #> [ name ; property function ] #> [ print ; function ] #> [ rem ; function ] #> [ rename ; function ] #> [ rep ; function ] #> [ series_equal ; function ] #> [ set_sorted ; function ] #> [ shape ; property function ] #> [ sort ; function ] #> [ std ; function ] #> [ sub ; function ] #> [ sum ; function ] #> [ to_frame ; function ] #> [ to_lit ; function ] #> [ to_r ; function ] #> [ to_r_list ; function ] #> [ to_r_vector ; function ] #> [ value_counts ; function ] #> [ var ; function ] #> #> #> When ( environment ): #> [ then ; function ] #> #> #> WhenThen ( environment ): #> [ otherwise ; function ] #> [ when ; function ] #> #> #> WhenThenThen ( environment ): #> [ otherwise ; function ] #> [ peak_inside ; function ] #> [ then ; function ] #> [ when ; function ] #>","title":"Pl class"},{"location":"reference/pl_class/#the-complete-polars-public-api","text":"","title":"The complete polars public API."},{"location":"reference/pl_class/#format","text":"An object of class environment of length 57. pl pl -object is a environment of all public functions and class constructors. Public functions are not exported as a normal package as it would be huge namespace collision with base:: and other functions. All object-methods are accessed with object$method() via the new class functions. Having all functions in an namespace is similar to the rust- and python- polars api.","title":"Format"},{"location":"reference/pl_class/#details","text":"If someone do not particularly like the letter combination pl , they are free to bind the environment to another variable name as simon_says = pl or even do attach(pl)","title":"Details"},{"location":"reference/pl_class/#examples","text":"#how to use polars via `pl` pl $ col ( \"colname\" ) $ sum ( ) / pl $ lit ( 42L ) #expression ~ chain-method / literal-expression #> polars Expr: [(col(\"colname\").sum()) / (42i32)] #pl inventory polars ::: print_env ( pl , \"polars public functions\" ) #> #> #> polars public functions ( environment ): #> [ all ; function ] #> [ Binary ; RPolarsDataType ] #> [ Boolean ; RPolarsDataType ] #> [ Categorical ; RPolarsDataType ] #> [ coalesce ; function ] #> [ col ; function ] #> [ concat ; function ] #> [ concat_list ; function ] #> [ csv_reader ; function ] #> [ DataFrame ; function ] #> [ Date ; RPolarsDataType ] #> [ date_range ; function ] #> [ Datetime ; function ] #> #> dtypes ( list ): #> [ Binary ; RPolarsDataType ] #> [ Boolean ; RPolarsDataType ] #> [ Categorical ; RPolarsDataType ] #> [ Date ; RPolarsDataType ] #> [ Datetime ; function ] #> [ Float32 ; RPolarsDataType ] #> [ Float64 ; RPolarsDataType ] #> [ Int16 ; RPolarsDataType ] #> [ Int32 ; RPolarsDataType ] #> [ Int64 ; RPolarsDataType ] #> [ Int8 ; RPolarsDataType ] #> [ List ; function ] #> [ Null ; RPolarsDataType ] #> [ Struct ; function ] #> [ Time ; RPolarsDataType ] #> [ UInt16 ; RPolarsDataType ] #> [ UInt32 ; RPolarsDataType ] #> [ UInt64 ; RPolarsDataType ] #> [ UInt8 ; RPolarsDataType ] #> [ Unknown ; RPolarsDataType ] #> [ Utf8 ; RPolarsDataType ] #> #> [ element ; function ] #> [ expr_to_r ; function ] #> [ extra_auto_completion ; function ] #> [ Field ; function ] #> [ Float32 ; RPolarsDataType ] #> [ Float64 ; RPolarsDataType ] #> [ from_arrow ; function ] #> [ get_polars_opt_requirements ; function ] #> [ get_polars_options ; function ] #> [ Int16 ; RPolarsDataType ] #> [ Int32 ; RPolarsDataType ] #> [ Int64 ; RPolarsDataType ] #> [ Int8 ; RPolarsDataType ] #> [ is_schema ; function ] #> [ lazy_csv_reader ; function ] #> [ List ; function ] #> [ lit ; function ] #> [ max ; function ] #> [ mem_address ; function ] #> [ min ; function ] #> [ Null ; RPolarsDataType ] #> #> numeric_dtypes ( list ): #> [ Float32 ; RPolarsDataType ] #> [ Float64 ; RPolarsDataType ] #> [ Int16 ; RPolarsDataType ] #> [ Int32 ; RPolarsDataType ] #> [ Int64 ; RPolarsDataType ] #> [ Int8 ; RPolarsDataType ] #> #> [ PTime ; function ] #> [ read_csv ; function ] #> [ reset_polars_options ; function ] #> [ same_outer_dt ; function ] #> [ scan_arrow_ipc ; function ] #> [ select ; function ] #> [ Series ; function ] #> [ set_polars_options ; function ] #> [ std ; function ] #> [ struct ; function ] #> [ Struct ; function ] #> [ sum ; function ] #> [ Time ; RPolarsDataType ] #> [ UInt16 ; RPolarsDataType ] #> [ UInt32 ; RPolarsDataType ] #> [ UInt64 ; RPolarsDataType ] #> [ UInt8 ; RPolarsDataType ] #> [ Unknown ; RPolarsDataType ] #> [ Utf8 ; RPolarsDataType ] #> [ var ; function ] #> [ when ; function ] #all accessible classes and their public methods polars ::: print_env ( polars ::: pl_pub_class_env , \"polars public class methods, access via object$method()\" ) #> #> #> polars public class methods, access via object$method() ( environment ): #> #> DataFrame ( environment ): #> [ as_data_frame ; function ] #> [ clone ; function ] #> [ columns ; setter property function ] #> [ dtypes ; property function ] #> [ estimated_size ; function ] #> [ filter ; function ] #> [ first ; function ] #> [ get_column ; function ] #> [ get_columns ; function ] #> [ groupby ; function ] #> [ height ; property function ] #> [ join ; function ] #> [ last ; function ] #> [ lazy ; function ] #> [ limit ; function ] #> [ max ; function ] #> [ mean ; function ] #> [ median ; function ] #> [ min ; function ] #> [ null_count ; function ] #> [ print ; function ] #> [ reverse ; function ] #> [ schema ; property function ] #> [ select ; function ] #> [ shape ; property function ] #> [ slice ; function ] #> [ std ; function ] #> [ sum ; function ] #> [ tail ; function ] #> [ to_list ; function ] #> [ to_series ; function ] #> [ to_struct ; function ] #> [ unnest ; function ] #> [ var ; function ] #> [ width ; property function ] #> [ with_column ; function ] #> [ with_columns ; function ] #> #> #> DataType ( environment ): #> [ eq ; function ] #> [ get_all_simple_type_names ; function ] #> [ get_insides ; function ] #> [ is_temporal ; function ] #> [ ne ; function ] #> [ new ; function ] #> [ new_datetime ; function ] #> [ new_duration ; function ] #> [ new_list ; function ] #> [ new_object ; function ] #> [ new_struct ; function ] #> [ print ; function ] #> [ same_outer_datatype ; function ] #> #> #> Expr ( environment ): #> [ abs ; function ] #> [ add ; function ] #> [ agg_groups ; function ] #> [ alias ; function ] #> [ all ; function ] #> [ and ; function ] #> [ any ; function ] #> [ append ; function ] #> [ apply ; function ] #> [ arccos ; function ] #> [ arccosh ; function ] #> [ arcsin ; function ] #> [ arcsinh ; function ] #> [ arctan ; function ] #> [ arctanh ; function ] #> [ arg_max ; function ] #> [ arg_min ; function ] #> [ arg_sort ; function ] #> [ arg_unique ; function ] #> [ argsort ; function ] #> [ arr ; property function ] #> [ backward_fill ; function ] #> [ bin ; property function ] #> [ cast ; function ] #> [ cat ; property function ] #> [ ceil ; function ] #> [ clip ; function ] #> [ clip_max ; function ] #> [ clip_min ; function ] #> [ cos ; function ] #> [ cosh ; function ] #> [ count ; function ] #> [ cumcount ; function ] #> [ cummax ; function ] #> [ cummin ; function ] #> [ cumprod ; function ] #> [ cumsum ; function ] #> [ cumulative_eval ; function ] #> [ diff ; function ] #> [ div ; function ] #> [ dot ; function ] #> [ drop_nans ; function ] #> [ drop_nulls ; function ] #> [ dt ; property function ] #> [ entropy ; function ] #> [ eq ; function ] #> [ ewm_mean ; function ] #> [ ewm_std ; function ] #> [ ewm_var ; function ] #> [ exclude ; function ] #> [ exp ; function ] #> [ explode ; function ] #> [ extend_constant ; function ] #> [ extend_expr ; function ] #> [ fill_nan ; function ] #> [ fill_null ; function ] #> [ filter ; function ] #> [ first ; function ] #> [ flatten ; function ] #> [ floor ; function ] #> [ forward_fill ; function ] #> [ gt ; function ] #> [ gt_eq ; function ] #> [ hash ; function ] #> [ head ; function ] #> [ inspect ; function ] #> [ interpolate ; function ] #> [ is_between ; function ] #> [ is_duplicated ; function ] #> [ is_finite ; function ] #> [ is_first ; function ] #> [ is_in ; function ] #> [ is_infinite ; function ] #> [ is_nan ; function ] #> [ is_not ; function ] #> [ is_not_nan ; function ] #> [ is_not_null ; function ] #> [ is_null ; function ] #> [ is_unique ; function ] #> [ keep_name ; function ] #> [ kurtosis ; function ] #> [ last ; function ] #> [ len ; function ] #> [ limit ; function ] #> [ list ; function ] #> [ lit ; function ] #> [ lit_to_df ; function ] #> [ lit_to_s ; function ] #> [ log ; function ] #> [ log10 ; function ] #> [ lower_bound ; function ] #> [ lt ; function ] #> [ lt_eq ; function ] #> [ map ; function ] #> [ map_alias ; function ] #> [ max ; function ] #> [ mean ; function ] #> [ median ; function ] #> [ meta ; property function ] #> [ min ; function ] #> [ mode ; function ] #> [ mul ; function ] #> [ n_unique ; function ] #> [ nan_max ; function ] #> [ nan_min ; function ] #> [ neq ; function ] #> [ null_count ; function ] #> [ or ; function ] #> [ over ; function ] #> [ pct_change ; function ] #> [ pow ; function ] #> [ prefix ; function ] #> [ print ; function ] #> [ product ; function ] #> [ quantile ; function ] #> [ rank ; function ] #> [ rechunk ; function ] #> [ reinterpret ; function ] #> [ rep ; function ] #> [ rep_extend ; function ] #> [ repeat_by ; function ] #> [ reshape ; function ] #> [ reverse ; function ] #> [ rolling_max ; function ] #> [ rolling_mean ; function ] #> [ rolling_median ; function ] #> [ rolling_min ; function ] #> [ rolling_quantile ; function ] #> [ rolling_skew ; function ] #> [ rolling_std ; function ] #> [ rolling_sum ; function ] #> [ rolling_var ; function ] #> [ round ; function ] #> [ rpow ; function ] #> [ sample ; function ] #> [ search_sorted ; function ] #> [ set_sorted ; function ] #> [ shift ; function ] #> [ shift_and_fill ; function ] #> [ shrink_dtype ; function ] #> [ shuffle ; function ] #> [ sign ; function ] #> [ sin ; function ] #> [ sinh ; function ] #> [ skew ; function ] #> [ slice ; function ] #> [ sort ; function ] #> [ sort_by ; function ] #> [ sqrt ; function ] #> [ std ; function ] #> [ str ; property function ] #> [ struct ; property function ] #> [ sub ; function ] #> [ suffix ; function ] #> [ sum ; function ] #> [ tail ; function ] #> [ take ; function ] #> [ take_every ; function ] #> [ tan ; function ] #> [ tanh ; function ] #> [ to_physical ; function ] #> [ to_r ; function ] #> [ to_struct ; function ] #> [ top_k ; function ] #> [ unique ; function ] #> [ unique_counts ; function ] #> [ upper_bound ; function ] #> [ value_counts ; function ] #> [ var ; function ] #> [ where ; function ] #> [ xor ; function ] #> #> #> LazyFrame ( environment ): #> [ collect ; function ] #> [ collect_background ; function ] #> [ describe_optimized_plan ; function ] #> [ describe_plan ; function ] #> [ filter ; function ] #> [ first ; function ] #> [ groupby ; function ] #> [ join ; function ] #> [ last ; function ] #> [ limit ; function ] #> [ max ; function ] #> [ mean ; function ] #> [ median ; function ] #> [ min ; function ] #> [ print ; function ] #> [ reverse ; function ] #> [ select ; function ] #> [ slice ; function ] #> [ std ; function ] #> [ sum ; function ] #> [ tail ; function ] #> [ var ; function ] #> [ with_column ; function ] #> [ with_columns ; function ] #> #> #> LazyGroupBy ( environment ): #> [ agg ; function ] #> [ apply ; function ] #> [ head ; function ] #> [ print ; function ] #> [ tail ; function ] #> #> #> PolarsBackgroundHandle ( environment ): #> [ is_exhausted ; function ] #> [ join ; function ] #> #> #> Series ( environment ): #> [ abs ; function ] #> [ add ; function ] #> [ alias ; function ] #> [ all ; function ] #> [ any ; function ] #> [ append ; function ] #> [ apply ; function ] #> [ arg_max ; function ] #> [ arg_min ; function ] #> [ arr ; property function ] #> [ ceil ; function ] #> [ chunk_lengths ; function ] #> [ clone ; function ] #> [ compare ; function ] #> [ cumsum ; function ] #> [ div ; function ] #> [ dtype ; property function ] #> [ expr ; property function ] #> [ flags ; property function ] #> [ floor ; function ] #> [ is_numeric ; function ] #> [ is_sorted ; function ] #> [ len ; function ] #> [ max ; function ] #> [ min ; function ] #> [ mul ; function ] #> [ name ; property function ] #> [ print ; function ] #> [ rem ; function ] #> [ rename ; function ] #> [ rep ; function ] #> [ series_equal ; function ] #> [ set_sorted ; function ] #> [ shape ; property function ] #> [ sort ; function ] #> [ std ; function ] #> [ sub ; function ] #> [ sum ; function ] #> [ to_frame ; function ] #> [ to_lit ; function ] #> [ to_r ; function ] #> [ to_r_list ; function ] #> [ to_r_vector ; function ] #> [ value_counts ; function ] #> [ var ; function ] #> #> #> When ( environment ): #> [ then ; function ] #> #> #> WhenThen ( environment ): #> [ otherwise ; function ] #> [ when ; function ] #> #> #> WhenThenThen ( environment ): #> [ otherwise ; function ] #> [ peak_inside ; function ] #> [ then ; function ] #> [ when ; function ] #>","title":"Examples"},{"location":"reference/pl_concat/","text":"Concat polars objects Arguments l : list of DataFrame, or Series, LazyFrame or Expr rechunk : perform a rechunk at last how : choice of bind direction \"vertical\"(rbind) \"horizontal\"(cbind) \"diagnoal\" diagonally parallel : BOOL default TRUE, only used for LazyFrames Returns DataFrame, or Series, LazyFrame or Expr Concat polars objects Examples #vertical l_ver = lapply ( 1 : 10 , function ( i ) { l_internal = list ( a = 1 : 5 , b = letters [ 1 : 5 ] ) pl $ DataFrame ( l_internal ) } ) pl $ concat ( l_ver , how = \"vertical\" ) #> polars DataFrame: shape: (50, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 a \u2502 #> \u2502 2 \u2506 b \u2502 #> \u2502 3 \u2506 c \u2502 #> \u2502 4 \u2506 d \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2 \u2506 b \u2502 #> \u2502 3 \u2506 c \u2502 #> \u2502 4 \u2506 d \u2502 #> \u2502 5 \u2506 e \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 #horizontal l_hor = lapply ( 1 : 10 , function ( i ) { l_internal = list ( 1 : 5 , letters [ 1 : 5 ] ) names ( l_internal ) = paste0 ( c ( \"a\" , \"b\" ) , i ) pl $ DataFrame ( l_internal ) } ) pl $ concat ( l_hor , how = \"horizontal\" ) #> polars DataFrame: shape: (5, 20) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a1 \u2506 b1 \u2506 a2 \u2506 b2 \u2506 ... \u2506 a9 \u2506 b9 \u2506 a10 \u2506 b10 \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2506 i32 \u2506 str \u2506 \u2506 i32 \u2506 str \u2506 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 a \u2506 1 \u2506 a \u2506 ... \u2506 1 \u2506 a \u2506 1 \u2506 a \u2502 #> \u2502 2 \u2506 b \u2506 2 \u2506 b \u2506 ... \u2506 2 \u2506 b \u2506 2 \u2506 b \u2502 #> \u2502 3 \u2506 c \u2506 3 \u2506 c \u2506 ... \u2506 3 \u2506 c \u2506 3 \u2506 c \u2502 #> \u2502 4 \u2506 d \u2506 4 \u2506 d \u2506 ... \u2506 4 \u2506 d \u2506 4 \u2506 d \u2502 #> \u2502 5 \u2506 e \u2506 5 \u2506 e \u2506 ... \u2506 5 \u2506 e \u2506 5 \u2506 e \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 #diagonal pl $ concat ( l_hor , how = \"diagonal\" ) #> polars DataFrame: shape: (50, 20) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a1 \u2506 b1 \u2506 a2 \u2506 b2 \u2506 ... \u2506 a9 \u2506 b9 \u2506 a10 \u2506 b10 \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2506 i32 \u2506 str \u2506 \u2506 i32 \u2506 str \u2506 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 a \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2502 2 \u2506 b \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2502 3 \u2506 c \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2502 4 \u2506 d \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 2 \u2506 b \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 3 \u2506 c \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 4 \u2506 d \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 5 \u2506 e \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"concat"},{"location":"reference/pl_concat/#concat-polars-objects","text":"","title":"Concat polars objects"},{"location":"reference/pl_concat/#arguments","text":"l : list of DataFrame, or Series, LazyFrame or Expr rechunk : perform a rechunk at last how : choice of bind direction \"vertical\"(rbind) \"horizontal\"(cbind) \"diagnoal\" diagonally parallel : BOOL default TRUE, only used for LazyFrames","title":"Arguments"},{"location":"reference/pl_concat/#returns","text":"DataFrame, or Series, LazyFrame or Expr Concat polars objects","title":"Returns"},{"location":"reference/pl_concat/#examples","text":"#vertical l_ver = lapply ( 1 : 10 , function ( i ) { l_internal = list ( a = 1 : 5 , b = letters [ 1 : 5 ] ) pl $ DataFrame ( l_internal ) } ) pl $ concat ( l_ver , how = \"vertical\" ) #> polars DataFrame: shape: (50, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 a \u2502 #> \u2502 2 \u2506 b \u2502 #> \u2502 3 \u2506 c \u2502 #> \u2502 4 \u2506 d \u2502 #> \u2502 ... \u2506 ... \u2502 #> \u2502 2 \u2506 b \u2502 #> \u2502 3 \u2506 c \u2502 #> \u2502 4 \u2506 d \u2502 #> \u2502 5 \u2506 e \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 #horizontal l_hor = lapply ( 1 : 10 , function ( i ) { l_internal = list ( 1 : 5 , letters [ 1 : 5 ] ) names ( l_internal ) = paste0 ( c ( \"a\" , \"b\" ) , i ) pl $ DataFrame ( l_internal ) } ) pl $ concat ( l_hor , how = \"horizontal\" ) #> polars DataFrame: shape: (5, 20) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a1 \u2506 b1 \u2506 a2 \u2506 b2 \u2506 ... \u2506 a9 \u2506 b9 \u2506 a10 \u2506 b10 \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2506 i32 \u2506 str \u2506 \u2506 i32 \u2506 str \u2506 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 a \u2506 1 \u2506 a \u2506 ... \u2506 1 \u2506 a \u2506 1 \u2506 a \u2502 #> \u2502 2 \u2506 b \u2506 2 \u2506 b \u2506 ... \u2506 2 \u2506 b \u2506 2 \u2506 b \u2502 #> \u2502 3 \u2506 c \u2506 3 \u2506 c \u2506 ... \u2506 3 \u2506 c \u2506 3 \u2506 c \u2502 #> \u2502 4 \u2506 d \u2506 4 \u2506 d \u2506 ... \u2506 4 \u2506 d \u2506 4 \u2506 d \u2502 #> \u2502 5 \u2506 e \u2506 5 \u2506 e \u2506 ... \u2506 5 \u2506 e \u2506 5 \u2506 e \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 #diagonal pl $ concat ( l_hor , how = \"diagonal\" ) #> polars DataFrame: shape: (50, 20) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a1 \u2506 b1 \u2506 a2 \u2506 b2 \u2506 ... \u2506 a9 \u2506 b9 \u2506 a10 \u2506 b10 \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2506 i32 \u2506 str \u2506 \u2506 i32 \u2506 str \u2506 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 a \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2502 2 \u2506 b \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2502 3 \u2506 c \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2502 4 \u2506 d \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 null \u2506 null \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 2 \u2506 b \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 3 \u2506 c \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 4 \u2506 d \u2502 #> \u2502 null \u2506 null \u2506 null \u2506 null \u2506 ... \u2506 null \u2506 null \u2506 5 \u2506 e \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/pl_date_range/","text":"new date_range Arguments low : POSIXt or Date preferably with time_zone or double or integer high : POSIXt or Date preferably with time_zone or double or integer. If high is and interval are missing, then single datetime is constructed. interval : string pl_duration or R difftime. Can be missing if high is missing also. lazy : bool, if TRUE return expression closed : option one of 'both'(default), 'left', 'none' or 'right' name : name of series time_unit : option string (\"ns\" \"us\" \"ms\") duration of one int64 value on polars side time_zone : optional string describing a timezone. Returns a datetime new date_range Details If param time_zone is not defined the Series will have no time zone. NOTICE: R POSIXt without defined timezones(tzone/tz), so called naive datetimes, are counter intuitive in R. It is recommended to always set the timezone of low and high. If not output will vary between local machine timezone, R and polars. In R/r-polars it is perfectly fine to mix timezones of params time_zone, low and high. Examples # All in GMT, straight forward, no mental confusion s_gmt = pl $ date_range ( as.POSIXct ( \"2022-01-01\" ,tz = \"GMT\" ) , as.POSIXct ( \"2022-01-02\" ,tz = \"GMT\" ) , interval = \"6h\" , time_unit = \"ms\" , time_zone = \"GMT\" ) s_gmt #> polars Series: shape: (5,) #> Series: '' [datetime[ms, GMT]] #> [ #> 2022-01-01 00:00:00 GMT #> 2022-01-01 06:00:00 GMT #> 2022-01-01 12:00:00 GMT #> 2022-01-01 18:00:00 GMT #> 2022-01-02 00:00:00 GMT #> ] s_gmt $ to_r ( ) #printed same way in R and polars becuase tagged with a time_zone/tzone #> [1] \"2022-01-01 00:00:00 GMT\" \"2022-01-01 06:00:00 GMT\" \"2022-01-01 12:00:00 GMT\" \"2022-01-01 18:00:00 GMT\" #> [5] \"2022-01-02 00:00:00 GMT\" # polars assumes any input in GMT if time_zone = NULL, set GMT on low high to see same print s_null = pl $ date_range ( as.POSIXct ( \"2022-01-01\" ,tz = \"GMT\" ) , as.POSIXct ( \"2022-01-02\" ,tz = \"GMT\" ) , interval = \"6h\" , time_unit = \"ms\" , time_zone = NULL ) s_null $ to_r ( ) #back to R POSIXct. R prints non tzone tagged POSIXct in local timezone. #> [1] \"2022-01-01 01:00:00 CET\" \"2022-01-01 07:00:00 CET\" \"2022-01-01 13:00:00 CET\" \"2022-01-01 19:00:00 CET\" #> [5] \"2022-01-02 01:00:00 CET\" #Any mixing of timezones is fine, just set them all, and it works as expected. t1 = as.POSIXct ( \"2022-01-01\" , tz = \"Etc/GMT+2\" ) t2 = as.POSIXct ( \"2022-01-01 08:00:00\" , tz = \"Etc/GMT-2\" ) s_mix = pl $ date_range ( low = t1 , high = t2 , interval = \"1h\" , time_unit = \"ms\" , time_zone = \"CET\" ) s_mix #> polars Series: shape: (5,) #> Series: '' [datetime[ms, CET]] #> [ #> 2022-01-01 03:00:00 CET #> 2022-01-01 04:00:00 CET #> 2022-01-01 05:00:00 CET #> 2022-01-01 06:00:00 CET #> 2022-01-01 07:00:00 CET #> ] s_mix $ to_r ( ) #> [1] \"2022-01-01 03:00:00 CET\" \"2022-01-01 04:00:00 CET\" \"2022-01-01 05:00:00 CET\" \"2022-01-01 06:00:00 CET\" #> [5] \"2022-01-01 07:00:00 CET\" #use of ISOdate t1 = ISOdate ( 2022 , 1 , 1 , 0 ) #preset GMT t2 = ISOdate ( 2022 , 1 , 2 , 0 ) #preset GMT pl $ date_range ( t1 , t2 ,interval = \"4h\" , time_unit = \"ms\" , time_zone = \"GMT\" ) #> polars Series: shape: (7,) #> Series: '' [datetime[ms, GMT]] #> [ #> 2022-01-01 00:00:00 GMT #> 2022-01-01 04:00:00 GMT #> 2022-01-01 08:00:00 GMT #> 2022-01-01 12:00:00 GMT #> 2022-01-01 16:00:00 GMT #> 2022-01-01 20:00:00 GMT #> 2022-01-02 00:00:00 GMT #> ]","title":"date_range"},{"location":"reference/pl_date_range/#new-date_range","text":"","title":"new date_range"},{"location":"reference/pl_date_range/#arguments","text":"low : POSIXt or Date preferably with time_zone or double or integer high : POSIXt or Date preferably with time_zone or double or integer. If high is and interval are missing, then single datetime is constructed. interval : string pl_duration or R difftime. Can be missing if high is missing also. lazy : bool, if TRUE return expression closed : option one of 'both'(default), 'left', 'none' or 'right' name : name of series time_unit : option string (\"ns\" \"us\" \"ms\") duration of one int64 value on polars side time_zone : optional string describing a timezone.","title":"Arguments"},{"location":"reference/pl_date_range/#returns","text":"a datetime new date_range","title":"Returns"},{"location":"reference/pl_date_range/#details","text":"If param time_zone is not defined the Series will have no time zone. NOTICE: R POSIXt without defined timezones(tzone/tz), so called naive datetimes, are counter intuitive in R. It is recommended to always set the timezone of low and high. If not output will vary between local machine timezone, R and polars. In R/r-polars it is perfectly fine to mix timezones of params time_zone, low and high.","title":"Details"},{"location":"reference/pl_date_range/#examples","text":"# All in GMT, straight forward, no mental confusion s_gmt = pl $ date_range ( as.POSIXct ( \"2022-01-01\" ,tz = \"GMT\" ) , as.POSIXct ( \"2022-01-02\" ,tz = \"GMT\" ) , interval = \"6h\" , time_unit = \"ms\" , time_zone = \"GMT\" ) s_gmt #> polars Series: shape: (5,) #> Series: '' [datetime[ms, GMT]] #> [ #> 2022-01-01 00:00:00 GMT #> 2022-01-01 06:00:00 GMT #> 2022-01-01 12:00:00 GMT #> 2022-01-01 18:00:00 GMT #> 2022-01-02 00:00:00 GMT #> ] s_gmt $ to_r ( ) #printed same way in R and polars becuase tagged with a time_zone/tzone #> [1] \"2022-01-01 00:00:00 GMT\" \"2022-01-01 06:00:00 GMT\" \"2022-01-01 12:00:00 GMT\" \"2022-01-01 18:00:00 GMT\" #> [5] \"2022-01-02 00:00:00 GMT\" # polars assumes any input in GMT if time_zone = NULL, set GMT on low high to see same print s_null = pl $ date_range ( as.POSIXct ( \"2022-01-01\" ,tz = \"GMT\" ) , as.POSIXct ( \"2022-01-02\" ,tz = \"GMT\" ) , interval = \"6h\" , time_unit = \"ms\" , time_zone = NULL ) s_null $ to_r ( ) #back to R POSIXct. R prints non tzone tagged POSIXct in local timezone. #> [1] \"2022-01-01 01:00:00 CET\" \"2022-01-01 07:00:00 CET\" \"2022-01-01 13:00:00 CET\" \"2022-01-01 19:00:00 CET\" #> [5] \"2022-01-02 01:00:00 CET\" #Any mixing of timezones is fine, just set them all, and it works as expected. t1 = as.POSIXct ( \"2022-01-01\" , tz = \"Etc/GMT+2\" ) t2 = as.POSIXct ( \"2022-01-01 08:00:00\" , tz = \"Etc/GMT-2\" ) s_mix = pl $ date_range ( low = t1 , high = t2 , interval = \"1h\" , time_unit = \"ms\" , time_zone = \"CET\" ) s_mix #> polars Series: shape: (5,) #> Series: '' [datetime[ms, CET]] #> [ #> 2022-01-01 03:00:00 CET #> 2022-01-01 04:00:00 CET #> 2022-01-01 05:00:00 CET #> 2022-01-01 06:00:00 CET #> 2022-01-01 07:00:00 CET #> ] s_mix $ to_r ( ) #> [1] \"2022-01-01 03:00:00 CET\" \"2022-01-01 04:00:00 CET\" \"2022-01-01 05:00:00 CET\" \"2022-01-01 06:00:00 CET\" #> [5] \"2022-01-01 07:00:00 CET\" #use of ISOdate t1 = ISOdate ( 2022 , 1 , 1 , 0 ) #preset GMT t2 = ISOdate ( 2022 , 1 , 2 , 0 ) #preset GMT pl $ date_range ( t1 , t2 ,interval = \"4h\" , time_unit = \"ms\" , time_zone = \"GMT\" ) #> polars Series: shape: (7,) #> Series: '' [datetime[ms, GMT]] #> [ #> 2022-01-01 00:00:00 GMT #> 2022-01-01 04:00:00 GMT #> 2022-01-01 08:00:00 GMT #> 2022-01-01 12:00:00 GMT #> 2022-01-01 16:00:00 GMT #> 2022-01-01 20:00:00 GMT #> 2022-01-02 00:00:00 GMT #> ]","title":"Examples"},{"location":"reference/pl_select/","text":"Select from an empty DataFrame Format method Returns DataFrame Select from an empty DataFrame Details param ... expressions passed to select pl$select is a shorthand for pl$DataFrame(list())$select NB param of this function Examples pl $ select ( pl $ lit ( 1 : 4 ) $ alias ( \"ints\" ) , pl $ lit ( letters [ 1 : 4 ] ) $ alias ( \"letters\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 ints \u2506 letters \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 a \u2502 #> \u2502 2 \u2506 b \u2502 #> \u2502 3 \u2506 c \u2502 #> \u2502 4 \u2506 d \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"select"},{"location":"reference/pl_select/#select-from-an-empty-dataframe","text":"","title":"Select from an empty DataFrame"},{"location":"reference/pl_select/#format","text":"method","title":"Format"},{"location":"reference/pl_select/#returns","text":"DataFrame Select from an empty DataFrame","title":"Returns"},{"location":"reference/pl_select/#details","text":"param ... expressions passed to select pl$select is a shorthand for pl$DataFrame(list())$select NB param of this function","title":"Details"},{"location":"reference/pl_select/#examples","text":"pl $ select ( pl $ lit ( 1 : 4 ) $ alias ( \"ints\" ) , pl $ lit ( letters [ 1 : 4 ] ) $ alias ( \"letters\" ) ) #> polars DataFrame: shape: (4, 2) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 ints \u2506 letters \u2502 #> \u2502 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 a \u2502 #> \u2502 2 \u2506 b \u2502 #> \u2502 3 \u2506 c \u2502 #> \u2502 4 \u2506 d \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/polars_options/","text":"polars options Arguments strictly_immutable : bool, default = TRUE, keep polars strictly immutable. Polars/arrow is in general pro \"immutable objects\". However pypolars API has some minor exceptions. All settable property elements of classes are mutable. Why?, I guess python just do not have strong stance on immutability. R strongly suggests immutable objects, so why not make polars strictly immutable where little performance costs? However, if to mimic pypolars as much as possible, set this to FALSE. named_exprs : bool, default = FALSE, allow named exprs in e.g. select, with_columns, groupby, join. a named expresion will be extended with $alias(name) wildcards or expression producing multiple are problematic due to name collision the related option in py-polars is currently called 'pl.Config.with_columns_kwargs' and only allow named exprs in with_columns (or potentially any method derived there of) no_messages : bool, default = FALSE, turn of messages do_not_repeat_call : bool, default = FALSE, turn of messages ... : any options to modify return_replaced_options : return previous state of modified options Convenient for temporarily swapping of options during testing. Returns current settings as list current settings as list list named by options of requirement function input must satisfy get, set, reset polars options Details who likes polars package messages? use this option to turn them off. do not print the call causing the error in error messages modifing list takes no effect, pass it to pl$set_polars_options get/set/resest interact with internal env polars:::polars_optenv setting an options may be rejected if not passing opt_requirements Examples #rename columns by naming expression, experimental requires option named_exprs = TRUE pl $ set_polars_options ( named_exprs = TRUE ) #> $named_exprs #> [1] TRUE #> pl $ DataFrame ( iris ) $ with_columns ( pl $ col ( \"Sepal.Length\" ) $ abs ( ) , #not named expr will keep name \"Sepal.Length\" SW_add_2 = ( pl $ col ( \"Sepal.Width\" ) + 2 ) ) #> polars DataFrame: shape: (150, 6) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2506 SW_add_2 \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2506 5.5 \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2506 5.0 \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2506 5.2 \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2506 5.1 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2506 4.5 \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2506 5.0 \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2506 5.4 \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2506 5.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ get_polars_options ( ) #> $do_not_repeat_call #> [1] FALSE #> #> $strictly_immutable #> [1] TRUE #> #> $named_exprs #> [1] TRUE #> #> $no_messages #> [1] FALSE #> pl $ set_polars_options ( strictly_immutable = FALSE ) #> $strictly_immutable #> [1] TRUE #> pl $ get_polars_options ( ) #> $do_not_repeat_call #> [1] FALSE #> #> $strictly_immutable #> [1] FALSE #> #> $named_exprs #> [1] TRUE #> #> $no_messages #> [1] FALSE #> #setting strictly_immutable = 42 will be rejected as tryCatch ( pl $ set_polars_options ( strictly_immutable = 42 ) , error = function ( e ) print ( e ) ) #> <simpleError: option: strictly_immutable must satisfy requirement named is_bool with function #> function (x) { #> is.logical(x) && length(x)==1 && !is.na(x) #> } #> <environment: namespace:polars>> #reset options like this pl $ reset_polars_options ( ) #use get_polars_opt_requirements() to requirements pl $ get_polars_opt_requirements ( ) #> $strictly_immutable #> $strictly_immutable$is_bool #> function (x) { #> is.logical(x) && length(x)==1 && !is.na(x) #> } #> <environment: namespace:polars> #> #> #> $named_exprs #> $named_exprs$is_bool #> function (x) { #> is.logical(x) && length(x)==1 && !is.na(x) #> } #> <environment: namespace:polars> #> #> #> $no_messages #> $no_messages$is_bool #> function (x) { #> is.logical(x) && length(x)==1 && !is.na(x) #> } #> <environment: namespace:polars> #> #> #> $do_not_repeat_call #> $do_not_repeat_call$is_bool #> function (x) { #> is.logical(x) && length(x)==1 && !is.na(x) #> } #> <environment: namespace:polars> #> #>","title":"polars_options"},{"location":"reference/polars_options/#polars-options","text":"","title":"polars options"},{"location":"reference/polars_options/#arguments","text":"strictly_immutable : bool, default = TRUE, keep polars strictly immutable. Polars/arrow is in general pro \"immutable objects\". However pypolars API has some minor exceptions. All settable property elements of classes are mutable. Why?, I guess python just do not have strong stance on immutability. R strongly suggests immutable objects, so why not make polars strictly immutable where little performance costs? However, if to mimic pypolars as much as possible, set this to FALSE. named_exprs : bool, default = FALSE, allow named exprs in e.g. select, with_columns, groupby, join. a named expresion will be extended with $alias(name) wildcards or expression producing multiple are problematic due to name collision the related option in py-polars is currently called 'pl.Config.with_columns_kwargs' and only allow named exprs in with_columns (or potentially any method derived there of) no_messages : bool, default = FALSE, turn of messages do_not_repeat_call : bool, default = FALSE, turn of messages ... : any options to modify return_replaced_options : return previous state of modified options Convenient for temporarily swapping of options during testing.","title":"Arguments"},{"location":"reference/polars_options/#returns","text":"current settings as list current settings as list list named by options of requirement function input must satisfy get, set, reset polars options","title":"Returns"},{"location":"reference/polars_options/#details","text":"who likes polars package messages? use this option to turn them off. do not print the call causing the error in error messages modifing list takes no effect, pass it to pl$set_polars_options get/set/resest interact with internal env polars:::polars_optenv setting an options may be rejected if not passing opt_requirements","title":"Details"},{"location":"reference/polars_options/#examples","text":"#rename columns by naming expression, experimental requires option named_exprs = TRUE pl $ set_polars_options ( named_exprs = TRUE ) #> $named_exprs #> [1] TRUE #> pl $ DataFrame ( iris ) $ with_columns ( pl $ col ( \"Sepal.Length\" ) $ abs ( ) , #not named expr will keep name \"Sepal.Length\" SW_add_2 = ( pl $ col ( \"Sepal.Width\" ) + 2 ) ) #> polars DataFrame: shape: (150, 6) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2506 SW_add_2 \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2506 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2506 5.5 \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2506 5.0 \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2506 5.2 \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2506 5.1 \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2506 4.5 \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2506 5.0 \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2506 5.4 \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2506 5.0 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 pl $ get_polars_options ( ) #> $do_not_repeat_call #> [1] FALSE #> #> $strictly_immutable #> [1] TRUE #> #> $named_exprs #> [1] TRUE #> #> $no_messages #> [1] FALSE #> pl $ set_polars_options ( strictly_immutable = FALSE ) #> $strictly_immutable #> [1] TRUE #> pl $ get_polars_options ( ) #> $do_not_repeat_call #> [1] FALSE #> #> $strictly_immutable #> [1] FALSE #> #> $named_exprs #> [1] TRUE #> #> $no_messages #> [1] FALSE #> #setting strictly_immutable = 42 will be rejected as tryCatch ( pl $ set_polars_options ( strictly_immutable = 42 ) , error = function ( e ) print ( e ) ) #> <simpleError: option: strictly_immutable must satisfy requirement named is_bool with function #> function (x) { #> is.logical(x) && length(x)==1 && !is.na(x) #> } #> <environment: namespace:polars>> #reset options like this pl $ reset_polars_options ( ) #use get_polars_opt_requirements() to requirements pl $ get_polars_opt_requirements ( ) #> $strictly_immutable #> $strictly_immutable$is_bool #> function (x) { #> is.logical(x) && length(x)==1 && !is.na(x) #> } #> <environment: namespace:polars> #> #> #> $named_exprs #> $named_exprs$is_bool #> function (x) { #> is.logical(x) && length(x)==1 && !is.na(x) #> } #> <environment: namespace:polars> #> #> #> $no_messages #> $no_messages$is_bool #> function (x) { #> is.logical(x) && length(x)==1 && !is.na(x) #> } #> <environment: namespace:polars> #> #> #> $do_not_repeat_call #> $do_not_repeat_call$is_bool #> function (x) { #> is.logical(x) && length(x)==1 && !is.na(x) #> } #> <environment: namespace:polars> #> #>","title":"Examples"},{"location":"reference/polars_runtime_flags/","text":"data internal keeping of state at runtime Format An object of class environment of length 0. runtime_state This environment is used internally for the package to remember what has been going on. Currently only used to throw one-time warnings()","title":"polars_runtime_flags"},{"location":"reference/polars_runtime_flags/#internal-keeping-of-state-at-runtime","text":"","title":"internal keeping of state at runtime"},{"location":"reference/polars_runtime_flags/#format","text":"An object of class environment of length 0. runtime_state This environment is used internally for the package to remember what has been going on. Currently only used to throw one-time warnings()","title":"Format"},{"location":"reference/prepare_alpha/","text":"preapare alpha prepare_alpha ( com = NULL , span = NULL , half_life = NULL , alpha = NULL ) Arguments com : numeric or NULL span : numeric or NULL half_life : numeric or NULL alpha : numeric or NULL Returns numeric internal function for emw_x expressions","title":"prepare_alpha"},{"location":"reference/prepare_alpha/#preapare-alpha","text":"prepare_alpha ( com = NULL , span = NULL , half_life = NULL , alpha = NULL )","title":"preapare alpha"},{"location":"reference/prepare_alpha/#arguments","text":"com : numeric or NULL span : numeric or NULL half_life : numeric or NULL alpha : numeric or NULL","title":"Arguments"},{"location":"reference/prepare_alpha/#returns","text":"numeric internal function for emw_x expressions","title":"Returns"},{"location":"reference/print-open-paren-close-paren/","text":"s3 method print DataFrame ## S3 method for class 'DataFrame' print ( x , ... ) Arguments x : DataFrame ... : not used Returns self s3 method print DataFrame Examples pl $ DataFrame ( iris ) #> polars DataFrame: shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"print-open-paren-close-paren"},{"location":"reference/print-open-paren-close-paren/#s3-method-print-dataframe","text":"## S3 method for class 'DataFrame' print ( x , ... )","title":"s3 method print DataFrame"},{"location":"reference/print-open-paren-close-paren/#arguments","text":"x : DataFrame ... : not used","title":"Arguments"},{"location":"reference/print-open-paren-close-paren/#returns","text":"self s3 method print DataFrame","title":"Returns"},{"location":"reference/print-open-paren-close-paren/#examples","text":"pl $ DataFrame ( iris ) #> polars DataFrame: shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/print.Expr/","text":"Print expr ## S3 method for class 'Expr' print ( x , ... ) Arguments x : Expr ... : not used Returns self Print expr Examples pl $ col ( \"some_column\" ) $ sum ( ) $ over ( \"some_other_column\" ) #> polars Expr: col(\"some_column\").sum().over([col(\"some_other_column\")])","title":"print.Expr"},{"location":"reference/print.Expr/#print-expr","text":"## S3 method for class 'Expr' print ( x , ... )","title":"Print expr"},{"location":"reference/print.Expr/#arguments","text":"x : Expr ... : not used","title":"Arguments"},{"location":"reference/print.Expr/#returns","text":"self Print expr","title":"Returns"},{"location":"reference/print.Expr/#examples","text":"pl $ col ( \"some_column\" ) $ sum ( ) $ over ( \"some_other_column\" ) #> polars Expr: col(\"some_column\").sum().over([col(\"some_other_column\")])","title":"Examples"},{"location":"reference/print.GroupBy/","text":"print GroupBy ## S3 method for class 'GroupBy' print ( x , ... ) Arguments x : DataFrame ... : not used Returns self print GroupBy Examples pl $ DataFrame ( iris ) $ groupby ( \"Species\" ) #> polars GroupBy: shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #> groups: ProtoExprArray( #> [ #> Expr( #> Expr( #> col(\"Species\"), #> ), #> ), #> ], #> ) #> maintain order: FALSE","title":"print.GroupBy"},{"location":"reference/print.GroupBy/#print-groupby","text":"## S3 method for class 'GroupBy' print ( x , ... )","title":"print GroupBy"},{"location":"reference/print.GroupBy/#arguments","text":"x : DataFrame ... : not used","title":"Arguments"},{"location":"reference/print.GroupBy/#returns","text":"self print GroupBy","title":"Returns"},{"location":"reference/print.GroupBy/#examples","text":"pl $ DataFrame ( iris ) $ groupby ( \"Species\" ) #> polars GroupBy: shape: (150, 5) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Sepal.Length \u2506 Sepal.Width \u2506 Petal.Length \u2506 Petal.Width \u2506 Species \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 cat \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 5.1 \u2506 3.5 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.9 \u2506 3.0 \u2506 1.4 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.7 \u2506 3.2 \u2506 1.3 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 4.6 \u2506 3.1 \u2506 1.5 \u2506 0.2 \u2506 setosa \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 6.3 \u2506 2.5 \u2506 5.0 \u2506 1.9 \u2506 virginica \u2502 #> \u2502 6.5 \u2506 3.0 \u2506 5.2 \u2506 2.0 \u2506 virginica \u2502 #> \u2502 6.2 \u2506 3.4 \u2506 5.4 \u2506 2.3 \u2506 virginica \u2502 #> \u2502 5.9 \u2506 3.0 \u2506 5.1 \u2506 1.8 \u2506 virginica \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #> groups: ProtoExprArray( #> [ #> Expr( #> Expr( #> col(\"Species\"), #> ), #> ), #> ], #> ) #> maintain order: FALSE","title":"Examples"},{"location":"reference/print.LazyFrame/","text":"print LazyFrame s3 method ## S3 method for class 'LazyFrame' print ( x , ... ) Arguments x : DataFrame ... : not used Returns self print LazyFrame s3 method Examples print ( pl $ DataFrame ( iris ) $ lazy ( ) ) #> [1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\" #> DF [\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"]; PROJECT */5 COLUMNS; SELECTION: \"None\" #>","title":"print.LazyFrame"},{"location":"reference/print.LazyFrame/#print-lazyframe-s3-method","text":"## S3 method for class 'LazyFrame' print ( x , ... )","title":"print LazyFrame s3 method"},{"location":"reference/print.LazyFrame/#arguments","text":"x : DataFrame ... : not used","title":"Arguments"},{"location":"reference/print.LazyFrame/#returns","text":"self print LazyFrame s3 method","title":"Returns"},{"location":"reference/print.LazyFrame/#examples","text":"print ( pl $ DataFrame ( iris ) $ lazy ( ) ) #> [1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\" #> DF [\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"]; PROJECT */5 COLUMNS; SELECTION: \"None\" #>","title":"Examples"},{"location":"reference/print.LazyGroupBy/","text":"print LazyGroupBy ## S3 method for class 'LazyGroupBy' print ( x , ... ) Arguments x : LazyGroupBy ... : not used Returns self print LazyGroupBy","title":"print.LazyGroupBy"},{"location":"reference/print.LazyGroupBy/#print-lazygroupby","text":"## S3 method for class 'LazyGroupBy' print ( x , ... )","title":"print LazyGroupBy"},{"location":"reference/print.LazyGroupBy/#arguments","text":"x : LazyGroupBy ... : not used","title":"Arguments"},{"location":"reference/print.LazyGroupBy/#returns","text":"self print LazyGroupBy","title":"Returns"},{"location":"reference/print.PTime/","text":"print PTime ## S3 method for class 'PTime' print ( x , ... ) Arguments x : a PTime vector ... : not used Returns invisible x print PTime","title":"print.PTime"},{"location":"reference/print.PTime/#print-ptime","text":"## S3 method for class 'PTime' print ( x , ... )","title":"print PTime"},{"location":"reference/print.PTime/#arguments","text":"x : a PTime vector ... : not used","title":"Arguments"},{"location":"reference/print.PTime/#returns","text":"invisible x print PTime","title":"Returns"},{"location":"reference/print.PolarsBackgroundHandle/","text":"print LazyFrame s3 method ## S3 method for class 'PolarsBackgroundHandle' print ( x , ... ) Arguments x : DataFrame ... : not used Returns self print LazyFrame s3 method Examples lazy_df = pl $ DataFrame ( iris [ , 1 : 3 ] ) $ lazy ( ) $ select ( pl $ all ( ) $ first ( ) ) handle = lazy_df $ collect_background ( ) handle $ is_exhausted ( ) #> [1] FALSE df = handle $ join ( ) handle $ is_exhausted ( ) #> [1] TRUE","title":"print.PolarsBackgroundHandle"},{"location":"reference/print.PolarsBackgroundHandle/#print-lazyframe-s3-method","text":"## S3 method for class 'PolarsBackgroundHandle' print ( x , ... )","title":"print LazyFrame s3 method"},{"location":"reference/print.PolarsBackgroundHandle/#arguments","text":"x : DataFrame ... : not used","title":"Arguments"},{"location":"reference/print.PolarsBackgroundHandle/#returns","text":"self print LazyFrame s3 method","title":"Returns"},{"location":"reference/print.PolarsBackgroundHandle/#examples","text":"lazy_df = pl $ DataFrame ( iris [ , 1 : 3 ] ) $ lazy ( ) $ select ( pl $ all ( ) $ first ( ) ) handle = lazy_df $ collect_background ( ) handle $ is_exhausted ( ) #> [1] FALSE df = handle $ join ( ) handle $ is_exhausted ( ) #> [1] TRUE","title":"Examples"},{"location":"reference/print.RField/","text":"Print a polars Field ## S3 method for class 'RField' print ( x , ... ) Arguments x : DataType ... : not used Returns self Print a polars Field Examples print ( pl $ Field ( \"foo\" , pl $ List ( pl $ UInt64 ) ) ) #> Field { #> name: \"foo\", #> dtype: List( #> UInt64, #> ), #> }","title":"print.RField"},{"location":"reference/print.RField/#print-a-polars-field","text":"## S3 method for class 'RField' print ( x , ... )","title":"Print a polars Field"},{"location":"reference/print.RField/#arguments","text":"x : DataType ... : not used","title":"Arguments"},{"location":"reference/print.RField/#returns","text":"self Print a polars Field","title":"Returns"},{"location":"reference/print.RField/#examples","text":"print ( pl $ Field ( \"foo\" , pl $ List ( pl $ UInt64 ) ) ) #> Field { #> name: \"foo\", #> dtype: List( #> UInt64, #> ), #> }","title":"Examples"},{"location":"reference/print.RPolarsDataType/","text":"print a polars datatype ## S3 method for class 'RPolarsDataType' print ( x , ... ) Arguments x : DataType ... : not used Returns self print a polars datatype Examples pl $ dtypes $ Boolean #implicit print #> DataType: Boolean","title":"print.RPolarsDataType"},{"location":"reference/print.RPolarsDataType/#print-a-polars-datatype","text":"## S3 method for class 'RPolarsDataType' print ( x , ... )","title":"print a polars datatype"},{"location":"reference/print.RPolarsDataType/#arguments","text":"x : DataType ... : not used","title":"Arguments"},{"location":"reference/print.RPolarsDataType/#returns","text":"self print a polars datatype","title":"Returns"},{"location":"reference/print.RPolarsDataType/#examples","text":"pl $ dtypes $ Boolean #implicit print #> DataType: Boolean","title":"Examples"},{"location":"reference/print.When/","text":"print When ## S3 method for class 'When' print ( x , ... ) Arguments x : When object ... : not used Returns self print When Examples print ( pl $ when ( pl $ col ( \"a\" ) > 2 ) ) #> polars When { predicate: Expr([(col(\"a\")) > (2f64)]) }","title":"print.When"},{"location":"reference/print.When/#print-when","text":"## S3 method for class 'When' print ( x , ... )","title":"print When"},{"location":"reference/print.When/#arguments","text":"x : When object ... : not used","title":"Arguments"},{"location":"reference/print.When/#returns","text":"self print When","title":"Returns"},{"location":"reference/print.When/#examples","text":"print ( pl $ when ( pl $ col ( \"a\" ) > 2 ) ) #> polars When { predicate: Expr([(col(\"a\")) > (2f64)]) }","title":"Examples"},{"location":"reference/print.WhenThen/","text":"print When ## S3 method for class 'WhenThen' print ( x , ... ) Arguments x : When object ... : not used Returns self print When Examples print ( pl $ when ( pl $ col ( \"a\" ) > 2 ) $ then ( pl $ lit ( \"more than two\" ) ) ) #> polars WhenThen { predicate: Expr([(col(\"a\")) > (2f64)]), then: Expr(Utf8(more than two)) }","title":"print.WhenThen"},{"location":"reference/print.WhenThen/#print-when","text":"## S3 method for class 'WhenThen' print ( x , ... )","title":"print When"},{"location":"reference/print.WhenThen/#arguments","text":"x : When object ... : not used","title":"Arguments"},{"location":"reference/print.WhenThen/#returns","text":"self print When","title":"Returns"},{"location":"reference/print.WhenThen/#examples","text":"print ( pl $ when ( pl $ col ( \"a\" ) > 2 ) $ then ( pl $ lit ( \"more than two\" ) ) ) #> polars WhenThen { predicate: Expr([(col(\"a\")) > (2f64)]), then: Expr(Utf8(more than two)) }","title":"Examples"},{"location":"reference/print.WhenThenThen/","text":"print When ## S3 method for class 'WhenThenThen' print ( x , ... ) Arguments x : When object ... : not used Returns self print When Examples # print ( pl $ when ( pl $ col ( \"a\" ) > 2 ) $ then ( pl $ lit ( \"more than two\" ) ) $ when ( pl $ col ( \"b\" ) < 5 ) ) #> polars Polars WhenThenThen","title":"print.WhenThenThen"},{"location":"reference/print.WhenThenThen/#print-when","text":"## S3 method for class 'WhenThenThen' print ( x , ... )","title":"print When"},{"location":"reference/print.WhenThenThen/#arguments","text":"x : When object ... : not used","title":"Arguments"},{"location":"reference/print.WhenThenThen/#returns","text":"self print When","title":"Returns"},{"location":"reference/print.WhenThenThen/#examples","text":"# print ( pl $ when ( pl $ col ( \"a\" ) > 2 ) $ then ( pl $ lit ( \"more than two\" ) ) $ when ( pl $ col ( \"b\" ) < 5 ) ) #> polars Polars WhenThenThen","title":"Examples"},{"location":"reference/print_env/","text":"print recursively an environment, used in some documentation print_env ( api , name , max_depth = 10 ) Arguments api : env name : name of env max_depth : numeric/int max levels to recursive iterate through print recursively an environment, used in some documentation","title":"print_env"},{"location":"reference/print_env/#print-recursively-an-environment-used-in-some-documentation","text":"print_env ( api , name , max_depth = 10 )","title":"print recursively an environment, used in some documentation"},{"location":"reference/print_env/#arguments","text":"api : env name : name of env max_depth : numeric/int max levels to recursive iterate through print recursively an environment, used in some documentation","title":"Arguments"},{"location":"reference/pstop/","text":"Internal preferred function to throw errors pstop ( err , call = sys.call ( 1L )) Arguments err : error msg string call : calling context Returns throws an error DEPRECATED USE stopf instead Examples f = function ( ) polars ::: pstop ( \"this aint right!!\" ) tryCatch ( f ( ) , error = \\ ( e ) as.character ( e ) ) #> [1] \"Error: Internal error: cannot unwrap non result\\n\"","title":"pstop"},{"location":"reference/pstop/#internal-preferred-function-to-throw-errors","text":"pstop ( err , call = sys.call ( 1L ))","title":"Internal preferred function to throw errors"},{"location":"reference/pstop/#arguments","text":"err : error msg string call : calling context","title":"Arguments"},{"location":"reference/pstop/#returns","text":"throws an error DEPRECATED USE stopf instead","title":"Returns"},{"location":"reference/pstop/#examples","text":"f = function ( ) polars ::: pstop ( \"this aint right!!\" ) tryCatch ( f ( ) , error = \\ ( e ) as.character ( e ) ) #> [1] \"Error: Internal error: cannot unwrap non result\\n\"","title":"Examples"},{"location":"reference/read_csv_/","text":"high level csv_reader, will download if path is url read_csv_ ( path , lazy = FALSE , reuse_downloaded = TRUE , ... ) Arguments path : file or url lazy : bool default FALSE, read csv lazy reuse_downloaded : bool default TRUE, cache url downloaded files in session an reuse ... : arguments forwarded to csv_reader or lazy_csv_reader Returns polars_DataFrame or polars_lazy_DataFrame high level csv_reader, will download if path is url Examples df = pl $ read_csv ( \"https://j.mp/iriscsv\" ) #> tmp file placed in #> C:\\Users\\etienne\\AppData\\Local\\Temp\\Rtmpq68bWo/https...j.mp.iriscsv","title":"read_csv_"},{"location":"reference/read_csv_/#high-level-csv_reader-will-download-if-path-is-url","text":"read_csv_ ( path , lazy = FALSE , reuse_downloaded = TRUE , ... )","title":"high level csv_reader, will download if path is url"},{"location":"reference/read_csv_/#arguments","text":"path : file or url lazy : bool default FALSE, read csv lazy reuse_downloaded : bool default TRUE, cache url downloaded files in session an reuse ... : arguments forwarded to csv_reader or lazy_csv_reader","title":"Arguments"},{"location":"reference/read_csv_/#returns","text":"polars_DataFrame or polars_lazy_DataFrame high level csv_reader, will download if path is url","title":"Returns"},{"location":"reference/read_csv_/#examples","text":"df = pl $ read_csv ( \"https://j.mp/iriscsv\" ) #> tmp file placed in #> C:\\Users\\etienne\\AppData\\Local\\Temp\\Rtmpq68bWo/https...j.mp.iriscsv","title":"Examples"},{"location":"reference/replace_private_with_pub_methods/","text":"replace private class-methods with public replace_private_with_pub_methods ( env , class_pattern , keep = c (), remove_f = FALSE ) Arguments env : class envrionment to modify. Envs are mutable so no return needed class_pattern : a regex string matching declared public functions of that class keep : list of unmentioned methods to keep in public api remove_f : bool if true, will move methods, not copy Returns side effects only extendr places the naked internal calls to rust in env-classes. This function can be used to delete them and replaces them with the public methods. Which are any function matching pattern typically '^CLASSNAME' e.g. '^DataFrame_' or '^Series_'. Likely only used in zzz.R","title":"replace_private_with_pub_methods"},{"location":"reference/replace_private_with_pub_methods/#replace-private-class-methods-with-public","text":"replace_private_with_pub_methods ( env , class_pattern , keep = c (), remove_f = FALSE )","title":"replace private class-methods with public"},{"location":"reference/replace_private_with_pub_methods/#arguments","text":"env : class envrionment to modify. Envs are mutable so no return needed class_pattern : a regex string matching declared public functions of that class keep : list of unmentioned methods to keep in public api remove_f : bool if true, will move methods, not copy","title":"Arguments"},{"location":"reference/replace_private_with_pub_methods/#returns","text":"side effects only extendr places the naked internal calls to rust in env-classes. This function can be used to delete them and replaces them with the public methods. Which are any function matching pattern typically '^CLASSNAME' e.g. '^DataFrame_' or '^Series_'. Likely only used in zzz.R","title":"Returns"},{"location":"reference/restruct_list/","text":"restruct list restruct_list ( l ) Arguments l : list Returns restructed list lifecycle:: Deprecate Restruct an object where structs where previously unnested Details It was much easier impl export unnested struct from polars. This function restructs exported unnested structs. This function should be repalced with rust code writing this output directly before nesting. This hack relies on rust uses the tag \"is_struct\" to mark what should be re-structed.","title":"restruct_list"},{"location":"reference/restruct_list/#restruct-list","text":"restruct_list ( l )","title":"restruct list"},{"location":"reference/restruct_list/#arguments","text":"l : list","title":"Arguments"},{"location":"reference/restruct_list/#returns","text":"restructed list lifecycle:: Deprecate Restruct an object where structs where previously unnested","title":"Returns"},{"location":"reference/restruct_list/#details","text":"It was much easier impl export unnested struct from polars. This function restructs exported unnested structs. This function should be repalced with rust code writing this output directly before nesting. This hack relies on rust uses the tag \"is_struct\" to mark what should be re-structed.","title":"Details"},{"location":"reference/same_outer_datatype/","text":"check if x is a valid RPolarsDataType Arguments lhs : an RPolarsDataType rhs : an RPolarsDataType Returns bool TRUE if outer datatype is the same. check if x is a valid RPolarsDataType Examples # TRUE pl $ same_outer_dt ( pl $ Datetime ( \"us\" ) , pl $ Datetime ( \"ms\" ) ) #> [1] TRUE pl $ same_outer_dt ( pl $ List ( pl $ Int64 ) , pl $ List ( pl $ Float32 ) ) #> [1] TRUE #FALSE pl $ same_outer_dt ( pl $ Int64 , pl $ Float64 ) #> [1] FALSE","title":"same_outer_datatype"},{"location":"reference/same_outer_datatype/#check-if-x-is-a-valid-rpolarsdatatype","text":"","title":"check if x is a valid RPolarsDataType"},{"location":"reference/same_outer_datatype/#arguments","text":"lhs : an RPolarsDataType rhs : an RPolarsDataType","title":"Arguments"},{"location":"reference/same_outer_datatype/#returns","text":"bool TRUE if outer datatype is the same. check if x is a valid RPolarsDataType","title":"Returns"},{"location":"reference/same_outer_datatype/#examples","text":"# TRUE pl $ same_outer_dt ( pl $ Datetime ( \"us\" ) , pl $ Datetime ( \"ms\" ) ) #> [1] TRUE pl $ same_outer_dt ( pl $ List ( pl $ Int64 ) , pl $ List ( pl $ Float32 ) ) #> [1] TRUE #FALSE pl $ same_outer_dt ( pl $ Int64 , pl $ Float64 ) #> [1] FALSE","title":"Examples"},{"location":"reference/scan_arrow_ipc/","text":"Import data in Apache Arrow IPC format scan_arrow_ipc ( path , n_rows = NULL , cache = TRUE , rechunk = TRUE , row_count_name = NULL , row_count_offset = 0L , memmap = TRUE ) Arguments path : string, path n_rows : integer, limit rows to scan cache : bool, use cache rechunk : bool, rechunk reorganize memory layout, potentially make future operations faster, however perform reallocation now. row_count_name : NULL or string, if a string add a rowcount column named by this string row_count_offset : integer, the rowcount column can be offst by this value memmap : bool, mapped memory Returns LazyFrame Import data in Apache Arrow IPC format Details Create new LazyFrame from Apache Arrow IPC file or stream","title":"scan_arrow_ipc"},{"location":"reference/scan_arrow_ipc/#import-data-in-apache-arrow-ipc-format","text":"scan_arrow_ipc ( path , n_rows = NULL , cache = TRUE , rechunk = TRUE , row_count_name = NULL , row_count_offset = 0L , memmap = TRUE )","title":"Import data in Apache Arrow IPC format"},{"location":"reference/scan_arrow_ipc/#arguments","text":"path : string, path n_rows : integer, limit rows to scan cache : bool, use cache rechunk : bool, rechunk reorganize memory layout, potentially make future operations faster, however perform reallocation now. row_count_name : NULL or string, if a string add a rowcount column named by this string row_count_offset : integer, the rowcount column can be offst by this value memmap : bool, mapped memory","title":"Arguments"},{"location":"reference/scan_arrow_ipc/#returns","text":"LazyFrame Import data in Apache Arrow IPC format","title":"Returns"},{"location":"reference/scan_arrow_ipc/#details","text":"Create new LazyFrame from Apache Arrow IPC file or stream","title":"Details"},{"location":"reference/scan_parquet/","text":"new LazyFrame from parquet file scan_parquet ( file , n_rows = NULL , cache = TRUE , parallel = c ( \"Auto\" , \"None\" , \"Columns\" , \"RowGroups\" ), rechunk = TRUE , row_count_name = NULL , row_count_offset = 0L , low_memory = FALSE ) Arguments file : string filepath n_rows : limit rows to scan cache : bool use cache parallel : String either Auto, None, Columns or RowGroups. The way to parralize the scan. rechunk : bool rechunk reorganize memory layout, potentially make future operations faster , however perform reallocation now. row_count_name : NULL or string, if a string add a rowcount column named by this string row_count_offset : integer, the rowcount column can be offst by this value low_memory : bool, try reduce memory footprint Returns LazyFrame new LazyFrame from parquet file Examples #TODO write parquet example","title":"scan_parquet"},{"location":"reference/scan_parquet/#new-lazyframe-from-parquet-file","text":"scan_parquet ( file , n_rows = NULL , cache = TRUE , parallel = c ( \"Auto\" , \"None\" , \"Columns\" , \"RowGroups\" ), rechunk = TRUE , row_count_name = NULL , row_count_offset = 0L , low_memory = FALSE )","title":"new LazyFrame from parquet file"},{"location":"reference/scan_parquet/#arguments","text":"file : string filepath n_rows : limit rows to scan cache : bool use cache parallel : String either Auto, None, Columns or RowGroups. The way to parralize the scan. rechunk : bool rechunk reorganize memory layout, potentially make future operations faster , however perform reallocation now. row_count_name : NULL or string, if a string add a rowcount column named by this string row_count_offset : integer, the rowcount column can be offst by this value low_memory : bool, try reduce memory footprint","title":"Arguments"},{"location":"reference/scan_parquet/#returns","text":"LazyFrame new LazyFrame from parquet file","title":"Returns"},{"location":"reference/scan_parquet/#examples","text":"#TODO write parquet example","title":"Examples"},{"location":"reference/str_string/","text":"Simple viewer of an R object based on str() str_string ( x , collapse = \" \" ) Arguments x : object to view. collapse : word to glue possible multilines with Returns string Simple viewer of an R object based on str() Examples polars ::: str_string ( list ( a = 42 , c ( 1 , 2 , 3 , NA ) ) ) #> [1] \"List of 2 $ a: num 42 $ : num [1:4] 1 2 3 NA\"","title":"str_string"},{"location":"reference/str_string/#simple-viewer-of-an-r-object-based-on-str","text":"str_string ( x , collapse = \" \" )","title":"Simple viewer of an R object based on str()"},{"location":"reference/str_string/#arguments","text":"x : object to view. collapse : word to glue possible multilines with","title":"Arguments"},{"location":"reference/str_string/#returns","text":"string Simple viewer of an R object based on str()","title":"Returns"},{"location":"reference/str_string/#examples","text":"polars ::: str_string ( list ( a = 42 , c ( 1 , 2 , 3 , NA ) ) ) #> [1] \"List of 2 $ a: num 42 $ : num [1:4] 1 2 3 NA\"","title":"Examples"},{"location":"reference/struct/","text":"struct Arguments exprs : Columns/Expressions to collect into a Struct. eager : Evaluate immediately. schema : Optional schema named list that explicitly defines the struct field dtypes. Each name must match a column name wrapped in the struct. Can only be used to cast some or all dtypes, not to change the names. NULL means to include keep columns into the struct by their current DataType. If a column is not included in the schema it is removed from the final struct. Returns Eager=FALSE: Expr of Series with dtype Struct | Eager=TRUE: Series with dtype Struct Collect several columns into a Series of dtype Struct. Details pl$struct creates Expr or Series of DataType Struct() pl$Struct creates the DataType Struct() In polars a schema is a named list of DataTypes. #' A schema describes e.g. a DataFrame. More formally schemas consist of Fields. A Field is an object describing the name and DataType of a column/Series, but same same. A struct is a DataFrame wrapped into a Series, the DataType is Struct, and each sub-datatype within are Fields. In a dynamic language schema and a Struct (the DataType) are quite the same, except schemas describe DataFrame and Struct's describe some Series. Examples #isolated expression to wrap all columns in a struct aliased 'my_struct' pl $ struct ( pl $ all ( ) ) $ alias ( \"my_struct\" ) #> polars Expr: *.as_struct().alias(\"my_struct\") #wrap all column into on column/Series df = pl $ DataFrame ( int = 1 : 2 , str = c ( \"a\" , \"b\" ) , bool = c ( TRUE , NA ) , list = list ( 1 : 2 , 3L ) ) $ select ( pl $ struct ( pl $ all ( ) ) $ alias ( \"my_struct\" ) ) print ( df ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 my_struct \u2502 #> \u2502 --- \u2502 #> \u2502 struct[4] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {1,\"a\",true,[1, 2]} \u2502 #> \u2502 {2,\"b\",null,[3]} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 print ( df $ schema ) #returns a schema, a named list containing one element a Struct named my_struct #> $my_struct #> DataType: Struct( #> [ #> Field { #> name: \"int\", #> dtype: Int32, #> }, #> Field { #> name: \"str\", #> dtype: Utf8, #> }, #> Field { #> name: \"bool\", #> dtype: Boolean, #> }, #> Field { #> name: \"list\", #> dtype: List( #> Int32, #> ), #> }, #> ], #> ) #> # wrap two columns in a struct and provide a schema to set all or some DataTypes by name e1 = pl $ struct ( pl $ col ( c ( \"int\" , \"str\" ) ) , schema = list ( int = pl $ Int64 , str = pl $ Utf8 ) ) $ alias ( \"my_struct\" ) # same result as e.g. wrapping the columns in a struct and casting afterwards e2 = pl $ struct ( list ( pl $ col ( \"int\" ) , pl $ col ( \"str\" ) ) ) $ cast ( pl $ Struct ( int = pl $ Int64 ,str = pl $ Utf8 ) ) $ alias ( \"my_struct\" ) df = pl $ DataFrame ( int = 1 : 2 , str = c ( \"a\" , \"b\" ) , bool = c ( TRUE , NA ) , list = list ( 1 : 2 , 3L ) ) #verify equality in R identical ( df $ select ( e1 ) $ to_list ( ) , df $ select ( e2 ) $ to_list ( ) ) #> [1] TRUE df $ select ( e2 ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 my_struct \u2502 #> \u2502 --- \u2502 #> \u2502 struct[2] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {1,\"a\"} \u2502 #> \u2502 {2,\"b\"} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( e2 ) $ as_data_frame ( ) #> my_struct #> 1 4.94065645841247e-324, a #> 2 9.88131291682493e-324, b","title":"struct"},{"location":"reference/struct/#struct","text":"","title":"struct"},{"location":"reference/struct/#arguments","text":"exprs : Columns/Expressions to collect into a Struct. eager : Evaluate immediately. schema : Optional schema named list that explicitly defines the struct field dtypes. Each name must match a column name wrapped in the struct. Can only be used to cast some or all dtypes, not to change the names. NULL means to include keep columns into the struct by their current DataType. If a column is not included in the schema it is removed from the final struct.","title":"Arguments"},{"location":"reference/struct/#returns","text":"Eager=FALSE: Expr of Series with dtype Struct | Eager=TRUE: Series with dtype Struct Collect several columns into a Series of dtype Struct.","title":"Returns"},{"location":"reference/struct/#details","text":"pl$struct creates Expr or Series of DataType Struct() pl$Struct creates the DataType Struct() In polars a schema is a named list of DataTypes. #' A schema describes e.g. a DataFrame. More formally schemas consist of Fields. A Field is an object describing the name and DataType of a column/Series, but same same. A struct is a DataFrame wrapped into a Series, the DataType is Struct, and each sub-datatype within are Fields. In a dynamic language schema and a Struct (the DataType) are quite the same, except schemas describe DataFrame and Struct's describe some Series.","title":"Details"},{"location":"reference/struct/#examples","text":"#isolated expression to wrap all columns in a struct aliased 'my_struct' pl $ struct ( pl $ all ( ) ) $ alias ( \"my_struct\" ) #> polars Expr: *.as_struct().alias(\"my_struct\") #wrap all column into on column/Series df = pl $ DataFrame ( int = 1 : 2 , str = c ( \"a\" , \"b\" ) , bool = c ( TRUE , NA ) , list = list ( 1 : 2 , 3L ) ) $ select ( pl $ struct ( pl $ all ( ) ) $ alias ( \"my_struct\" ) ) print ( df ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 my_struct \u2502 #> \u2502 --- \u2502 #> \u2502 struct[4] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {1,\"a\",true,[1, 2]} \u2502 #> \u2502 {2,\"b\",null,[3]} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 print ( df $ schema ) #returns a schema, a named list containing one element a Struct named my_struct #> $my_struct #> DataType: Struct( #> [ #> Field { #> name: \"int\", #> dtype: Int32, #> }, #> Field { #> name: \"str\", #> dtype: Utf8, #> }, #> Field { #> name: \"bool\", #> dtype: Boolean, #> }, #> Field { #> name: \"list\", #> dtype: List( #> Int32, #> ), #> }, #> ], #> ) #> # wrap two columns in a struct and provide a schema to set all or some DataTypes by name e1 = pl $ struct ( pl $ col ( c ( \"int\" , \"str\" ) ) , schema = list ( int = pl $ Int64 , str = pl $ Utf8 ) ) $ alias ( \"my_struct\" ) # same result as e.g. wrapping the columns in a struct and casting afterwards e2 = pl $ struct ( list ( pl $ col ( \"int\" ) , pl $ col ( \"str\" ) ) ) $ cast ( pl $ Struct ( int = pl $ Int64 ,str = pl $ Utf8 ) ) $ alias ( \"my_struct\" ) df = pl $ DataFrame ( int = 1 : 2 , str = c ( \"a\" , \"b\" ) , bool = c ( TRUE , NA ) , list = list ( 1 : 2 , 3L ) ) #verify equality in R identical ( df $ select ( e1 ) $ to_list ( ) , df $ select ( e2 ) $ to_list ( ) ) #> [1] TRUE df $ select ( e2 ) #> polars DataFrame: shape: (2, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 my_struct \u2502 #> \u2502 --- \u2502 #> \u2502 struct[2] \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 {1,\"a\"} \u2502 #> \u2502 {2,\"b\"} \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 df $ select ( e2 ) $ as_data_frame ( ) #> my_struct #> 1 4.94065645841247e-324, a #> 2 9.88131291682493e-324, b","title":"Examples"},{"location":"reference/sum/","text":"sum across expressions / literals / Series Arguments ... : is a: If one arg: Series or Expr, same as column$sum() string, same as pl$col(column)$sum() numeric, same as pl$lit(column)$sum() list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ... If several args, then wrapped in a list and handled as above. Returns Expr syntactic sugar for starting a expression with sum Examples #column as string pl $ DataFrame ( iris ) $ select ( pl $ sum ( \"Petal.Width\" ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Petal.Width \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 179.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #column as Expr (prefer pl$col(\"Petal.Width\")$sum()) pl $ DataFrame ( iris ) $ select ( pl $ sum ( pl $ col ( \"Petal.Width\" ) ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Petal.Width \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 179.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #column as numeric pl $ DataFrame ( ) $ select ( pl $ sum ( 1 : 5 ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 15 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 #column as list pl $ DataFrame ( a = 1 : 2 ,b = 3 : 4 ,c = 5 : 6 ) $ with_column ( pl $ sum ( list ( \"a\" , \"c\" ) ) ) #> polars DataFrame: shape: (2, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 sum \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 3 \u2506 5 \u2506 6 \u2502 #> \u2502 2 \u2506 4 \u2506 6 \u2506 8 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( a = 1 : 2 ,b = 3 : 4 ,c = 5 : 6 ) $ with_column ( pl $ sum ( list ( \"a\" , \"c\" , 42L ) ) ) #> polars DataFrame: shape: (2, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 sum \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 3 \u2506 5 \u2506 48 \u2502 #> \u2502 2 \u2506 4 \u2506 6 \u2506 50 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 #three eqivalent lines pl $ DataFrame ( a = 1 : 2 ,b = 3 : 4 ,c = 5 : 6 ) $ with_column ( pl $ sum ( list ( \"a\" , \"c\" , pl $ sum ( list ( \"a\" , \"b\" , \"c\" ) ) ) ) ) #> polars DataFrame: shape: (2, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 sum \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 3 \u2506 5 \u2506 15 \u2502 #> \u2502 2 \u2506 4 \u2506 6 \u2506 20 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( a = 1 : 2 ,b = 3 : 4 ,c = 5 : 6 ) $ with_column ( pl $ sum ( list ( pl $ col ( \"a\" ) + pl $ col ( \"b\" ) , \"c\" ) ) ) #> polars DataFrame: shape: (2, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 sum \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 3 \u2506 5 \u2506 9 \u2502 #> \u2502 2 \u2506 4 \u2506 6 \u2506 12 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( a = 1 : 2 ,b = 3 : 4 ,c = 5 : 6 ) $ with_column ( pl $ sum ( list ( \"*\" ) ) ) #> polars DataFrame: shape: (2, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 sum \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 3 \u2506 5 \u2506 9 \u2502 #> \u2502 2 \u2506 4 \u2506 6 \u2506 12 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518","title":"sum"},{"location":"reference/sum/#sum-across-expressions-literals-series","text":"","title":"sum across expressions / literals / Series"},{"location":"reference/sum/#arguments","text":"... : is a: If one arg: Series or Expr, same as column$sum() string, same as pl$col(column)$sum() numeric, same as pl$lit(column)$sum() list of strings(column names) or exprressions to add up as expr1 + expr2 + expr3 + ... If several args, then wrapped in a list and handled as above.","title":"Arguments"},{"location":"reference/sum/#returns","text":"Expr syntactic sugar for starting a expression with sum","title":"Returns"},{"location":"reference/sum/#examples","text":"#column as string pl $ DataFrame ( iris ) $ select ( pl $ sum ( \"Petal.Width\" ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Petal.Width \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 179.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #column as Expr (prefer pl$col(\"Petal.Width\")$sum()) pl $ DataFrame ( iris ) $ select ( pl $ sum ( pl $ col ( \"Petal.Width\" ) ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 Petal.Width \u2502 #> \u2502 --- \u2502 #> \u2502 f64 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 179.9 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 #column as numeric pl $ DataFrame ( ) $ select ( pl $ sum ( 1 : 5 ) ) #> polars DataFrame: shape: (1, 1) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 \u2502 #> \u2502 --- \u2502 #> \u2502 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 15 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2518 #column as list pl $ DataFrame ( a = 1 : 2 ,b = 3 : 4 ,c = 5 : 6 ) $ with_column ( pl $ sum ( list ( \"a\" , \"c\" ) ) ) #> polars DataFrame: shape: (2, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 sum \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 3 \u2506 5 \u2506 6 \u2502 #> \u2502 2 \u2506 4 \u2506 6 \u2506 8 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( a = 1 : 2 ,b = 3 : 4 ,c = 5 : 6 ) $ with_column ( pl $ sum ( list ( \"a\" , \"c\" , 42L ) ) ) #> polars DataFrame: shape: (2, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 sum \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 3 \u2506 5 \u2506 48 \u2502 #> \u2502 2 \u2506 4 \u2506 6 \u2506 50 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 #three eqivalent lines pl $ DataFrame ( a = 1 : 2 ,b = 3 : 4 ,c = 5 : 6 ) $ with_column ( pl $ sum ( list ( \"a\" , \"c\" , pl $ sum ( list ( \"a\" , \"b\" , \"c\" ) ) ) ) ) #> polars DataFrame: shape: (2, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 sum \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 3 \u2506 5 \u2506 15 \u2502 #> \u2502 2 \u2506 4 \u2506 6 \u2506 20 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( a = 1 : 2 ,b = 3 : 4 ,c = 5 : 6 ) $ with_column ( pl $ sum ( list ( pl $ col ( \"a\" ) + pl $ col ( \"b\" ) , \"c\" ) ) ) #> polars DataFrame: shape: (2, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 sum \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 3 \u2506 5 \u2506 9 \u2502 #> \u2502 2 \u2506 4 \u2506 6 \u2506 12 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 pl $ DataFrame ( a = 1 : 2 ,b = 3 : 4 ,c = 5 : 6 ) $ with_column ( pl $ sum ( list ( \"*\" ) ) ) #> polars DataFrame: shape: (2, 4) #> \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 a \u2506 b \u2506 c \u2506 sum \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 i32 \u2506 i32 \u2506 i32 \u2506 i32 \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 1 \u2506 3 \u2506 5 \u2506 9 \u2502 #> \u2502 2 \u2506 4 \u2506 6 \u2506 12 \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/tick-set-_DataFrame-tick/","text":"generic setter method ## S3 replacement method for class 'DataFrame' self $ name <- value Arguments self : DataFrame name : name method/property to set value : value to insert Returns value set value of properties of DataFrames Details settable polars object properties may appear to be R objects, but they are not. See [[method_name]] example Examples #For internal use #is only activated for following methods of DataFrame ls ( polars ::: DataFrame.property_setters ) #> [1] \"columns\" #specific use case for one object property 'columns' (names) df = pl $ DataFrame ( iris ) #get values df $ columns #> [1] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" \"Species\" #set + get values df $ columns = letters [ 1 : 5 ] #<- is fine too df $ columns #> [1] \"a\" \"b\" \"c\" \"d\" \"e\" # Rstudio is not using the standard R code completion tool # and it will backtick any special characters. It is possible # to completely customize the R / Rstudio code completion except # it will trigger Rstudio to backtick any completion! Also R does # not support package isolated customization. #Concrete example if tabbing on 'df$' the raw R suggestion is df$columns<- #however Rstudio backticks it into df$`columns<-` #to make life simple, this is valid polars syntax also, and can be used in fast scripting df $ `columns<-` = letters [ 5 : 1 ] #for stable code prefer e.g. df$columns = letters[5:1] #to see inside code of a property use the [[]] syntax instead df [[ \"columns\" ] ] # to see property code, .pr is the internal polars api into rust polars #> function() { #> .pr$DataFrame$columns(self) #> } #> <environment: 0x00000185db641788> #> attr(,\"class\") #> [1] \"setter\" \"property\" \"function\" polars ::: DataFrame.property_setters $ columns #and even more obscure to see setter code #> function(self, names) unwrap(.pr$DataFrame$set_column_names_mut(self,names)) #> <environment: namespace:polars>","title":"tick-set-_DataFrame-tick"},{"location":"reference/tick-set-_DataFrame-tick/#generic-setter-method","text":"## S3 replacement method for class 'DataFrame' self $ name <- value","title":"generic setter method"},{"location":"reference/tick-set-_DataFrame-tick/#arguments","text":"self : DataFrame name : name method/property to set value : value to insert","title":"Arguments"},{"location":"reference/tick-set-_DataFrame-tick/#returns","text":"value set value of properties of DataFrames","title":"Returns"},{"location":"reference/tick-set-_DataFrame-tick/#details","text":"settable polars object properties may appear to be R objects, but they are not. See [[method_name]] example","title":"Details"},{"location":"reference/tick-set-_DataFrame-tick/#examples","text":"#For internal use #is only activated for following methods of DataFrame ls ( polars ::: DataFrame.property_setters ) #> [1] \"columns\" #specific use case for one object property 'columns' (names) df = pl $ DataFrame ( iris ) #get values df $ columns #> [1] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" \"Species\" #set + get values df $ columns = letters [ 1 : 5 ] #<- is fine too df $ columns #> [1] \"a\" \"b\" \"c\" \"d\" \"e\" # Rstudio is not using the standard R code completion tool # and it will backtick any special characters. It is possible # to completely customize the R / Rstudio code completion except # it will trigger Rstudio to backtick any completion! Also R does # not support package isolated customization. #Concrete example if tabbing on 'df$' the raw R suggestion is df$columns<- #however Rstudio backticks it into df$`columns<-` #to make life simple, this is valid polars syntax also, and can be used in fast scripting df $ `columns<-` = letters [ 5 : 1 ] #for stable code prefer e.g. df$columns = letters[5:1] #to see inside code of a property use the [[]] syntax instead df [[ \"columns\" ] ] # to see property code, .pr is the internal polars api into rust polars #> function() { #> .pr$DataFrame$columns(self) #> } #> <environment: 0x00000185db641788> #> attr(,\"class\") #> [1] \"setter\" \"property\" \"function\" polars ::: DataFrame.property_setters $ columns #and even more obscure to see setter code #> function(self, names) unwrap(.pr$DataFrame$set_column_names_mut(self,names)) #> <environment: namespace:polars>","title":"Examples"},{"location":"reference/to_list/","text":"return polars DataFrame as R lit of vectors DataFrame_to_list ( unnest_structs = TRUE ) Arguments unnest_structs : bool default true, as calling $unnest() on any struct column Returns R list of vectors return polars DataFrame as R lit of vectors Details This implementation for simplicity reasons relies on unnesting all structs before exporting to R. unnest_structs = FALSE, the previous struct columns will be re- nested. A struct in a R is a lists of lists, where each row is a list of values. Such a structure is not very typical or efficient in R. Examples pl $ DataFrame ( iris ) $ to_list ( ) #> $Sepal.Length #> [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 #> [30] 4.7 4.8 5.4 5.2 5.5 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 6.5 5.7 6.3 4.9 #> [59] 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 #> [88] 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 #> [117] 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 #> [146] 6.7 6.3 6.5 6.2 5.9 #> #> $Sepal.Width #> [1] 3.5 3.0 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 3.7 3.4 3.0 3.0 4.0 4.4 3.9 3.5 3.8 3.8 3.4 3.7 3.6 3.3 3.4 3.0 3.4 3.5 3.4 #> [30] 3.2 3.1 3.4 4.1 4.2 3.1 3.2 3.5 3.6 3.0 3.4 3.5 2.3 3.2 3.5 3.8 3.0 3.8 3.2 3.7 3.3 3.2 3.2 3.1 2.3 2.8 2.8 3.3 2.4 #> [59] 2.9 2.7 2.0 3.0 2.2 2.9 2.9 3.1 3.0 2.7 2.2 2.5 3.2 2.8 2.5 2.8 2.9 3.0 2.8 3.0 2.9 2.6 2.4 2.4 2.7 2.7 3.0 3.4 3.1 #> [88] 2.3 3.0 2.5 2.6 3.0 2.6 2.3 2.7 3.0 2.9 2.9 2.5 2.8 3.3 2.7 3.0 2.9 3.0 3.0 2.5 2.9 2.5 3.6 3.2 2.7 3.0 2.5 2.8 3.2 #> [117] 3.0 3.8 2.6 2.2 3.2 2.8 2.8 2.7 3.3 3.2 2.8 3.0 2.8 3.0 2.8 3.8 2.8 2.8 2.6 3.0 3.4 3.1 3.0 3.1 3.1 3.1 2.7 3.2 3.3 #> [146] 3.0 2.5 3.0 3.4 3.0 #> #> $Petal.Length #> [1] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 1.5 1.6 1.4 1.1 1.2 1.5 1.3 1.4 1.7 1.5 1.7 1.5 1.0 1.7 1.9 1.6 1.6 1.5 1.4 #> [30] 1.6 1.6 1.5 1.5 1.4 1.5 1.2 1.3 1.4 1.3 1.5 1.3 1.3 1.3 1.6 1.9 1.4 1.6 1.4 1.5 1.4 4.7 4.5 4.9 4.0 4.6 4.5 4.7 3.3 #> [59] 4.6 3.9 3.5 4.2 4.0 4.7 3.6 4.4 4.5 4.1 4.5 3.9 4.8 4.0 4.9 4.7 4.3 4.4 4.8 5.0 4.5 3.5 3.8 3.7 3.9 5.1 4.5 4.5 4.7 #> [88] 4.4 4.1 4.0 4.4 4.6 4.0 3.3 4.2 4.2 4.2 4.3 3.0 4.1 6.0 5.1 5.9 5.6 5.8 6.6 4.5 6.3 5.8 6.1 5.1 5.3 5.5 5.0 5.1 5.3 #> [117] 5.5 6.7 6.9 5.0 5.7 4.9 6.7 4.9 5.7 6.0 4.8 4.9 5.6 5.8 6.1 6.4 5.6 5.1 5.6 6.1 5.6 5.5 4.8 5.4 5.6 5.1 5.1 5.9 5.7 #> [146] 5.2 5.0 5.2 5.4 5.1 #> #> $Petal.Width #> [1] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 0.2 0.2 0.1 0.1 0.2 0.4 0.4 0.3 0.3 0.3 0.2 0.4 0.2 0.5 0.2 0.2 0.4 0.2 0.2 #> [30] 0.2 0.2 0.4 0.1 0.2 0.2 0.2 0.2 0.1 0.2 0.2 0.3 0.3 0.2 0.6 0.4 0.3 0.2 0.2 0.2 0.2 1.4 1.5 1.5 1.3 1.5 1.3 1.6 1.0 #> [59] 1.3 1.4 1.0 1.5 1.0 1.4 1.3 1.4 1.5 1.0 1.5 1.1 1.8 1.3 1.5 1.2 1.3 1.4 1.4 1.7 1.5 1.0 1.1 1.0 1.2 1.6 1.5 1.6 1.5 #> [88] 1.3 1.3 1.3 1.2 1.4 1.2 1.0 1.3 1.2 1.3 1.3 1.1 1.3 2.5 1.9 2.1 1.8 2.2 2.1 1.7 1.8 1.8 2.5 2.0 1.9 2.1 2.0 2.4 2.3 #> [117] 1.8 2.2 2.3 1.5 2.3 2.0 2.0 1.8 2.1 1.8 1.8 1.8 2.1 1.6 1.9 2.0 2.2 1.5 1.4 2.3 2.4 1.8 1.8 2.1 2.4 2.3 1.9 2.3 2.5 #> [146] 2.3 1.9 2.0 2.3 1.8 #> #> $Species #> [1] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa #> [11] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa #> [21] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa #> [31] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa #> [41] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa #> [51] versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor #> [61] versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor #> [71] versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor #> [81] versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor #> [91] versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor #> [101] virginica virginica virginica virginica virginica virginica virginica virginica virginica virginica #> [111] virginica virginica virginica virginica virginica virginica virginica virginica virginica virginica #> [121] virginica virginica virginica virginica virginica virginica virginica virginica virginica virginica #> [131] virginica virginica virginica virginica virginica virginica virginica virginica virginica virginica #> [141] virginica virginica virginica virginica virginica virginica virginica virginica virginica virginica #> Levels: setosa versicolor virginica #>","title":"to_list"},{"location":"reference/to_list/#return-polars-dataframe-as-r-lit-of-vectors","text":"DataFrame_to_list ( unnest_structs = TRUE )","title":"return polars DataFrame as R lit of vectors"},{"location":"reference/to_list/#arguments","text":"unnest_structs : bool default true, as calling $unnest() on any struct column","title":"Arguments"},{"location":"reference/to_list/#returns","text":"R list of vectors return polars DataFrame as R lit of vectors","title":"Returns"},{"location":"reference/to_list/#details","text":"This implementation for simplicity reasons relies on unnesting all structs before exporting to R. unnest_structs = FALSE, the previous struct columns will be re- nested. A struct in a R is a lists of lists, where each row is a list of values. Such a structure is not very typical or efficient in R.","title":"Details"},{"location":"reference/to_list/#examples","text":"pl $ DataFrame ( iris ) $ to_list ( ) #> $Sepal.Length #> [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 #> [30] 4.7 4.8 5.4 5.2 5.5 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 6.5 5.7 6.3 4.9 #> [59] 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 #> [88] 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 #> [117] 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 #> [146] 6.7 6.3 6.5 6.2 5.9 #> #> $Sepal.Width #> [1] 3.5 3.0 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 3.7 3.4 3.0 3.0 4.0 4.4 3.9 3.5 3.8 3.8 3.4 3.7 3.6 3.3 3.4 3.0 3.4 3.5 3.4 #> [30] 3.2 3.1 3.4 4.1 4.2 3.1 3.2 3.5 3.6 3.0 3.4 3.5 2.3 3.2 3.5 3.8 3.0 3.8 3.2 3.7 3.3 3.2 3.2 3.1 2.3 2.8 2.8 3.3 2.4 #> [59] 2.9 2.7 2.0 3.0 2.2 2.9 2.9 3.1 3.0 2.7 2.2 2.5 3.2 2.8 2.5 2.8 2.9 3.0 2.8 3.0 2.9 2.6 2.4 2.4 2.7 2.7 3.0 3.4 3.1 #> [88] 2.3 3.0 2.5 2.6 3.0 2.6 2.3 2.7 3.0 2.9 2.9 2.5 2.8 3.3 2.7 3.0 2.9 3.0 3.0 2.5 2.9 2.5 3.6 3.2 2.7 3.0 2.5 2.8 3.2 #> [117] 3.0 3.8 2.6 2.2 3.2 2.8 2.8 2.7 3.3 3.2 2.8 3.0 2.8 3.0 2.8 3.8 2.8 2.8 2.6 3.0 3.4 3.1 3.0 3.1 3.1 3.1 2.7 3.2 3.3 #> [146] 3.0 2.5 3.0 3.4 3.0 #> #> $Petal.Length #> [1] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 1.5 1.6 1.4 1.1 1.2 1.5 1.3 1.4 1.7 1.5 1.7 1.5 1.0 1.7 1.9 1.6 1.6 1.5 1.4 #> [30] 1.6 1.6 1.5 1.5 1.4 1.5 1.2 1.3 1.4 1.3 1.5 1.3 1.3 1.3 1.6 1.9 1.4 1.6 1.4 1.5 1.4 4.7 4.5 4.9 4.0 4.6 4.5 4.7 3.3 #> [59] 4.6 3.9 3.5 4.2 4.0 4.7 3.6 4.4 4.5 4.1 4.5 3.9 4.8 4.0 4.9 4.7 4.3 4.4 4.8 5.0 4.5 3.5 3.8 3.7 3.9 5.1 4.5 4.5 4.7 #> [88] 4.4 4.1 4.0 4.4 4.6 4.0 3.3 4.2 4.2 4.2 4.3 3.0 4.1 6.0 5.1 5.9 5.6 5.8 6.6 4.5 6.3 5.8 6.1 5.1 5.3 5.5 5.0 5.1 5.3 #> [117] 5.5 6.7 6.9 5.0 5.7 4.9 6.7 4.9 5.7 6.0 4.8 4.9 5.6 5.8 6.1 6.4 5.6 5.1 5.6 6.1 5.6 5.5 4.8 5.4 5.6 5.1 5.1 5.9 5.7 #> [146] 5.2 5.0 5.2 5.4 5.1 #> #> $Petal.Width #> [1] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 0.2 0.2 0.1 0.1 0.2 0.4 0.4 0.3 0.3 0.3 0.2 0.4 0.2 0.5 0.2 0.2 0.4 0.2 0.2 #> [30] 0.2 0.2 0.4 0.1 0.2 0.2 0.2 0.2 0.1 0.2 0.2 0.3 0.3 0.2 0.6 0.4 0.3 0.2 0.2 0.2 0.2 1.4 1.5 1.5 1.3 1.5 1.3 1.6 1.0 #> [59] 1.3 1.4 1.0 1.5 1.0 1.4 1.3 1.4 1.5 1.0 1.5 1.1 1.8 1.3 1.5 1.2 1.3 1.4 1.4 1.7 1.5 1.0 1.1 1.0 1.2 1.6 1.5 1.6 1.5 #> [88] 1.3 1.3 1.3 1.2 1.4 1.2 1.0 1.3 1.2 1.3 1.3 1.1 1.3 2.5 1.9 2.1 1.8 2.2 2.1 1.7 1.8 1.8 2.5 2.0 1.9 2.1 2.0 2.4 2.3 #> [117] 1.8 2.2 2.3 1.5 2.3 2.0 2.0 1.8 2.1 1.8 1.8 1.8 2.1 1.6 1.9 2.0 2.2 1.5 1.4 2.3 2.4 1.8 1.8 2.1 2.4 2.3 1.9 2.3 2.5 #> [146] 2.3 1.9 2.0 2.3 1.8 #> #> $Species #> [1] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa #> [11] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa #> [21] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa #> [31] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa #> [41] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa #> [51] versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor #> [61] versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor #> [71] versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor #> [81] versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor #> [91] versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor versicolor #> [101] virginica virginica virginica virginica virginica virginica virginica virginica virginica virginica #> [111] virginica virginica virginica virginica virginica virginica virginica virginica virginica virginica #> [121] virginica virginica virginica virginica virginica virginica virginica virginica virginica virginica #> [131] virginica virginica virginica virginica virginica virginica virginica virginica virginica virginica #> [141] virginica virginica virginica virginica virginica virginica virginica virginica virginica virginica #> Levels: setosa versicolor virginica #>","title":"Examples"},{"location":"reference/unAsIs/","text":"Reverts wrapping in I unAsIs ( X ) Arguments X : any Robj wrapped in `I()`` Returns X without any AsIs subclass Reverts wrapping in I Details https://stackoverflow.com/questions/12865218/getting-rid-of-asis-class-attribute","title":"unAsIs"},{"location":"reference/unAsIs/#reverts-wrapping-in-i","text":"unAsIs ( X )","title":"Reverts wrapping in I"},{"location":"reference/unAsIs/#arguments","text":"X : any Robj wrapped in `I()``","title":"Arguments"},{"location":"reference/unAsIs/#returns","text":"X without any AsIs subclass Reverts wrapping in I","title":"Returns"},{"location":"reference/unAsIs/#details","text":"https://stackoverflow.com/questions/12865218/getting-rid-of-asis-class-attribute","title":"Details"},{"location":"reference/unwrap/","text":"rust-like unwrapping of result. Useful to keep error handling on the R side. unwrap ( result , context = NULL , call = sys.call ( 1L )) Arguments result : a list here either element ok or err is NULL, or both if ok is litteral NULL context : a msg to prefix a raised error with call : context of error or string Returns the ok-element of list , or a error will be thrown rust-like unwrapping of result. Useful to keep error handling on the R side. Examples structure ( list ( ok = \"foo\" , err = NULL ) , class = \"extendr_result\" ) #> $ok #> [1] \"foo\" #> #> $err #> NULL #> #> attr(,\"class\") #> [1] \"extendr_result\" tryCatch ( unwrap ( structure ( list ( ok = NULL , err = \"something happen on the rust side\" ) , class = \"extendr_result\" ) ) , error = function ( err ) as.character ( err ) ) #> [1] \"Error: something happen on the rust side \\n when calling :\\n source(\\\"C:/Users/etienne/Desktop/Divers/r-polars/docs/make-docs.R\\\", \\n echo = TRUE)\\n\"","title":"unwrap"},{"location":"reference/unwrap/#rust-like-unwrapping-of-result-useful-to-keep-error-handling-on-the-r-side","text":"unwrap ( result , context = NULL , call = sys.call ( 1L ))","title":"rust-like unwrapping of result. Useful to keep error handling on the R side."},{"location":"reference/unwrap/#arguments","text":"result : a list here either element ok or err is NULL, or both if ok is litteral NULL context : a msg to prefix a raised error with call : context of error or string","title":"Arguments"},{"location":"reference/unwrap/#returns","text":"the ok-element of list , or a error will be thrown rust-like unwrapping of result. Useful to keep error handling on the R side.","title":"Returns"},{"location":"reference/unwrap/#examples","text":"structure ( list ( ok = \"foo\" , err = NULL ) , class = \"extendr_result\" ) #> $ok #> [1] \"foo\" #> #> $err #> NULL #> #> attr(,\"class\") #> [1] \"extendr_result\" tryCatch ( unwrap ( structure ( list ( ok = NULL , err = \"something happen on the rust side\" ) , class = \"extendr_result\" ) ) , error = function ( err ) as.character ( err ) ) #> [1] \"Error: something happen on the rust side \\n when calling :\\n source(\\\"C:/Users/etienne/Desktop/Divers/r-polars/docs/make-docs.R\\\", \\n echo = TRUE)\\n\"","title":"Examples"},{"location":"reference/verify_method_call/","text":"Verify user selected method/attribute exists verify_method_call ( Class_env , Method_name , call = sys.call ( 1L ), class_name = NULL ) Arguments Class_env : env_class object (the classes created by extendr-wrappers.R) Method_name : name of method requested by user call : context to throw user error, just use default class_name : NULLs Returns invisible(NULL) internal function to check method call of env_classes","title":"verify_method_call"},{"location":"reference/verify_method_call/#verify-user-selected-methodattribute-exists","text":"verify_method_call ( Class_env , Method_name , call = sys.call ( 1L ), class_name = NULL )","title":"Verify user selected method/attribute exists"},{"location":"reference/verify_method_call/#arguments","text":"Class_env : env_class object (the classes created by extendr-wrappers.R) Method_name : name of method requested by user call : context to throw user error, just use default class_name : NULLs","title":"Arguments"},{"location":"reference/verify_method_call/#returns","text":"invisible(NULL) internal function to check method call of env_classes","title":"Returns"},{"location":"reference/when_then_otherwise/","text":"when-then-otherwise Expr Arguments predicate : Into Expr into a boolean mask to branch by expr : Into Expr value to insert in when() or otherwise() Returns Expr Start a \u201cwhen, then, otherwise\u201d expression. Details For the impl nerds: pl$when returns a whenthen object and whenthen returns whenthenthen, except for otherwise(), which will terminate and return an Expr. Otherwise may fail to return an Expr if e.g. two consecutive when(x)$when(y) Examples df = pl $ DataFrame ( mtcars ) wtt = pl $ when ( pl $ col ( \"cyl\" ) <= 4 ) $ then ( \"<=4cyl\" ) $ when ( pl $ col ( \"cyl\" ) <= 6 ) $ then ( \"<=6cyl\" ) $ otherwise ( \">6cyl\" ) $ alias ( \"cyl_groups\" ) print ( wtt ) #> polars Expr: #> WHEN [(col(\"cyl\")) <= (4f64)] #> THEN #> Utf8(<=4cyl) #> OTHERWISE #> #> WHEN [(col(\"cyl\")) <= (6f64)] #> THEN #> Utf8(<=6cyl) #> OTHERWISE #> Utf8(>6cyl).alias(\"cyl_groups\") df $ with_columns ( wtt ) #> polars DataFrame: shape: (32, 12) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 am \u2506 gear \u2506 carb \u2506 cyl_groups \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2506 <=6cyl \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2506 <=6cyl \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2506 <=4cyl \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2506 <=6cyl \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 1.0 \u2506 5.0 \u2506 4.0 \u2506 >6cyl \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 1.0 \u2506 5.0 \u2506 6.0 \u2506 <=6cyl \u2502 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2506 >6cyl \u2502 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2506 <=4cyl \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"when_then_otherwise"},{"location":"reference/when_then_otherwise/#when-then-otherwise-expr","text":"","title":"when-then-otherwise Expr"},{"location":"reference/when_then_otherwise/#arguments","text":"predicate : Into Expr into a boolean mask to branch by expr : Into Expr value to insert in when() or otherwise()","title":"Arguments"},{"location":"reference/when_then_otherwise/#returns","text":"Expr Start a \u201cwhen, then, otherwise\u201d expression.","title":"Returns"},{"location":"reference/when_then_otherwise/#details","text":"For the impl nerds: pl$when returns a whenthen object and whenthen returns whenthenthen, except for otherwise(), which will terminate and return an Expr. Otherwise may fail to return an Expr if e.g. two consecutive when(x)$when(y)","title":"Details"},{"location":"reference/when_then_otherwise/#examples","text":"df = pl $ DataFrame ( mtcars ) wtt = pl $ when ( pl $ col ( \"cyl\" ) <= 4 ) $ then ( \"<=4cyl\" ) $ when ( pl $ col ( \"cyl\" ) <= 6 ) $ then ( \"<=6cyl\" ) $ otherwise ( \">6cyl\" ) $ alias ( \"cyl_groups\" ) print ( wtt ) #> polars Expr: #> WHEN [(col(\"cyl\")) <= (4f64)] #> THEN #> Utf8(<=4cyl) #> OTHERWISE #> #> WHEN [(col(\"cyl\")) <= (6f64)] #> THEN #> Utf8(<=6cyl) #> OTHERWISE #> Utf8(>6cyl).alias(\"cyl_groups\") df $ with_columns ( wtt ) #> polars DataFrame: shape: (32, 12) #> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 #> \u2502 mpg \u2506 cyl \u2506 disp \u2506 hp \u2506 ... \u2506 am \u2506 gear \u2506 carb \u2506 cyl_groups \u2502 #> \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502 #> \u2502 f64 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 \u2506 f64 \u2506 f64 \u2506 f64 \u2506 str \u2502 #> \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2506 <=6cyl \u2502 #> \u2502 21.0 \u2506 6.0 \u2506 160.0 \u2506 110.0 \u2506 ... \u2506 1.0 \u2506 4.0 \u2506 4.0 \u2506 <=6cyl \u2502 #> \u2502 22.8 \u2506 4.0 \u2506 108.0 \u2506 93.0 \u2506 ... \u2506 1.0 \u2506 4.0 \u2506 1.0 \u2506 <=4cyl \u2502 #> \u2502 21.4 \u2506 6.0 \u2506 258.0 \u2506 110.0 \u2506 ... \u2506 0.0 \u2506 3.0 \u2506 1.0 \u2506 <=6cyl \u2502 #> \u2502 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2506 ... \u2502 #> \u2502 15.8 \u2506 8.0 \u2506 351.0 \u2506 264.0 \u2506 ... \u2506 1.0 \u2506 5.0 \u2506 4.0 \u2506 >6cyl \u2502 #> \u2502 19.7 \u2506 6.0 \u2506 145.0 \u2506 175.0 \u2506 ... \u2506 1.0 \u2506 5.0 \u2506 6.0 \u2506 <=6cyl \u2502 #> \u2502 15.0 \u2506 8.0 \u2506 301.0 \u2506 335.0 \u2506 ... \u2506 1.0 \u2506 5.0 \u2506 8.0 \u2506 >6cyl \u2502 #> \u2502 21.4 \u2506 4.0 \u2506 121.0 \u2506 109.0 \u2506 ... \u2506 1.0 \u2506 4.0 \u2506 2.0 \u2506 <=4cyl \u2502 #> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Examples"},{"location":"reference/wrap_e/","text":"wrap as literal wrap_e ( e , str_to_lit = TRUE ) Arguments e : an Expr(polars) or any R expression Returns Expr wrap as literal Details used internally to ensure an object is an expression Examples pl $ col ( \"foo\" ) < 5 #> polars Expr: [(col(\"foo\")) < (5f64)]","title":"wrap_e"},{"location":"reference/wrap_e/#wrap-as-literal","text":"wrap_e ( e , str_to_lit = TRUE )","title":"wrap as literal"},{"location":"reference/wrap_e/#arguments","text":"e : an Expr(polars) or any R expression","title":"Arguments"},{"location":"reference/wrap_e/#returns","text":"Expr wrap as literal","title":"Returns"},{"location":"reference/wrap_e/#details","text":"used internally to ensure an object is an expression","title":"Details"},{"location":"reference/wrap_e/#examples","text":"pl $ col ( \"foo\" ) < 5 #> polars Expr: [(col(\"foo\")) < (5f64)]","title":"Examples"},{"location":"reference/wrap_e_result/","text":"wrap as Expression capture ok/err as result wrap_e_result ( e , str_to_lit = TRUE , argname = NULL ) Arguments e : an Expr(polars) or any R expression str_to_lit : bool should string become a column name or not, then a literal string argname : if error, blame argument of this name Returns Expr wrap as Expression capture ok/err as result Details used internally to ensure an object is an expression and to catch any error Examples pl $ col ( \"foo\" ) < 5 #> polars Expr: [(col(\"foo\")) < (5f64)]","title":"wrap_e_result"},{"location":"reference/wrap_e_result/#wrap-as-expression-capture-okerr-as-result","text":"wrap_e_result ( e , str_to_lit = TRUE , argname = NULL )","title":"wrap as Expression capture ok/err as result"},{"location":"reference/wrap_e_result/#arguments","text":"e : an Expr(polars) or any R expression str_to_lit : bool should string become a column name or not, then a literal string argname : if error, blame argument of this name","title":"Arguments"},{"location":"reference/wrap_e_result/#returns","text":"Expr wrap as Expression capture ok/err as result","title":"Returns"},{"location":"reference/wrap_e_result/#details","text":"used internally to ensure an object is an expression and to catch any error","title":"Details"},{"location":"reference/wrap_e_result/#examples","text":"pl $ col ( \"foo\" ) < 5 #> polars Expr: [(col(\"foo\")) < (5f64)]","title":"Examples"},{"location":"reference/wrap_elist_result/","text":"wrap_elist_result wrap_elist_result ( elist , str_to_lit = TRUE ) Arguments elist : a list Expr or any R object Into (passable to pl$lit) Returns Expr make sure all elementsof a list is wrapped as Expr Capture any conversion error in the result Details Used internally to ensure an object is a list of expression The output is wrapped in a result, which can contain an ok or err value. Examples polars ::: wrap_elist_result ( list ( pl $ lit ( 42 ) , 42 , 1 : 3 ) ) #> $ok #> $ok[[1]] #> polars Expr: 42f64 #> #> $ok[[2]] #> polars Expr: 42f64 #> #> $ok[[3]] #> polars Expr: Series #> #> #> $err #> NULL #> #> attr(,\"class\") #> [1] \"extendr_result\"","title":"wrap_elist_result"},{"location":"reference/wrap_elist_result/#wrap_elist_result","text":"wrap_elist_result ( elist , str_to_lit = TRUE )","title":"wrap_elist_result"},{"location":"reference/wrap_elist_result/#arguments","text":"elist : a list Expr or any R object Into (passable to pl$lit)","title":"Arguments"},{"location":"reference/wrap_elist_result/#returns","text":"Expr make sure all elementsof a list is wrapped as Expr Capture any conversion error in the result","title":"Returns"},{"location":"reference/wrap_elist_result/#details","text":"Used internally to ensure an object is a list of expression The output is wrapped in a result, which can contain an ok or err value.","title":"Details"},{"location":"reference/wrap_elist_result/#examples","text":"polars ::: wrap_elist_result ( list ( pl $ lit ( 42 ) , 42 , 1 : 3 ) ) #> $ok #> $ok[[1]] #> polars Expr: 42f64 #> #> $ok[[2]] #> polars Expr: 42f64 #> #> $ok[[3]] #> polars Expr: Series #> #> #> $err #> NULL #> #> attr(,\"class\") #> [1] \"extendr_result\"","title":"Examples"},{"location":"reference/wrap_proto_schema/","text":"wrap proto schema Format function wrap_proto_schema ( x ) Arguments x : either schema, or incomplete schema where dataType can be NULL or schema is just char vec, implicitly the same as if all DataType are NULL, mean undefinesd. Returns bool wrap proto schema Examples polars ::: wrap_proto_schema ( c ( \"alice\" , \"bob\" ) ) #> $alice #> NULL #> #> $bob #> NULL #> polars ::: wrap_proto_schema ( list ( \"alice\" = pl $ Int64 , \"bob\" = NULL ) ) #> $alice #> DataType: Int64 #> #> $bob #> NULL #>","title":"wrap_proto_schema"},{"location":"reference/wrap_proto_schema/#wrap-proto-schema","text":"","title":"wrap proto schema"},{"location":"reference/wrap_proto_schema/#format","text":"function wrap_proto_schema ( x )","title":"Format"},{"location":"reference/wrap_proto_schema/#arguments","text":"x : either schema, or incomplete schema where dataType can be NULL or schema is just char vec, implicitly the same as if all DataType are NULL, mean undefinesd.","title":"Arguments"},{"location":"reference/wrap_proto_schema/#returns","text":"bool wrap proto schema","title":"Returns"},{"location":"reference/wrap_proto_schema/#examples","text":"polars ::: wrap_proto_schema ( c ( \"alice\" , \"bob\" ) ) #> $alice #> NULL #> #> $bob #> NULL #> polars ::: wrap_proto_schema ( list ( \"alice\" = pl $ Int64 , \"bob\" = NULL ) ) #> $alice #> DataType: Int64 #> #> $bob #> NULL #>","title":"Examples"},{"location":"reference/wrap_s/","text":"Wrap as Series wrap_s ( x ) Arguments x : a Series or something-turned-into-Series Returns Series input is either already a Series of will be passed to the Series constructor","title":"wrap_s"},{"location":"reference/wrap_s/#wrap-as-series","text":"wrap_s ( x )","title":"Wrap as Series"},{"location":"reference/wrap_s/#arguments","text":"x : a Series or something-turned-into-Series","title":"Arguments"},{"location":"reference/wrap_s/#returns","text":"Series input is either already a Series of will be passed to the Series constructor","title":"Returns"}]}