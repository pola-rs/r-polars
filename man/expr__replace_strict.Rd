% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expr-expr.R
\name{expr__replace_strict}
\alias{expr__replace_strict}
\title{Replace all values by different values}
\usage{
expr__replace_strict(old, new, ..., default = NULL, return_dtype = NULL)
}
\arguments{
\item{old}{Value or vector of values to replace. Accepts expression input.
Vectors are parsed as Series, other non-expression inputs are parsed as
literals. Also accepts a list of values like \code{list(old = new)}.}

\item{new}{Value or vector of values to replace by. Accepts expression
input. Vectors are parsed as Series, other non-expression inputs are parsed
as literals. Length must match the length of \code{old} or have length 1.}

\item{...}{These dots are for future extensions and must be empty.}

\item{default}{Set values that were not replaced to this value. If \code{NULL}
(default), an error is raised if any values were not replaced. Accepts
expression input. Non-expression inputs are parsed as literals.}

\item{return_dtype}{The data type of the resulting expression. If \code{NULL}
(default), the data type is determined automatically based on the other
inputs.}
}
\value{
A polars \link{expression}
}
\description{
This changes all the values in a column, either using a specific replacement
or a default one. See \code{\link[=expr__replace]{$replace()}} to replace only a subset
of values.
}
\details{
The global string cache must be enabled when replacing categorical values.
}
\examples{
df <- pl$DataFrame(a = c(1, 2, 2, 3))

# "old" and "new" can take vectors of length 1 or of same length
df$with_columns(replaced = pl$col("a")$replace_strict(2, 100, default = 1))
df$with_columns(
  replaced = pl$col("a")$replace_strict(c(2, 3), c(100, 200), default = 1)
)

# "old" can be a named list where names are values to replace, and values are
# the replacements
mapping <- list(`2` = 100, `3` = 200)
df$with_columns(replaced = pl$col("a")$replace_strict(mapping, default = -1))

# By default, an error is raised if any non-null values were not replaced.
# Specify a default to set all values that were not matched.
tryCatch(
  df$with_columns(replaced = pl$col("a")$replace_strict(mapping)),
  error = function(e) print(e)
)

# one can specify the data type to return instead of automatically
# inferring it
df$with_columns(
  replaced = pl$col("a")$replace_strict(
    mapping,
    default = 1, return_dtype = pl$Int32
  )
)

# "old", "new", and "default" can take Expr
df <- pl$DataFrame(a = c(1, 2, 2, 3), b = c(1.5, 2.5, 5, 1))
df$with_columns(
  replaced = pl$col("a")$replace_strict(
    old = pl$col("a")$max(),
    new = pl$col("b")$sum(),
    default = pl$col("b"),
  )
)
}
