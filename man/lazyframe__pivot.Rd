% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lazyframe-frame.R
\name{lazyframe__pivot}
\alias{lazyframe__pivot}
\title{Pivot a frame from long to wide format}
\usage{
lazyframe__pivot(
  on,
  on_columns,
  ...,
  index = NULL,
  values = NULL,
  aggregate_function = NULL,
  maintain_order = FALSE,
  separator = "_"
)
}
\arguments{
\item{on}{The column(s) whose values will be used as the new columns of the output.}

\item{on_columns}{What value combinations will be considered for the output table.
Something can be converted to a \link{DataFrame} by
\code{as_polars_series(on_columns) |> as_polars_df()}.
If \code{on} contains multiple columns, the DataFrame passed to \code{on_columns} must have
exactly the same columns in the same order as \code{on}.
See examples for details.}

\item{...}{These dots are for future extensions and must be empty.}

\item{index}{The column(s) that remain from the input to the output. The
output will have one row for each unique combination of the \code{index}'s values.
If \code{NULL}, all remaining columns not specified in \code{on} and \code{values} will be used.
At least one of \code{index} and \code{values} must be specified.}

\item{values}{The existing column(s) of values which will be moved under the
new columns from \code{index}. If an aggregation is specified, these are the
values on which the aggregation will be computed. If \code{NULL}, all remaining
columns not specified in \code{on} and \code{index} will be used. At least one of
\code{index} and \code{values} must be specified.}

\item{aggregate_function}{Choose from:
\itemize{
\item \code{NULL} (default): no aggregation takes place, will raise error if multiple values
are in group. Same as \code{pl$element()$item(allow_empty = TRUE)}.
\item A predefined aggregate function string, one of \code{"min"}, \code{"max"},
\code{"first"}, \code{"last"}, \code{"sum"}, \code{"mean"}, \code{"median"}, \code{"len"}, \code{"item"}.
Same as \verb{pl$element()$<function>()}.
\item An \link[=Expr]{expression} to do the aggregation.
}}

\item{maintain_order}{Ensure the values of \code{index} are sorted by discovery
order.}

\item{separator}{Used as separator/delimiter in generated column names in
case of multiple values columns.}
}
\value{
A polars \link{LazyFrame}
}
\description{
Reshape data from long to wide format, known as "pivot wider".

Unlike for \link{DataFrame}, the values contained in the columns must be
specified beforehand using \code{on_columns}.
}
\examples{
\dontshow{if (exists("penguins", where = asNamespace("datasets"))) withAutoprint(\{ # examplesIf}
df <- pl$DataFrame(
  name = c("Cady", "Cady", "Karen", "Karen"),
  subject = c("maths", "physics", "maths", "physics"),
  test_1 = c(98, 99, 61, 58),
  test_2 = c(100, 100, 60, 60),
)
df

# Using `pivot`, we can reshape so we have one row per student, with different
# subjects as columns, and their `test_1` scores as values:
df$lazy()$pivot(
  "subject",
  on_columns = c("maths", "physics"),
  index = "name",
  values = "test_1",
)$collect()

# You can use selectors too - here we include all test scores in the pivoted table:
df$lazy()$pivot(
  "subject",
  on_columns = c("maths", "physics"),
  values = cs$starts_with("test"),
)$collect()

# If you end up with multiple values per cell, you can specify how to aggregate
# them with `aggregate_function`:
lf <- pl$LazyFrame(
  ix = c(1, 1, 2, 2, 1, 2),
  col = c("a", "a", "a", "a", "b", "b"),
  foo = c(0, 1, 2, 2, 7, 1),
  bar = c(0, 2, 0, 0, 9, 4),
)
lf$pivot(
  "col", on_columns = c("a", "b"), index = "ix", aggregate_function = "sum"
)$collect()

# You can also pass a custom aggregation function using `pl$element()` expressions:
lf <- pl$LazyFrame(
  col1 = c("a", "a", "a", "b", "b", "b"),
  col2 = c("x", "x", "x", "x", "y", "y"),
  col3 = c(6, 7, 3, 2, 5, 7),
)
lf$pivot(
  "col2",
  on_columns = c("x", "y"),
  index = "col1",
  values = "col3",
  aggregate_function = pl$element()$tanh()$mean(),
)$collect()

# Note that `on_columns` must contain all combinations of the values in `on`.
# For example, you can use the `expand.grid()` function to create all combinations
# of multiple columns as follows:
as_polars_lf(datasets::penguins)$pivot(
  on = c("species", "sex"),
  on_columns = expand.grid(
    species = c("Adelie", "Gentoo", "Chinstrap"),
    sex = c("male", "female")
  ),
  index = "island",
  values = "body_mass",
  aggregate_function = "mean",
)$collect()
\dontshow{\}) # examplesIf}
}
