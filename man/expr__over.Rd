% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expr-expr.R
\name{expr__over}
\alias{expr__over}
\title{Compute expressions over the given groups}
\usage{
expr__over(
  ...,
  order_by = NULL,
  mapping_strategy = c("group_to_rows", "join", "explode")
)
}
\arguments{
\item{...}{\code{\link[rlang:dyn-dots]{dynamic-dots}}> Column(s) to group by. Accepts
expression input. Characters are parsed as column names.}

\item{order_by}{Order the window functions/aggregations with the partitioned
groups by the result of the expression passed to \code{order_by}. Accepts
expression input. Strings are parsed as column names.}

\item{mapping_strategy}{One of the following:
\itemize{
\item \code{"group_to_rows"} (default): if the aggregation results in multiple values,
assign them back to their position in the DataFrame. This can only be done
if the group yields the same elements before aggregation as after.
\item \code{"join"}: join the groups as \verb{List<group_dtype>} to the row positions. Note
that this can be memory intensive.
\item \code{"explode"}: donâ€™t do any mapping, but simply flatten the group. This only
makes sense if the input data is sorted.
}}
}
\value{
A polars \link{expression}
}
\description{
This expression is similar to performing a group by aggregation and
joining the result back into the original \link[=DataFrame_class]{DataFrame}.
The outcome is similar to how window functions work in
\href{https://www.postgresql.org/docs/current/tutorial-window.html}{PostgreSQL}.
}
\examples{
# Pass the name of a column to compute the expression over that column.
df <- pl$DataFrame(
  a = c("a", "a", "b", "b", "b"),
  b = c(1, 2, 3, 5, 3),
  c = c(5, 4, 2, 1, 3)
)

df$with_columns(
  pl$col("c")$max()$over("a")$name$suffix("_max")
)

# Expression input is supported.
df$with_columns(
  pl$col("c")$max()$over(pl$col("b") \%/\% 2)$name$suffix("_max")
)

# Group by multiple columns by passing several column names a or list of
# expressions.
df$with_columns(
  pl$col("c")$min()$over("a", "b")$name$suffix("_min")
)

group_vars <- list(pl$col("a"), pl$col("b"))
df$with_columns(
  pl$col("c")$min()$over(!!!group_vars)$name$suffix("_min")
)

# Or use positional arguments to group by multiple columns in the same way.
df$with_columns(
  pl$col("c")$min()$over("a", pl$col("b") \%\% 2)$name$suffix("_min")
)

# Alternative mapping strategy: join values in a list output
df$with_columns(
  top_2 = pl$col("c")$top_k(2)$over("a", mapping_strategy = "join")
)

# order_by specifies how values are sorted within a group, which is
# essential when the operation depends on the order of values
df <- pl$DataFrame(
  g = c(1, 1, 1, 1, 2, 2, 2, 2),
  t = c(1, 2, 3, 4, 4, 1, 2, 3),
  x = c(10, 20, 30, 40, 10, 20, 30, 40)
)

# without order_by, the first and second values in the second group would
# be inverted, which would be wrong
df$with_columns(
  x_lag = pl$col("x")$shift(1)$over("g", order_by = "t")
)
}
