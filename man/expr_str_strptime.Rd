% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expr-string.R
\name{expr_str_strptime}
\alias{expr_str_strptime}
\title{Convert a String column into a Date/Datetime/Time column.}
\usage{
expr_str_strptime(
  dtype,
  format = NULL,
  ...,
  strict = TRUE,
  exact = TRUE,
  cache = TRUE,
  ambiguous = c("raise", "earliest", "latest", "null")
)
}
\arguments{
\item{dtype}{The data type to convert into. Can be either \code{\link[=DataType]{pl$Date}},
\code{\link[=pl__Datetime]{pl$Datetime}}, or \code{\link[=DataType]{pl$Time}}.}

\item{format}{Format to use for conversion. Refer to
\href{https://docs.rs/chrono/latest/chrono/format/strftime/index.html}{the chrono crate documentation}
for the full specification. Example: \code{"\%Y-\%m-\%d \%H:\%M:\%S"}.
If \code{NULL} (default), the format is inferred from the data.
Notice that time zone \verb{\%Z} is not supported and will just ignore timezones.
Numeric time zones like \verb{\%z} or \verb{\%:z} are supported.}

\item{...}{These dots are for future extensions and must be empty.}

\item{strict}{If \code{TRUE} (default), raise an error if a single string cannot
be parsed. If \code{FALSE}, produce a polars \code{null}.}

\item{exact}{If \code{TRUE} (default), require an exact format match. If \code{FALSE},
allow the format to match anywhere in the target string.
Conversion to the Time type is always exact.
Note that using \code{exact = FALSE} introduces a performance penalty -
cleaning your data beforehand will almost certainly be more performant.}

\item{cache}{Use a cache of unique, converted dates to apply the datetime
conversion.}

\item{ambiguous}{Determine how to deal with ambiguous datetimes.
Character vector or \link{expression} containing the followings:
\itemize{
\item \code{"raise"} (default): Throw an error
\item \code{"earliest"}: Use the earliest datetime
\item \code{"latest"}: Use the latest datetime
\item \code{"null"}: Return a null value
}}
}
\value{
A polars \link{expression}
}
\description{
Similar to the \code{\link[=strptime]{strptime()}} function.
}
\details{
When parsing a Datetime the column precision will be inferred from the format
string, if given, e.g.: \code{"\%F \%T\%.3f"} => \code{\link[=pl__Datetime]{pl$Datetime("ms")}}.
If no fractional second component is found then the default is \code{"us"} (microsecond).
}
\examples{
# Dealing with a consistent format
df <- pl$DataFrame(x = c("2020-01-01 01:00Z", "2020-01-01 02:00Z"))

df$select(pl$col("x")$str$strptime(pl$Datetime(), "\%Y-\%m-\%d \%H:\%M\%#z"))

# Dealing with different formats.
df <- pl$DataFrame(
  date = c(
    "2021-04-22",
    "2022-01-04 00:00:00",
    "01/31/22",
    "Sun Jul  8 00:34:60 2001"
  )
)

df$select(
  pl$coalesce(
    pl$col("date")$str$strptime(pl$Date, "\%F", strict = FALSE),
    pl$col("date")$str$strptime(pl$Date, "\%F \%T", strict = FALSE),
    pl$col("date")$str$strptime(pl$Date, "\%D", strict = FALSE),
    pl$col("date")$str$strptime(pl$Date, "\%c", strict = FALSE)
  )
)

# Ignore invalid time
df <- pl$DataFrame(
  x = c(
    "2023-01-01 11:22:33 -0100",
    "2023-01-01 11:22:33 +0300",
    "invalid time"
  )
)

df$select(pl$col("x")$str$strptime(
  pl$Datetime("ns"),
  format = "\%Y-\%m-\%d \%H:\%M:\%S \%z",
  strict = FALSE
))
}
\seealso{
\itemize{
\item \code{\link[=expr_str_to_date]{<expr>$str$to_date()}}
\item \code{\link[=expr_str_to_datetime]{<expr>$str$to_datetime()}}
\item \code{\link[=expr_str_to_time]{<expr>$str$to_time()}}
\item \code{\link[=series_str_to_datetime]{<series>$str$to_datetime()}}
}
}
