% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/output-batches.R
\name{lazyframe__sink_batches}
\alias{lazyframe__sink_batches}
\alias{lazyframe__lazy_sink_batches}
\title{Evaluate the query and call a user-defined function for every ready batch}
\usage{
lazyframe__sink_batches(
  lambda,
  ...,
  chunk_size = NULL,
  maintain_order = TRUE,
  engine = c("auto", "in-memory", "streaming")
)

lazyframe__lazy_sink_batches(
  lambda,
  ...,
  chunk_size = NULL,
  maintain_order = TRUE
)
}
\arguments{
\item{lambda}{A function that will receive a \link{DataFrame} as the first argument and
called for side effects (e.g., writing to a file).
If the function returns \code{TRUE} and using the streaming engine,
this signals that no more results are needed, allowing for early stopping.}

\item{...}{These dots are for future extensions and must be empty.}

\item{chunk_size}{A positive integer or \code{NULL} (default).
The number of rows that are buffered before the callback is called.}

\item{maintain_order}{Maintain the order in which data is processed. Setting
this to \code{FALSE} will be slightly faster.}

\item{engine}{The engine name to use for processing the query.
One of the followings:
\itemize{
\item \code{"auto"} (default): Select the engine automatically.
The \code{"in-memory"} engine will be selected for most cases.
\item \code{"in-memory"}: Use the in-memory engine.
\item \code{"streaming"}: \ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}} Use the (new) streaming engine.
}}
}
\value{
\itemize{
\item \verb{<lazyframe>$sink_batches()} returns \code{NULL} invisibly.
\item \verb{<lazyframe>$lazy_sink_batches()} returns a new \link{LazyFrame}.
}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}
This allows streaming results that are larger than RAM in certain cases.
Note that this method is much slower than native sinks.
Only use it if you cannot implement your logic otherwise.
}
\details{
\verb{<lazyframe>$sink_batches()} is a shortcut for \verb{<lazyframe>$lazy_sink_batches()$collect()}.
}
\examples{
lf <- as_polars_lf(mtcars)
lf$sink_batches(\(df) print(df), chunk_size = 10)

# Early stopping by returning TRUE from the function
lf$sort("cyl")$sink_batches(
  \(df) {
    print(df)
    if (max(df[["cyl"]])$to_r_vector() > 4) TRUE else FALSE
  },
  chunk_size = 10
)
}
