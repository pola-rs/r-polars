% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dataframe-frame.R
\name{dataframe__pivot}
\alias{dataframe__pivot}
\title{Pivot a frame from long to wide format}
\usage{
dataframe__pivot(
  on,
  ...,
  index = NULL,
  values = NULL,
  aggregate_function = NULL,
  maintain_order = TRUE,
  sort_columns = FALSE,
  separator = "_"
)
}
\arguments{
\item{on}{The column(s) whose values will be used as the new columns of the
output DataFrame.}

\item{...}{These dots are for future extensions and must be empty.}

\item{index}{The column(s) that remain from the input to the output. The
output DataFrame will have one row for each unique combination of the
\code{index}'s values. If \code{NULL}, all remaining columns not specified in \code{on} and
\code{values} will be used. At least one of \code{index} and \code{values} must be
specified.}

\item{values}{The existing column(s) of values which will be moved under the
new columns from \code{index}. If an aggregation is specified, these are the
values on which the aggregation will be computed. If \code{NULL}, all remaining
columns not specified in \code{on} and \code{index} will be used. At least one of
\code{index} and \code{values} must be specified.}

\item{aggregate_function}{Choose from:
\itemize{
\item \code{NULL}: no aggregation takes place, will raise error if multiple values
are in group;
\item A predefined aggregate function string, one of \code{"min"}, \code{"max"},
\code{"first"}, \code{"last"}, \code{"sum"}, \code{"mean"}, \code{"median"}, \code{"len"};
\item An expression to do the aggregation.
}}

\item{maintain_order}{Ensure the values of \code{index} are sorted by discovery
order.}

\item{sort_columns}{Sort the transposed columns by name. Default is by order
of discovery.}

\item{separator}{Used as separator/delimiter in generated column names in
case of multiple values columns.}
}
\value{
A polars \link{DataFrame}
}
\description{
Only available in eager mode. See "Examples" section below for how to do a
"lazy pivot" if you know the unique column values in advance.
}
\examples{
# Suppose we have a dataframe of test scores achieved by some students,
# where each row represents a distinct test.
df <- pl$DataFrame(
  name = c("Cady", "Cady", "Karen", "Karen"),
  subject = c("maths", "physics", "maths", "physics"),
  test_1 = c(98, 99, 61, 58),
  test_2 = c(100, 100, 60, 60)
)
df

# Using pivot(), we can reshape so we have one row per student, with
# different subjects as columns, and their `test_1` scores as values:
df$pivot("subject", index = "name", values = "test_1")

# You can use selectors too - here we include all test scores
# in the pivoted table:
df$pivot("subject", values = cs$starts_with("test"))

# If you end up with multiple values per cell, you can specify how to
# aggregate them with `aggregate_function`:
df <- pl$DataFrame(
  ix = c(1, 1, 2, 2, 1, 2),
  col = c("a", "a", "a", "a", "b", "b"),
  foo = c(0, 1, 2, 2, 7, 1),
  bar = c(0, 2, 0, 0, 9, 4)
)
df

df$pivot("col", index = "ix", aggregate_function = "sum")

# You can also pass a custom aggregation function using `pl$element()`:
df <- pl$DataFrame(
  col1 = c("a", "a", "a", "b", "b", "b"),
  col2 = c("x", "x", "x", "x", "y", "y"),
  col3 = c(6, 7, 3, 2, 5, 7),
)
df$pivot(
  "col2",
  index = "col1",
  values = "col3",
  aggregate_function = pl$element()$tanh()$mean(),
)

# Note that pivot is only available in eager mode. If you know the unique
# column values in advance, you can use `$group_by()` on a LazyFrame to get
# the same result as above in lazy mode:
index <- pl$col("col1")
on <- pl$col("col2")
values <- pl$col("col3")
unique_column_values <- c("x", "y")
aggregate_function <- \(col) col$tanh()$mean()
funs <- lapply(unique_column_values, \(value) {
  aggregate_function(values$filter(on == value))$alias(value)
})
df$lazy()$group_by(index)$agg(!!!funs)$collect()
}
