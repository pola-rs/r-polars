% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dataframe__frame.R
\name{DataFrame_n_chunks}
\alias{DataFrame_n_chunks}
\title{Number of chunks of the Series' in a DataFrame}
\usage{
DataFrame_n_chunks(strategy = "all")
}
\arguments{
\item{strategy}{string either 'all' or 'first'. 'first' only returns chunks for first Series.}
}
\value{
real vector of chunk counts per Series.
}
\description{
Number of chunks (mem allocations) for all or first Series' in a DataFrame.
}
\details{
DataFrame is a vector of Series'. Each Series in rust-polars is a wrapper around a ChunkedArray,
which is like a virtual contiguous vector, which is physically backed by an ordered set of
chunks. Each chunk of values has a contiguous memory layout and is an arrow array. Arrow arrays
are a fast, thread-safe and cross-platform  memory layout.

In R when combining with \code{c()} or \code{rbind()}, it requires immediate vector re-allocation to place
vector values in contiguous memory, hence repeated appending to a vector in R is discouraged
because slow.

When concatenating/appending to Series' or DataFrame' re-allocation can be avoided or delayed,
by simply appending chunks to each individual Series.

However, if chunks become many and small or are misaligned across Series, this can hurt the
performance of following operations.

Most places in the polars api where chunking could occur, the user have to
typically actively opt-out by setting and arg \code{rechunk = FALSE}. Thus it is not normal
}
\examples{
# create DataFrame with miss aligned chunks
df = pl$concat(
  1:10, # single chunk
  pl$concat(1:5, 1:5, rechunk = FALSE, how = "vertical")$rename("b"), # two chunks
  how = "horizontal"
)
df
df$n_chunks()

# rechunk a chunked DataFrame
df$rechunk()$n_chunks()

# rechunk is not an in-place operation
df$n_chunks()

# The following toy example emulates the Series "chunkyness" in R. Here it a S3-classed list with
# same type of vectors and where have all relevant S3 generics implemented to make behave as if
# it was a regular vector.
"+.chunked_vector" = \(x, y) structure(list(unlist(x) + unlist(y)), class = "chunked_vector")
print.chunked_vector = \(x, ...) print(unlist(x), ...)
c.chunked_vector = \(...) structure(do.call(c, lapply(list(...), unclass)), class = "chunked_vector")
rechunk = \(x) structure(unlist(x), class = "chunked_vector")
x = structure(list(1:4, 5L), class = "chunked_vector")
x
x + 5:1
lapply(x, tracemem) # trace chunks to verify no re-allocation
z = c(x, x)
z # looks like a plain vector
lapply(z, tracemem) # mem allocation  in z are the same from x
str(z)
z = rechunk(z)
str(z)
}
\seealso{
\code{\link[=DataFrame_rechunk]{<DataFrame>$rechunk()}}
}
\keyword{DataFrame}
