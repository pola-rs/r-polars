% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expr__expr.R
\name{Expr_rolling_quantile}
\alias{Expr_rolling_quantile}
\title{Rolling quantile}
\usage{
Expr_rolling_quantile(
  quantile,
  interpolation = "nearest",
  window_size,
  weights = NULL,
  min_periods = NULL,
  center = FALSE,
  by = NULL,
  closed = c("left", "right", "both", "none"),
  warn_if_unsorted = TRUE
)
}
\arguments{
\item{quantile}{Quantile between 0 and 1.}

\item{interpolation}{String, one of \code{"nearest"}, \code{"higher"}, \code{"lower"},
\code{"midpoint"}, \code{"linear"}.}

\item{window_size}{The length of the window. Can be a fixed integer size, or a dynamic temporal
size indicated by the following string language:
\itemize{
\item 1ns   (1 nanosecond)
\item 1us   (1 microsecond)
\item 1ms   (1 millisecond)
\item 1s    (1 second)
\item 1m    (1 minute)
\item 1h    (1 hour)
\item 1d    (1 day)
\item 1w    (1 week)
\item 1mo   (1 calendar month)
\item 1y    (1 calendar year)
\item 1i    (1 index count)
If the dynamic string language is used, the \code{by} and \code{closed} arguments must
also be set.
}}

\item{weights}{An optional slice with the same length as the window that will
be multiplied elementwise with the values in the window.}

\item{min_periods}{The number of values in the window that should be non-null
before computing a result. If \code{NULL}, it will be set equal to window size.}

\item{center}{Set the labels at the center of the window}

\item{by}{If the \code{window_size} is temporal for instance \code{"5h"} or \code{"3s"}, you
must set the column that will be used to determine the windows. This column
must be of DataType Date or DateTime.}

\item{closed}{String, one of \code{"left"}, \code{"right"}, \code{"both"}, \code{"none"}. Defines
whether the temporal window interval is closed or not.}

\item{warn_if_unsorted}{Warn if data is not known to be sorted by \code{by} column (if passed).
Experimental.}
}
\value{
Expr
}
\description{
Compute the rolling (= moving) quantile over the values in this array. A
window of length \code{window_size} will traverse the array. The values that fill
this window will (optionally) be multiplied with the weights given by the
\code{weight} vector.
}
\details{
If you want to compute multiple aggregation statistics over the same dynamic
window, consider using \verb{$rolling()} this method can cache the window size
computation.
}
\examples{
pl$DataFrame(a = c(1, 3, 2, 4, 5, 6))$
  with_columns(roll_quant = pl$col("a")$rolling_quantile(0.3, window_size = 2))
}
