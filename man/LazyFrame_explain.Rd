% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lazyframe__lazy.R
\name{LazyFrame_explain}
\alias{LazyFrame_explain}
\title{Create a string representation of the query plan}
\usage{
LazyFrame_explain(
  ...,
  format = "plain",
  optimized = TRUE,
  type_coercion = TRUE,
  predicate_pushdown = TRUE,
  projection_pushdown = TRUE,
  simplify_expression = TRUE,
  slice_pushdown = TRUE,
  comm_subplan_elim = TRUE,
  comm_subexpr_elim = TRUE,
  cluster_with_columns = TRUE,
  streaming = FALSE
)
}
\arguments{
\item{...}{Ignored.}

\item{format}{The format to use for displaying the logical plan. Must be either
\code{"plain"} (default) or \code{"tree"}.}

\item{optimized}{Return an optimized query plan. If \code{TRUE} (default), the
subsequent optimization flags control which optimizations run.}

\item{type_coercion}{Logical. Coerce types such that operations succeed and
run on minimal required memory.}

\item{predicate_pushdown}{Logical. Applies filters as early as possible at
scan level.}

\item{projection_pushdown}{Logical. Select only the columns that are needed
at the scan level.}

\item{simplify_expression}{Logical. Various optimizations, such as constant
folding and replacing expensive operations with faster alternatives.}

\item{slice_pushdown}{Logical. Only load the required slice from the scan
level. Don't materialize sliced outputs (e.g. \code{join$head(10)}).}

\item{comm_subplan_elim}{Logical. Will try to cache branching subplans that
occur on self-joins or unions.}

\item{comm_subexpr_elim}{Logical. Common subexpressions will be cached and
reused.}

\item{cluster_with_columns}{Combine sequential independent calls to
\code{\link[=DataFrame_with_columns]{with_columns()}}.}

\item{streaming}{Logical. Run parts of the query in a streaming fashion
(this is in an alpha state).}
}
\value{
A character value containing the query plan.
}
\description{
The query plan is read from bottom to top. When \code{optimized = FALSE}, the
query as it was written by the user is shown. This is not what Polars runs.
Instead, it applies optimizations that are displayed by default by \verb{$explain()}.
One classic example is the predicate pushdown, which applies the filter as
early as possible (i.e. at the bottom of the plan).
}
\examples{
lazy_frame = pl$LazyFrame(iris)

# Prepare your query
lazy_query = lazy_frame$sort("Species")$filter(pl$col("Species") != "setosa")

# This is the query that was written by the user, without any optimizations
# (use cat() for better printing)
lazy_query$explain(optimized = FALSE) |> cat()

# This is the query after `polars` optimizes it: instead of sorting first and
# then filtering, it is faster to filter first and then sort the rest.
lazy_query$explain() |> cat()

# Also possible to see this as tree format
lazy_query$explain(format = "tree") |> cat()
}
