% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dataframe__frame.R
\name{DataFrame_transpose}
\alias{DataFrame_transpose}
\title{Transpose a DataFrame over the diagonal.}
\usage{
DataFrame_transpose(
  include_header = FALSE,
  header_name = "column",
  column_names = NULL
)
}
\arguments{
\item{include_header}{boolean (default FALSE) if TRUE, add previous column names as
a new Utf8 column.}

\item{header_name}{string name of the header column containing previous column names. Only
relevant if include_header = TRUE.}

\item{column_names}{character vector or default NULL. How to name previous rows as columns.
NULL is default and is "column_1", "column_2" ... . Length of column names must match n rows of
input DataFrame.}
}
\value{
DataFrame
}
\description{
Transpose a DataFrame over the diagonal.
}
\details{
This is a very expensive operation. Perhaps you can do it differently.

If you need to perform non foldable (see fold / reduce) row operations like median.
Transpose may be the fastest option, for that.

Polars transpose is currently eager only, likely because it is not trivial to deduce the schema.
}
\examples{

# simple use-case
pl$DataFrame(mtcars)$transpose(include_header = TRUE, column_names = rownames(mtcars))

# All rows must have one shared supertype, recast Categorical to Utf8 which is a supertype
# of f64, and then dataset "Iris" can be transposed
pl$DataFrame(iris)$with_columns(pl$col("Species")$cast(pl$Utf8))$transpose()

# An example where transpose is warranted for speed.
# Imagine mtcars is really a several million row LazyFrame and something like row-wise median
# computation is needed. e.g. to compute MAD row-wise as this expression, does it column-wise.
MAD_all_col_expr = pl$all()$median()$sub(pl$all())$abs()$mean() |> print()

# Median cannot be folded or reduced because it included a sort of values.

# our "very big" DataFrame to compute row-wise MAD
total_N = nrow(mtcars) # all rows have same type or at least a meaningful shared supertype
big_lf = pl$DataFrame(mtcars)$lazy()
chunk_size = 11 # rows or maybe 5000 rows per chunk for bigger data

# define chunks to not store an entire DataFrame of the HUGE maybe larger than memory LazyFrame.
slice_off = c(floor(seq(0, total_N, by = chunk_size)), total_N) |> unique()
slice_len = diff(slice_off)
slice_off = head(slice_off, -1)

# slice "very big" LazyFrame and transpose each chunk and then compute MAD on columns
# and lastly transpose back and concat (rbind) chunks.
MAD_df = lapply(seq_along(slice_off), \(i) {
  big_lf$slice(slice_off[i], slice_len[i])$
    collect()$
    transpose()$
    select(MAD_all_col_expr)$
    transpose(column_names = "MADs")
}) |>
  pl$concat()

big_lf_mad = big_lf$with_columns(MAD_df$get_column("MADs"))
big_lf_mad$fetch()

}
\keyword{DataFrame}
