% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lazyframe__lazy.R
\name{LazyFrame_class}
\alias{LazyFrame_class}
\alias{RPolarsLazyFrame}
\title{Inner workings of the LazyFrame-class}
\description{
The \code{LazyFrame}-class is simply two environments of respectively
the public and private methods/function calls to the polars rust side. The
instantiated \code{LazyFrame}-object is an \code{externalptr} to a lowlevel rust polars
LazyFrame  object. The pointer address is the only statefullness of the
LazyFrame object on the R side. Any other state resides on the rust side. The
S3 method \code{.DollarNames.RPolarsLazyFrame} exposes all public \verb{$foobar()}-methods which
are callable onto the object.

Most methods return another \code{LazyFrame}-class instance or similar which allows
for method chaining. This class system in lack of a better name could be called
"environment classes" and is the same class system extendr provides, except
here there is both a public and private set of methods. For implementation
reasons, the private methods are external and must be called from
\code{.pr$LazyFrame$methodname()}. Also, all private methods must take
any self as an argument, thus they are pure functions. Having the private methods
as pure functions solved/simplified self-referential complications.

\code{DataFrame} and \code{LazyFrame} can both be said to be a \code{Frame}. To convert use
\code{\link[=DataFrame_lazy]{<DataFrame>$lazy()}} and \code{\link[=LazyFrame_collect]{<LazyFrame>$collect()}}.
You can also create a \code{LazyFrame} directly with \code{\link[=pl_LazyFrame]{pl$LazyFrame()}}.
This is quite similar to the lazy-collect syntax of the \code{dplyr} package to
interact with database connections such as SQL variants. Most SQL databases
would be able to perform the same optimizations as polars such predicate pushdown
and projection pushdown. However polars can interact and optimize queries with both
SQL DBs and other data sources such parquet files simultaneously.
}
\section{Active bindings}{

\subsection{columns}{

\verb{$columns} returns a character vector with the column names.
}

\subsection{dtypes}{

\verb{$dtypes} returns a unnamed list with the \link[=pl_dtypes]{data type} of each column.
}

\subsection{schema}{

\verb{$schema} returns a named list with the \link[=pl_dtypes]{data type} of each column.
}

\subsection{width}{

\verb{$width} returns the number of columns in the LazyFrame.
}
}

\section{Conversion to R data types considerations}{

When converting Polars objects, such as \link[=DataFrame_class]{DataFrames}
to R objects, for example via the \code{\link[=as.data.frame.RPolarsDataFrame]{as.data.frame()}} generic function,
each type in the Polars object is converted to an R type.
In some cases, an error may occur because the conversion is not appropriate.
In particular, there is a high possibility of an error when converting
a \link[=DataType_Datetime]{Datetime} type without a time zone.
A \link[=DataType_Datetime]{Datetime} type without a time zone in Polars is converted
to the \link{POSIXct} type in R, which takes into account the time zone in which
the R session is running (which can be checked with the \code{\link[=Sys.timezone]{Sys.timezone()}}
function). In this case, if ambiguous times are included, a conversion error
will occur. In such cases, change the session time zone using
\code{\link[base:Sys.setenv]{Sys.setenv(TZ = "UTC")}} and then perform the conversion, or use the
\code{\link[=ExprDT_replace_time_zone]{$dt$replace_time_zone()}} method on the Datetime type column to
explicitly specify the time zone before conversion.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# Due to daylight savings, clocks were turned forward 1 hour on Sunday, March 8, 2020, 2:00:00 am
# so this particular date-time doesn't exist
non_existent_time = pl$Series("2020-03-08 02:00:00")$str$strptime(pl$Datetime(), "\%F \%T")

withr::with_envvar(
  new = c(TZ = "America/New_York"),
  \{
    tryCatch(
      # This causes an error due to the time zone (the `TZ` env var is affected).
      as.vector(non_existent_time),
      error = function(e) e
    )
  \}
)
#> <error: in to_r: ComputeError(ErrString("datetime '2020-03-08 02:00:00' is non-existent in time zone 'America/New_York'. You may be able to use `non_existent='null'` to return `null` in this case.")) When calling: devtools::document()>

withr::with_envvar(
  new = c(TZ = "America/New_York"),
  \{
    # This is safe.
    as.vector(non_existent_time$dt$replace_time_zone("UTC"))
  \}
)
#> [1] "2020-03-08 02:00:00 UTC"
}\if{html}{\out{</div>}}
}

\examples{
# see all exported methods
ls(.pr$env$RPolarsLazyFrame)

# see all private methods (not intended for regular use)
ls(.pr$LazyFrame)


## Practical example ##
# First writing R iris dataset to disk, to illustrte a difference
temp_filepath = tempfile()
write.csv(iris, temp_filepath, row.names = FALSE)

# Following example illustrates 2 ways to obtain a LazyFrame

# The-Okay-way: convert an in-memory DataFrame to LazyFrame

# eager in-mem R data.frame
Rdf = read.csv(temp_filepath)

# eager in-mem polars DataFrame
Pdf = as_polars_df(Rdf)

# lazy frame starting from in-mem DataFrame
Ldf_okay = Pdf$lazy()

# The-Best-Way:  LazyFrame created directly from a data source is best...
Ldf_best = pl$scan_csv(temp_filepath)

# ... as if to e.g. filter the LazyFrame, that filtering also caleld predicate will be
# pushed down in the executation stack to the csv_reader, and thereby only bringing into
# memory the rows matching to filter.
# apply filter:
filter_expr = pl$col("Species") == "setosa" # get only rows where Species is setosa
Ldf_okay = Ldf_okay$filter(filter_expr) # overwrite LazyFrame with new
Ldf_best = Ldf_best$filter(filter_expr)

# the non optimized plans are similar, on entire in-mem csv, apply filter
Ldf_okay$describe_plan()
Ldf_best$describe_plan()

# NOTE For Ldf_okay, the full time to load csv alrady paid when creating Rdf and Pdf

# The optimized plan are quite different, Ldf_best will read csv and perform filter simultaneously
Ldf_okay$describe_optimized_plan()
Ldf_best$describe_optimized_plan()


# To acquire result in-mem use $colelct()
Pdf_okay = Ldf_okay$collect()
Pdf_best = Ldf_best$collect()


# verify tables would be the same
all.equal(
  Pdf_okay$to_data_frame(),
  Pdf_best$to_data_frame()
)

# a user might write it as a one-liner like so:
Pdf_best2 = pl$scan_csv(temp_filepath)$filter(pl$col("Species") == "setosa")
}
\keyword{LazyFrame}
