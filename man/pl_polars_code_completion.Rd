% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/autocompletion.R
\name{pl_polars_code_completion}
\alias{pl_polars_code_completion}
\title{Polars code completion}
\usage{
pl_polars_code_completion(
  activate = TRUE,
  mode = c("auto", "rstudio", "nativeR"),
  verbose = TRUE
)
}
\arguments{
\item{activate}{bool, TRUE activates, FALSE deactivates}

\item{mode}{choice either. "auto" picks "rstudio" if  "tools:rstudio" is found in search().
"rstudio" modifies rstudio code internal .DollarNames and function args completion.
"nativeR" registers a custom line buffer completer with
\code{utils:::rc.getOption("custom.completer")}.

Rstudio IDE does not behave well with \code{utils:::rc.getOption("custom.completer")} and therefore
has its own custom completion.}

\item{verbose}{print message of what mode is started.}
}
\description{
Polars code completion
}
\details{
Polars code completion has one implementation for an nativeR terminal via
\code{utils:::rc.getOption("custom.completer")} and one for Rstudio by intercepting Rstudio internal
functions \code{.rs.getCompletionsFunction} & \code{.rs.getCompletionsDollar} in the loaded session
environment \code{tools:rstudio}. Any blame for sluggishness or errors should be directed to r-polars.

Either completers will evaluate the full line-buffer to decide what methods are available.
Pressing tab will literally evaluate left-hand-side with any following side. This
works swiftly for the polars lazy API. For the eager API any table transformation is literally
envoked. For large DataFrame and Series this could be slow.#'
}
\examples{

# activate completion
pl$polars_code_completions()

pl$DataFrame(iris)$lazy() # add a $ and press tab to see methods of LazyFrame

# Arg + column-name completion. Rstudio only for now
pl$DataFrame(iris)$lazy()$group_by() # press tab inside group_by() to see args and/or column
names.

# deactivate like this or restart R session
pl$polars_code_completions(activate = FALSE)
}
