% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rbackground.R
\name{RThreadHandle_RThreadHandle_class}
\alias{RThreadHandle_RThreadHandle_class}
\title{The RPolarsRThreadHandle class}
\value{
see methods:
\code{\link[=RThreadHandle_is_finished]{is_finished()}}
\code{\link[=RThreadHandle_join]{join()}}
}
\description{
A handle to some polars query running in a background thread.
}
\details{
\code{\link[=LazyFrame_collect_in_background]{<LazyFrame>$collect_in_background()}} will execute a polars
query detached from the R session and return an \code{RPolarsRThreadHandle} immediately. This
\code{RPolarsRThreadHandle}-class has the methods \code{\link[=RThreadHandle_is_finished]{is_finished()}} and
\code{\link[=RThreadHandle_join]{join()}}.

NOTICE:
The background thread cannot use the main R session, but can access the pool of extra R sessions
to process R code embedded in polars query via \verb{$map_batches(..., background = TRUE)} or
\verb{$map_elements(background=TRUE)}. Use \code{\link[=set_options]{pl$set_options(rpool_cap = XX)}} to limit number of
parallel R sessions.
Starting polars  \code{\link[=LazyFrame_collect_in_background]{<LazyFrame>$collect_in_background()}} with
e.g. some \verb{$map_batches(..., background = FALSE)} will raise an Error as the main R session is not
available to process the R part of the polars query. Native polars query does not need any R
session.
}
\examples{
prexpr = pl$col("mpg")$map_batches(\(x) {
  Sys.sleep(.1)
  x * 0.43
}, in_background = TRUE)$alias("kml")
handle = pl$LazyFrame(mtcars)$with_columns(prexpr)$collect_in_background()
if (!handle$is_finished()) print("not done yet")
df = handle$join() # get result
df
}
\seealso{
\code{\link[=LazyFrame_collect_in_background]{<LazyFrame>$collect_in_background()}}
\code{\link[=Expr_map_batches]{<Expr>$map_batches()}}
\code{\link[=Expr_map_elements]{<Expr>$map_elements()}}
}
\keyword{RThreadHandle}
