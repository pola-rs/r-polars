% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dataframe__frame.R
\name{DataFrame_rechunk}
\alias{DataFrame_rechunk}
\title{Rechunk a DataFrame}
\usage{
DataFrame_rechunk()
}
\value{
A DataFrame
}
\description{
Rechunking re-allocates any "chunked" memory allocations to
speed-up e.g. vectorized operations.
}
\details{
A DataFrame is a vector of Series. Each Series in rust-polars is a wrapper
around a ChunkedArray, which is like a virtual contiguous vector physically
backed by an ordered set of chunks. Each chunk of values has a contiguous
memory layout and is an arrow array. Arrow arrays are a fast, thread-safe and
cross-platform memory layout.

In R, combining with \code{c()} or \code{rbind()} requires immediate vector re-allocation
to place vector values in contiguous memory. This is slow and memory consuming,
and it is why repeatedly appending to a vector in R is discouraged.

In polars, when we concatenate or append to Series or DataFrame, the
re-allocation can be avoided or delayed by simply appending chunks to each
individual Series. However, if chunks become many and small or are misaligned
across Series, this can hurt the performance of subsequent operations.

Most places in the polars api where chunking could occur, the user have to
typically actively opt-out by setting an argument \code{rechunk = FALSE}.
}
\examples{
# create DataFrame with misaligned chunks
df = pl$concat(
  1:10, # single chunk
  pl$concat(1:5, 1:5, rechunk = FALSE, how = "vertical")$rename("b"), # two chunks
  how = "horizontal"
)
df
df$n_chunks()

# rechunk a chunked DataFrame
df$rechunk()$n_chunks()

# rechunk is not an in-place operation
df$n_chunks()

# The following toy example emulates the Series "chunkyness" in R. Here it a
# S3-classed list with same type of vectors and where have all relevant S3
# generics implemented to make behave as if it was a regular vector.
"+.chunked_vector" = \(x, y) structure(list(unlist(x) + unlist(y)), class = "chunked_vector")
print.chunked_vector = \(x, ...) print(unlist(x), ...)
c.chunked_vector = \(...) {
  structure(do.call(c, lapply(list(...), unclass)), class = "chunked_vector")
}
rechunk = \(x) structure(unlist(x), class = "chunked_vector")
x = structure(list(1:4, 5L), class = "chunked_vector")
x
x + 5:1
lapply(x, tracemem) # trace chunks to verify no re-allocation
z = c(x, x)
z # looks like a plain vector
lapply(z, tracemem) # mem allocation  in z are the same from x
str(z)
z = rechunk(z)
str(z)
}
\seealso{
\code{\link[=DataFrame_n_chunks]{<DataFrame>$n_chunks()}}
}
\keyword{DataFrame}
