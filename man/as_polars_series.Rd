% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/as_polars_series.R
\name{as_polars_series}
\alias{as_polars_series}
\alias{as_polars_series.default}
\alias{as_polars_series.polars_series}
\alias{as_polars_series.polars_data_frame}
\alias{as_polars_series.double}
\alias{as_polars_series.integer}
\alias{as_polars_series.character}
\alias{as_polars_series.logical}
\alias{as_polars_series.raw}
\alias{as_polars_series.factor}
\alias{as_polars_series.Date}
\alias{as_polars_series.POSIXct}
\alias{as_polars_series.POSIXlt}
\alias{as_polars_series.difftime}
\alias{as_polars_series.hms}
\alias{as_polars_series.blob}
\alias{as_polars_series.array}
\alias{as_polars_series.NULL}
\alias{as_polars_series.list}
\alias{as_polars_series.AsIs}
\alias{as_polars_series.data.frame}
\alias{as_polars_series.integer64}
\alias{as_polars_series.ITime}
\alias{as_polars_series.vctrs_unspecified}
\alias{as_polars_series.vctrs_rcrd}
\alias{as_polars_series.clock_time_point}
\alias{as_polars_series.clock_sys_time}
\alias{as_polars_series.clock_zoned_time}
\alias{as_polars_series.clock_duration}
\title{Create a Polars Series from an R object}
\usage{
as_polars_series(x, name = NULL, ...)

\method{as_polars_series}{default}(x, name = NULL, ...)

\method{as_polars_series}{polars_series}(x, name = NULL, ...)

\method{as_polars_series}{polars_data_frame}(x, name = NULL, ...)

\method{as_polars_series}{double}(x, name = NULL, ...)

\method{as_polars_series}{integer}(x, name = NULL, ...)

\method{as_polars_series}{character}(x, name = NULL, ...)

\method{as_polars_series}{logical}(x, name = NULL, ...)

\method{as_polars_series}{raw}(x, name = NULL, ...)

\method{as_polars_series}{factor}(x, name = NULL, ...)

\method{as_polars_series}{Date}(x, name = NULL, ...)

\method{as_polars_series}{POSIXct}(x, name = NULL, ...)

\method{as_polars_series}{POSIXlt}(x, name = NULL, ...)

\method{as_polars_series}{difftime}(x, name = NULL, ...)

\method{as_polars_series}{hms}(x, name = NULL, ...)

\method{as_polars_series}{blob}(x, name = NULL, ...)

\method{as_polars_series}{array}(x, name = NULL, ...)

\method{as_polars_series}{`NULL`}(x, name = NULL, ...)

\method{as_polars_series}{list}(x, name = NULL, ..., strict = FALSE)

\method{as_polars_series}{AsIs}(x, name = NULL, ...)

\method{as_polars_series}{data.frame}(x, name = NULL, ...)

\method{as_polars_series}{integer64}(x, name = NULL, ...)

\method{as_polars_series}{ITime}(x, name = NULL, ...)

\method{as_polars_series}{vctrs_unspecified}(x, name = NULL, ...)

\method{as_polars_series}{vctrs_rcrd}(x, name = NULL, ...)

\method{as_polars_series}{clock_time_point}(x, name = NULL, ...)

\method{as_polars_series}{clock_sys_time}(x, name = NULL, ...)

\method{as_polars_series}{clock_zoned_time}(x, name = NULL, ...)

\method{as_polars_series}{clock_duration}(x, name = NULL, ...)
}
\arguments{
\item{x}{An R object.}

\item{name}{A single string or \code{NULL}. Name of the Series.
Will be used as a column name when used in a \link[=DataFrame]{polars DataFrame}.
When not specified, name is set to an empty string.}

\item{...}{Additional arguments passed to the methods.}

\item{strict}{A logical value to indicate whether throwing an error when
the input \link{list}'s elements have different data types.
If \code{FALSE} (default), all elements are automatically cast to the super type, or,
casting to the super type is failed, the value will be \code{null}.
If \code{TRUE}, the first non-\code{NULL} element's data type is used as the data type of the inner Series.}
}
\value{
A \link[=Series]{polars Series}
}
\description{
The \code{\link[=as_polars_series]{as_polars_series()}} function creates a \link[=Series]{polars Series} from various R objects.
The Data Type of the Series is determined by the class of the input object.
}
\details{
The default method of \code{\link[=as_polars_series]{as_polars_series()}} throws an error,
so we need to define S3 methods for the classes we want to support.
\subsection{S3 method for \link{list} and \link{list} based classes}{

In R, a \link{list} can contain elements of different types, but in Polars (Apache Arrow),
all elements must have the same type.
So the \code{\link[=as_polars_series]{as_polars_series()}} function automatically casts all elements to the same type
or throws an error, depending on the \code{strict} argument.
If you want to create a list with all elements of the same type in R,
consider using the \code{\link[vctrs:list_of]{vctrs::list_of()}} function.

Since a \link{list} can contain another \link{list}, the \code{strict} argument is also used
when creating \link{Series} from the inner \link{list} in the case of classes constructed on top of a \link{list},
such as \link{data.frame} or \link[vctrs:new_rcrd]{vctrs_rcrd}.
}

\subsection{S3 method for \link{Date}}{

Sub-day values will be ignored (floored to the day).
}

\subsection{S3 method for \link{POSIXct}}{

Sub-millisecond values will be ignored (floored to the millisecond).

If the \code{tzone} attribute is not present or an empty string (\code{""}),
the \link{Series}' \link[=DataType]{dtype} will be Datetime without timezone.
}

\subsection{S3 method for \link{POSIXlt}}{

Sub-nanosecond values will be ignored (floored to the nanosecond).
}

\subsection{S3 method for \link{difftime}}{

Sub-millisecond values will be rounded to milliseconds.
}

\subsection{S3 method for \link[hms:hms]{hms}}{

Sub-nanosecond values will be ignored (floored to the nanosecond).

If the \link[hms:hms]{hms} vector contains values greater-equal to 24-oclock or less than 0-oclock,
an error will be thrown.
}

\subsection{S3 method for \link[clock:duration-helper]{clock_duration}}{

Calendrical durations (years, quarters, months) are treated as chronologically with
the internal representation of seconds.
Please check the \link[clock:duration-helper]{clock_duration} documentation for more details.
}

\subsection{S3 method for \link[=DataFrame]{polars_data_frame}}{

This method is a shortcut for \code{\link[=dataframe__to_struct]{<DataFrame>$to_struct()}}.
}
}
\examples{
# double
as_polars_series(c(NA, 1, 2))

# integer
as_polars_series(c(NA, 1:2))

# character
as_polars_series(c(NA, "foo", "bar"))

# logical
as_polars_series(c(NA, TRUE, FALSE))

# raw
as_polars_series(charToRaw("foo"))

# factor
as_polars_series(factor(c(NA, "a", "b")))

# Date
as_polars_series(as.Date(c(NA, "2021-01-01")))

## Sub-day precision will be ignored
as.Date(c(-0.5, 0, 0.5)) |>
  as_polars_series()

# POSIXct with timezone
as_polars_series(as.POSIXct(c(NA, "2021-01-01 00:00:00.123456789"), "UTC"))

# POSIXct without timezone
as_polars_series(as.POSIXct(c(NA, "2021-01-01 00:00:00.123456789")))

# POSIXlt
as_polars_series(as.POSIXlt(c(NA, "2021-01-01 00:00:00.123456789"), "UTC"))

# difftime
as_polars_series(as.difftime(c(NA, 1), units = "days"))

## Sub-millisecond values will be rounded to milliseconds
as.difftime(c(0.0005, 0.0010, 0.0015, 0.0020), units = "secs") |>
  as_polars_series()

as.difftime(c(0.0005, 0.0010, 0.0015, 0.0020), units = "weeks") |>
  as_polars_series()

# NULL
as_polars_series(NULL)

# list
as_polars_series(list(NA, NULL, list(), 1, "foo", TRUE))

## 1st element will be `null` due to the casting failure
as_polars_series(list(list("bar"), "foo"))

# data.frame
as_polars_series(
  data.frame(x = 1:2, y = c("foo", "bar"), z = I(list(1, 2)))
)

# vctrs_unspecified
if (requireNamespace("vctrs", quietly = TRUE)) {
  as_polars_series(vctrs::unspecified(3L))
}

# hms
if (requireNamespace("hms", quietly = TRUE)) {
  as_polars_series(hms::as_hms(c(NA, "01:00:00")))
}

# blob
if (requireNamespace("blob", quietly = TRUE)) {
  as_polars_series(blob::as_blob(c(NA, "foo", "bar")))
}

# integer64
if (requireNamespace("bit64", quietly = TRUE)) {
  as_polars_series(bit64::as.integer64(c(NA, "9223372036854775807")))
}

# clock_naive_time
if (requireNamespace("clock", quietly = TRUE)) {
  as_polars_series(clock::naive_time_parse(c(
    NA,
    "1900-01-01T12:34:56.123456789",
    "2020-01-01T12:34:56.123456789"
  ), precision = "nanosecond"))
}

# clock_duration
if (requireNamespace("clock", quietly = TRUE)) {
  as_polars_series(clock::duration_nanoseconds(c(NA, 1)))
}

## Calendrical durations are treated as chronologically
if (requireNamespace("clock", quietly = TRUE)) {
  as_polars_series(clock::duration_years(c(NA, 1)))
}
}
\seealso{
\itemize{
\item \code{\link[=series__to_r_vector]{<Series>$to_r_vector()}}: Export the Series as an R vector.
\item \code{\link[=as_polars_df]{as_polars_df()}}: Create a Polars DataFrame from an R object.
}
}
