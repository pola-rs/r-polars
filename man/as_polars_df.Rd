% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/as_polars_df.R
\name{as_polars_df}
\alias{as_polars_df}
\alias{as_polars_df.default}
\alias{as_polars_df.polars_series}
\alias{as_polars_df.polars_data_frame}
\alias{as_polars_df.polars_group_by}
\alias{as_polars_df.polars_lazy_frame}
\alias{as_polars_df.list}
\alias{as_polars_df.data.frame}
\alias{as_polars_df.NULL}
\title{Create a Polars DataFrame from an R object}
\usage{
as_polars_df(x, ...)

\method{as_polars_df}{default}(x, ...)

\method{as_polars_df}{polars_series}(x, ..., column_name = NULL, from_struct = TRUE)

\method{as_polars_df}{polars_data_frame}(x, ...)

\method{as_polars_df}{polars_group_by}(x, ...)

\method{as_polars_df}{polars_lazy_frame}(
  x,
  ...,
  type_coercion = TRUE,
  predicate_pushdown = TRUE,
  projection_pushdown = TRUE,
  simplify_expression = TRUE,
  slice_pushdown = TRUE,
  comm_subplan_elim = TRUE,
  comm_subexpr_elim = TRUE,
  cluster_with_columns = TRUE,
  no_optimization = FALSE,
  streaming = FALSE
)

\method{as_polars_df}{list}(x, ...)

\method{as_polars_df}{data.frame}(x, ...)

\method{as_polars_df}{`NULL`}(x, ...)
}
\arguments{
\item{x}{An R object.}

\item{...}{Additional arguments passed to the methods.}

\item{column_name}{A character or \code{NULL}. If not \code{NULL},
name/rename the \link{Series} column in the new \link{DataFrame}.
If \code{NULL}, the column name is taken from the \link{Series} name.}

\item{from_struct}{A logical. If \code{TRUE} (default) and the \link{Series} data type is a struct,
the \code{\link[=series_struct_unnest]{<Series>$struct$unnest()}} method is used to create a \link{DataFrame}
from the struct \link{Series}. In this case, the \code{column_name} argument is ignored.}

\item{type_coercion}{A logical, indicats type coercion optimization.}

\item{predicate_pushdown}{A logical, indicats predicate pushdown optimization.}

\item{projection_pushdown}{A logical, indicats projection pushdown optimization.}

\item{simplify_expression}{A logical, indicats simplify expression optimization.}

\item{slice_pushdown}{A logical, indicats slice pushdown optimization.}

\item{comm_subplan_elim}{A logical, indicats tring to cache branching subplans that occur on self-joins or unions.}

\item{comm_subexpr_elim}{A logical, indicats tring to cache common subexpressions.}

\item{cluster_with_columns}{A logical, indicats to combine sequential independent calls to with_columns.}

\item{no_optimization}{A logical. If \code{TRUE}, turn off (certain) optimizations.}

\item{streaming}{A logical. If \code{TRUE}, process the query in batches to handle larger-than-memory data.
If \code{FALSE} (default), the entire query is processed in a single batch.
Note that streaming mode is considered unstable.
It may be changed at any point without it being considered a breaking change.}
}
\value{
A polars \link{DataFrame}
}
\description{
The \code{\link[=as_polars_df]{as_polars_df()}} function creates a \link[=DataFrame]{polars DataFrame} from various R objects.
\link[=DataFrame]{Polars DataFrame} is based on a sequence of \link[=Series]{Polars Series},
so basically, the input object is converted to a \link{list} of
\link[=Series]{Polars Series} by \code{\link[=as_polars_series]{as_polars_series()}},
then a \link[=DataFrame]{Polars DataFrame} is created from the list.
}
\details{
The default method of \code{\link[=as_polars_df]{as_polars_df()}} throws an error,
so we need to define methods for the classes we want to support.
\subsection{S3 method for \link{list}}{
\itemize{
\item The argument \code{...} (except \code{name}) is passed to \code{\link[=as_polars_series]{as_polars_series()}} for each element of the list.
\item All elements of the list must be converted to the same length of \link{Series} by \code{\link[=as_polars_series]{as_polars_series()}}.
\item The name of the each element is used as the column name of the \link{DataFrame}.
For unnamed elements, the column name will be an empty string \code{""} or if the element is a \link{Series},
the column name will be the name of the \link{Series}.
}
}

\subsection{S3 method for \link{data.frame}}{
\itemize{
\item The argument \code{...} (except \code{name}) is passed to \code{\link[=as_polars_series]{as_polars_series()}} for each column.
\item All columns must be converted to the same length of \link{Series} by \code{\link[=as_polars_series]{as_polars_series()}}.
}
}

\subsection{S3 method for \link[=Series]{polars_series}}{

This is a shortcut for \code{\link[=series__to_frame]{<Series>$to_frame()}} or
\code{\link[=series_struct_unnest]{<Series>$struct$unnest()}}, depending on the \code{from_struct} argument and the \link{Series} data type.
The \code{column_name} argument is passed to the \code{name} argument of the \code{\link[=series__to_frame]{$to_frame()}} method.
}

\subsection{S3 method for \link[=LazyFrame]{polars_lazy_frame}}{

This is a shortcut for \code{\link[=lazyframe__collect]{<LazyFrame>$collect()}}.
}
}
\examples{
# list
as_polars_df(list(a = 1:2, b = c("foo", "bar")))

# data.frame
as_polars_df(data.frame(a = 1:2, b = c("foo", "bar")))

# polars_series
s_int <- as_polars_series(1:2, "a")
s_struct <- as_polars_series(
  data.frame(a = 1:2, b = c("foo", "bar")),
  "struct"
)

## Use the Series as a column
as_polars_df(s_int)
as_polars_df(s_struct, column_name = "values", from_struct = FALSE)

## Unnest the struct data
as_polars_df(s_struct)
}
\seealso{
\itemize{
\item \code{\link[=as.list.polars_data_frame]{as.list(<polars_data_frame>)}}: Export the DataFrame as an R list.
\item \code{\link[=as.data.frame.polars_data_frame]{as.data.frame(<polars_data_frame>)}}: Export the DataFrame as an R data frame.
}
}
