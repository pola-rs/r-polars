% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expr-array.R
\name{expr_arr_agg}
\alias{expr_arr_agg}
\title{Run any polars aggregation expression against the array's elements}
\usage{
expr_arr_agg(expr)
}
\arguments{
\item{expr}{Expression to run. Note that you can select an element with
\code{pl$element()}, \code{pl$first()}, and more. See Examples.}
}
\value{
A polars \link{expression}
}
\description{
This looks similar to \code{\link[=expr_arr_eval]{$arr$eval()}}, but the key
difference is that \verb{$arr$agg()} automatically explodes the array if the
expression inside returns a scalar (while \verb{$arr$eval()} always returns an
array).
}
\examples{
df <- pl$DataFrame(a = list(c(1, NA), c(42, 13), c(NA, NA)))$
  cast(pl$Array(pl$Int64, 2))

# The column "null_count" has dtype u32 because `$null_count()` returns a
# scalar for each sub-array. Using `$arr$eval()` instead would return a
# column with dtype arr(u32).
df$with_columns(
  null_count = pl$col("a")$arr$agg(pl$element()$null_count())
)

# The column "no_nulls" has dtype arr(u32) because the expression doesn't
# guarantee to return a scalar.
df$with_columns(
  no_nulls = pl$col("a")$arr$agg(pl$element()$drop_nulls())
)
}
