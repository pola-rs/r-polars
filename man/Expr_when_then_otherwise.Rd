% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions__whenthen.R
\name{Expr_when_then_otherwise}
\alias{Expr_when_then_otherwise}
\alias{pl_when}
\alias{when}
\alias{then}
\alias{otherwise}
\alias{When}
\alias{Then}
\alias{ChainedWhen}
\alias{ChainedThen}
\title{when-then-otherwise Expr}
\usage{
pl_when(...)
}
\arguments{
\item{...}{Into Expr into a boolean mask to branch by.}

\item{statement}{Into Expr value to insert in when() or otherwise().
Strings interpreted as column.}
}
\value{
Expr
}
\description{
Start a “when, then, otherwise” expression.
}
\details{
when-then-otherwise is similar to R \code{ifelse()}. \code{pl$when(condition)} takes a condition as input
this will an polars \verb{<Expr>} which renderes to a Boolean column. Then it is chained with a
\verb{$then(statement)} when arg statement is an \verb{<Expr>} which produces a column with values if
idealy all Boolean are true. Then finally an \verb{$otherwise(statement)} with values if false.
\verb{$otherwise()} returns an \code{Expr} which will mix the \verb{$then()} statement with the \verb{$otherwise()}
as given by the when-condition.

State-machine details below. The state machine consists of 4 classes \verb{<When>}, \verb{<Then>},
\verb{<ChainedWhen>} & \verb{<ChainedThen>} and a starter function \code{pl$when()} and the final expression
class  a polars \verb{<Expr>}.

\code{pl$when}return a \verb{<When>} object.
\verb{pl$when(condition) -> <When>}

\verb{<When>} has a single public method \verb{$then(statement)}
\verb{<When>$then(statement) -> <Then>}

#the follow objects and methods are
\verb{<Then>$when(condition) -> <ChainedWhen>}
\verb{<Then>$otherwise(statement) -> <Expr>}
\verb{<ChainedWhen>$then(statement) -> <ChainedThen>}
\verb{<ChainedThen>$when(condition) -> <Expr>}
\verb{<ChainedThen>$otherwise(statement) -> <Expr>}

This statemachine ensures only syntacticly allowed methods are availble at any specific place in
a nested when-then-otherwise expression.
}
\examples{
df = pl$DataFrame(foo = c(1, 3, 4), bar = c(3, 4, 0))

# Add a column with the value 1, where column "foo" > 2 and the value -1 where it isn’t.
df$with_columns(
  pl$when(pl$col("foo") > 2)$then(1)$otherwise(-1)$alias("val")
)

# With multiple when, thens chained:
df$with_columns(
  pl$when(pl$col("foo") > 2)
  $then(1)
  $when(pl$col("bar") > 2)
  $then(4)
  $otherwise(-1)
  $alias("val")
)

# Pass multiple predicates, each of which must be met:
df$with_columns(
  val = pl$when(
    pl$col("bar") > 0,
    pl$col("foo") \%\% 2 != 0
  )
  $then(99)
  $otherwise(-1)
)
}
\keyword{Expr}
