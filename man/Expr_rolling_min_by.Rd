% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expr__expr.R
\name{Expr_rolling_min_by}
\alias{Expr_rolling_min_by}
\title{Apply a rolling min based on another column.}
\usage{
Expr_rolling_min_by(by, window_size, ..., min_periods = 1, closed = "right")
}
\arguments{
\item{by}{This column must of dtype \code{\link[=pl_date]{Date}} or
\code{\link[=DataType_Datetime]{Datetime}}.}

\item{window_size}{The length of the window. Can be a fixed integer size, or a dynamic temporal
size indicated by the following string language:
\itemize{
\item 1ns   (1 nanosecond)
\item 1us   (1 microsecond)
\item 1ms   (1 millisecond)
\item 1s    (1 second)
\item 1m    (1 minute)
\item 1h    (1 hour)
\item 1d    (1 day)
\item 1w    (1 week)
\item 1mo   (1 calendar month)
\item 1y    (1 calendar year)
\item 1i    (1 index count)
If the dynamic string language is used, the \code{by} and \code{closed} arguments must
also be set.
}}

\item{...}{Ignored.}

\item{min_periods}{The number of values in the window that should be non-null
before computing a result. If \code{NULL}, it will be set equal to window size.}

\item{closed}{Define which sides of the temporal interval are closed
(inclusive). This can be either \code{"left"}, \code{"right"}, \code{"both"} or \code{"none"}.}
}
\value{
Expr
}
\description{
Apply a rolling min based on another column.
}
\details{
If you want to compute multiple aggregation statistics over the same dynamic
window, consider using \verb{$rolling()} this method can cache the window size
computation.
}
\examples{
df_temporal = pl$DataFrame(
  date = pl$datetime_range(as.Date("2001-1-1"), as.Date("2001-1-2"), "1h")
)$with_row_index("index")

df_temporal

df_temporal$with_columns(
  rolling_row_min = pl$col("index")$rolling_min_by("date", window_size = "3h")
)
}
