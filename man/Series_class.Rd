% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/series__series.R
\name{Series_class}
\alias{Series_class}
\alias{RPolarsSeries}
\title{Inner workings of the Series-class}
\description{
The \code{Series}-class is simply two environments of respectively
the public and private methods/function calls to the polars rust side. The
instantiated \code{Series}-object is an \code{externalptr} to a lowlevel rust polars
Series  object. The pointer address is the only statefullness of the Series
object on the R side. Any other state resides on the rust side. The S3
method \code{.DollarNames.RPolarsSeries} exposes all public \verb{$foobar()}-methods
which are callable onto the object. Most methods return another
\code{Series}-class instance or similar which allows for method chaining. This
class system in lack of a better name could be called "environment classes"
and is the same class system extendr provides, except here there is both a
public and private set of methods. For implementation reasons, the private
methods are external and must be called from \code{.pr$Series$methodname()},
also all private methods must take any self as an argument, thus they are
pure functions. Having the private methods as pure functions
solved/simplified self-referential complications.
}
\details{
Check out the source code in R/Series_frame.R how public methods are
derived from private methods. Check out  extendr-wrappers.R to see the
extendr-auto-generated methods. These are moved to .pr and converted into
pure external functions in after-wrappers.R. In zzz.R (named zzz to be last
file sourced) the extendr-methods are removed and replaced by any function
prefixed \code{Series_}.
}
\section{Active bindings}{

\subsection{dtype}{

\verb{$dtype} returns the \link[=pl_dtypes]{data type} of the Series.
}

\subsection{flags}{

\verb{$flags} returns a named list with flag names and their values.

Flags are used internally to avoid doing unnecessary computations, such as
sorting a variable that we know is already sorted. The number of flags
varies depending on the column type: columns of type \code{array} and \code{list}
have the flags \code{SORTED_ASC}, \code{SORTED_DESC}, and \code{FAST_EXPLODE}, while other
column types only have the former two.
\itemize{
\item \code{SORTED_ASC} is set to \code{TRUE} when we sort a column in increasing order, so
that we can use this information later on to avoid re-sorting it.
\item \code{SORTED_DESC} is similar but applies to sort in decreasing order.
}
}

\subsection{name}{

\verb{$name} returns the name of the Series.
}

\subsection{shape}{

\verb{$shape} returns a numeric vector of length two with the number of length
of the Series and width of the Series (always 1).
}
}

\section{Sub-namespaces}{

\subsection{arr}{

\verb{$arr} stores all array related methods.
}

\subsection{bin}{

\verb{$bin} stores all binary related methods.
}

\subsection{cat}{

\verb{$cat} stores all categorical related methods.
}

\subsection{dt}{

\verb{$dt} stores all temporal related methods.
}

\subsection{expr}{

\verb{$expr} works as a workaround for applying arbitrary \link[=Expr_class]{Expr} methods
to the Series class object, which means that this is a shortcut
works like \verb{pl$select(s)$select(pl$col(s$name)$<Expr method>)$to_series(0)}.
This subnamespace is experimental.
}

\subsection{list}{

\verb{$list} stores all list related methods.
}

\subsection{str}{

\verb{$str} stores all string related methods.
}

\subsection{struct}{

\verb{$struct} stores all struct related methods.
}
}

\examples{
# make a Series
s = pl$Series(c(1:3, 1L))

# call an active binding
s$shape

# show flags
s$sort()$flags

# use subnamespaces
pl$Series(list(3:1, 1:2, NULL))$list$first()
pl$Series(c(1, NA, 2))$str$concat("-")

s = pl$date_range(
  as.Date("2024-02-18"), as.Date("2024-02-24"),
  interval = "1d"
)$to_series()
s
s$dt$day()

# show all available methods for Series
pl$show_all_public_methods("RPolarsSeries")

}
\keyword{Series}
