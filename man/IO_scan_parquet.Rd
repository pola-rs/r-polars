% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/io_parquet.R
\name{pl_scan_parquet}
\alias{pl_scan_parquet}
\title{Scan a parquet file}
\usage{
pl_scan_parquet(
  source,
  ...,
  n_rows = NULL,
  row_index_name = NULL,
  row_index_offset = 0L,
  parallel = c("auto", "columns", "row_groups", "none"),
  hive_partitioning = NULL,
  hive_schema = NULL,
  try_parse_hive_dates = TRUE,
  glob = TRUE,
  rechunk = FALSE,
  low_memory = FALSE,
  storage_options = NULL,
  use_statistics = TRUE,
  cache = TRUE,
  include_file_paths = NULL
)
}
\arguments{
\item{source}{Path to a file. You can use globbing with \code{*} to scan/read multiple
files in the same directory (see examples).}

\item{...}{Ignored.}

\item{n_rows}{Maximum number of rows to read.}

\item{row_index_name}{If not \code{NULL}, this will insert a row index column with
the given name into the DataFrame.}

\item{row_index_offset}{Offset to start the row index column (only used if
the name is set).}

\item{parallel}{This determines the direction of parallelism. \code{"auto"} will
try to determine the optimal direction. Can be \code{"auto"}, \code{"columns"},
\code{"row_groups"}, \code{"prefiltered"}, or \code{"none"}. See 'Details'.}

\item{hive_partitioning}{Infer statistics and schema from Hive partitioned URL
and use them to prune reads. If \code{NULL} (default), it is automatically
enabled when a single directory is passed, and otherwise disabled.}

\item{hive_schema}{A list containing the column names and data types of the
columns by which the data is partitioned, e.g.
\code{list(a = pl$String, b = pl$Float32)}. If \code{NULL} (default), the schema of
the Hive partitions is inferred.}

\item{try_parse_hive_dates}{Whether to try parsing hive values as date/datetime
types.}

\item{glob}{Expand path given via globbing rules.}

\item{rechunk}{In case of reading multiple files via a glob pattern, rechunk
the final DataFrame into contiguous memory chunks.}

\item{low_memory}{Reduce memory usage (will yield a lower performance).}

\item{storage_options}{Experimental. List of options necessary to scan
parquet files from different cloud storage providers (GCP, AWS, Azure).
See the 'Details' section.}

\item{use_statistics}{Use statistics in the parquet file to determine if pages
can be skipped from reading.}

\item{cache}{Cache the result after reading.}

\item{include_file_paths}{Character value indicating the column name that will
include the path of the source file(s).}
}
\value{
\link[=LazyFrame_class]{LazyFrame}
}
\description{
Scan a parquet file
}
\details{
\subsection{On parallel strategies}{

The prefiltered strategy first evaluates the pushed-down predicates in
parallel and determines a mask of which rows to read. Then, it parallelizes
over both the columns and the row groups while filtering out rows that do not
need to be read. This can provide significant speedups for large files (i.e.
many row-groups) with a predicate that filters clustered rows or filters
heavily. In other cases, prefiltered may slow down the scan compared other
strategies.

The prefiltered settings falls back to auto if no predicate is given.
}

\subsection{Connecting to cloud providers}{

Polars supports scanning parquet files from different cloud providers.
The cloud providers currently supported are AWS, GCP, and Azure.
The supported keys to pass to the \code{storage_options} argument can be found
here:
\itemize{
\item \href{https://docs.rs/object_store/latest/object_store/aws/enum.AmazonS3ConfigKey.html}{aws}
\item \href{https://docs.rs/object_store/latest/object_store/gcp/enum.GoogleConfigKey.html}{gcp}
\item \href{https://docs.rs/object_store/latest/object_store/azure/enum.AzureConfigKey.html}{azure}
}
\subsection{Implementation details}{
\itemize{
\item Currently it is impossible to scan public parquet files from GCP without
a valid service account. Be sure to always include a service account in the
\code{storage_options} argument.
}
}

}
}
\examples{
\dontshow{if (requireNamespace("arrow", quietly = TRUE) && arrow::arrow_with_dataset() && arrow::arrow_with_parquet()) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
# Write a Parquet file than we can then import as DataFrame
temp_file = tempfile(fileext = ".parquet")
pl$DataFrame(mtcars)$write_parquet(temp_file)

pl$scan_parquet(temp_file)$collect()
invisible(file.remove(temp_file))

# Write a hive-style partitioned parquet dataset
temp_dir = tempdir()
arrow::write_dataset(
  mtcars,
  temp_dir,
  partitioning = c("cyl", "gear"),
  format = "parquet",
  hive_style = TRUE
)
list.files(temp_dir, recursive = TRUE)

# If the path is a folder, Polars automatically tries to detect partitions
# and includes them in the output
pl$scan_parquet(temp_dir)$collect()

# We can also impose a schema to the partition
pl$scan_parquet(temp_dir, hive_schema = list(cyl = pl$String, gear = pl$Int32))$collect()
\dontshow{\}) # examplesIf}
}
