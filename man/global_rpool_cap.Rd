% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rbackground.R
\name{global_rpool_cap}
\alias{global_rpool_cap}
\alias{set_global_rpool_cap}
\title{get/set global R session pool cap}
\arguments{
\item{n}{integer, the capacity limit R sessions to process R code.}
}
\value{
for \code{pl$get_global_rpool_cap()} a list(available = ? , capacity = ?)
where available is how many R session already spawned in pool. Capacity is the limit of
how many new R sessions to spawn. Anytime a polars thread worker needs a background R session
specifically to run R code embedded in a query via \verb{$map(..., in_background = TRUE)} or
\verb{$apply(..., in_background = TRUE)} it will obtain any R session idling in rpool, otherwise spawn
a new R session (process) and add it to pool if not \code{capacity} has been reached. If capacity has
been reached already the thread worker will sleep until an R session is idling.

Background R sessions communicate via polars arrow IPC (series/vectors) or R serialize +
shared memory buffers via the rust crate \code{ipc-channel}. Multi-process communication has overhead
because all data must be serialized/de-serialized and sent via buffers. Using multiple R sessions
will likely only give a speed-up in a \verb{low io - high cpu} scenario. Native polars query syntax
runs in threads and have no overhead.
}
\description{
get/set global R session pool cap
}
\examples{
default = pl$get_global_rpool_cap()
print(default)
pl$set_global_rpool_cap(8)
pl$get_global_rpool_cap()
pl$set_global_rpool_cap(default$capacity)
}
