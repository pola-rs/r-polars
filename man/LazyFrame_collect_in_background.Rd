% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lazyframe__lazy.R
\name{LazyFrame_collect_in_background}
\alias{LazyFrame_collect_in_background}
\title{Collect a query in background}
\usage{
LazyFrame_collect_in_background()
}
\value{
RThreadHandle, a future-like thread handle for the task
}
\description{
This doesn't block the R session as it calls \verb{$collect()} in a
a detached thread. This can also be used via \verb{$collect(collect_in_background = TRUE)}.
}
\details{
This function immediately returns an \link[=RThreadHandle_RThreadHandle_class]{RThreadHandle}.
Use \code{\link[=RThreadHandle_is_finished]{<RThreadHandle>$is_finished()}} to see if done.
Use \code{\link[=RThreadHandle_join]{<RThreadHandle>$join()}} to wait and get the final result.

It is useful to not block the R session while query executes. If you use
\code{\link[=Expr_map]{<Expr>$map()}} or \code{\link[=Expr_apply]{<Expr>apply()}} to run R functions
in the query, then you must pass \code{in_background = TRUE} in \verb{$map()} (or
\verb{$apply()}). Otherwise, \verb{$collect_in_background()} will fail because the main
R session is not available for polars execution. See also examples below.
}
\examples{
# Some expression which does contain a map
expr = pl$col("mpg")$map(
  \(x) {
    Sys.sleep(.5)
    x * 0.43
  },
  in_background = TRUE # set TRUE if collecting in background queries with $map or $apply
)$alias("kml")

# return is immediately a handle to another thread.
handle = pl$LazyFrame(mtcars)$with_columns(expr)$collect_in_background()

# ask if query is done
if (!handle$is_finished()) print("not done yet")

# get result, blocking until polars query is done
df = handle$join()
df
}
\keyword{DataFrame_new}
\keyword{LazyFrame}
