% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/series-to_r_vector.R
\name{series__to_r_vector}
\alias{series__to_r_vector}
\title{Export the Series as an R vector}
\usage{
series__to_r_vector(
  ...,
  ensure_vector = FALSE,
  uint8 = c("integer", "raw"),
  int64 = c("double", "character", "integer", "integer64"),
  date = c("Date", "IDate"),
  time = c("hms", "ITime"),
  struct = c("dataframe", "tibble"),
  decimal = c("double", "character"),
  as_clock_class = FALSE,
  ambiguous = c("raise", "earliest", "latest", "null"),
  non_existent = c("raise", "null")
)
}
\arguments{
\item{...}{These dots are for future extensions and must be empty.}

\item{ensure_vector}{A logical value indicating whether to ensure the return value is a \link{vector}.
When the Series has the Struct data type and this argument is \code{FALSE} (default),
the return value is a \link{data.frame}, not a \link{vector} (\verb{is.vector(<data.frame>)} is \code{FALSE}).
If \code{TRUE}, return a named \link{list} instead of a \link{data.frame}.}

\item{uint8}{Determine how to convert Polars' UInt8 type values to R type.
One of the followings:
\itemize{
\item \code{"integer"} (default): Convert to the R's \link{integer} type.
\item \code{"raw"}: Convert to the R's \link{raw} type.
If the value is \code{null}, export as \code{00}.
}}

\item{int64}{Determine how to convert Polars' Int64, UInt32, or UInt64 type values to R type.
One of the followings:
\itemize{
\item \code{"double"} (default): Convert to the R's \link{double} type.
Accuracy may be degraded.
\item \code{"character"}: Convert to the R's \link{character} type.
\item \code{"integer"}: Convert to the R's \link{integer} type.
If the value is out of the range of R's integer type, export as \link{NA_integer_}.
\item \code{"integer64"}: Convert to the \link[bit64:bit64-package]{bit64::integer64} class.
The \link[bit64:bit64-package]{bit64} package must be installed.
If the value is out of the range of \link[bit64:bit64-package]{bit64::integer64}, export as \link[bit64:as.integer64.character]{bit64::NA_integer64_}.
}}

\item{date}{Determine how to convert Polars' Date type values to R class.
One of the followings:
\itemize{
\item \code{"Date"} (default): Convert to the R's \link{Date} class.
\item \code{"IDate"}: Convert to the \link[data.table:IDateTime]{data.table::IDate} class.
}}

\item{time}{Determine how to convert Polars' Time type values to R class.
One of the followings:
\itemize{
\item \code{"hms"} (default): Convert to the \link[hms:hms]{hms::hms} class.
If the \link[hms:hms-package]{hms} package is not installed, a warning will be shown.
\item \code{"ITime"}: Convert to the \link[data.table:IDateTime]{data.table::ITime} class.
The \link[data.table:data.table]{data.table} package must be installed.
}}

\item{struct}{Determine how to convert Polars' Struct type values to R class.
One of the followings:
\itemize{
\item \code{"dataframe"} (default): Convert to the R's \link{data.frame} class.
\item \code{"tibble"}: Convert to the \link[tibble:tbl_df-class]{tibble} class.
If the \link[tibble:tibble-package]{tibble} package is not installed, a warning will be shown.
}}

\item{decimal}{Determine how to convert Polars' Decimal type values to R type.
One of the followings:
\itemize{
\item \code{"double"} (default): Convert to the R's \link{double} type.
\item \code{"character"}: Convert to the R's \link{character} type.
}}

\item{as_clock_class}{A logical value indicating whether to export datetimes and duration as
the \link[clock:clock-package]{clock} package's classes.
\itemize{
\item \code{FALSE} (default): Duration values are exported as \link{difftime}
and datetime values are exported as \link{POSIXct}.
Accuracy may be degraded.
\item \code{TRUE}: Duration values are exported as \link[clock:duration-helper]{clock_duration},
datetime without timezone values are exported as \link[clock:as_naive_time]{clock_naive_time},
and datetime with timezone values are exported as \link[clock:as_zoned_time]{clock_zoned_time}.
For this case, the \link[clock:clock-package]{clock} package must be installed.
Accuracy will be maintained.
}}

\item{ambiguous}{Determine how to deal with ambiguous datetimes.
Only applicable when \code{as_clock_class} is set to \code{FALSE} and
datetime without timezone values are exported as \link{POSIXct}.
Character vector or \link{expression} containing the followings:
\itemize{
\item \code{"raise"} (default): Throw an error
\item \code{"earliest"}: Use the earliest datetime
\item \code{"latest"}: Use the latest datetime
\item \code{"null"}: Return a \code{NA} value
}}

\item{non_existent}{Determine how to deal with non-existent datetimes.
Only applicable when \code{as_clock_class} is set to \code{FALSE} and
datetime without timezone values are exported as \link{POSIXct}.
One of the followings:
\itemize{
\item \code{"raise"} (default): Throw an error
\item \code{"null"}: Return a \code{NA} value
}}
}
\value{
A \link{vector}
}
\description{
Export the \link{Series} as an R \link{vector}.
But note that the Struct data type is exported as a \link{data.frame} by default for consistency,
and a \link{data.frame} is not a vector.
If you want to ensure the return value is a \link{vector}, please set \code{ensure_vector = TRUE},
or use the \code{\link[=as.vector]{as.vector()}} function instead.
}
\details{
The class/type of the exported object depends on the data type of the Series as follows:
\itemize{
\item Boolean: \link{logical}.
\item UInt8: \link{integer} or \link{raw}, depending on the \code{uint8} argument.
\item UInt16, Int8, Int16, Int32: \link{integer}.
\item Int64, UInt32, UInt64: \link{double}, \link{character}, \link{integer}, or \link[bit64:bit64-package]{bit64::integer64},
depending on the \code{int64} argument.
\item Float32, Float64: \link{double}.
\item Decimal: \link{double}.
\item String: \link{character}.
\item Categorical: \link{factor}.
\item Date: \link{Date} or \link[data.table:IDateTime]{data.table::IDate},
depending on the \code{date} argument.
\item Time: \link[hms:hms]{hms::hms} or \link[data.table:IDateTime]{data.table::ITime},
depending on the \code{time} argument.
\item Datetime (without timezone): \link{POSIXct} or \link[clock:as_naive_time]{clock_naive_time},
depending on the \code{as_clock_class} argument.
\item Datetime (with timezone): \link{POSIXct} or \link[clock:as_zoned_time]{clock_zoned_time},
depending on the \code{as_clock_class} argument.
\item Duration: \link{difftime} or \link[clock:duration-helper]{clock_duration},
depending on the \code{as_clock_class} argument.
\item Binary: \link[blob:blob]{blob::blob}.
\item Null: \link[vctrs:unspecified]{vctrs::unspecified}.
\item List, Array: \link[vctrs:list_of]{vctrs::list_of}.
\item Struct: \link{data.frame} or \link[tibble:tbl_df-class]{tibble}, depending on the \code{struct} argument.
If \code{ensure_vector = TRUE}, the top-level Struct is exported as a named \link{list} for
to ensure the return value is a \link{vector}.
}
}
\examples{
# Struct values handling
series_struct <- as_polars_series(
  data.frame(
    a = 1:2,
    b = I(list(data.frame(c = "foo"), data.frame(c = "bar")))
  )
)
series_struct

## Export Struct as data.frame
series_struct$to_r_vector()

## Export Struct as data.frame,
## but the top-level Struct is exported as a named list
series_struct$to_r_vector(ensure_vector = TRUE)

## Export Struct as tibble
series_struct$to_r_vector(struct = "tibble")

## Export Struct as tibble,
## but the top-level Struct is exported as a named list
series_struct$to_r_vector(struct = "tibble", ensure_vector = TRUE)

# UInt8 values handling
series_uint8 <- as_polars_series(c(NA, 0, 255))$cast(pl$UInt8)
series_uint8

## Export UInt8 as integer
series_uint8$to_r_vector(uint8 = "integer")

## Export UInt8 as raw (`null` is exported as `00`)
series_uint8$to_r_vector(uint8 = "raw")

# Other Integer values handlings
series_uint64 <- as_polars_series(
  c(NA, "0", "4294967295", "18446744073709551615")
)$cast(pl$UInt64)
series_uint64

## Export UInt64 as double
series_uint64$to_r_vector(int64 = "double")

## Export UInt64 as character
series_uint64$to_r_vector(int64 = "character")

## Export UInt64 as integer (overflow occurs)
series_uint64$to_r_vector(int64 = "integer")

## Export UInt64 as bit64::integer64 (overflow occurs)
if (requireNamespace("bit64", quietly = TRUE)) {
  series_uint64$to_r_vector(int64 = "integer64")
}

# Duration values handling
series_duration <- as_polars_series(
  c(NA, -1000000000, -10, -1, 1000000000)
)$cast(pl$Duration("ns"))
series_duration

## Export Duration as difftime
series_duration$to_r_vector(as_clock_class = FALSE)

## Export Duration as clock_duration
if (requireNamespace("clock", quietly = TRUE)) {
  series_duration$to_r_vector(as_clock_class = TRUE)
}

# Datetime values handling
series_datetime <- as_polars_series(
  as.POSIXct(
    c(NA, "1920-01-01 00:00:00", "1970-01-01 00:00:00", "2020-01-01 00:00:00"),
    tz = "UTC"
  )
)$cast(pl$Datetime("ns", "UTC"))
series_datetime

## Export zoned datetime as POSIXct
series_datetime$to_r_vector(as_clock_class = FALSE)

## Export zoned datetime as clock_zoned_time
if (requireNamespace("clock", quietly = TRUE)) {
  series_datetime$to_r_vector(as_clock_class = TRUE)
}
}
