% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/options.R
\name{pl_set_options}
\alias{pl_set_options}
\alias{pl_reset_options}
\title{Set polars options}
\usage{
pl_set_options(
  ...,
  strictly_immutable = TRUE,
  maintain_order = FALSE,
  do_not_repeat_call = FALSE,
  debug_polars = FALSE,
  no_messages = FALSE,
  rpool_cap = 4,
  int64_conversion = c("bit64", "double", "string")
)

pl_reset_options()
}
\arguments{
\item{...}{Ignored.}

\item{strictly_immutable}{Keep polars strictly immutable. Polars/arrow is in
general pro "immutable objects". Immutability is also classic in R. To mimic
the Python-polars API, set this to \code{FALSE.}}

\item{maintain_order}{Default for all \code{maintain_order} options (present in
\verb{$group_by()} or \verb{$unique()} for example).}

\item{do_not_repeat_call}{Do not print the call causing the error in error
messages. The default (\code{FALSE}) is to show them.}

\item{debug_polars}{Print additional information to debug Polars.}

\item{no_messages}{Hide messages.}

\item{rpool_cap}{The maximum number of R sessions that can be used to process
R code in the background. See Details.}

\item{int64_conversion}{How should Int64 values be handled when converting a
polars object to R?
\itemize{
\item \code{"double"} (default) converts the integer values to double.
\item \code{"bit64"} uses \code{bit64::as.integer64()} to do the conversion (requires
the package \code{bit64} to be attached).
\item \code{"string"} converts Int64 values to character.
}}
}
\value{
\code{pl$options} returns a named list with the value (\code{TRUE} or \code{FALSE}) of
each option.

\code{pl$set_options()} silently modifies the options values.

\code{pl$reset_options()} silently resets the options to their default values.
}
\description{
Get and set polars options. See sections "Value" and "Examples" below for
more details.
}
\details{
\code{pl$options$rpool_active} indicates the number of R sessions already
spawned in pool. \code{pl$options$rpool_cap} indicates the maximum number of new R
sessions that can be spawned. Anytime a polars thread worker needs a background
R session specifically to run R code embedded in a query via
\code{\link[=Expr_map_batches]{$map_batches(..., in_background = TRUE)}} or
\code{\link[=Expr_map_elements]{$map_elements(..., in_background = TRUE)}}, it
will obtain any R session idling in rpool, or spawn a new R session (process)
and add it to the rpool if \code{rpool_cap} is not already reached. If \code{rpool_cap}
is already reached, the thread worker will sleep until an R session is idling.

Background R sessions communicate via polars arrow IPC (series/vectors) or R
serialize + shared memory buffers via the rust crate \code{ipc-channel}.
Multi-process communication has overhead because all data must be
serialized/de-serialized and sent via buffers. Using multiple R sessions
will likely only give a speed-up in a \verb{low io - high cpu} scenario. Native
polars query syntax runs in threads and have no overhead.
}
\examples{
pl$set_options(maintain_order = TRUE, strictly_immutable = FALSE)
pl$options

# these options only accept booleans (TRUE or FALSE)
tryCatch(
  pl$set_options(strictly_immutable = 42),
  error = function(e) print(e)
)

# reset options to their default value
pl$reset_options()
}
