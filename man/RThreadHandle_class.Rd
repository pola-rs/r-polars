% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rbackground.R
\name{RThreadHandle_class}
\alias{RThreadHandle_class}
\alias{RPolarsRThreadHandle}
\title{The RPolarsRThreadHandle class}
\description{
A handle to some polars query running in a background thread.
}
\details{
\code{\link[=LazyFrame_collect_in_background]{<LazyFrame>$collect_in_background()}} will execute a polars
query detached from the R session and return an \code{RPolarsRThreadHandle} immediately. This
\code{RPolarsRThreadHandle}-class has the methods \code{\link[=RThreadHandle_is_finished]{is_finished()}} and
\code{\link[=RThreadHandle_join]{join()}}.
}
\section{NOTICE}{

The background thread cannot use the main R session, but can access the pool of extra R sessions
to process R code embedded in polars query via \code{\link[=Expr_map_batches]{$map_batches(..., in_background = TRUE)}} or
\verb{$map_elements(background=TRUE)}. Use \code{\link[=polars_options]{options(polars.rpool_cap = XX)}} to limit number of
parallel R sessions.
Starting polars  \code{\link[=LazyFrame_collect_in_background]{<LazyFrame>$collect_in_background()}} with
e.g. some \code{\link[=Expr_map_batches]{$map_batches(..., in_background = FALSE)}} will raise an Error as the main R session is not
available to process the R part of the polars query. Native polars query does not need any R
session.
}

\examples{
prexpr = pl$col("mpg")$map_batches(\(x) {
  Sys.sleep(.1)
  x * 0.43
}, in_background = TRUE)$alias("kml")
handle = pl$LazyFrame(mtcars)$with_columns(prexpr)$collect_in_background()
if (!handle$is_finished()) print("not done yet")
df = handle$join() # get result
df
}
\seealso{
\itemize{
\item \code{\link[=LazyFrame_collect_in_background]{<LazyFrame>$collect_in_background()}}
\item \code{\link[=Expr_map_batches]{<Expr>$map_batches()}}
\item \code{\link[=Expr_map_elements]{<Expr>$map_elements()}}
}
}
