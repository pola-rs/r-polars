% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dataframe__frame.R
\name{DataFrame_group_by_dynamic}
\alias{DataFrame_group_by_dynamic}
\title{Group based on a date/time or integer column}
\usage{
DataFrame_group_by_dynamic(
  index_column,
  every,
  period = NULL,
  offset = NULL,
  include_boundaries = FALSE,
  closed = "left",
  label = "left",
  by = NULL,
  start_by = "window",
  check_sorted = TRUE
)
}
\arguments{
\item{index_column}{Column used to group based on the time window. Often of
type Date/Datetime. This column must be sorted in ascending order (or, if \code{by}
is specified, then it must be sorted in ascending order within each group). In
case of a rolling group by on indices, dtype needs to be either Int32 or Int64.
Note that Int32 gets temporarily cast to Int64, so if performance matters use
an Int64 column.}

\item{every}{Interval of the window.}

\item{period}{Length of the window, must be non-negative.}

\item{offset}{Offset of the window. Default is \code{-period}.}

\item{include_boundaries}{Add two columns \code{"_lower_boundary"} and
\code{"_upper_boundary"} columns that show the boundaries of the window. This will
impact performance because it’s harder to parallelize.}

\item{closed}{Define which sides of the temporal interval are closed
(inclusive). This can be either \code{"left"}, \code{"right"}, \code{"both"} or \code{"none"}.}

\item{label}{Define which label to use for the window:
\itemize{
\item \code{"left"}: lower boundary of the window
\item \code{"right"}: upper boundary of the window
\item \code{"datapoint"}: the first value of the index column in the given window. If
you don’t need the label to be at one of the boundaries, choose this option
for maximum performance.
}}

\item{by}{Also group by this column/these columns.}

\item{start_by}{The strategy to determine the start of the first window by:
\itemize{
\item \code{"window"}: start by taking the earliest timestamp, truncating it with \code{every},
and then adding \code{offset}. Note that weekly windows start on Monday.
\item \code{"datapoint"}: start from the first encountered data point.
\item a day of the week (only takes effect if \code{every} contains \code{"w"}): \code{"monday"}
starts the window on the Monday before the first data point, etc.
}}

\item{check_sorted}{Check whether data is actually sorted. Checking it is
expensive so if you are sure the data within the \code{index_column} is sorted, you
can set this to \code{FALSE} but note that if the data actually is unsorted, it
will lead to incorrect output.}
}
\value{
A \link[=GroupBy_class]{GroupBy} object
}
\description{
If you have a time series \verb{<t_0, t_1, ..., t_n>}, then by default the windows
created will be:
\itemize{
\item (t_0 - period, t_0]
\item (t_1 - period, t_1]
\item …
\item (t_n - period, t_n]
}

whereas if you pass a non-default offset, then the windows will be:
\itemize{
\item (t_0 + offset, t_0 + offset + period]
\item (t_1 + offset, t_1 + offset + period]
\item …
\item (t_n + offset, t_n + offset + period]
}
}
\details{
The period and offset arguments are created either from a timedelta, or by
using the following string language:
\itemize{
\item 1ns (1 nanosecond)
\item 1us (1 microsecond)
\item 1ms (1 millisecond)
\item 1s (1 second)
\item 1m (1 minute)
\item 1h (1 hour)
\item 1d (1 calendar day)
\item 1w (1 calendar week)
\item 1mo (1 calendar month)
\item 1q (1 calendar quarter)
\item 1y (1 calendar year)
\item 1i (1 index count)
}

Or combine them: "3d12h4m25s" # 3 days, 12 hours, 4 minutes, and 25 seconds

By "calendar day", we mean the corresponding time on the next day (which may
not be 24 hours, due to daylight savings). Similarly for "calendar week",
"calendar month", "calendar quarter", and "calendar year".

In case of a rolling operation on an integer column, the windows are defined
by:
\itemize{
\item "1i" # length 1
\item "10i" # length 10
}
}
\examples{
df = pl$DataFrame(
  time = pl$date_range(
    start = strptime("2021-12-16 00:00:00", format = "\%Y-\%m-\%d \%H:\%M:\%S", tz = "UTC"),
    end = strptime("2021-12-16 03:00:00", format = "\%Y-\%m-\%d \%H:\%M:\%S", tz = "UTC"),
    interval = "30m"
  ),
  n = 0:6
)

# get the sum in the following hour relative to the "time" column
df$group_by_dynamic("time", every = "1h")$agg(
  vals = pl$col("n"),
  sum = pl$col("n")$sum()
)

# using "include_boundaries = TRUE" is helpful to see the period considered
df$group_by_dynamic("time", every = "1h", include_boundaries = TRUE)$agg(
  vals = pl$col("n")
)

# in the example above, the values didn't include the one *exactly* 1h after
# the start because "closed = 'left'" by default.
# Changing it to "right" includes values that are exactly 1h after. Note that
# the value at 00:00:00 now becomes included in the interval [23:00:00 - 00:00:00],
# even if this interval wasn't there originally
df$group_by_dynamic("time", every = "1h", closed = "right")$agg(
  vals = pl$col("n")
)
# To keep both boundaries, we use "closed = 'both'". Some values now belong to
# several groups:
df$group_by_dynamic("time", every = "1h", closed = "both")$agg(
  vals = pl$col("n")
)

# Dynamic group bys can also be combined with grouping on normal keys
df = df$with_columns(groups = pl$Series(c("a", "a", "a", "b", "b", "a", "a")))
df

df$group_by_dynamic(
  "time",
  every = "1h",
  closed = "both",
  by = "groups",
  include_boundaries = TRUE
)$agg(pl$col("n"))

# We can also create a dynamic group by based on an index column
df = pl$LazyFrame(
  idx = 0:5,
  A = c("A", "A", "B", "B", "B", "C")
)$with_columns(pl$col("idx")$set_sorted())
df

df$group_by_dynamic(
  "idx",
  every = "2i",
  period = "3i",
  include_boundaries = TRUE,
  closed = "right"
)$agg(A_agg_list = pl$col("A"))
}
